{"commit_url": "https://github.com/godotengine/godot/commit/082f9245668384d5bad79998dee40370c2d38dce", "commit_message": "Updated Tabs to not update excessively", "code_diff": "@@ -98,29 +98,45 @@ void Tabs::gui_input(const Ref<InputEvent> &p_event) {\n \tif (mm.is_valid()) {\n \t\tPoint2 pos = mm->get_position();\n \n-\t\thighlight_arrow = -1;\n \t\tif (buttons_visible) {\n \t\t\tRef<Texture2D> incr = get_theme_icon(SNAME(\"increment\"));\n \t\t\tRef<Texture2D> decr = get_theme_icon(SNAME(\"decrement\"));\n \n \t\t\tif (is_layout_rtl()) {\n \t\t\t\tif (pos.x < decr->get_width()) {\n-\t\t\t\t\thighlight_arrow = 1;\n+\t\t\t\t\tif (highlight_arrow != 1) {\n+\t\t\t\t\t\thighlight_arrow = 1;\n+\t\t\t\t\t\tupdate();\n+\t\t\t\t\t}\n \t\t\t\t} else if (pos.x < incr->get_width() + decr->get_width()) {\n-\t\t\t\t\thighlight_arrow = 0;\n+\t\t\t\t\tif (highlight_arrow != 0) {\n+\t\t\t\t\t\thighlight_arrow = 0;\n+\t\t\t\t\t\tupdate();\n+\t\t\t\t\t}\n+\t\t\t\t} else if (highlight_arrow != -1) {\n+\t\t\t\t\thighlight_arrow = -1;\n+\t\t\t\t\tupdate();\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tint limit_minus_buttons = get_size().width - incr->get_width() - decr->get_width();\n \t\t\t\tif (pos.x > limit_minus_buttons + decr->get_width()) {\n-\t\t\t\t\thighlight_arrow = 1;\n+\t\t\t\t\tif (highlight_arrow != 1) {\n+\t\t\t\t\t\thighlight_arrow = 1;\n+\t\t\t\t\t\tupdate();\n+\t\t\t\t\t}\n \t\t\t\t} else if (pos.x > limit_minus_buttons) {\n-\t\t\t\t\thighlight_arrow = 0;\n+\t\t\t\t\tif (highlight_arrow != 0) {\n+\t\t\t\t\t\thighlight_arrow = 0;\n+\t\t\t\t\t\tupdate();\n+\t\t\t\t\t}\n+\t\t\t\t} else if (highlight_arrow != -1) {\n+\t\t\t\t\thighlight_arrow = -1;\n+\t\t\t\t\tupdate();\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t_update_hover();\n-\t\tupdate();\n \t\treturn;\n \t}\n \n", "changed_method_name": "Tabs::gui_input"}
{"commit_url": "https://github.com/godotengine/godot/commit/ba431a9306f6f018488b6d19854ea40fa528f205", "commit_message": "Fix volumetric fog memory leak on resize", "code_diff": "@@ -4011,6 +4011,9 @@ void RendererSceneRenderRD::_volumetric_fog_erase(RenderBuffers *rb) {\n \tRD::get_singleton()->free(rb->volumetric_fog->prev_light_density_map);\n \tRD::get_singleton()->free(rb->volumetric_fog->light_density_map);\n \tRD::get_singleton()->free(rb->volumetric_fog->fog_map);\n+\tRD::get_singleton()->free(rb->volumetric_fog->density_map);\n+\tRD::get_singleton()->free(rb->volumetric_fog->light_map);\n+\tRD::get_singleton()->free(rb->volumetric_fog->emissive_map);\n \n \tif (rb->volumetric_fog->fog_uniform_set.is_valid() && RD::get_singleton()->uniform_set_is_valid(rb->volumetric_fog->fog_uniform_set)) {\n \t\tRD::get_singleton()->free(rb->volumetric_fog->fog_uniform_set);\n", "changed_method_name": "RendererSceneRenderRD::_volumetric_fog_erase"}
{"commit_url": "https://github.com/godotengine/godot/commit/c37bd41c794819e0b6bc3ad4b162548057098e1c", "commit_message": "Increase RemoteDebuggerPeerTCP poll to 6.9ms\n\nFix high CPU usage on MacOS by reverting the polling for Network\ndebugging to match 144hz refresh rate.", "code_diff": "@@ -190,7 +190,8 @@ Error RemoteDebuggerPeerTCP::connect_to_host(const String &p_host, uint16_t p_po\n }\n \n void RemoteDebuggerPeerTCP::_thread_func(void *p_ud) {\n-\tconst uint64_t min_tick = 100;\n+\t// Update in time for 144hz monitors\n+\tconst uint64_t min_tick = 6900;\n \tRemoteDebuggerPeerTCP *peer = (RemoteDebuggerPeerTCP *)p_ud;\n \twhile (peer->running && peer->is_peer_connected()) {\n \t\tuint64_t ticks_usec = OS::get_singleton()->get_ticks_usec();\n", "changed_method_name": "RemoteDebuggerPeerTCP::_thread_func"}
{"commit_url": "https://github.com/godotengine/godot/commit/66d27df12f5b710ac5f569144944c1db0c86c96b", "commit_message": "Fix 3D sky update performance regression", "code_diff": "@@ -1172,7 +1172,7 @@ void RendererSceneSkyRD::setup(RendererSceneEnvironmentRD *p_env, RID p_render_b\n \t\t\t\t}\n \t\t\t}\n \t\t\t// Check whether the directional_light_buffer changes\n-\t\t\tbool light_data_dirty = true;\n+\t\t\tbool light_data_dirty = false;\n \n \t\t\t// Light buffer is dirty if we have fewer or more lights\n \t\t\t// If we have fewer lights, make sure that old lights are disabled\n", "changed_method_name": "RendererSceneSkyRD::setup"}
{"commit_url": "https://github.com/godotengine/godot/commit/ddc8ec6b448edd69642d61c4827882a035498274", "commit_message": "Limit inspector updates when dragging anchored controls", "code_diff": "@@ -1585,14 +1585,25 @@ void Control::set_anchor_and_offset(Side p_side, real_t p_anchor, real_t p_pos,\n }\n \n void Control::_set_anchors_layout_preset(int p_preset) {\n-\tset_meta(\"_edit_layout_mode\", (int)LayoutMode::LAYOUT_MODE_ANCHORS);\n+\tbool list_changed = false;\n+\n+\tif (has_meta(\"_edit_layout_mode\") && (int)get_meta(\"_edit_layout_mode\") != (int)LayoutMode::LAYOUT_MODE_ANCHORS) {\n+\t\tlist_changed = true;\n+\t\tset_meta(\"_edit_layout_mode\", (int)LayoutMode::LAYOUT_MODE_ANCHORS);\n+\t}\n \n \tif (p_preset == -1) {\n-\t\tset_meta(\"_edit_use_custom_anchors\", true);\n-\t\tnotify_property_list_changed();\n+\t\tif (!has_meta(\"_edit_use_custom_anchors\") || !(bool)get_meta(\"_edit_use_custom_anchors\")) {\n+\t\t\tset_meta(\"_edit_use_custom_anchors\", true);\n+\t\t\tnotify_property_list_changed();\n+\t\t}\n \t\treturn; // Keep settings as is.\n \t}\n-\tset_meta(\"_edit_use_custom_anchors\", false);\n+\n+\tif (!has_meta(\"_edit_use_custom_anchors\") || (bool)get_meta(\"_edit_use_custom_anchors\")) {\n+\t\tlist_changed = true;\n+\t\tset_meta(\"_edit_use_custom_anchors\", false);\n+\t}\n \n \tLayoutPreset preset = (LayoutPreset)p_preset;\n \t// Set correct anchors.\n@@ -1625,7 +1636,9 @@ void Control::_set_anchors_layout_preset(int p_preset) {\n \t// Select correct grow directions.\n \tset_grow_direction_preset(preset);\n \n-\tnotify_property_list_changed();\n+\tif (list_changed) {\n+\t\tnotify_property_list_changed();\n+\t}\n }\n \n int Control::_get_anchors_layout_preset() const {\n", "changed_method_name": "Control::_set_anchors_layout_preset"}
{"commit_url": "https://github.com/godotengine/godot/commit/ab5eaf0ad97cfac2d3bc924ae99c5fc83cd3e838", "commit_message": "Fix new performance regressions (short delay_usec)\n\nMy Mac was using 20% cpu again, which was related to the Javascript\nExport plugin.\n\nI had however no export templates setup in the project so this is more\nof a stopgap fix.", "code_diff": "@@ -645,7 +645,7 @@ Ref<Texture2D> EditorExportPlatformJavaScript::get_run_icon() const {\n void EditorExportPlatformJavaScript::_server_thread_poll(void *data) {\n \tEditorExportPlatformJavaScript *ej = (EditorExportPlatformJavaScript *)data;\n \twhile (!ej->server_quit) {\n-\t\tOS::get_singleton()->delay_usec(1000);\n+\t\tOS::get_singleton()->delay_usec(6900);\n \t\t{\n \t\t\tMutexLock lock(ej->server_lock);\n \t\t\tej->server->poll();\n", "changed_method_name": "EditorExportPlatformJavaScript::_server_thread_poll"}
{"commit_url": "https://github.com/godotengine/godot/commit/32b16c876b92c3dae35046d37740fc6e5cc65b24", "commit_message": "[Net] Fix SceneReplicationConfig setter.\n\nUsed by resource loader, it would always add properties as both sync and\nspawn, disregarding the actual option value.", "code_diff": "@@ -52,11 +52,19 @@ bool SceneReplicationConfig::_set(const StringName &p_name, const Variant &p_val\n \t\tReplicationProperty &prop = properties[idx];\n \t\tif (what == \"sync\") {\n \t\t\tprop.sync = p_value;\n-\t\t\tsync_props.push_back(prop.name);\n+\t\t\tif (prop.sync) {\n+\t\t\t\tsync_props.push_back(prop.name);\n+\t\t\t} else {\n+\t\t\t\tsync_props.erase(prop.name);\n+\t\t\t}\n \t\t\treturn true;\n \t\t} else if (what == \"spawn\") {\n \t\t\tprop.spawn = p_value;\n-\t\t\tspawn_props.push_back(prop.name);\n+\t\t\tif (prop.spawn) {\n+\t\t\t\tspawn_props.push_back(prop.name);\n+\t\t\t} else {\n+\t\t\t\tspawn_props.erase(prop.name);\n+\t\t\t}\n \t\t\treturn true;\n \t\t}\n \t}\n", "changed_method_name": "SceneReplicationConfig::_set"}
{"commit_url": "https://github.com/godotengine/godot/commit/0cbd1c85a96384ef93978661e408ce7c1b721847", "commit_message": "Fix burning CPU with udev disabled on Flatpak\n\nFixes #67355.", "code_diff": "@@ -218,8 +218,8 @@ void JoypadLinux::monitor_joypads() {\n \t\t\t}\n \t\t}\n \t\tclosedir(input_directory);\n+\t\tusleep(1000000); // 1s\n \t}\n-\tusleep(1000000); // 1s\n }\n \n void JoypadLinux::close_joypads() {\n", "changed_method_name": "JoypadLinux::monitor_joypads"}
{"commit_url": "https://github.com/godotengine/godot/commit/d44a91c2f78809365020a67647a2c94ccab418ad", "commit_message": "use depth prepass to increase performance", "code_diff": "@@ -256,6 +256,7 @@ void SceneShaderForwardClustered::ShaderData::set_code(const String &p_code) {\n \t\tdepth_stencil_state.depth_compare_operator = RD::COMPARE_OP_LESS_OR_EQUAL;\n \t\tdepth_stencil_state.enable_depth_write = depth_draw != DEPTH_DRAW_DISABLED ? true : false;\n \t}\n+\tbool depth_pre_pass_enabled = bool(GLOBAL_GET(\"rendering/driver/depth_prepass/enable\"));\n \n \tfor (int i = 0; i < CULL_VARIANT_MAX; i++) {\n \t\tRD::PolygonCullMode cull_mode_rd_table[CULL_VARIANT_MAX][3] = {\n@@ -307,8 +308,16 @@ void SceneShaderForwardClustered::ShaderData::set_code(const String &p_code) {\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \n-\t\t\t\t\t\tRD::PipelineColorBlendState blend_state;\n \t\t\t\t\t\tRD::PipelineDepthStencilState depth_stencil = depth_stencil_state;\n+\t\t\t\t\t\tif (depth_pre_pass_enabled && casts_shadows()) {\n+\t\t\t\t\t\t\t// We already have a depth from the depth pre-pass, there is no need to write it again.\n+\t\t\t\t\t\t\t// In addition we can use COMPARE_OP_EQUAL instead of COMPARE_OP_LESS_OR_EQUAL.\n+\t\t\t\t\t\t\t// This way we can use the early depth test to discard transparent fragments before the fragment shader even starts.\n+\t\t\t\t\t\t\tdepth_stencil.depth_compare_operator = RD::COMPARE_OP_EQUAL;\n+\t\t\t\t\t\t\tdepth_stencil.enable_depth_write = false;\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tRD::PipelineColorBlendState blend_state;\n \t\t\t\t\t\tRD::PipelineMultisampleState multisample_state;\n \n \t\t\t\t\t\tint shader_flags = 0;\n", "changed_method_name": "SceneShaderForwardClustered::ShaderData::set_code"}
{"commit_url": "https://github.com/godotengine/godot/commit/51777a2914dc46f2831752b74db6276369df0905", "commit_message": "Fix constant editor redraw after shortcut\n\nIntroduced by me by mistake on #71328. Fixes #71652.", "code_diff": "@@ -385,6 +385,7 @@ void BaseButton::shortcut_input(const Ref<InputEvent> &p_event) {\n \t\tif (shortcut_feedback) {\n \t\t\tif (shortcut_feedback_timer == nullptr) {\n \t\t\t\tshortcut_feedback_timer = memnew(Timer);\n+\t\t\t\tshortcut_feedback_timer->set_one_shot(true);\n \t\t\t\tadd_child(shortcut_feedback_timer);\n \t\t\t\tshortcut_feedback_timer->set_wait_time(GLOBAL_GET(\"gui/timers/button_shortcut_feedback_highlight_time\"));\n \t\t\t\tshortcut_feedback_timer->connect(\"timeout\", callable_mp(this, &BaseButton::_shortcut_feedback_timeout));\n", "changed_method_name": "BaseButton::shortcut_input"}
{"commit_url": "https://github.com/godotengine/godot/commit/340c3b84fd9f06f4d4a794c0a0b8e95165aeee9f", "commit_message": "Set Default compression to VRAM uncompressed for LightmapGI\n\nThis increases the speed to be near instant and removes the perceived lightmap bake speed regression\n\nWe need to investigate the speed and quality issues with BPTC and re-enable compression when we can", "code_diff": "@@ -163,7 +163,8 @@ Array LightmapGIData::_get_light_textures_data() const {\n \t\tconfig->set_value(\"remap\", \"importer\", \"2d_array_texture\");\n \t\tconfig->set_value(\"remap\", \"type\", \"CompressedTexture2DArray\");\n \t\tif (!config->has_section_key(\"params\", \"compress/mode\")) {\n-\t\t\tconfig->set_value(\"params\", \"compress/mode\", 2); //user may want another compression, so leave it be\n+\t\t\t// User may want another compression, so leave it be, but default to VRAM uncompressed.\n+\t\t\tconfig->set_value(\"params\", \"compress/mode\", 3);\n \t\t}\n \t\tconfig->set_value(\"params\", \"compress/channel_pack\", 1);\n \t\tconfig->set_value(\"params\", \"mipmaps/generate\", false);\n", "changed_method_name": "LightmapGIData::_get_light_textures_data"}
{"commit_url": "https://github.com/godotengine/godot/commit/e5bebbc9ffda8b4fa5a786842ea24f0a3ea0763a", "commit_message": "Fix unnecessary break when calculating the height of visible lines\n\nThis break causes the minsize to be smaller than expected, and then\nthe size keeps increasing by one line to cover all visible lines.\nThis can cause performance issues when there are many visible lines.", "code_diff": "@@ -290,9 +290,6 @@ void Label::_update_visible() {\n \tint last_line = MIN(lines_rid.size(), lines_visible + lines_skipped);\n \tfor (int64_t i = lines_skipped; i < last_line; i++) {\n \t\tminsize.height += TS->shaped_text_get_size(lines_rid[i]).y + line_spacing;\n-\t\tif (minsize.height > (get_size().height - style->get_minimum_size().height + line_spacing)) {\n-\t\t\tbreak;\n-\t\t}\n \t}\n }\n \n", "changed_method_name": "Label::_update_visible"}
{"commit_url": "https://github.com/godotengine/godot/commit/8cdab04d7fd57aaabd790349cd8a4e9ec21a7edd", "commit_message": "Fix that the focus-out notification got sent deferred\n\nCurrently the window receives a focus-out notification, directly after\nit popup, because currently the signal is sent deferred.\nThe original intention was that the previously focused window must\nreceive a focus-out notification.\nThis change makes the notification more precise by only sending the\nfocus-out to the previously focused window.", "code_diff": "@@ -1624,7 +1624,15 @@ void Window::popup(const Rect2i &p_screen_rect) {\n \t\t// Send a focus-out notification when opening a Window Manager Popup.\n \t\tSceneTree *scene_tree = get_tree();\n \t\tif (scene_tree) {\n-\t\t\tscene_tree->notify_group_flags(SceneTree::GROUP_CALL_DEFERRED, \"_viewports\", NOTIFICATION_WM_WINDOW_FOCUS_OUT);\n+\t\t\tList<Node *> list;\n+\t\t\tscene_tree->get_nodes_in_group(\"_viewports\", &list);\n+\t\t\tfor (Node *n : list) {\n+\t\t\t\tWindow *w = Object::cast_to<Window>(n);\n+\t\t\t\tif (w && !w->get_embedder() && w->has_focus()) {\n+\t\t\t\t\tw->_event_callback(DisplayServer::WINDOW_EVENT_FOCUS_OUT);\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n \t\t}\n \t}\n \n", "changed_method_name": "Window::popup"}
{"commit_url": "https://github.com/godotengine/godot/commit/bc1aef88eef7bb09d1c537bf150414c50abfa374", "commit_message": "SCons: Disable misbehaving MSVC incremental linking\n\nFixes #77968.", "code_diff": "@@ -355,6 +355,9 @@ def configure_msvc(env, vcvars_msvc_config):\n         else:\n             env.AppendUnique(CCFLAGS=[\"/MD\"])\n \n+    # MSVC incremental linking is broken and _increases_ link time (GH-77968).\n+    env.Append(LINKFLAGS=[\"/INCREMENTAL:NO\"])\n+\n     if env[\"arch\"] == \"x86_32\":\n         env[\"x86_libtheora_opt_vc\"] = True\n \n", "changed_method_name": "configure_msvc"}
{"commit_url": "https://github.com/godotengine/godot/commit/085255bd0ed2c36b217769c6f75c8ea856725b1a", "commit_message": "Improved X11 screen_get_refresh_rate performance", "code_diff": "@@ -1571,7 +1571,7 @@ float DisplayServerX11::screen_get_refresh_rate(int p_screen) const {\n \n \t//Use xrandr to get screen refresh rate.\n \tif (xrandr_ext_ok) {\n-\t\tXRRScreenResources *screen_info = XRRGetScreenResources(x11_display, windows[MAIN_WINDOW_ID].x11_window);\n+\t\tXRRScreenResources *screen_info = XRRGetScreenResourcesCurrent(x11_display, windows[MAIN_WINDOW_ID].x11_window);\n \t\tif (screen_info) {\n \t\t\tRRMode current_mode = 0;\n \t\t\txrr_monitor_info *monitors = nullptr;\n", "changed_method_name": "DisplayServerX11::screen_get_refresh_rate"}
{"commit_url": "https://github.com/godotengine/godot/commit/5dd11e8eee739f2ac3bbecd93cd4862c151aebc8", "commit_message": "Limit window size updates on title change.", "code_diff": "@@ -284,7 +284,13 @@ void Window::set_title(const String &p_title) {\n \t\tembedder->_sub_window_update(this);\n \t} else if (window_id != DisplayServer::INVALID_WINDOW_ID) {\n \t\tDisplayServer::get_singleton()->window_set_title(tr_title, window_id);\n-\t\t_update_window_size();\n+\t\tif (keep_title_visible) {\n+\t\t\tSize2i title_size = DisplayServer::get_singleton()->window_get_title_size(tr_title, window_id);\n+\t\t\tSize2i size_limit = get_clamped_minimum_size();\n+\t\t\tif (title_size.x > size_limit.x || title_size.y > size_limit.y) {\n+\t\t\t\t_update_window_size();\n+\t\t\t}\n+\t\t}\n \t}\n }\n \n", "changed_method_name": "Window::set_title"}
{"commit_url": "https://github.com/godotengine/godot/commit/b9225f67c85c3eab47df96b9fa1bd5a5034eae53", "commit_message": "Warn that navigation mesh baking from Meshes is bad for runtime performance\n\nWarns that navigation mesh baking from Meshes is bad for runtime performance.", "code_diff": "@@ -158,6 +158,15 @@ void NavigationMeshSourceGeometryData3D::_add_faces(const PackedVector3Array &p_\n \n void NavigationMeshSourceGeometryData3D::add_mesh(const Ref<Mesh> &p_mesh, const Transform3D &p_xform) {\n \tERR_FAIL_COND(!p_mesh.is_valid());\n+\n+#ifdef DEBUG_ENABLED\n+\tif (!Engine::get_singleton()->is_editor_hint()) {\n+\t\tWARN_PRINT_ONCE(\"Source geometry parsing for navigation mesh baking had to parse RenderingServer meshes at runtime.\\n\\\n+\t\tThis poses a significant performance issues as visual meshes store geometry data on the GPU and transferring this data back to the CPU blocks the rendering.\\n\\\n+\t\tFor runtime (re)baking navigation meshes use and parse collision shapes as source geometry or create geometry data procedurally in scripts.\");\n+\t}\n+#endif\n+\n \t_add_mesh(p_mesh, root_node_transform * p_xform);\n }\n \n", "changed_method_name": "NavigationMeshSourceGeometryData3D::add_mesh"}
{"commit_url": "https://github.com/godotengine/godot/commit/e201e5bf30bdd7ea4f515ebf8d47a70172683f7e", "commit_message": "Fix Windows Activate Process", "code_diff": "@@ -4727,6 +4727,7 @@ LRESULT DisplayServerWindows::WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARA\n \t\t} break;\n \t\tcase WM_EXITSIZEMOVE: {\n \t\t\tKillTimer(windows[window_id].hWnd, windows[window_id].move_timer_id);\n+\t\t\twindows[window_id].move_timer_id = 0;\n \t\t} break;\n \t\tcase WM_TIMER: {\n \t\t\tif (wParam == windows[window_id].move_timer_id) {\n", "changed_method_name": "DisplayServerWindows::WndProc"}
{"commit_url": "https://github.com/godotengine/godot/commit/97085358ce154f34d6ab571c35529a8b0e063513", "commit_message": "[Editor] Prevent unnecessary editor theme regeneration on unrelated system setting update.", "code_diff": "@@ -670,7 +670,10 @@ void EditorNode::_notification(int p_what) {\n \n \t\t\tcallable_mp(this, &EditorNode::_begin_first_scan).call_deferred();\n \n-\t\t\tDisplayServer::get_singleton()->set_system_theme_change_callback(callable_mp(this, &EditorNode::_update_theme).bind(false));\n+\t\t\tlast_dark_mode_state = DisplayServer::get_singleton()->is_dark_mode();\n+\t\t\tlast_system_accent_color = DisplayServer::get_singleton()->get_accent_color();\n+\t\t\tlast_system_base_color = DisplayServer::get_singleton()->get_base_color();\n+\t\t\tDisplayServer::get_singleton()->set_system_theme_change_callback(callable_mp(this, &EditorNode::_check_system_theme_changed));\n \n \t\t\t/* DO NOT LOAD SCENES HERE, WAIT FOR FILE SCANNING AND REIMPORT TO COMPLETE */\n \t\t} break;\n", "changed_method_name": "EditorNode::_notification"}
{"commit_url": "https://github.com/ClickHouse/ClickHouse/commit/eeb78bf29172112ee832e2e46ed75271961717d9", "commit_message": "slightly optimize very short queries with LowCardinality", "code_diff": "@@ -43,11 +43,13 @@ MergeTreeReaderStream::MergeTreeReaderStream(\n         /// If the end of range is inside the block, we will need to read it too.\n         if (right_mark < marks_count && marks_loader.getMark(right_mark).offset_in_decompressed_block > 0)\n         {\n-            while (right_mark < marks_count\n-                && marks_loader.getMark(right_mark).offset_in_compressed_file == marks_loader.getMark(mark_range.end).offset_in_compressed_file)\n+            auto indices = ext::range(right_mark, marks_count);\n+            auto it = std::upper_bound(indices.begin(), indices.end(), right_mark, [this](size_t i, size_t j)\n             {\n-                ++right_mark;\n-            }\n+                return marks_loader.getMark(i).offset_in_compressed_file < marks_loader.getMark(j).offset_in_compressed_file;\n+            });\n+\n+            right_mark = (it == indices.end() ? marks_count : *it);\n         }\n \n         size_t mark_range_bytes;\n", "changed_method_name": "DB::MergeTreeReaderStream::MergeTreeReaderStream"}
{"commit_url": "https://github.com/ClickHouse/ClickHouse/commit/fff110aa38c8af9d91682a34d79f21a47a47b632", "commit_message": "HashedDictionary clickhouse source preallocate regression fix", "code_diff": "@@ -384,42 +384,13 @@ void HashedDictionary::loadData()\n {\n     if (!source_ptr->hasUpdateField())\n     {\n-        /// atomic since progress callbac called in parallel\n-        std::atomic<uint64_t> new_size = 0;\n         auto stream = source_ptr->loadAll();\n \n-        /// preallocation can be used only when we know number of rows, for this we need:\n-        /// - source clickhouse\n-        /// - no filtering (i.e. lack of <where>), since filtering can filter\n-        ///   too much rows and eventually it may allocate memory that will\n-        ///   never be used.\n-        bool preallocate = false;\n-        if (const auto & clickhouse_source = dynamic_cast<ClickHouseDictionarySource *>(source_ptr.get()))\n-        {\n-            if (!clickhouse_source->hasWhere())\n-                preallocate = true;\n-        }\n-\n-        if (preallocate)\n-        {\n-            stream->setProgressCallback([&new_size](const Progress & progress)\n-            {\n-                new_size += progress.total_rows_to_read;\n-            });\n-        }\n-\n         stream->readPrefix();\n \n         while (const auto block = stream->read())\n         {\n-            if (new_size)\n-            {\n-                size_t current_new_size = new_size.exchange(0);\n-                if (current_new_size)\n-                    resize(current_new_size);\n-            }\n-            else\n-                resize(block.rows());\n+            resize(block.rows());\n             blockToAttributes(block);\n         }\n \n", "changed_method_name": "DB::HashedDictionary::loadData"}
{"commit_url": "https://github.com/ClickHouse/ClickHouse/commit/3e700e854d6a1620bf80da5340206e1ec691b22a", "commit_message": "cancel merges before acquiring lock for truncate", "code_diff": "@@ -35,6 +35,10 @@ namespace ErrorCodes\n     extern const int TABLE_IS_READ_ONLY;\n }\n \n+namespace ActionLocks\n+{\n+    extern const StorageActionBlockType PartsMerge;\n+}\n \n static DatabasePtr tryGetDatabase(const String & database_name, bool if_exists)\n {\n@@ -202,7 +206,15 @@ BlockIO InterpreterDropQuery::executeToTableImpl(ContextPtr context_, ASTDropQue\n \n             table->checkTableCanBeDropped();\n \n-            auto table_lock = table->lockExclusively(context_->getCurrentQueryId(), context_->getSettingsRef().lock_acquire_timeout);\n+            TableExclusiveLockHolder table_lock;\n+            /// We don't need this lock for ReplicatedMergeTree\n+            if (!table->supportsReplication())\n+            {\n+                /// And for simple MergeTree we can stop merges before acquiring the lock\n+                auto merges_blocker = table->getActionLock(ActionLocks::PartsMerge);\n+                auto table_lock = table->lockExclusively(context_->getCurrentQueryId(), context_->getSettingsRef().lock_acquire_timeout);\n+            }\n+\n             auto metadata_snapshot = table->getInMemoryMetadataPtr();\n             /// Drop table data, don't touch metadata\n             table->truncate(query_ptr, metadata_snapshot, context_, table_lock);\n", "changed_method_name": "DB::InterpreterDropQuery::executeToTableImpl"}
{"commit_url": "https://github.com/ClickHouse/ClickHouse/commit/a45e3d47adacc59699de26b59e5966307b97b8fb", "commit_message": "Remove useless codec from system.asynchronous_metric_log", "code_diff": "@@ -40,7 +40,7 @@ struct AsynchronousMetricLogElement\n         return \"event_date Date CODEC(Delta(2), ZSTD(1)), \"\n                \"event_time DateTime CODEC(Delta(4), ZSTD(1)), \"\n                \"metric LowCardinality(String) CODEC(ZSTD(1)), \"\n-               \"value Float64 CODEC(Gorilla, ZSTD(3))\";\n+               \"value Float64 CODEC(ZSTD(3))\";\n     }\n };\n \n", "changed_method_name": "DB::AsynchronousMetricLogElement::getCustomColumnList"}
{"commit_url": "https://github.com/ClickHouse/ClickHouse/commit/6c8fc4cd11966cb96571fe3a2dfaac6b82cbd03c", "commit_message": "fix hashjoin debug code condition", "code_diff": "@@ -495,7 +495,7 @@ size_t HashJoin::getTotalByteCount() const\n     if (!data)\n         return 0;\n \n-#ifdef NDEBUG\n+#ifndef NDEBUG\n     size_t debug_blocks_allocated_size = 0;\n     for (const auto & block : data->blocks)\n         debug_blocks_allocated_size += block.allocatedBytes();\n", "changed_method_name": "DB::HashJoin::getTotalByteCount"}
{"commit_url": "https://github.com/qbittorrent/qBittorrent/commit/534ed91d043abfe8ad7ccd307e4c8b060bdaf214", "commit_message": "Change MixedModeAlgorithm default to TCP. Closes #7779.\n\nMixedModeAlgorithm::Proportional will throttle TCP connections when utp\nis in use and users is expecting maximum speed no matter what, so now\ndisable the throttling.", "code_diff": "@@ -304,7 +304,7 @@ Session::Session(QObject *parent)\n     , m_btProtocol(BITTORRENT_SESSION_KEY(\"BTProtocol\"), BTProtocol::Both\n         , clampValue(BTProtocol::Both, BTProtocol::UTP))\n     , m_isUTPRateLimited(BITTORRENT_SESSION_KEY(\"uTPRateLimited\"), true)\n-    , m_utpMixedMode(BITTORRENT_SESSION_KEY(\"uTPMixedMode\"), MixedModeAlgorithm::Proportional\n+    , m_utpMixedMode(BITTORRENT_SESSION_KEY(\"uTPMixedMode\"), MixedModeAlgorithm::TCP\n         , clampValue(MixedModeAlgorithm::TCP, MixedModeAlgorithm::Proportional))\n     , m_multiConnectionsPerIpEnabled(BITTORRENT_SESSION_KEY(\"MultiConnectionsPerIp\"), false)\n     , m_isAddTrackersEnabled(BITTORRENT_SESSION_KEY(\"AddTrackersEnabled\"), false)\n", "changed_method_name": "Session::Session"}
{"commit_url": "https://github.com/hrydgard/ppsspp/commit/adda49d05d1091decb8832259f0ca4e9e085f143", "commit_message": "Add a heuristic avoiding joining framebuffers horizontally\n\n...when texturing from the other one.\n\nGreatly improves GPU performance in Rainbow Six: Vegas.\n\nFixes #9324.", "code_diff": "@@ -426,6 +426,14 @@ VirtualFramebuffer *FramebufferManagerCommon::DoSetRenderFrameBuffer(Framebuffer\n \t\t\tu32 v_fb_end_ptr = v->fb_address + v->fb_stride * v->height * bpp;\n \n \t\t\tif (params.fb_address > v->fb_address && params.fb_address < v_fb_first_line_end_ptr) {\n+\t\t\t\t// If the framebuffer we can join to is currently bound as a texture, we likely have\n+\t\t\t\t// a situation like in #9324 and don't want to do this.\n+\t\t\t\tu32 curTextureAddress = gstate.getTextureAddress(0);\n+\t\t\t\tif (v->fb_address == curTextureAddress) {\n+\t\t\t\t\t// Don't try these joining shenanigans.\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\n \t\t\t\tconst int x_offset = (params.fb_address - v->fb_address) / bpp;\n \t\t\t\tif (x_offset < params.fb_stride && v->height >= drawing_height) {\n \t\t\t\t\t// Pretty certainly a pure render-to-X-offset.\n", "changed_method_name": "FramebufferManagerCommon::DoSetRenderFrameBuffer"}
{"commit_url": "https://github.com/NixOS/nix/commit/0f977bf91e29192d7f0c0f9cad16351bad7cd137", "commit_message": "Remove a useless debug message in filetransfer.cc\n\nRemove the `verify TLS: Nix CA file = 'blah'` message that Nix used to print when fetching anything as it's both useless (`libcurl` prints the same info in its logs) and misleading (gives the impression that a new TLS connection is being established which might not be the case because of multiplexing. See #7011 )", "code_diff": "@@ -322,7 +322,6 @@ struct curlFileTransfer : public FileTransfer\n             }\n \n             if (request.verifyTLS) {\n-                debug(\"verify TLS: Nix CA file = '%s'\", settings.caFile);\n                 if (settings.caFile != \"\")\n                     curl_easy_setopt(req, CURLOPT_CAINFO, settings.caFile.c_str());\n             } else {\n", "changed_method_name": "nix::curlFileTransfer::TransferItem::init"}
{"commit_url": "https://github.com/mapbox/mapbox-gl-native/commit/2f30dfe97d851f2a2bb4141dc234013b01f8afd3", "commit_message": "Disable heading updates for .FollowWithCourse\n\nFixes #2180.", "code_diff": "@@ -2310,6 +2310,7 @@ CLLocationCoordinate2D MGLLocationCoordinate2DFromLatLng(mbgl::LatLng latLng)\n             break;\n         }\n         case MGLUserTrackingModeFollow:\n+        case MGLUserTrackingModeFollowWithCourse:\n         {\n             self.showsUserLocation = YES;\n \n@@ -2323,7 +2324,6 @@ CLLocationCoordinate2D MGLLocationCoordinate2DFromLatLng(mbgl::LatLng latLng)\n             break;\n         }\n         case MGLUserTrackingModeFollowWithHeading:\n-        case MGLUserTrackingModeFollowWithCourse:\n         {\n             self.showsUserLocation = YES;\n \n", "changed_method_name": "switch"}
{"commit_url": "https://github.com/rwengine/openrw/commit/f7bd8701db2a98678e206ae78515b0a0e16b092b", "commit_message": "setForcedUpdateAllAabbs to false; Reduces stepSimulation time by 35%.\n\nThis causes a drop from 6.5ms to 4.2ms on my machine.", "code_diff": "@@ -92,6 +92,7 @@ GameWorld::GameWorld(Logger* log, GameData* dat)\n         _overlappingPairCallback.get());\n     gContactProcessedCallback = ContactProcessedCallback;\n     dynamicsWorld->setInternalTickCallback(PhysicsTickCallback, this);\n+    dynamicsWorld->setForceUpdateAllAabbs(false);\n }\n \n GameWorld::~GameWorld() {\n", "changed_method_name": "GameWorld::GameWorld"}
{"commit_url": "https://github.com/kokkos/kokkos/commit/910d43e45b04fb0e7d155233f7069cab0aeefc79", "commit_message": "OpenMP: Adding an ifdef around chunksize for static schedule for GCC compiler.", "code_diff": "@@ -101,8 +101,15 @@ class ParallelFor<FunctorType, Kokkos::RangePolicy<Traits...>, Kokkos::OpenMP> {\n   std::enable_if_t<!std::is_same<typename Policy::schedule_type::type,\n                                  Kokkos::Dynamic>::value>\n   execute_parallel() const {\n+// Specifying an chunksize with GCC compiler leads to performance regression\n+// with static schedule.\n+#ifdef KOKKOS_COMPILER_GNU\n+#pragma omp parallel for schedule(static) \\\n+    num_threads(m_instance->thread_pool_size())\n+#else\n #pragma omp parallel for schedule(static KOKKOS_OPENMP_OPTIONAL_CHUNK_SIZE) \\\n     num_threads(m_instance->thread_pool_size())\n+#endif\n     KOKKOS_PRAGMA_IVDEP_IF_ENABLED\n     for (auto iwork = m_policy.begin(); iwork < m_policy.end(); ++iwork) {\n       exec_work(m_functor, iwork);\n", "changed_method_name": "Kokkos::Impl::ParallelFor::execute_parallel"}
{"commit_url": "https://github.com/NREL/EnergyPlus/commit/ff568f7733204d88c810b10b3c792fe6b9c2a188", "commit_message": "Don't copy structs into kiva convection lambdas.", "code_diff": "@@ -3441,16 +3441,11 @@ void CalcCeilingDiffuserIntConvCoeff(EnergyPlusData &state,\n \n     for (auto SurfNum = Zone(ZoneNum).HTSurfaceFirst; SurfNum <= Zone(ZoneNum).HTSurfaceLast; ++SurfNum) {\n         if (Surface(SurfNum).ExtBoundCond == DataSurfaces::KivaFoundation) {\n+            Real64 height = state.dataSurface->Surface(SurfNum).Height;\n+            bool isWindow = state.dataConstruction->Construct(state.dataSurface->Surface(SurfNum).Construction).TypeIsWindow;\n             state.dataSurfaceGeometry->kivaManager.surfaceConvMap[SurfNum].in =\n                 [=, &state](double Tsurf, double Tamb, double, double, double cosTilt) -> double {\n-                return CalcCeilingDiffuserIntConvCoeff(state,\n-                                                       ACH,\n-                                                       Tsurf,\n-                                                       Tamb,\n-                                                       cosTilt,\n-                                                       AirHumRat,\n-                                                       Surface(SurfNum).Height,\n-                                                       state.dataConstruction->Construct(Surface(SurfNum).Construction).TypeIsWindow);\n+                return CalcCeilingDiffuserIntConvCoeff(state, ACH, Tsurf, Tamb, cosTilt, AirHumRat, height, isWindow);\n             };\n         } else {\n             state.dataHeatBalSurf->SurfHConvInt(SurfNum) =\n", "changed_method_name": "EnergyPlus::ConvectionCoefficients::CalcCeilingDiffuserIntConvCoeff"}
{"commit_url": "https://github.com/EasyRPG/Player/commit/a086820de8eadbd830f3aa5ebf822d548a465879", "commit_message": "When the cache is exhausted do not delete unreferenced assets that were used during the last 50ms (approx. 3 frames).\n\nThe current behaviour (flush everything unreferenced when cache is full) was added to workaround out-of-memory issues on systems with limited RAM but this direct unload makes some use cases like face rendering in the Battle scene with Gauge style really slow (when the cache is full the face is unloaded and reloaded from disk once every frame).\n\nI hope that 50ms is a good compromise here.\n\nFix #2509", "code_diff": "@@ -101,8 +101,15 @@ namespace {\n \t\t\t\tcontinue;\n \t\t\t}\n \n-\t\t\tif (cache_size <= cache_limit && cur_ticks - it->second.last_access < 3s) {\n-\t\t\t\t// Below memory limit and last access < 3s\n+\t\t\tauto last_access = cur_ticks - it->second.last_access;\n+\t\t\tbool cache_exhausted = cache_size > cache_limit;\n+\t\t\tif (cache_exhausted) {\n+\t\t\t\tif (last_access <= 50ms) {\n+\t\t\t\t\t// Used during the last 3 frames, must be important, keep it.\n+\t\t\t\t\t++it;\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t} else if (last_access <= 3s) {\n \t\t\t\t++it;\n \t\t\t\tcontinue;\n \t\t\t}\n", "changed_method_name": "FreeBitmapMemory"}
{"commit_url": "https://github.com/EasyRPG/Player/commit/72749b7a94ea09ec59870e099aac9bbf5de89a45", "commit_message": "Effects cache: Fix memory leak\n\nThe BitmapRef reference counter never reached 0 because it was part of the key, preventing deletion.\nChanged it to a pointer. The value is never read so doesn't matter if it becomes stale.\n\nFix #3163", "code_diff": "@@ -81,7 +81,7 @@ namespace {\n \tstd::unordered_map<tile_key_type, std::weak_ptr<Bitmap>> cache_tiles;\n \n \t// rect, flip_x, flip_y, tone, blend\n-\tusing effect_key_type = std::tuple<BitmapRef, Rect, bool, bool, Tone, Color>;\n+\tusing effect_key_type = std::tuple<Bitmap*, Rect, bool, bool, Tone, Color>;\n \tstd::map<effect_key_type, std::weak_ptr<Bitmap>> cache_effects;\n \n \tstd::string system_name;\n@@ -444,7 +444,7 @@ BitmapRef Cache::Tile(StringView filename, int tile_id) {\n \n BitmapRef Cache::SpriteEffect(const BitmapRef& src_bitmap, const Rect& rect, bool flip_x, bool flip_y, const Tone& tone, const Color& blend) {\n \tconst effect_key_type key {\n-\t\tsrc_bitmap,\n+\t\tsrc_bitmap.get(),\n \t\trect,\n \t\tflip_x,\n \t\tflip_y,\n", "changed_method_name": "Cache::SpriteEffect"}
{"commit_url": "https://github.com/CasparCG/server/commit/a7fb293dd8ba4ed5c3cafa3da35dbdf872371d84", "commit_message": "fix(decklink): guard against null video or audio frame from decklink", "code_diff": "@@ -388,15 +388,18 @@ class decklink_producer : public IDeckLinkInputCallback\n         {\n             state_[\"file/name\"]              = model_name_;\n             state_[\"file/path\"]              = device_index_;\n-            state_[\"file/video/width\"]       = video->GetWidth();\n-            state_[\"file/video/height\"]      = video->GetHeight();\n             state_[\"file/audio/sample-rate\"] = format_desc_.audio_sample_rate;\n             state_[\"file/audio/channels\"]    = format_desc_.audio_channels;\n             state_[\"file/fps\"]               = format_desc_.fps;\n             state_[\"profiler/time\"]          = {frame_timer.elapsed(), format_desc_.fps};\n             state_[\"buffer\"]                 = {frame_buffer_.size(), frame_buffer_.capacity()};\n \n-            graph_->set_value(\"frame-time\", frame_timer.elapsed() * format_desc_.fps / format_desc_.field_count * 0.5);\n+            if (video) {\n+                state_[\"file/video/width\"]  = video->GetWidth();\n+                state_[\"file/video/height\"] = video->GetHeight();\n+            }\n+\n+            graph_->set_value(\"frame-time\", frame_timer.elapsed() * format_desc_.fps * 0.5);\n             graph_->set_value(\"output-buffer\",\n                               static_cast<float>(frame_buffer_.size()) / static_cast<float>(frame_buffer_.capacity()));\n         };\n@@ -408,7 +411,7 @@ class decklink_producer : public IDeckLinkInputCallback\n             BMDTimeValue in_video_pts = 0LL;\n             BMDTimeValue in_audio_pts = 0LL;\n \n-            {\n+            if (video) {\n                 auto src    = std::shared_ptr<AVFrame>(av_frame_alloc(), [](AVFrame* ptr) { av_frame_free(&ptr); });\n                 src->format = AV_PIX_FMT_UYVY422;\n                 src->width  = video->GetWidth();\n@@ -418,7 +421,7 @@ class decklink_producer : public IDeckLinkInputCallback\n                 src->key_frame        = 1;\n \n                 void* video_bytes = nullptr;\n-                if (video && SUCCEEDED(video->GetBytes(&video_bytes)) && video_bytes) {\n+                if (SUCCEEDED(video->GetBytes(&video_bytes)) && video_bytes) {\n                     video->AddRef();\n                     src = std::shared_ptr<AVFrame>(src.get(), [src, video](AVFrame* ptr) { video->Release(); });\n \n@@ -439,14 +442,14 @@ class decklink_producer : public IDeckLinkInputCallback\n                 }\n             }\n \n-            {\n+            if (audio) {\n                 auto src             = std::shared_ptr<AVFrame>(av_frame_alloc(), [](AVFrame* ptr) { av_frame_free(&ptr); });\n                 src->format          = AV_SAMPLE_FMT_S32;\n                 src->channels        = format_desc_.audio_channels;\n                 src->sample_rate     = format_desc_.audio_sample_rate;\n \n                 void* audio_bytes = nullptr;\n-                if (audio && SUCCEEDED(audio->GetBytes(&audio_bytes)) && audio_bytes) {\n+                if (SUCCEEDED(audio->GetBytes(&audio_bytes)) && audio_bytes) {\n                     audio->AddRef();\n                     src = std::shared_ptr<AVFrame>(src.get(), [src, audio](AVFrame* ptr) { audio->Release(); });\n                     src->nb_samples  = audio->GetSampleFrameCount();\n@@ -472,6 +475,8 @@ class decklink_producer : public IDeckLinkInputCallback\n                     auto av_video = alloc_frame();\n                     auto av_audio = alloc_frame();\n \n+                    // TODO (fix) this may get stuck if the decklink sends a frame of video or audio\n+\n                     if (av_buffersink_get_frame_flags(video_filter_.sink, av_video.get(), AV_BUFFERSINK_FLAG_PEEK) <\n                         0) {\n                         return S_OK;\n", "changed_method_name": "caspar::decklink::decklink_producer::VideoInputFrameArrived"}
{"commit_url": "https://github.com/mockingbirdnest/Principia/commit/2c7f44c717fc333bd98e8cd2d0748aaba4db7448", "commit_message": "A more useful trace.", "code_diff": "@@ -20,6 +20,8 @@ using base::HexadecimalEncoder;\n using base::UniqueArray;\n using interface::principia__ActivatePlayer;\n \n+using namespace std::chrono_literals;\n+\n namespace journal {\n \n Player::Player(std::filesystem::path const& path)\n@@ -67,8 +69,9 @@ bool Player::Play(int const index) {\n #include \"journal/player.generated.cc\"\n \n   auto const after = std::chrono::system_clock::now();\n-  if (after - before > std::chrono::milliseconds(100)) {\n-    LOG(ERROR) << \"Long method:\\n\" << method_in->DebugString();\n+  if (after - before > 100ms) {\n+    LOG(ERROR) << \"Long method (\" << (after - before) / 1ms << \" ms):\\n\"\n+               << method_in->DebugString();\n   }\n \n   last_method_in_.swap(method_in);\n", "changed_method_name": "principia::journal::Player::Play"}
{"commit_url": "https://github.com/stan-dev/math/commit/b295b04f0d3500e50740e8aff32ff7c22d04af76", "commit_message": "Improve performance of poisson_log_lpmf in some cases", "code_diff": "@@ -41,9 +41,7 @@ return_type_t<T_log_rate> poisson_log_lpmf(const T_n& n,\n   scalar_seq_view<T_log_rate> alpha_vec(alpha);\n   size_t max_size_seq_view = max_size(n, alpha);\n \n-  // FIXME: first loop size of alpha_vec, second loop if-ed for\n-  // max_size_seq_view==1\n-  for (size_t i = 0; i < max_size_seq_view; i++) {\n+  for (size_t i = 0, size_alpha = size(alpha); i < size_alpha; i++) {\n     if (INFTY == alpha_vec[i]) {\n       return LOG_ZERO;\n     }\n@@ -56,20 +54,28 @@ return_type_t<T_log_rate> poisson_log_lpmf(const T_n& n,\n \n   operands_and_partials<T_log_rate> ops_partials(alpha);\n \n-  // FIXME: cache value_of for alpha_vec?  faster if only one?\n+  VectorBuilder<include_summand<propto>::value, T_partials_return, T_n>\n+      lgamma_n_plus_one(size(n));\n+  if (include_summand<propto>::value) {\n+    for (size_t i = 0, size_n = size(n); i < size_n; i++) {\n+      lgamma_n_plus_one[i] = lgamma(n_vec[i] + 1.0);\n+    }\n+  }\n+\n   VectorBuilder<include_summand<propto, T_log_rate>::value, T_partials_return,\n                 T_log_rate>\n       exp_alpha(size(alpha));\n-  for (size_t i = 0; i < size(alpha); i++) {\n+  for (size_t i = 0, size_alpha = size(alpha); i < size_alpha; i++) {\n     exp_alpha[i] = exp(value_of(alpha_vec[i]));\n   }\n \n   for (size_t i = 0; i < max_size_seq_view; i++) {\n-    if (!(alpha_vec[i] == NEGATIVE_INFTY && n_vec[i] == 0)) {\n+    const auto& alpha_val = value_of(alpha_vec[i]);\n+    if (!(alpha_val == NEGATIVE_INFTY && n_vec[i] == 0)) {\n       if (include_summand<propto>::value) {\n-        logp -= lgamma(n_vec[i] + 1.0);\n+        logp -= lgamma_n_plus_one[i];\n       }\n-      logp += n_vec[i] * value_of(alpha_vec[i]) - exp_alpha[i];\n+      logp += n_vec[i] * alpha_val - exp_alpha[i];\n     }\n \n     if (!is_constant_all<T_log_rate>::value) {\n", "changed_method_name": "stan::math::poisson_log_lpmf"}
{"commit_url": "https://github.com/stan-dev/math/commit/75bcadb96cc061cf3dea20c68c5847bbdc09a3ce", "commit_message": "avoid putting un-needed vars on chain stack and place them on nochain stack to reduce chain calls", "code_diff": "@@ -43,7 +43,9 @@ void gradient(const F& f, const Eigen::Matrix<double, Eigen::Dynamic, 1>& x,\n               double& fx, Eigen::Matrix<double, Eigen::Dynamic, 1>& grad_fx) {\n   start_nested();\n   try {\n-    Eigen::Matrix<var, Eigen::Dynamic, 1> x_var(x);\n+    Eigen::Matrix<var, Eigen::Dynamic, 1> x_var(x.size());\n+    for (int i = 0; i < x.size(); ++i)\n+      x_var(i) = var(new vari(x(i), false));\n     var fx_var = f(x_var);\n     fx = fx_var.val();\n     grad_fx.resize(x.size());\n", "changed_method_name": "stan::math::gradient"}
{"commit_url": "https://github.com/kokkos/kokkos-kernels/commit/cb24a0d477a35e20eabc321985e14d720788c120", "commit_message": "Don't call optimize_gemv for one-shot spmv", "code_diff": "@@ -736,11 +736,9 @@ struct spmv_onemkl_wrapper<false> {\n         const_cast<ordinal_type*>(A.graph.row_map.data()),\n         const_cast<ordinal_type*>(A.graph.entries.data()),\n         const_cast<scalar_type*>(A.values.data()));\n-    auto ev_opt = oneapi::mkl::sparse::optimize_gemv(\n-        exec.sycl_queue(), mkl_mode, handle, {ev_set});\n     auto ev_gemv =\n         oneapi::mkl::sparse::gemv(exec.sycl_queue(), mkl_mode, alpha, handle,\n-                                  x.data(), beta, y.data(), {ev_opt});\n+                                  x.data(), beta, y.data(), {ev_set});\n     // MKL 2023.2 and up make this release okay async even though it takes a\n     // pointer to a stack variable\n #if INTEL_MKL_VERSION >= 20230200\n@@ -776,13 +774,11 @@ struct spmv_onemkl_wrapper<true> {\n         const_cast<ordinal_type*>(A.graph.entries.data()),\n         reinterpret_cast<std::complex<mag_type>*>(\n             const_cast<scalar_type*>(A.values.data())));\n-    auto ev_opt = oneapi::mkl::sparse::optimize_gemv(\n-        exec.sycl_queue(), mkl_mode, handle, {ev_set});\n     auto ev_gemv = oneapi::mkl::sparse::gemv(\n         exec.sycl_queue(), mkl_mode, alpha, handle,\n         reinterpret_cast<std::complex<mag_type>*>(\n             const_cast<scalar_type*>(x.data())),\n-        beta, reinterpret_cast<std::complex<mag_type>*>(y.data()), {ev_opt});\n+        beta, reinterpret_cast<std::complex<mag_type>*>(y.data()), {ev_set});\n     // MKL 2023.2 and up make this release okay async even though it takes a\n     // pointer to a stack variable\n #if INTEL_MKL_VERSION >= 20230200\n", "changed_method_name": "KokkosSparse::Impl::spmv_onemkl_wrapper::spmv"}
{"commit_url": "https://github.com/PrincetonUniversity/athena/commit/36a24ba98c79313fdc8eb99a2b6328e13432b187", "commit_message": "fix a bug in disk.cpp related to #430", "code_diff": "@@ -175,7 +175,7 @@ void GetCylCoord(Coordinates *pco,Real &rad,Real &phi,Real &z,int i,int j,int k)\n     z=pco->x3v(k);\n   } else if (std::strcmp(COORDINATE_SYSTEM, \"spherical_polar\") == 0) {\n     rad=std::abs(pco->x1v(i)*std::sin(pco->x2v(j)));\n-    phi=pco->x3v(i);\n+    phi=pco->x3v(k);\n     z=pco->x1v(i)*std::cos(pco->x2v(j));\n   }\n   return;\n", "changed_method_name": "GetCylCoord"}
