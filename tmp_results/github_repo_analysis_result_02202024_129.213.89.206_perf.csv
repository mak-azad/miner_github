Project Name,Commit URL,Message,src_before,src,changed_method_name,loc
ccache,https://github.com/ccache/ccache/commit/3eaee4c2a7c9992547585e416f51da1a6337e167,"""Bail out on profiling flags

GCCs options -fprofile-generate and -fprofile-use are used for profile guided
optimization. It depends on the ability to locate the profile data files
(.gcda) after running the executable with the training data. However, ccache
prevents the compiler from finding the correct profile data file. Therefore the
following patch disables the caching when one of the -fprofile-generate
-fprofile-use flags is found.""","""/*
  a re-implementation of the compilercache scripts in C

  The idea is based on the shell-script compilercache by Erik Thiele <erikyyy@erikyyy.de>

   Copyright (C) Andrew Tridgell 2002-2007
   Copyright (C) Martin Pool 2003
   Copyright (C) Joel Rosdahl 2009-2010

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
*/

#include ""ccache.h""
#include ""getopt_long.h""
#include ""hashtable.h""
#include ""hashtable_itr.h""
#include ""hashutil.h""
#include ""manifest.h""
#include ""comments.h""

#include <sys/mman.h>
#include <errno.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

/* current working directory taken from $PWD, or getcwd() if $PWD is bad */
char *current_working_dir;

/* the base cache directory */
char *cache_dir = NULL;

/* the directory for temporary files */
char *temp_dir = NULL;

/* the debug logfile name, if set */
char *cache_logfile = NULL;

/* base directory (from CCACHE_BASEDIR) */
char *base_dir;

/* the argument list after processing */
static ARGS *stripped_args;

/* the original argument list */
static ARGS *orig_args;

/* the output filename being compiled to */
static char *output_file;

/* the source file */
static char *input_file;

/*
 * the hash of the file containing the cached object code (abcdef[...]-size)
 */
struct file_hash *object_hash;

/*
 * the name of the file containing the cached object code (abcdef[...]-size)
 */
static char *object_name;

/*
 * the full path of the file containing the cached object code
 * (cachedir/a/b/cdef[...]-size)
 */
static char *object_path;

/* the name of the manifest file without the extension (abcdef[...]-size) */
static char *manifest_name;

/*
 * the full path of the file containing the manifest
 * (cachedir/a/b/cdef[...]-size.manifest)
 */
static char *manifest_path;

/*
 * Time of compilation. Used to see if include files have changed after
 * compilation.
 */
static time_t time_of_compilation;

/*
 * Files included by the preprocessor and their hashes/sizes. Key: file path.
 * Value: struct file_hash.
 */
static struct hashtable *included_files;

/* is gcc being asked to output dependencies? */
static int generating_dependencies;

/* the path to the dependency file (implicit or specified with -MF) */
static char *dependency_path;

/* the extension of the file after pre-processing */
static const char *i_extension;

/* the name of the temporary pre-processor file */
static char *i_tmpfile;

/* are we compiling a .i or .ii file directly? */
static int direct_i_file;

/* the name of the cpp stderr file */
static char *cpp_stderr;

/* the name of the statistics file */
char *stats_file = NULL;

/* can we safely use the unification hashing backend? */
static int enable_unify;

/* should we use the direct mode? */
static int enable_direct = 1;

/* a list of supported file extensions, and the equivalent
   extension for code that has been through the pre-processor
*/
static struct {
	char *extension;
	char *i_extension;
} extensions[] = {
	{""c"", ""i""},
	{""C"", ""ii""},
	{""m"", ""mi""},
	{""cc"", ""ii""},
	{""CC"", ""ii""},
	{""cpp"", ""ii""},
	{""CPP"", ""ii""},
	{""cxx"", ""ii""},
	{""CXX"", ""ii""},
	{""c++"", ""ii""},
	{""C++"", ""ii""},
	{""i"", ""i""},
	{""ii"", ""ii""},
	{NULL, NULL}};

enum fromcache_call_mode {
	FROMCACHE_DIRECT_MODE,
	FROMCACHE_CPP_MODE,
	FROMCACHE_COMPILED_MODE
};

enum findhash_call_mode {
	FINDHASH_DIRECT_MODE,
	FINDHASH_CPP_MODE
};

/*
  something went badly wrong - just execute the real compiler
*/
static void failed(void)
{
	char *e;

	/* delete intermediate pre-processor file if needed */
	if (i_tmpfile) {
		if (!direct_i_file) {
			unlink(i_tmpfile);
		}
		free(i_tmpfile);
		i_tmpfile = NULL;
	}

	/* delete the cpp stderr file if necessary */
	if (cpp_stderr) {
		unlink(cpp_stderr);
		free(cpp_stderr);
		cpp_stderr = NULL;
	}

	/* strip any local args */
	args_strip(orig_args, ""--ccache-"");

	if ((e=getenv(""CCACHE_PREFIX""))) {
		char *p = find_executable(e, MYNAME);
		if (!p) {
			perror(e);
			exit(1);
		}
		args_add_prefix(orig_args, p);
	}

	cc_log(""Failed; falling back to running the real compiler\n"");
	execv(orig_args->argv[0], orig_args->argv);
	cc_log(""execv returned (%s)!\n"", strerror(errno));
	perror(orig_args->argv[0]);
	exit(1);
}

char *format_file_hash(struct file_hash *file_hash)
{
	char *ret;
	int i;

	ret = x_malloc(53);
	for (i = 0; i < 16; i++) {
		sprintf(&ret[i*2], ""%02x"", (unsigned)file_hash->hash[i]);
	}
	sprintf(&ret[i*2], ""-%u"", (unsigned)file_hash->size);

	return ret;
}

/*
 * Transform a name to a full path into the cache directory, creating needed
 * sublevels if needed. Caller frees.
 */
static char *get_path_in_cache(const char *name, const char *suffix,
			       int nlevels)
{
	int i;
	char *path;
	char *result;

	path = x_strdup(cache_dir);
	for (i = 0; i < nlevels; ++i) {
		char *p;
		x_asprintf(&p, ""%s/%c"", path, name[i]);
		free(path);
		path = p;
		if (create_dir(path) != 0) {
			cc_log(""failed to create %s\n"", path);
			failed();
		}
	}
	x_asprintf(&result, ""%s/%s%s"", path, name + nlevels, suffix);
	free(path);
	return result;
}

/* Takes over ownership of path. */
static void remember_include_file(char *path, size_t path_len)
{
	struct file_hash *h;
	struct mdfour fhash;
	struct stat st;
	int fd = -1;
	char *data = (char *)-1;

	if (!included_files) {
		goto ignore;
	}

	if (path_len >= 2 && (path[0] == '<' && path[path_len - 1] == '>')) {
		/* Typically <built-in> or <command-line>. */
		goto ignore;
	}

	if (strcmp(path, input_file) == 0) {
		/* Don't remember the input file. */
		goto ignore;
	}

	if (hashtable_search(included_files, path)) {
		/* Already known include file. */
		goto ignore;
	}

	/* Let's hash the include file. */
	fd = open(path, O_RDONLY|O_BINARY);
	if (fd == -1) {
		cc_log(""Failed to open include file \""%s\""\n"", path);
		goto failure;
	}
	if (fstat(fd, &st) != 0) {
		cc_log(""Failed to fstat include file \""%s\""\n"", path);
		goto failure;
	}
	if (S_ISDIR(st.st_mode)) {
		/* Ignore directory, typically $PWD. */
		goto ignore;
	}
	if (st.st_mtime >= time_of_compilation
	    || st.st_ctime >= time_of_compilation) {
		cc_log(""Include file \""%s\"" too new\n"", path);
		goto failure;
	}
	data = mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE, fd, 0);
	if (data == (char *)-1) {
		cc_log(""Failed to mmap %s\n"", path);
		goto failure;
	}

	hash_start(&fhash);
	hash_string_ignoring_comments(&fhash, data, st.st_size);

	h = x_malloc(sizeof(*h));
	hash_result_as_bytes(&fhash, h->hash);
	h->size = fhash.totalN;
	hashtable_insert(included_files, path, h);
	munmap(data, st.st_size);
	return;

failure:
	cc_log(""Disabling direct mode\n"");
	enable_direct = 0;
	hashtable_destroy(included_files, 1);
	included_files = NULL;
	/* Fall through. */
ignore:
	free(path);
	if (data != (char *)-1) {
		munmap(data, st.st_size);
	}
	if (fd != -1) {
		close(fd);
	}
}

/*
 * Make a relative path from CCACHE_BASEDIR to path. Takes over ownership of
 * path. Caller frees.
 */
static char *make_relative_path(char *path)
{
	char *relpath;

	if (!base_dir || strncmp(path, base_dir, strlen(base_dir)) != 0) {
		return path;
	}

	relpath = get_relative_path(current_working_dir, path);
	free(path);
	return relpath;
}

/*
 * This function reads and hashes a file. While doing this, it also does these
 * things with preprocessor lines starting with a hash:
 *
 * - Makes include file paths whose prefix is CCACHE_BASEDIR relative.
 * - Stores the paths of included files in the global variable included_files.
 */
static int process_preprocessed_file(struct mdfour *hash, const char *path)
{
	int fd;
	char *data;
	char *p, *q, *end;
	off_t size;
	struct stat st;

	fd = open(path, O_RDONLY);
	if (fd == -1) {
		cc_log(""failed to open %s\n"", path);
		return 0;
	}
	if (fstat(fd, &st) != 0) {
		cc_log(""failed to fstat %s\n"", path);
		return 0;
	}
	size = st.st_size;
	data = mmap(NULL, size, PROT_READ, MAP_PRIVATE, fd, 0);
	if (data == (void *)-1) {
		cc_log(""failed to mmap %s\n"", path);
		return 0;
	}
	close(fd);

	if (enable_direct) {
		included_files = create_hashtable(1000, hash_from_string,
						  strings_equal);
	}

	/* Bytes between p and q are pending to be hashed. */
	end = data + size;
	p = data;
	q = data;
	while (q < end - 1) {
		if (q[0] == '#' && q[1] == ' ' /* Need to avoid ""#pragma""... */
		    && (q == data || q[-1] == '\n')) {
			char *path;

			while (q < end && *q != '""') {
				q++;
			}
			q++;
			if (q >= end) {
				cc_log(""Failed parsing included file path\n"");
				munmap(data, size);
				return 0;
			}
			/* q points to the beginning of an include file path */
			hash_buffer(hash, p, q - p);
			p = q;
			while (q < end && *q != '""') {
				q++;
			}
			/* p and q span the include file path */
			path = x_strndup(p, q - p);
			path = make_relative_path(path);
			hash_string(hash, path);
			if (enable_direct) {
				remember_include_file(path, q - p);
			} else {
				free(path);
			}
			p = q;
		} else {
			q++;
		}
	}

	hash_buffer(hash, p, (end - p));
	munmap(data, size);
	return 1;
}

/* run the real compiler and put the result in cache */
static void to_cache(ARGS *args)
{
	char *tmp_stdout, *tmp_stderr, *tmp_hashname;
	struct stat st;
	int status;
	int compress;

	x_asprintf(&tmp_stdout, ""%s.tmp.stdout.%s"", object_path, tmp_string());
	x_asprintf(&tmp_stderr, ""%s.tmp.stderr.%s"", object_path, tmp_string());
	x_asprintf(&tmp_hashname, ""%s.tmp.%s"", object_path, tmp_string());

	args_add(args, ""-o"");
	args_add(args, tmp_hashname);

	/* Turn off DEPENDENCIES_OUTPUT when running cc1, because
	 * otherwise it will emit a line like
	 *
	 *  tmp.stdout.vexed.732.o: /home/mbp/.ccache/tmp.stdout.vexed.732.i
	 *
	 * unsetenv() is on BSD and Linux but not portable. */
	putenv(""DEPENDENCIES_OUTPUT"");

	if (getenv(""CCACHE_CPP2"")) {
		args_add(args, input_file);
	} else {
		args_add(args, i_tmpfile);
	}

	cc_log(""Running real compiler\n"");
	status = execute(args->argv, tmp_stdout, tmp_stderr);
	args_pop(args, 3);

	if (stat(tmp_stdout, &st) != 0 || st.st_size != 0) {
		cc_log(""Compiler produced stdout for %s\n"", output_file);
		stats_update(STATS_STDOUT);
		unlink(tmp_stdout);
		unlink(tmp_stderr);
		unlink(tmp_hashname);
		failed();
	}
	unlink(tmp_stdout);

	/*
	 * Merge stderr from the preprocessor (if any) and stderr from the real
	 * compiler into tmp_stderr.
	 */
	if (cpp_stderr) {
		int fd_cpp_stderr;
		int fd_real_stderr;
		int fd_result;

		fd_cpp_stderr = open(cpp_stderr, O_RDONLY | O_BINARY);
		if (fd_cpp_stderr == -1) {
			cc_log(""Failed opening %s\n"", cpp_stderr);
			failed();
		}
		fd_real_stderr = open(tmp_stderr, O_RDONLY | O_BINARY);
		if (fd_real_stderr == -1) {
			cc_log(""Failed opening %s\n"", tmp_stderr);
			failed();
		}
		unlink(tmp_stderr);
		fd_result = open(tmp_stderr,
				 O_WRONLY | O_CREAT | O_TRUNC | O_BINARY,
				 0666);
		if (fd_result == -1) {
			cc_log(""Failed opening %s\n"", tmp_stderr);
			failed();
		}
		copy_fd(fd_cpp_stderr, fd_result);
		copy_fd(fd_real_stderr, fd_result);
		close(fd_cpp_stderr);
		close(fd_real_stderr);
		close(fd_result);
		unlink(cpp_stderr);
		free(cpp_stderr);
		cpp_stderr = NULL;
	}

	if (status != 0) {
		int fd;
		cc_log(""Compile of %s gave status = %d\n"", output_file, status);
		stats_update(STATS_STATUS);

		fd = open(tmp_stderr, O_RDONLY | O_BINARY);
		if (fd != -1) {
			if (strcmp(output_file, ""/dev/null"") == 0
			    || move_file(tmp_hashname, output_file, 0) == 0
			    || errno == ENOENT) {
				/* we can use a quick method of
				   getting the failed output */
				copy_fd(fd, 2);
				close(fd);
				unlink(tmp_stderr);
				if (i_tmpfile && !direct_i_file) {
					unlink(i_tmpfile);
				}
				exit(status);
			}
		}

		unlink(tmp_stderr);
		unlink(tmp_hashname);
		failed();
	}

	compress = !getenv(""CCACHE_NOCOMPRESS"");

	if (stat(tmp_stderr, &st) != 0) {
		cc_log(""Failed to stat %s\n"", tmp_stderr);
		stats_update(STATS_ERROR);
		failed();
	}
	if (st.st_size > 0) {
		char *path_stderr;
		x_asprintf(&path_stderr, ""%s.stderr"", object_path);
		if (move_file(tmp_stderr, path_stderr, compress) != 0) {
			cc_log(""Failed to move tmp stderr to the cache\n"");
			stats_update(STATS_ERROR);
			failed();
		}
		cc_log(""Stored stderr from the compiler in the cache\n"");
		free(path_stderr);
	} else {
		unlink(tmp_stderr);
	}
	if (move_file(tmp_hashname, object_path, compress) != 0) {
		cc_log(""Failed to move tmp object file into the cache\n"");
		stats_update(STATS_ERROR);
		failed();
	}

	/*
	 * Do an extra stat on the potentially compressed object file for the
	 * size statistics.
	 */
	if (stat(object_path, &st) != 0) {
		cc_log(""Failed to stat %s\n"", strerror(errno));
		stats_update(STATS_ERROR);
		failed();
	}

	cc_log(""Placed object file into the cache\n"");
	stats_tocache(file_size(&st));

	free(tmp_hashname);
	free(tmp_stderr);
	free(tmp_stdout);
}

/*
 * Find the object file name by running the compiler in preprocessor mode.
 * Returns the hash as a heap-allocated hex string.
 */
static struct file_hash *
get_object_name_from_cpp(ARGS *args, struct mdfour *hash)
{
	char *input_base;
	char *tmp;
	char *path_stdout, *path_stderr;
	int status;
	struct file_hash *result;

	/* ~/hello.c -> tmp.hello.123.i
	   limit the basename to 10
	   characters in order to cope with filesystem with small
	   maximum filename length limits */
	input_base = str_basename(input_file);
	tmp = strchr(input_base, '.');
	if (tmp != NULL) {
		*tmp = 0;
	}
	if (strlen(input_base) > 10) {
		input_base[10] = 0;
	}

	/* now the run */
	x_asprintf(&path_stdout, ""%s/%s.tmp.%s.%s"", temp_dir,
		   input_base, tmp_string(), i_extension);
	x_asprintf(&path_stderr, ""%s/tmp.cpp_stderr.%s"", temp_dir,
		   tmp_string());

	time_of_compilation = time(NULL);

	if (!direct_i_file) {
		/* run cpp on the input file to obtain the .i */
		args_add(args, ""-E"");
		args_add(args, input_file);
		status = execute(args->argv, path_stdout, path_stderr);
		args_pop(args, 2);
	} else {
		/* we are compiling a .i or .ii file - that means we
		   can skip the cpp stage and directly form the
		   correct i_tmpfile */
		path_stdout = input_file;
		if (create_empty_file(path_stderr) != 0) {
			stats_update(STATS_ERROR);
			cc_log(""failed to create empty stderr file\n"");
			failed();
		}
		status = 0;
	}

	if (status != 0) {
		if (!direct_i_file) {
			unlink(path_stdout);
		}
		unlink(path_stderr);
		cc_log(""the preprocessor gave %d\n"", status);
		stats_update(STATS_PREPROCESSOR);
		failed();
	}

	/* if the compilation is with -g then we have to include the whole of the
	   preprocessor output, which means we are sensitive to line number
	   information. Otherwise we can discard line number info, which makes
	   us less sensitive to reformatting changes

	   Note! I have now disabled the unification code by default
	   as it gives the wrong line numbers for warnings. Pity.
	*/
	if (!enable_unify) {
		if (!process_preprocessed_file(hash, path_stdout)) {
			stats_update(STATS_ERROR);
			unlink(path_stderr);
			failed();
		}
	} else {
		if (unify_hash(hash, path_stdout) != 0) {
			stats_update(STATS_ERROR);
			unlink(path_stderr);
			cc_log(""Failed to unify %s\n"", path_stdout);
			failed();
		}
	}

	if (!hash_file(hash, path_stderr)) {
		fatal(""Failed to open %s\n"", path_stderr);
	}

	i_tmpfile = path_stdout;

	if (!getenv(""CCACHE_CPP2"")) {
		/* if we are using the CPP trick then we need to remember this
		   stderr stderr data and output it just before the main stderr
		   from the compiler pass */
		cpp_stderr = path_stderr;
	} else {
		unlink(path_stderr);
		free(path_stderr);
	}

	result = x_malloc(sizeof(*result));
	hash_result_as_bytes(hash, result->hash);
	result->size = hash->totalN;
	return result;
}

/* find the hash for a command. The hash includes all argument lists,
   plus the output from running the compiler with -E */
static int find_hash(ARGS *args, enum findhash_call_mode mode)
{
	int i;
	char *s;
	struct stat st;
	int nlevels = 2;
	struct mdfour hash;

	switch (mode) {
	case FINDHASH_DIRECT_MODE:
		cc_log(""Trying direct lookup\n"");
		break;

	case FINDHASH_CPP_MODE:
		cc_log(""Running preprocessor\n"");
		break;
	}

	if ((s = getenv(""CCACHE_NLEVELS""))) {
		nlevels = atoi(s);
		if (nlevels < 1) nlevels = 1;
		if (nlevels > 8) nlevels = 8;
	}

	hash_start(&hash);

	/*
	 * Let compressed files get a different hash sum than uncompressed
	 * files to avoid problems when older ccache versions (without
	 * compression support) access the cache.
	 */
	if (!getenv(""CCACHE_NOCOMPRESS"")) {
		hash_buffer(&hash, ""compression"", 12); /* also hash NUL byte */
	}

	/* when we are doing the unifying tricks we need to include
	   the input file name in the hash to get the warnings right */
	if (enable_unify) {
		hash_string(&hash, input_file);
	}

	/* we have to hash the extension, as a .i file isn't treated the same
	   by the compiler as a .ii file */
	hash_string(&hash, i_extension);

	/* first the arguments */
	for (i=1;i<args->argc;i++) {
		/* -L doesn't affect compilation. */
		if (i < args->argc-1 && strcmp(args->argv[i], ""-L"") == 0) {
			i++;
			continue;
		}
		if (strncmp(args->argv[i], ""-L"", 2) == 0) {
			continue;
		}

		/* When using the preprocessor, some arguments don't contribute
		   to the hash. The theory is that these arguments will change
		   the output of -E if they are going to have any effect at
		   all. */
		if (mode == FINDHASH_CPP_MODE) {
			if (i < args->argc-1) {
				if (strcmp(args->argv[i], ""-I"") == 0 ||
				    strcmp(args->argv[i], ""-imacros"") == 0 ||
				    strcmp(args->argv[i], ""-include"") == 0 ||
				    strcmp(args->argv[i], ""-D"") == 0 ||
				    strcmp(args->argv[i], ""-iprefix"") == 0 ||
				    strcmp(args->argv[i], ""-iwithprefix"") == 0 ||
				    strcmp(args->argv[i], ""-iwithprefixbefore"") == 0 ||
				    strcmp(args->argv[i], ""-idirafter"") == 0 ||
				    strcmp(args->argv[i], ""-isystem"") == 0) {
					/* Skip from hash. */
					i++;
					continue;
				}
			}
			if (strncmp(args->argv[i], ""-I"", 2) == 0 ||
			    strncmp(args->argv[i], ""-D"", 2) == 0) {
				/* Skip from hash. */
				continue;
			}
		}

		if (strncmp(args->argv[i], ""--specs="", 8) == 0 &&
		    stat(args->argv[i]+8, &st) == 0) {
			/* If given a explicit specs file, then hash that file,
			   but don't include the path to it in the hash. */
			if (!hash_file(&hash, args->argv[i]+8)) {
				failed();
			}
			continue;
		}

		/* All other arguments are included in the hash. */
		hash_string(&hash, args->argv[i]);
	}

	/* The compiler driver size and date. This is a simple minded way
	   to try and detect compiler upgrades. It is not 100% reliable. */
	if (stat(args->argv[0], &st) != 0) {
		cc_log(""Couldn't stat the compiler!? (argv[0]='%s')\n"", args->argv[0]);
		stats_update(STATS_COMPILER);
		failed();
	}

	/* also include the hash of the compiler name - as some compilers
	   use hard links and behave differently depending on the real name */
	if (st.st_nlink > 1) {
		hash_string(&hash, str_basename(args->argv[0]));
	}

	if (getenv(""CCACHE_HASH_COMPILER"")) {
		hash_file(&hash, args->argv[0]);
	} else if (!getenv(""CCACHE_NOHASH_SIZE_MTIME"")) {
		hash_int(&hash, st.st_size);
		hash_int(&hash, st.st_mtime);
	}

	/* possibly hash the current working directory */
	if (getenv(""CCACHE_HASHDIR"")) {
		char *cwd = gnu_getcwd();
		if (cwd) {
			hash_string(&hash, cwd);
			free(cwd);
		}
	}

	switch (mode) {
	case FINDHASH_DIRECT_MODE:
		if (!hash_file_ignoring_comments(&hash, input_file)) {
			cc_log(""Failed hashing %s\n"", input_file);
			failed();
		}
		manifest_name = hash_result(&hash);
		manifest_path = get_path_in_cache(manifest_name, "".manifest"",
						  nlevels);
		object_hash = manifest_get(manifest_path);
		if (object_hash) {
			cc_log(""Got object file hash from manifest\n"");
		} else {
			cc_log(""Did not find object file hash in manifest\n"");
			return 0;
		}
		break;

	case FINDHASH_CPP_MODE:
		object_hash = get_object_name_from_cpp(args, &hash);
		cc_log(""Got object file hash from preprocessor\n"");
		if (generating_dependencies) {
			cc_log(""Preprocessor created %s\n"", dependency_path);
		}
		break;
	}

	object_name = format_file_hash(object_hash);
	object_path = get_path_in_cache(object_name, """", nlevels);
	x_asprintf(&stats_file, ""%s/%c/stats"", cache_dir, object_name[0]);

	return 1;
}

/*
   try to return the compile result from cache. If we can return from
   cache then this function exits with the correct status code,
   otherwise it returns */
static void from_cache(enum fromcache_call_mode mode, int put_object_in_manifest)
{
	int fd_stderr;
	char *stderr_file;
	char *dep_file;
	int ret;
	struct stat st;
	int produce_dep_file;

	/* the user might be disabling cache hits */
	if (mode != FROMCACHE_COMPILED_MODE && getenv(""CCACHE_RECACHE"")) {
		return;
	}

	/* Check if the object file is there. */
	if (stat(object_path, &st) != 0) {
		cc_log(""Did not find object file in cache\n"");
		return;
	}

	/*
	 * (If mode != FROMCACHE_DIRECT_MODE, the dependency file is created by
	 * gcc.)
	 */
	produce_dep_file = \
		generating_dependencies && mode == FROMCACHE_DIRECT_MODE;

	/* If the dependency file should be in the cache, check that it is. */
	x_asprintf(&dep_file, ""%s.d"", object_path);
	if (produce_dep_file && stat(dep_file, &st) != 0) {
		cc_log(""Dependency file missing in cache\n"");
		free(dep_file);
		return;
	}

	x_asprintf(&stderr_file, ""%s.stderr"", object_path);

	if (strcmp(output_file, ""/dev/null"") == 0) {
		ret = 0;
	} else {
		unlink(output_file);
		/* only make a hardlink if the cache file is uncompressed */
		if (getenv(""CCACHE_HARDLINK"") &&
		    test_if_compressed(object_path) == 0) {
			ret = link(object_path, output_file);
		} else {
			ret = copy_file(object_path, output_file, 0);
		}
	}

	if (ret == -1) {
		if (errno == ENOENT) {
			/* Someone removed the file just before we began copying? */
			cc_log(""Object file missing for %s\n"", output_file);
			stats_update(STATS_MISSING);
		} else {
			cc_log(""Failed to copy/link %s -> %s (%s)\n"",
			       object_path, output_file, strerror(errno));
			stats_update(STATS_ERROR);
			failed();
		}
		unlink(output_file);
		unlink(stderr_file);
		unlink(object_path);
		unlink(dep_file);
		free(dep_file);
		free(stderr_file);
		return;
	} else {
		cc_log(""Created %s\n"", output_file);
	}

	if (produce_dep_file) {
		unlink(dependency_path);
		/* only make a hardlink if the cache file is uncompressed */
		if (getenv(""CCACHE_HARDLINK"") &&
		    test_if_compressed(dep_file) == 0) {
			ret = link(dep_file, dependency_path);
		} else {
			ret = copy_file(dep_file, dependency_path, 0);
		}
		if (ret == -1) {
			if (errno == ENOENT) {
				/*
				 * Someone removed the file just before we
				 * began copying?
				 */
				cc_log(""dependency file missing for %s\n"",
				       output_file);
				stats_update(STATS_MISSING);
			} else {
				cc_log(""failed to copy/link %s -> %s (%s)\n"",
				       dep_file, dependency_path,
				       strerror(errno));
				stats_update(STATS_ERROR);
				failed();
			}
			unlink(output_file);
			unlink(stderr_file);
			unlink(object_path);
			unlink(dep_file);
			free(dep_file);
			free(stderr_file);
			return;
		} else {
			cc_log(""Created %s\n"", dependency_path);
		}
	}

	/* Update modification timestamps to save files from LRU cleanup.
	   Also gives files a sensible mtime when hard-linking. */
	update_mtime(object_path);
	update_mtime(stderr_file);
	if (produce_dep_file) {
		update_mtime(dep_file);
	}

	if (generating_dependencies && mode != FROMCACHE_DIRECT_MODE) {
		/* Store the dependency file in the cache. */
		ret = copy_file(dependency_path, dep_file, 1);
		if (ret == -1) {
			cc_log(""Failed to copy %s -> %s\n"", dependency_path,
			       dep_file);
			/* Continue despite the error. */
		} else {
			cc_log(""Placed dependency file into the cache\n"");
		}
	}
	free(dep_file);

	/* get rid of the intermediate preprocessor file */
	if (i_tmpfile) {
		if (!direct_i_file) {
			unlink(i_tmpfile);
		}
		free(i_tmpfile);
		i_tmpfile = NULL;
	}

	/* Delete the cpp stderr file if necessary. */
	if (cpp_stderr) {
		unlink(cpp_stderr);
		free(cpp_stderr);
		cpp_stderr = NULL;
	}

	/* Send the stderr, if any. */
	fd_stderr = open(stderr_file, O_RDONLY | O_BINARY);
	if (fd_stderr != -1) {
		copy_fd(fd_stderr, 2);
		close(fd_stderr);
	}
	free(stderr_file);

	/* Create or update the manifest file. */
	if (put_object_in_manifest && included_files) {
		if (manifest_put(manifest_path, object_hash, included_files)) {
			cc_log(""Added object file hash to manifest %s\n"",
				manifest_path);
			update_mtime(manifest_path);
		} else {
			cc_log(""Failed to add object file hash to manifest\n"");
		}
	}

	/* log the cache hit */
	switch (mode) {
	case FROMCACHE_DIRECT_MODE:
		cc_log(""Succeded getting cached result\n"");
		stats_update(STATS_CACHEHIT_DIR);
		break;

	case FROMCACHE_CPP_MODE:
		cc_log(""Succeded getting cached result\n"");
		stats_update(STATS_CACHEHIT_CPP);
		break;

	case FROMCACHE_COMPILED_MODE:
		break;
	}

	/* and exit with the right status code */
	exit(0);
}

/* find the real compiler. We just search the PATH to find a executable of the
   same name that isn't a link to ourselves */
static void find_compiler(int argc, char **argv)
{
	char *base;
	char *path;

	orig_args = args_init(argc, argv);

	base = str_basename(argv[0]);

	/* we might be being invoked like ""ccache gcc -c foo.c"" */
	if (strcmp(base, MYNAME) == 0) {
		args_remove_first(orig_args);
		free(base);
		if (strchr(argv[1],'/')) {
			/* a full path was given */
			return;
		}
		base = str_basename(argv[1]);
	}

	/* support user override of the compiler */
	if ((path=getenv(""CCACHE_CC""))) {
		base = strdup(path);
	}

	orig_args->argv[0] = find_executable(base, MYNAME);

	/* can't find the compiler! */
	if (!orig_args->argv[0]) {
		stats_update(STATS_COMPILER);
		perror(base);
		exit(1);
	}
}


/* check a filename for C/C++ extension. Return the pre-processor
   extension */
static const char *check_extension(const char *fname, int *direct_i)
{
	int i;
	const char *p;

	if (direct_i) {
		*direct_i = 0;
	}

	p = strrchr(fname, '.');
	if (!p) return NULL;
	p++;
	for (i=0; extensions[i].extension; i++) {
		if (strcmp(p, extensions[i].extension) == 0) {
			if (direct_i && strcmp(p, extensions[i].i_extension) == 0) {
				*direct_i = 1;
			}
			p = getenv(""CCACHE_EXTENSION"");
			if (p) return p;
			return extensions[i].i_extension;
		}
	}
	return NULL;
}


/*
   process the compiler options to form the correct set of options
   for obtaining the preprocessor output
*/
static void process_args(int argc, char **argv)
{
	int i;
	int found_c_opt = 0;
	int found_S_opt = 0;
	struct stat st;
	/* is the dependency makefile name overridden with -MF? */
	int dependency_filename_specified = 0;
	/* is the dependency makefile target name specified with -MT or -MQ? */
	int dependency_target_specified = 0;

	stripped_args = args_init(0, NULL);

	args_add(stripped_args, argv[0]);

	for (i=1; i<argc; i++) {
		/* some options will never work ... */
		if (strcmp(argv[i], ""-E"") == 0) {
			cc_log(""Compiler option -E is unsupported\n"");
			failed();
		}

		/* these are too hard */
		if (strncmp(argv[i], ""@"", 1) == 0 ||
		    strcmp(argv[i], ""-fbranch-probabilities"") == 0 ||
		    strcmp(argv[i], ""--coverage"") == 0 ||
		    strcmp(argv[i], ""-fprofile-arcs"") == 0 ||
		    strcmp(argv[i], ""-ftest-coverage"") == 0 ||
		    strcmp(argv[i], ""-M"") == 0 ||
		    strcmp(argv[i], ""-MM"") == 0 ||
		    strcmp(argv[i], ""-x"") == 0) {
			cc_log(""Compiler option %s is unsupported\n"", argv[i]);
			stats_update(STATS_UNSUPPORTED);
			failed();
			continue;
		}

		/* we must have -c */
		if (strcmp(argv[i], ""-c"") == 0) {
			args_add(stripped_args, argv[i]);
			found_c_opt = 1;
			continue;
		}

		/* -S changes the default extension */
		if (strcmp(argv[i], ""-S"") == 0) {
			args_add(stripped_args, argv[i]);
			found_S_opt = 1;
			continue;
		}

		/* we need to work out where the output was meant to go */
		if (strcmp(argv[i], ""-o"") == 0) {
			if (i == argc-1) {
				cc_log(""missing argument to %s\n"", argv[i]);
				stats_update(STATS_ARGS);
				failed();
			}
			output_file = argv[i+1];
			i++;
			continue;
		}

		/* alternate form of -o, with no space */
		if (strncmp(argv[i], ""-o"", 2) == 0) {
			output_file = &argv[i][2];
			continue;
		}

		/* debugging is handled specially, so that we know if we
		   can strip line number info
		*/
		if (strncmp(argv[i], ""-g"", 2) == 0) {
			args_add(stripped_args, argv[i]);
			if (strcmp(argv[i], ""-g0"") != 0) {
				enable_unify = 0;
			}
			continue;
		}

		/* The user knows best: just swallow the next arg */
		if (strcmp(argv[i], ""--ccache-skip"") == 0) {
			i++;
			if (i == argc) {
				cc_log(""--ccache-skip lacks an argument\n"");
				failed();
			}
			args_add(stripped_args, argv[i]);
			continue;
		}

		/* These options require special handling, because they
		   behave differently with gcc -E, when the output
		   file is not specified. */
		if (strcmp(argv[i], ""-MD"") == 0
		    || strcmp(argv[i], ""-MMD"") == 0) {
			generating_dependencies = 1;
		}
		if (i < argc - 1) {
			if (strcmp(argv[i], ""-MF"") == 0) {
				dependency_filename_specified = 1;
				dependency_path = make_relative_path(
					x_strdup(argv[i + 1]));
			} else if (strcmp(argv[i], ""-MQ"") == 0
				   || strcmp(argv[i], ""-MT"") == 0) {
				dependency_target_specified = 1;
			}
		}

		if (enable_direct && strncmp(argv[i], ""-Wp,"", 4) == 0) {
			if (strncmp(argv[i], ""-Wp,-MD,"", 8) == 0) {
				generating_dependencies = 1;
				dependency_filename_specified = 1;
				dependency_path = make_relative_path(
					x_strdup(argv[i] + 8));
			} else if (strncmp(argv[i], ""-Wp,-MMD,"", 9) == 0) {
				generating_dependencies = 1;
				dependency_filename_specified = 1;
				dependency_path = make_relative_path(
					x_strdup(argv[i] + 9));
			} else if (enable_direct) {
				cc_log(""Unsupported compiler option for direct mode: %s\n"",
				       argv[i]);
				enable_direct = 0;
			}
		}

		/*
		 * Options taking an argument that that we may want to rewrite
		 * to relative paths to get better hit rate. A secondary effect
		 * is that paths in the standard error output produced by the
		 * compiler will be normalized.
		 */
		{
			const char *opts[] = {
				""-I"", ""-idirafter"", ""-imacros"", ""-include"",
				""-iprefix"", ""-isystem"", NULL
			};
			int j;
			char *relpath;
			for (j = 0; opts[j]; j++) {
				if (strcmp(argv[i], opts[j]) == 0) {
					if (i == argc-1) {
						cc_log(""missing argument to %s\n"",
						       argv[i]);
						stats_update(STATS_ARGS);
						failed();
					}

					args_add(stripped_args, argv[i]);
					relpath = make_relative_path(x_strdup(argv[i+1]));
					args_add(stripped_args, relpath);
					free(relpath);
					i++;
					break;
				}
			}
			if (opts[j]) {
				continue;
			}
		}

		/* Same as above but options with concatenated argument. */
		{
			const char *opts[] = {""-I"", NULL};
			int j;
			char *relpath;
			char *option;
			for (j = 0; opts[j]; j++) {
				if (strncmp(argv[i], opts[j], strlen(opts[j])) == 0) {
					relpath = make_relative_path(
						x_strdup(argv[i] + strlen(opts[j])));
					x_asprintf(&option, ""%s%s"", opts[j], relpath);
					args_add(stripped_args, option);
					free(relpath);
					free(option);
					break;
				}
			}
			if (opts[j]) {
				continue;
			}
		}

		/* options that take an argument */
		{
			const char *opts[] = {""-iwithprefix"", ""-iwithprefixbefore"",
					      ""-L"", ""-D"", ""-U"", ""-x"", ""-MF"",
					      ""-MT"", ""-MQ"", ""-aux-info"",
					      ""--param"", ""-A"", ""-Xlinker"", ""-u"",
					      NULL};
			int j;
			for (j=0;opts[j];j++) {
				if (strcmp(argv[i], opts[j]) == 0) {
					if (i == argc-1) {
						cc_log(""missing argument to %s\n"",
						       argv[i]);
						stats_update(STATS_ARGS);
						failed();
					}

					args_add(stripped_args, argv[i]);
					args_add(stripped_args, argv[i+1]);
					i++;
					break;
				}
			}
			if (opts[j]) continue;
		}

		/* other options */
		if (argv[i][0] == '-') {
			args_add(stripped_args, argv[i]);
			continue;
		}

		/* if an argument isn't a plain file then assume its
		   an option, not an input file. This allows us to
		   cope better with unusual compiler options */
		if (stat(argv[i], &st) != 0 || !S_ISREG(st.st_mode)) {
			args_add(stripped_args, argv[i]);
			continue;
		}

		if (input_file) {
			if (check_extension(argv[i], NULL)) {
				cc_log(""multiple input files (%s and %s)\n"",
				       input_file, argv[i]);
				stats_update(STATS_MULTIPLE);
			} else if (!found_c_opt) {
				cc_log(""called for link with %s\n"", argv[i]);
				if (strstr(argv[i], ""conftest."")) {
					stats_update(STATS_CONFTEST);
				} else {
					stats_update(STATS_LINK);
				}
			} else {
				cc_log(""non C/C++ file %s\n"", argv[i]);
				stats_update(STATS_NOTC);
			}
			failed();
		}

		/* Rewrite to relative to increase hit rate. */
		input_file = make_relative_path(x_strdup(argv[i]));
	}

	if (!input_file) {
		cc_log(""No input file found\n"");
		stats_update(STATS_NOINPUT);
		failed();
	}

	i_extension = check_extension(input_file, &direct_i_file);
	if (i_extension == NULL) {
		cc_log(""Not a C/C++ file - %s\n"", input_file);
		stats_update(STATS_NOTC);
		failed();
	}

	if (!found_c_opt) {
		cc_log(""No -c option found for %s\n"", input_file);
		/* I find that having a separate statistic for autoconf tests is useful,
		   as they are the dominant form of ""called for link"" in many cases */
		if (strstr(input_file, ""conftest."")) {
			stats_update(STATS_CONFTEST);
		} else {
			stats_update(STATS_LINK);
		}
		failed();
	}


	/* don't try to second guess the compilers heuristics for stdout handling */
	if (output_file && strcmp(output_file, ""-"") == 0) {
		stats_update(STATS_OUTSTDOUT);
		cc_log(""Output file is -\n"");
		failed();
	}

	if (!output_file) {
		char *p;
		output_file = x_strdup(input_file);
		if ((p = strrchr(output_file, '/'))) {
			output_file = p+1;
		}
		p = strrchr(output_file, '.');
		if (!p || !p[1]) {
			cc_log(""badly formed output_file %s\n"", output_file);
			stats_update(STATS_ARGS);
			failed();
		}
		p[1] = found_S_opt ? 's' : 'o';
		p[2] = 0;
	}

	/* If dependencies are generated, configure the preprocessor */

	if (generating_dependencies && output_file) {
		if (!dependency_filename_specified) {
			char *default_depfile_name = x_strdup(output_file);
			char *p = strrchr(default_depfile_name, '.');

			if (p) {
				if (strlen(p) < 2) {
					stats_update(STATS_ARGS);
					cc_log(""Too short file extension in %s\n"",
					       default_depfile_name);
					failed();
					return;
				}
				*p = 0;
			}
			else  {
				int len = p - default_depfile_name;

				p = x_malloc(len + 3);
				strncpy(default_depfile_name, p, len - 1);
				free(default_depfile_name);
				default_depfile_name = p;
			}

			strcat(default_depfile_name, "".d"");
			args_add(stripped_args, ""-MF"");
			args_add(stripped_args, default_depfile_name);
			dependency_path = make_relative_path(
				x_strdup(default_depfile_name));
		}

		if (!dependency_target_specified) {
			args_add(stripped_args, ""-MT"");
			args_add(stripped_args, output_file);
		}
	}

	/* cope with -o /dev/null */
	if (strcmp(output_file,""/dev/null"") != 0 && stat(output_file, &st) == 0 && !S_ISREG(st.st_mode)) {
		cc_log(""Not a regular file %s\n"", output_file);
		stats_update(STATS_DEVICE);
		failed();
	}
}

/* the main ccache driver function */
static void ccache(int argc, char *argv[])
{
	char *prefix;
	char now[64];
	time_t t;
	struct tm *tm;
	int put_object_in_manifest = 0;
	struct file_hash *object_hash_from_manifest = NULL;

	t = time(NULL);
	tm = localtime(&t);
	if (!tm) {
		cc_log(""localtime failed\n"");
		failed();
	}

	if (strftime(now, sizeof(now), ""%Y-%m-%d %H:%M:%S"", tm) == 0) {
		cc_log(""strftime failed\n"");
		failed();
	}

	cc_log(""=== %s ===\n"", now);

	cc_log(""Base directory: %s\n"", base_dir);

	/* find the real compiler */
	find_compiler(argc, argv);

	/* use the real compiler if HOME is not set */
	if (!cache_dir) {
		cc_log(""Unable to determine home directory\n"");
		cc_log(""ccache is disabled\n"");
		failed();
	}

	/* we might be disabled */
	if (getenv(""CCACHE_DISABLE"")) {
		cc_log(""ccache is disabled\n"");
		failed();
	}

	if (getenv(""CCACHE_UNIFY"")) {
		enable_unify = 1;
	}

	if (getenv(""CCACHE_NODIRECT"") || enable_unify) {
		cc_log(""Direct mode disabled\n"");
		enable_direct = 0;
	}

	/* process argument list, returning a new set of arguments for
	   pre-processing */
	process_args(orig_args->argc, orig_args->argv);

	cc_log(""Source file: %s\n"", input_file);
	if (generating_dependencies) {
		cc_log(""Dependency file: %s\n"", dependency_path);
	}
	cc_log(""Object file: %s\n"", output_file);

	/* try to find the hash using the manifest */
	if (enable_direct) {
		if (find_hash(stripped_args, FINDHASH_DIRECT_MODE)) {
			/*
			 * If we can return from cache at this point then do
			 * so.
			 */
			from_cache(FROMCACHE_DIRECT_MODE, 0);

			/*
			 * Wasn't able to return from cache at this point.
			 * However, the object was already found in manifest,
			 * so don't readd it later.
			 */
			put_object_in_manifest = 0;

			object_hash_from_manifest = object_hash;
			object_hash = NULL;
		} else {
			/* Add object to manifest later. */
			put_object_in_manifest = 1;
		}
	}

	/*
	 * Find the hash using the preprocessed output. Also updates
	 * included_files.
	 */
	find_hash(stripped_args, FINDHASH_CPP_MODE);

	if (object_hash_from_manifest
	    && !file_hashes_equal(object_hash_from_manifest, object_hash)) {
		/*
		 * The hash from manifest differs from the hash of the
		 * preprocessor output. This could be because:
		 *
		 * - The preprocessor produces different output for the same
		 *   input (not likely).
		 * - There's a bug in ccache (maybe incorrect handling of
		 *   compiler arguments).
		 * - The user has used a different CCACHE_BASEDIR (most
		 *   likely).
		 *
		 * The best thing here would probably be to remove the hash
		 * entry from the manifest. For now, we use a simpler method:
		 * just remove the manifest file.
		 */
		cc_log(""Hash from manifest doesn't match preprocessor output\n"");
		cc_log(""Likely reason: different CCACHE_BASEDIRs used\n"");
		cc_log(""Removing manifest as a safety measure\n"");
		unlink(manifest_path);

		put_object_in_manifest = 1;
	}

	/* if we can return from cache at this point then do */
	from_cache(FROMCACHE_CPP_MODE, put_object_in_manifest);

	if (getenv(""CCACHE_READONLY"")) {
		cc_log(""read-only set - doing real compile\n"");
		failed();
	}

	prefix = getenv(""CCACHE_PREFIX"");
	if (prefix) {
		char *p = find_executable(prefix, MYNAME);
		if (!p) {
			perror(prefix);
			exit(1);
		}
		args_add_prefix(stripped_args, p);
	}

	/* run real compiler, sending output to cache */
	to_cache(stripped_args);

	/* return from cache */
	from_cache(FROMCACHE_COMPILED_MODE, put_object_in_manifest);

	/* oh oh! */
	cc_log(""secondary from_cache failed!\n"");
	stats_update(STATS_ERROR);
	failed();
}


static void usage(void)
{
	printf(""ccache, a compiler cache. Version %s\n"", CCACHE_VERSION);
	printf(""Copyright Andrew Tridgell, 2002\n\n"");

	printf(""Usage:\n"");
	printf(""\tccache [options]\n"");
	printf(""\tccache compiler [compile options]\n"");
	printf(""\tcompiler [compile options]    (via symbolic link)\n"");
	printf(""\nOptions:\n"");

	printf(""-s, --show-stats         show statistics summary\n"");
	printf(""-z, --zero-stats         zero statistics\n"");
	printf(""-c, --cleanup            run a cache cleanup\n"");
	printf(""-C, --clear              clear the cache completely\n"");
	printf(""-F <n>, --max-files=<n>  set maximum number of files in cache (0: no limit)\n"");
	printf(""-M <n>, --max-size=<n>   set maximum size of cache (use G, M or K; 0: no limit)\n"");
	printf(""-h, --help               this help page\n"");
	printf(""-V, --version            print version number\n"");
}

static void check_cache_dir(void)
{
	if (!cache_dir) {
		fatal(""Unable to determine home directory\n"");
	}
}

/* the main program when not doing a compile */
static int ccache_main(int argc, char *argv[])
{
	int c;
	size_t v;

	static struct option long_options[] = {
		{""show-stats"", no_argument,       0, 's'},
		{""zero-stats"", no_argument,       0, 'z'},
		{""cleanup"",    no_argument,       0, 'c'},
		{""clear"",      no_argument,       0, 'C'},
		{""max-files"",  required_argument, 0, 'F'},
		{""max-size"",   required_argument, 0, 'M'},
		{""help"",       no_argument,       0, 'h'},
		{""version"",    no_argument,       0, 'V'},
		{0, 0, 0, 0}
	};
	int option_index = 0;

	while ((c = getopt_long(argc, argv, ""hszcCF:M:V"", long_options, &option_index)) != -1) {
		switch (c) {
		case 'V':
			printf(""ccache version %s\n"", CCACHE_VERSION);
			printf(""\n"");
			printf(""See http://ccache.samba.org.\n"");
			printf(""\n"");
			printf(""Copyright (C) Andrew Tridgell 2002-2007\n"");
			printf(""Copyright (C) Joel Rosdahl 2009-2010\n"");
			printf(""\n"");
			printf(""This program is free software; you can"");
			printf("" redistribute it and/or modify it under\nthe"");
			printf("" terms of the GNU General Public License as"");
			printf("" published by the Free Software\nFoundation;"");
			printf("" either version 2 of the License, or (at"");
			printf("" your option) any later\nversion.\n"");
			exit(0);

		case 'h':
			usage();
			exit(0);

		case 's':
			check_cache_dir();
			stats_summary();
			break;

		case 'c':
			check_cache_dir();
			cleanup_all(cache_dir);
			printf(""Cleaned cache\n"");
			break;

		case 'C':
			check_cache_dir();
			wipe_all(cache_dir);
			printf(""Cleared cache\n"");
			break;

		case 'z':
			check_cache_dir();
			stats_zero();
			printf(""Statistics cleared\n"");
			break;

		case 'F':
			check_cache_dir();
			v = atoi(optarg);
			if (stats_set_limits(v, -1) == 0) {
				if (v == 0) {
					printf(""Unset cache file limit\n"");
				} else {
					printf(""Set cache file limit to %u\n"", (unsigned)v);
				}
			} else {
				printf(""Could not set cache file limit.\n"");
				exit(1);
			}
			break;

		case 'M':
			check_cache_dir();
			v = value_units(optarg);
			if (stats_set_limits(-1, v) == 0) {
				if (v == 0) {
					printf(""Unset cache size limit\n"");
				} else {
					printf(""Set cache size limit to %uk\n"", (unsigned)v);
				}
			} else {
				printf(""Could not set cache size limit.\n"");
				exit(1);
			}
			break;

		default:
			usage();
			exit(1);
		}
	}

	return 0;
}


/* Make a copy of stderr that will not be cached, so things like
   distcc can send networking errors to it. */
static void setup_uncached_err(void)
{
	char *buf;
	int uncached_fd;

	uncached_fd = dup(2);
	if (uncached_fd == -1) {
		cc_log(""dup(2) failed\n"");
		failed();
	}

	/* leak a pointer to the environment */
	x_asprintf(&buf, ""UNCACHED_ERR_FD=%d"", uncached_fd);

	if (putenv(buf) == -1) {
		cc_log(""putenv failed\n"");
		failed();
	}
}


int main(int argc, char *argv[])
{
	char *p;

	current_working_dir = get_cwd();

	cache_dir = getenv(""CCACHE_DIR"");
	if (!cache_dir) {
		const char *home_directory = get_home_directory();
		if (home_directory) {
			x_asprintf(&cache_dir, ""%s/.ccache"", home_directory);
		}
	}

	temp_dir = getenv(""CCACHE_TEMPDIR"");
	if (!temp_dir) {
		x_asprintf(&temp_dir, ""%s/tmp"", cache_dir);
	}

	cache_logfile = getenv(""CCACHE_LOGFILE"");

	base_dir = getenv(""CCACHE_BASEDIR"");
	if (base_dir) {
		if (strcmp(base_dir, """") == 0) {
			base_dir = NULL;
		}
	} else {
		base_dir = get_cwd();
	}

	setup_uncached_err();

	/* the user might have set CCACHE_UMASK */
	p = getenv(""CCACHE_UMASK"");
	if (p) {
		mode_t mask;
		errno = 0;
		mask = strtol(p, NULL, 8);
		if (errno == 0) {
			umask(mask);
		}
	}


	/* check if we are being invoked as ""ccache"" */
	if (strlen(argv[0]) >= strlen(MYNAME) &&
	    strcmp(argv[0] + strlen(argv[0]) - strlen(MYNAME), MYNAME) == 0) {
		if (argc < 2) {
			usage();
			exit(1);
		}
		/* if the first argument isn't an option, then assume we are
		   being passed a compiler name and options */
		if (argv[1][0] == '-') {
			return ccache_main(argc, argv);
		}
	}

	/* make sure the cache dir exists */
	if (create_dir(cache_dir) != 0) {
		fprintf(stderr,""ccache: failed to create %s (%s)\n"",
			cache_dir, strerror(errno));
		exit(1);
	}

	/* make sure the temp dir exists */
	if (create_dir(temp_dir) != 0) {
		fprintf(stderr,""ccache: failed to create %s (%s)\n"",
			temp_dir, strerror(errno));
		exit(1);
	}

	if (!getenv(""CCACHE_READONLY"")) {
		if (create_cachedirtag(cache_dir) != 0) {
			fprintf(stderr,""ccache: failed to create %s/CACHEDIR.TAG (%s)\n"",
				cache_dir, strerror(errno));
			exit(1);
		}
	}

	ccache(argc, argv);
	return 1;
}
""","""/*
  a re-implementation of the compilercache scripts in C

  The idea is based on the shell-script compilercache by Erik Thiele <erikyyy@erikyyy.de>

   Copyright (C) Andrew Tridgell 2002-2007
   Copyright (C) Martin Pool 2003
   Copyright (C) Joel Rosdahl 2009-2010

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
*/

#include ""ccache.h""
#include ""getopt_long.h""
#include ""hashtable.h""
#include ""hashtable_itr.h""
#include ""hashutil.h""
#include ""manifest.h""
#include ""comments.h""

#include <sys/mman.h>
#include <errno.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

/* current working directory taken from $PWD, or getcwd() if $PWD is bad */
char *current_working_dir;

/* the base cache directory */
char *cache_dir = NULL;

/* the directory for temporary files */
char *temp_dir = NULL;

/* the debug logfile name, if set */
char *cache_logfile = NULL;

/* base directory (from CCACHE_BASEDIR) */
char *base_dir;

/* the argument list after processing */
static ARGS *stripped_args;

/* the original argument list */
static ARGS *orig_args;

/* the output filename being compiled to */
static char *output_file;

/* the source file */
static char *input_file;

/*
 * the hash of the file containing the cached object code (abcdef[...]-size)
 */
struct file_hash *object_hash;

/*
 * the name of the file containing the cached object code (abcdef[...]-size)
 */
static char *object_name;

/*
 * the full path of the file containing the cached object code
 * (cachedir/a/b/cdef[...]-size)
 */
static char *object_path;

/* the name of the manifest file without the extension (abcdef[...]-size) */
static char *manifest_name;

/*
 * the full path of the file containing the manifest
 * (cachedir/a/b/cdef[...]-size.manifest)
 */
static char *manifest_path;

/*
 * Time of compilation. Used to see if include files have changed after
 * compilation.
 */
static time_t time_of_compilation;

/*
 * Files included by the preprocessor and their hashes/sizes. Key: file path.
 * Value: struct file_hash.
 */
static struct hashtable *included_files;

/* is gcc being asked to output dependencies? */
static int generating_dependencies;

/* the path to the dependency file (implicit or specified with -MF) */
static char *dependency_path;

/* the extension of the file after pre-processing */
static const char *i_extension;

/* the name of the temporary pre-processor file */
static char *i_tmpfile;

/* are we compiling a .i or .ii file directly? */
static int direct_i_file;

/* the name of the cpp stderr file */
static char *cpp_stderr;

/* the name of the statistics file */
char *stats_file = NULL;

/* can we safely use the unification hashing backend? */
static int enable_unify;

/* should we use the direct mode? */
static int enable_direct = 1;

/* a list of supported file extensions, and the equivalent
   extension for code that has been through the pre-processor
*/
static struct {
	char *extension;
	char *i_extension;
} extensions[] = {
	{""c"", ""i""},
	{""C"", ""ii""},
	{""m"", ""mi""},
	{""cc"", ""ii""},
	{""CC"", ""ii""},
	{""cpp"", ""ii""},
	{""CPP"", ""ii""},
	{""cxx"", ""ii""},
	{""CXX"", ""ii""},
	{""c++"", ""ii""},
	{""C++"", ""ii""},
	{""i"", ""i""},
	{""ii"", ""ii""},
	{NULL, NULL}};

enum fromcache_call_mode {
	FROMCACHE_DIRECT_MODE,
	FROMCACHE_CPP_MODE,
	FROMCACHE_COMPILED_MODE
};

enum findhash_call_mode {
	FINDHASH_DIRECT_MODE,
	FINDHASH_CPP_MODE
};

/*
  something went badly wrong - just execute the real compiler
*/
static void failed(void)
{
	char *e;

	/* delete intermediate pre-processor file if needed */
	if (i_tmpfile) {
		if (!direct_i_file) {
			unlink(i_tmpfile);
		}
		free(i_tmpfile);
		i_tmpfile = NULL;
	}

	/* delete the cpp stderr file if necessary */
	if (cpp_stderr) {
		unlink(cpp_stderr);
		free(cpp_stderr);
		cpp_stderr = NULL;
	}

	/* strip any local args */
	args_strip(orig_args, ""--ccache-"");

	if ((e=getenv(""CCACHE_PREFIX""))) {
		char *p = find_executable(e, MYNAME);
		if (!p) {
			perror(e);
			exit(1);
		}
		args_add_prefix(orig_args, p);
	}

	cc_log(""Failed; falling back to running the real compiler\n"");
	execv(orig_args->argv[0], orig_args->argv);
	cc_log(""execv returned (%s)!\n"", strerror(errno));
	perror(orig_args->argv[0]);
	exit(1);
}

char *format_file_hash(struct file_hash *file_hash)
{
	char *ret;
	int i;

	ret = x_malloc(53);
	for (i = 0; i < 16; i++) {
		sprintf(&ret[i*2], ""%02x"", (unsigned)file_hash->hash[i]);
	}
	sprintf(&ret[i*2], ""-%u"", (unsigned)file_hash->size);

	return ret;
}

/*
 * Transform a name to a full path into the cache directory, creating needed
 * sublevels if needed. Caller frees.
 */
static char *get_path_in_cache(const char *name, const char *suffix,
			       int nlevels)
{
	int i;
	char *path;
	char *result;

	path = x_strdup(cache_dir);
	for (i = 0; i < nlevels; ++i) {
		char *p;
		x_asprintf(&p, ""%s/%c"", path, name[i]);
		free(path);
		path = p;
		if (create_dir(path) != 0) {
			cc_log(""failed to create %s\n"", path);
			failed();
		}
	}
	x_asprintf(&result, ""%s/%s%s"", path, name + nlevels, suffix);
	free(path);
	return result;
}

/* Takes over ownership of path. */
static void remember_include_file(char *path, size_t path_len)
{
	struct file_hash *h;
	struct mdfour fhash;
	struct stat st;
	int fd = -1;
	char *data = (char *)-1;

	if (!included_files) {
		goto ignore;
	}

	if (path_len >= 2 && (path[0] == '<' && path[path_len - 1] == '>')) {
		/* Typically <built-in> or <command-line>. */
		goto ignore;
	}

	if (strcmp(path, input_file) == 0) {
		/* Don't remember the input file. */
		goto ignore;
	}

	if (hashtable_search(included_files, path)) {
		/* Already known include file. */
		goto ignore;
	}

	/* Let's hash the include file. */
	fd = open(path, O_RDONLY|O_BINARY);
	if (fd == -1) {
		cc_log(""Failed to open include file \""%s\""\n"", path);
		goto failure;
	}
	if (fstat(fd, &st) != 0) {
		cc_log(""Failed to fstat include file \""%s\""\n"", path);
		goto failure;
	}
	if (S_ISDIR(st.st_mode)) {
		/* Ignore directory, typically $PWD. */
		goto ignore;
	}
	if (st.st_mtime >= time_of_compilation
	    || st.st_ctime >= time_of_compilation) {
		cc_log(""Include file \""%s\"" too new\n"", path);
		goto failure;
	}
	data = mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE, fd, 0);
	if (data == (char *)-1) {
		cc_log(""Failed to mmap %s\n"", path);
		goto failure;
	}

	hash_start(&fhash);
	hash_string_ignoring_comments(&fhash, data, st.st_size);

	h = x_malloc(sizeof(*h));
	hash_result_as_bytes(&fhash, h->hash);
	h->size = fhash.totalN;
	hashtable_insert(included_files, path, h);
	munmap(data, st.st_size);
	return;

failure:
	cc_log(""Disabling direct mode\n"");
	enable_direct = 0;
	hashtable_destroy(included_files, 1);
	included_files = NULL;
	/* Fall through. */
ignore:
	free(path);
	if (data != (char *)-1) {
		munmap(data, st.st_size);
	}
	if (fd != -1) {
		close(fd);
	}
}

/*
 * Make a relative path from CCACHE_BASEDIR to path. Takes over ownership of
 * path. Caller frees.
 */
static char *make_relative_path(char *path)
{
	char *relpath;

	if (!base_dir || strncmp(path, base_dir, strlen(base_dir)) != 0) {
		return path;
	}

	relpath = get_relative_path(current_working_dir, path);
	free(path);
	return relpath;
}

/*
 * This function reads and hashes a file. While doing this, it also does these
 * things with preprocessor lines starting with a hash:
 *
 * - Makes include file paths whose prefix is CCACHE_BASEDIR relative.
 * - Stores the paths of included files in the global variable included_files.
 */
static int process_preprocessed_file(struct mdfour *hash, const char *path)
{
	int fd;
	char *data;
	char *p, *q, *end;
	off_t size;
	struct stat st;

	fd = open(path, O_RDONLY);
	if (fd == -1) {
		cc_log(""failed to open %s\n"", path);
		return 0;
	}
	if (fstat(fd, &st) != 0) {
		cc_log(""failed to fstat %s\n"", path);
		return 0;
	}
	size = st.st_size;
	data = mmap(NULL, size, PROT_READ, MAP_PRIVATE, fd, 0);
	if (data == (void *)-1) {
		cc_log(""failed to mmap %s\n"", path);
		return 0;
	}
	close(fd);

	if (enable_direct) {
		included_files = create_hashtable(1000, hash_from_string,
						  strings_equal);
	}

	/* Bytes between p and q are pending to be hashed. */
	end = data + size;
	p = data;
	q = data;
	while (q < end - 1) {
		if (q[0] == '#' && q[1] == ' ' /* Need to avoid ""#pragma""... */
		    && (q == data || q[-1] == '\n')) {
			char *path;

			while (q < end && *q != '""') {
				q++;
			}
			q++;
			if (q >= end) {
				cc_log(""Failed parsing included file path\n"");
				munmap(data, size);
				return 0;
			}
			/* q points to the beginning of an include file path */
			hash_buffer(hash, p, q - p);
			p = q;
			while (q < end && *q != '""') {
				q++;
			}
			/* p and q span the include file path */
			path = x_strndup(p, q - p);
			path = make_relative_path(path);
			hash_string(hash, path);
			if (enable_direct) {
				remember_include_file(path, q - p);
			} else {
				free(path);
			}
			p = q;
		} else {
			q++;
		}
	}

	hash_buffer(hash, p, (end - p));
	munmap(data, size);
	return 1;
}

/* run the real compiler and put the result in cache */
static void to_cache(ARGS *args)
{
	char *tmp_stdout, *tmp_stderr, *tmp_hashname;
	struct stat st;
	int status;
	int compress;

	x_asprintf(&tmp_stdout, ""%s.tmp.stdout.%s"", object_path, tmp_string());
	x_asprintf(&tmp_stderr, ""%s.tmp.stderr.%s"", object_path, tmp_string());
	x_asprintf(&tmp_hashname, ""%s.tmp.%s"", object_path, tmp_string());

	args_add(args, ""-o"");
	args_add(args, tmp_hashname);

	/* Turn off DEPENDENCIES_OUTPUT when running cc1, because
	 * otherwise it will emit a line like
	 *
	 *  tmp.stdout.vexed.732.o: /home/mbp/.ccache/tmp.stdout.vexed.732.i
	 *
	 * unsetenv() is on BSD and Linux but not portable. */
	putenv(""DEPENDENCIES_OUTPUT"");

	if (getenv(""CCACHE_CPP2"")) {
		args_add(args, input_file);
	} else {
		args_add(args, i_tmpfile);
	}

	cc_log(""Running real compiler\n"");
	status = execute(args->argv, tmp_stdout, tmp_stderr);
	args_pop(args, 3);

	if (stat(tmp_stdout, &st) != 0 || st.st_size != 0) {
		cc_log(""Compiler produced stdout for %s\n"", output_file);
		stats_update(STATS_STDOUT);
		unlink(tmp_stdout);
		unlink(tmp_stderr);
		unlink(tmp_hashname);
		failed();
	}
	unlink(tmp_stdout);

	/*
	 * Merge stderr from the preprocessor (if any) and stderr from the real
	 * compiler into tmp_stderr.
	 */
	if (cpp_stderr) {
		int fd_cpp_stderr;
		int fd_real_stderr;
		int fd_result;

		fd_cpp_stderr = open(cpp_stderr, O_RDONLY | O_BINARY);
		if (fd_cpp_stderr == -1) {
			cc_log(""Failed opening %s\n"", cpp_stderr);
			failed();
		}
		fd_real_stderr = open(tmp_stderr, O_RDONLY | O_BINARY);
		if (fd_real_stderr == -1) {
			cc_log(""Failed opening %s\n"", tmp_stderr);
			failed();
		}
		unlink(tmp_stderr);
		fd_result = open(tmp_stderr,
				 O_WRONLY | O_CREAT | O_TRUNC | O_BINARY,
				 0666);
		if (fd_result == -1) {
			cc_log(""Failed opening %s\n"", tmp_stderr);
			failed();
		}
		copy_fd(fd_cpp_stderr, fd_result);
		copy_fd(fd_real_stderr, fd_result);
		close(fd_cpp_stderr);
		close(fd_real_stderr);
		close(fd_result);
		unlink(cpp_stderr);
		free(cpp_stderr);
		cpp_stderr = NULL;
	}

	if (status != 0) {
		int fd;
		cc_log(""Compile of %s gave status = %d\n"", output_file, status);
		stats_update(STATS_STATUS);

		fd = open(tmp_stderr, O_RDONLY | O_BINARY);
		if (fd != -1) {
			if (strcmp(output_file, ""/dev/null"") == 0
			    || move_file(tmp_hashname, output_file, 0) == 0
			    || errno == ENOENT) {
				/* we can use a quick method of
				   getting the failed output */
				copy_fd(fd, 2);
				close(fd);
				unlink(tmp_stderr);
				if (i_tmpfile && !direct_i_file) {
					unlink(i_tmpfile);
				}
				exit(status);
			}
		}

		unlink(tmp_stderr);
		unlink(tmp_hashname);
		failed();
	}

	compress = !getenv(""CCACHE_NOCOMPRESS"");

	if (stat(tmp_stderr, &st) != 0) {
		cc_log(""Failed to stat %s\n"", tmp_stderr);
		stats_update(STATS_ERROR);
		failed();
	}
	if (st.st_size > 0) {
		char *path_stderr;
		x_asprintf(&path_stderr, ""%s.stderr"", object_path);
		if (move_file(tmp_stderr, path_stderr, compress) != 0) {
			cc_log(""Failed to move tmp stderr to the cache\n"");
			stats_update(STATS_ERROR);
			failed();
		}
		cc_log(""Stored stderr from the compiler in the cache\n"");
		free(path_stderr);
	} else {
		unlink(tmp_stderr);
	}
	if (move_file(tmp_hashname, object_path, compress) != 0) {
		cc_log(""Failed to move tmp object file into the cache\n"");
		stats_update(STATS_ERROR);
		failed();
	}

	/*
	 * Do an extra stat on the potentially compressed object file for the
	 * size statistics.
	 */
	if (stat(object_path, &st) != 0) {
		cc_log(""Failed to stat %s\n"", strerror(errno));
		stats_update(STATS_ERROR);
		failed();
	}

	cc_log(""Placed object file into the cache\n"");
	stats_tocache(file_size(&st));

	free(tmp_hashname);
	free(tmp_stderr);
	free(tmp_stdout);
}

/*
 * Find the object file name by running the compiler in preprocessor mode.
 * Returns the hash as a heap-allocated hex string.
 */
static struct file_hash *
get_object_name_from_cpp(ARGS *args, struct mdfour *hash)
{
	char *input_base;
	char *tmp;
	char *path_stdout, *path_stderr;
	int status;
	struct file_hash *result;

	/* ~/hello.c -> tmp.hello.123.i
	   limit the basename to 10
	   characters in order to cope with filesystem with small
	   maximum filename length limits */
	input_base = str_basename(input_file);
	tmp = strchr(input_base, '.');
	if (tmp != NULL) {
		*tmp = 0;
	}
	if (strlen(input_base) > 10) {
		input_base[10] = 0;
	}

	/* now the run */
	x_asprintf(&path_stdout, ""%s/%s.tmp.%s.%s"", temp_dir,
		   input_base, tmp_string(), i_extension);
	x_asprintf(&path_stderr, ""%s/tmp.cpp_stderr.%s"", temp_dir,
		   tmp_string());

	time_of_compilation = time(NULL);

	if (!direct_i_file) {
		/* run cpp on the input file to obtain the .i */
		args_add(args, ""-E"");
		args_add(args, input_file);
		status = execute(args->argv, path_stdout, path_stderr);
		args_pop(args, 2);
	} else {
		/* we are compiling a .i or .ii file - that means we
		   can skip the cpp stage and directly form the
		   correct i_tmpfile */
		path_stdout = input_file;
		if (create_empty_file(path_stderr) != 0) {
			stats_update(STATS_ERROR);
			cc_log(""failed to create empty stderr file\n"");
			failed();
		}
		status = 0;
	}

	if (status != 0) {
		if (!direct_i_file) {
			unlink(path_stdout);
		}
		unlink(path_stderr);
		cc_log(""the preprocessor gave %d\n"", status);
		stats_update(STATS_PREPROCESSOR);
		failed();
	}

	/* if the compilation is with -g then we have to include the whole of the
	   preprocessor output, which means we are sensitive to line number
	   information. Otherwise we can discard line number info, which makes
	   us less sensitive to reformatting changes

	   Note! I have now disabled the unification code by default
	   as it gives the wrong line numbers for warnings. Pity.
	*/
	if (!enable_unify) {
		if (!process_preprocessed_file(hash, path_stdout)) {
			stats_update(STATS_ERROR);
			unlink(path_stderr);
			failed();
		}
	} else {
		if (unify_hash(hash, path_stdout) != 0) {
			stats_update(STATS_ERROR);
			unlink(path_stderr);
			cc_log(""Failed to unify %s\n"", path_stdout);
			failed();
		}
	}

	if (!hash_file(hash, path_stderr)) {
		fatal(""Failed to open %s\n"", path_stderr);
	}

	i_tmpfile = path_stdout;

	if (!getenv(""CCACHE_CPP2"")) {
		/* if we are using the CPP trick then we need to remember this
		   stderr stderr data and output it just before the main stderr
		   from the compiler pass */
		cpp_stderr = path_stderr;
	} else {
		unlink(path_stderr);
		free(path_stderr);
	}

	result = x_malloc(sizeof(*result));
	hash_result_as_bytes(hash, result->hash);
	result->size = hash->totalN;
	return result;
}

/* find the hash for a command. The hash includes all argument lists,
   plus the output from running the compiler with -E */
static int find_hash(ARGS *args, enum findhash_call_mode mode)
{
	int i;
	char *s;
	struct stat st;
	int nlevels = 2;
	struct mdfour hash;

	switch (mode) {
	case FINDHASH_DIRECT_MODE:
		cc_log(""Trying direct lookup\n"");
		break;

	case FINDHASH_CPP_MODE:
		cc_log(""Running preprocessor\n"");
		break;
	}

	if ((s = getenv(""CCACHE_NLEVELS""))) {
		nlevels = atoi(s);
		if (nlevels < 1) nlevels = 1;
		if (nlevels > 8) nlevels = 8;
	}

	hash_start(&hash);

	/*
	 * Let compressed files get a different hash sum than uncompressed
	 * files to avoid problems when older ccache versions (without
	 * compression support) access the cache.
	 */
	if (!getenv(""CCACHE_NOCOMPRESS"")) {
		hash_buffer(&hash, ""compression"", 12); /* also hash NUL byte */
	}

	/* when we are doing the unifying tricks we need to include
	   the input file name in the hash to get the warnings right */
	if (enable_unify) {
		hash_string(&hash, input_file);
	}

	/* we have to hash the extension, as a .i file isn't treated the same
	   by the compiler as a .ii file */
	hash_string(&hash, i_extension);

	/* first the arguments */
	for (i=1;i<args->argc;i++) {
		/* -L doesn't affect compilation. */
		if (i < args->argc-1 && strcmp(args->argv[i], ""-L"") == 0) {
			i++;
			continue;
		}
		if (strncmp(args->argv[i], ""-L"", 2) == 0) {
			continue;
		}

		/* When using the preprocessor, some arguments don't contribute
		   to the hash. The theory is that these arguments will change
		   the output of -E if they are going to have any effect at
		   all. */
		if (mode == FINDHASH_CPP_MODE) {
			if (i < args->argc-1) {
				if (strcmp(args->argv[i], ""-I"") == 0 ||
				    strcmp(args->argv[i], ""-imacros"") == 0 ||
				    strcmp(args->argv[i], ""-include"") == 0 ||
				    strcmp(args->argv[i], ""-D"") == 0 ||
				    strcmp(args->argv[i], ""-iprefix"") == 0 ||
				    strcmp(args->argv[i], ""-iwithprefix"") == 0 ||
				    strcmp(args->argv[i], ""-iwithprefixbefore"") == 0 ||
				    strcmp(args->argv[i], ""-idirafter"") == 0 ||
				    strcmp(args->argv[i], ""-isystem"") == 0) {
					/* Skip from hash. */
					i++;
					continue;
				}
			}
			if (strncmp(args->argv[i], ""-I"", 2) == 0 ||
			    strncmp(args->argv[i], ""-D"", 2) == 0) {
				/* Skip from hash. */
				continue;
			}
		}

		if (strncmp(args->argv[i], ""--specs="", 8) == 0 &&
		    stat(args->argv[i]+8, &st) == 0) {
			/* If given a explicit specs file, then hash that file,
			   but don't include the path to it in the hash. */
			if (!hash_file(&hash, args->argv[i]+8)) {
				failed();
			}
			continue;
		}

		/* All other arguments are included in the hash. */
		hash_string(&hash, args->argv[i]);
	}

	/* The compiler driver size and date. This is a simple minded way
	   to try and detect compiler upgrades. It is not 100% reliable. */
	if (stat(args->argv[0], &st) != 0) {
		cc_log(""Couldn't stat the compiler!? (argv[0]='%s')\n"", args->argv[0]);
		stats_update(STATS_COMPILER);
		failed();
	}

	/* also include the hash of the compiler name - as some compilers
	   use hard links and behave differently depending on the real name */
	if (st.st_nlink > 1) {
		hash_string(&hash, str_basename(args->argv[0]));
	}

	if (getenv(""CCACHE_HASH_COMPILER"")) {
		hash_file(&hash, args->argv[0]);
	} else if (!getenv(""CCACHE_NOHASH_SIZE_MTIME"")) {
		hash_int(&hash, st.st_size);
		hash_int(&hash, st.st_mtime);
	}

	/* possibly hash the current working directory */
	if (getenv(""CCACHE_HASHDIR"")) {
		char *cwd = gnu_getcwd();
		if (cwd) {
			hash_string(&hash, cwd);
			free(cwd);
		}
	}

	switch (mode) {
	case FINDHASH_DIRECT_MODE:
		if (!hash_file_ignoring_comments(&hash, input_file)) {
			cc_log(""Failed hashing %s\n"", input_file);
			failed();
		}
		manifest_name = hash_result(&hash);
		manifest_path = get_path_in_cache(manifest_name, "".manifest"",
						  nlevels);
		object_hash = manifest_get(manifest_path);
		if (object_hash) {
			cc_log(""Got object file hash from manifest\n"");
		} else {
			cc_log(""Did not find object file hash in manifest\n"");
			return 0;
		}
		break;

	case FINDHASH_CPP_MODE:
		object_hash = get_object_name_from_cpp(args, &hash);
		cc_log(""Got object file hash from preprocessor\n"");
		if (generating_dependencies) {
			cc_log(""Preprocessor created %s\n"", dependency_path);
		}
		break;
	}

	object_name = format_file_hash(object_hash);
	object_path = get_path_in_cache(object_name, """", nlevels);
	x_asprintf(&stats_file, ""%s/%c/stats"", cache_dir, object_name[0]);

	return 1;
}

/*
   try to return the compile result from cache. If we can return from
   cache then this function exits with the correct status code,
   otherwise it returns */
static void from_cache(enum fromcache_call_mode mode, int put_object_in_manifest)
{
	int fd_stderr;
	char *stderr_file;
	char *dep_file;
	int ret;
	struct stat st;
	int produce_dep_file;

	/* the user might be disabling cache hits */
	if (mode != FROMCACHE_COMPILED_MODE && getenv(""CCACHE_RECACHE"")) {
		return;
	}

	/* Check if the object file is there. */
	if (stat(object_path, &st) != 0) {
		cc_log(""Did not find object file in cache\n"");
		return;
	}

	/*
	 * (If mode != FROMCACHE_DIRECT_MODE, the dependency file is created by
	 * gcc.)
	 */
	produce_dep_file = \
		generating_dependencies && mode == FROMCACHE_DIRECT_MODE;

	/* If the dependency file should be in the cache, check that it is. */
	x_asprintf(&dep_file, ""%s.d"", object_path);
	if (produce_dep_file && stat(dep_file, &st) != 0) {
		cc_log(""Dependency file missing in cache\n"");
		free(dep_file);
		return;
	}

	x_asprintf(&stderr_file, ""%s.stderr"", object_path);

	if (strcmp(output_file, ""/dev/null"") == 0) {
		ret = 0;
	} else {
		unlink(output_file);
		/* only make a hardlink if the cache file is uncompressed */
		if (getenv(""CCACHE_HARDLINK"") &&
		    test_if_compressed(object_path) == 0) {
			ret = link(object_path, output_file);
		} else {
			ret = copy_file(object_path, output_file, 0);
		}
	}

	if (ret == -1) {
		if (errno == ENOENT) {
			/* Someone removed the file just before we began copying? */
			cc_log(""Object file missing for %s\n"", output_file);
			stats_update(STATS_MISSING);
		} else {
			cc_log(""Failed to copy/link %s -> %s (%s)\n"",
			       object_path, output_file, strerror(errno));
			stats_update(STATS_ERROR);
			failed();
		}
		unlink(output_file);
		unlink(stderr_file);
		unlink(object_path);
		unlink(dep_file);
		free(dep_file);
		free(stderr_file);
		return;
	} else {
		cc_log(""Created %s\n"", output_file);
	}

	if (produce_dep_file) {
		unlink(dependency_path);
		/* only make a hardlink if the cache file is uncompressed */
		if (getenv(""CCACHE_HARDLINK"") &&
		    test_if_compressed(dep_file) == 0) {
			ret = link(dep_file, dependency_path);
		} else {
			ret = copy_file(dep_file, dependency_path, 0);
		}
		if (ret == -1) {
			if (errno == ENOENT) {
				/*
				 * Someone removed the file just before we
				 * began copying?
				 */
				cc_log(""dependency file missing for %s\n"",
				       output_file);
				stats_update(STATS_MISSING);
			} else {
				cc_log(""failed to copy/link %s -> %s (%s)\n"",
				       dep_file, dependency_path,
				       strerror(errno));
				stats_update(STATS_ERROR);
				failed();
			}
			unlink(output_file);
			unlink(stderr_file);
			unlink(object_path);
			unlink(dep_file);
			free(dep_file);
			free(stderr_file);
			return;
		} else {
			cc_log(""Created %s\n"", dependency_path);
		}
	}

	/* Update modification timestamps to save files from LRU cleanup.
	   Also gives files a sensible mtime when hard-linking. */
	update_mtime(object_path);
	update_mtime(stderr_file);
	if (produce_dep_file) {
		update_mtime(dep_file);
	}

	if (generating_dependencies && mode != FROMCACHE_DIRECT_MODE) {
		/* Store the dependency file in the cache. */
		ret = copy_file(dependency_path, dep_file, 1);
		if (ret == -1) {
			cc_log(""Failed to copy %s -> %s\n"", dependency_path,
			       dep_file);
			/* Continue despite the error. */
		} else {
			cc_log(""Placed dependency file into the cache\n"");
		}
	}
	free(dep_file);

	/* get rid of the intermediate preprocessor file */
	if (i_tmpfile) {
		if (!direct_i_file) {
			unlink(i_tmpfile);
		}
		free(i_tmpfile);
		i_tmpfile = NULL;
	}

	/* Delete the cpp stderr file if necessary. */
	if (cpp_stderr) {
		unlink(cpp_stderr);
		free(cpp_stderr);
		cpp_stderr = NULL;
	}

	/* Send the stderr, if any. */
	fd_stderr = open(stderr_file, O_RDONLY | O_BINARY);
	if (fd_stderr != -1) {
		copy_fd(fd_stderr, 2);
		close(fd_stderr);
	}
	free(stderr_file);

	/* Create or update the manifest file. */
	if (put_object_in_manifest && included_files) {
		if (manifest_put(manifest_path, object_hash, included_files)) {
			cc_log(""Added object file hash to manifest %s\n"",
				manifest_path);
			update_mtime(manifest_path);
		} else {
			cc_log(""Failed to add object file hash to manifest\n"");
		}
	}

	/* log the cache hit */
	switch (mode) {
	case FROMCACHE_DIRECT_MODE:
		cc_log(""Succeded getting cached result\n"");
		stats_update(STATS_CACHEHIT_DIR);
		break;

	case FROMCACHE_CPP_MODE:
		cc_log(""Succeded getting cached result\n"");
		stats_update(STATS_CACHEHIT_CPP);
		break;

	case FROMCACHE_COMPILED_MODE:
		break;
	}

	/* and exit with the right status code */
	exit(0);
}

/* find the real compiler. We just search the PATH to find a executable of the
   same name that isn't a link to ourselves */
static void find_compiler(int argc, char **argv)
{
	char *base;
	char *path;

	orig_args = args_init(argc, argv);

	base = str_basename(argv[0]);

	/* we might be being invoked like ""ccache gcc -c foo.c"" */
	if (strcmp(base, MYNAME) == 0) {
		args_remove_first(orig_args);
		free(base);
		if (strchr(argv[1],'/')) {
			/* a full path was given */
			return;
		}
		base = str_basename(argv[1]);
	}

	/* support user override of the compiler */
	if ((path=getenv(""CCACHE_CC""))) {
		base = strdup(path);
	}

	orig_args->argv[0] = find_executable(base, MYNAME);

	/* can't find the compiler! */
	if (!orig_args->argv[0]) {
		stats_update(STATS_COMPILER);
		perror(base);
		exit(1);
	}
}


/* check a filename for C/C++ extension. Return the pre-processor
   extension */
static const char *check_extension(const char *fname, int *direct_i)
{
	int i;
	const char *p;

	if (direct_i) {
		*direct_i = 0;
	}

	p = strrchr(fname, '.');
	if (!p) return NULL;
	p++;
	for (i=0; extensions[i].extension; i++) {
		if (strcmp(p, extensions[i].extension) == 0) {
			if (direct_i && strcmp(p, extensions[i].i_extension) == 0) {
				*direct_i = 1;
			}
			p = getenv(""CCACHE_EXTENSION"");
			if (p) return p;
			return extensions[i].i_extension;
		}
	}
	return NULL;
}


/*
   process the compiler options to form the correct set of options
   for obtaining the preprocessor output
*/
static void process_args(int argc, char **argv)
{
	int i;
	int found_c_opt = 0;
	int found_S_opt = 0;
	struct stat st;
	/* is the dependency makefile name overridden with -MF? */
	int dependency_filename_specified = 0;
	/* is the dependency makefile target name specified with -MT or -MQ? */
	int dependency_target_specified = 0;

	stripped_args = args_init(0, NULL);

	args_add(stripped_args, argv[0]);

	for (i=1; i<argc; i++) {
		/* some options will never work ... */
		if (strcmp(argv[i], ""-E"") == 0) {
			cc_log(""Compiler option -E is unsupported\n"");
			failed();
		}

		/* these are too hard */
		if (strncmp(argv[i], ""@"", 1) == 0 ||
		    strcmp(argv[i], ""-fbranch-probabilities"") == 0 ||
		    strcmp(argv[i], ""--coverage"") == 0 ||
		    strcmp(argv[i], ""-fprofile-arcs"") == 0 ||
		    strcmp(argv[i], ""-fprofile-generate"") == 0 ||
		    strcmp(argv[i], ""-fprofile-use"") == 0 ||
		    strcmp(argv[i], ""-ftest-coverage"") == 0 ||
		    strcmp(argv[i], ""-M"") == 0 ||
		    strcmp(argv[i], ""-MM"") == 0 ||
		    strcmp(argv[i], ""-x"") == 0) {
			cc_log(""Compiler option %s is unsupported\n"", argv[i]);
			stats_update(STATS_UNSUPPORTED);
			failed();
			continue;
		}

		/* we must have -c */
		if (strcmp(argv[i], ""-c"") == 0) {
			args_add(stripped_args, argv[i]);
			found_c_opt = 1;
			continue;
		}

		/* -S changes the default extension */
		if (strcmp(argv[i], ""-S"") == 0) {
			args_add(stripped_args, argv[i]);
			found_S_opt = 1;
			continue;
		}

		/* we need to work out where the output was meant to go */
		if (strcmp(argv[i], ""-o"") == 0) {
			if (i == argc-1) {
				cc_log(""missing argument to %s\n"", argv[i]);
				stats_update(STATS_ARGS);
				failed();
			}
			output_file = argv[i+1];
			i++;
			continue;
		}

		/* alternate form of -o, with no space */
		if (strncmp(argv[i], ""-o"", 2) == 0) {
			output_file = &argv[i][2];
			continue;
		}

		/* debugging is handled specially, so that we know if we
		   can strip line number info
		*/
		if (strncmp(argv[i], ""-g"", 2) == 0) {
			args_add(stripped_args, argv[i]);
			if (strcmp(argv[i], ""-g0"") != 0) {
				enable_unify = 0;
			}
			continue;
		}

		/* The user knows best: just swallow the next arg */
		if (strcmp(argv[i], ""--ccache-skip"") == 0) {
			i++;
			if (i == argc) {
				cc_log(""--ccache-skip lacks an argument\n"");
				failed();
			}
			args_add(stripped_args, argv[i]);
			continue;
		}

		/* These options require special handling, because they
		   behave differently with gcc -E, when the output
		   file is not specified. */
		if (strcmp(argv[i], ""-MD"") == 0
		    || strcmp(argv[i], ""-MMD"") == 0) {
			generating_dependencies = 1;
		}
		if (i < argc - 1) {
			if (strcmp(argv[i], ""-MF"") == 0) {
				dependency_filename_specified = 1;
				dependency_path = make_relative_path(
					x_strdup(argv[i + 1]));
			} else if (strcmp(argv[i], ""-MQ"") == 0
				   || strcmp(argv[i], ""-MT"") == 0) {
				dependency_target_specified = 1;
			}
		}

		if (enable_direct && strncmp(argv[i], ""-Wp,"", 4) == 0) {
			if (strncmp(argv[i], ""-Wp,-MD,"", 8) == 0) {
				generating_dependencies = 1;
				dependency_filename_specified = 1;
				dependency_path = make_relative_path(
					x_strdup(argv[i] + 8));
			} else if (strncmp(argv[i], ""-Wp,-MMD,"", 9) == 0) {
				generating_dependencies = 1;
				dependency_filename_specified = 1;
				dependency_path = make_relative_path(
					x_strdup(argv[i] + 9));
			} else if (enable_direct) {
				cc_log(""Unsupported compiler option for direct mode: %s\n"",
				       argv[i]);
				enable_direct = 0;
			}
		}

		/*
		 * Options taking an argument that that we may want to rewrite
		 * to relative paths to get better hit rate. A secondary effect
		 * is that paths in the standard error output produced by the
		 * compiler will be normalized.
		 */
		{
			const char *opts[] = {
				""-I"", ""-idirafter"", ""-imacros"", ""-include"",
				""-iprefix"", ""-isystem"", NULL
			};
			int j;
			char *relpath;
			for (j = 0; opts[j]; j++) {
				if (strcmp(argv[i], opts[j]) == 0) {
					if (i == argc-1) {
						cc_log(""missing argument to %s\n"",
						       argv[i]);
						stats_update(STATS_ARGS);
						failed();
					}

					args_add(stripped_args, argv[i]);
					relpath = make_relative_path(x_strdup(argv[i+1]));
					args_add(stripped_args, relpath);
					free(relpath);
					i++;
					break;
				}
			}
			if (opts[j]) {
				continue;
			}
		}

		/* Same as above but options with concatenated argument. */
		{
			const char *opts[] = {""-I"", NULL};
			int j;
			char *relpath;
			char *option;
			for (j = 0; opts[j]; j++) {
				if (strncmp(argv[i], opts[j], strlen(opts[j])) == 0) {
					relpath = make_relative_path(
						x_strdup(argv[i] + strlen(opts[j])));
					x_asprintf(&option, ""%s%s"", opts[j], relpath);
					args_add(stripped_args, option);
					free(relpath);
					free(option);
					break;
				}
			}
			if (opts[j]) {
				continue;
			}
		}

		/* options that take an argument */
		{
			const char *opts[] = {""-iwithprefix"", ""-iwithprefixbefore"",
					      ""-L"", ""-D"", ""-U"", ""-x"", ""-MF"",
					      ""-MT"", ""-MQ"", ""-aux-info"",
					      ""--param"", ""-A"", ""-Xlinker"", ""-u"",
					      NULL};
			int j;
			for (j=0;opts[j];j++) {
				if (strcmp(argv[i], opts[j]) == 0) {
					if (i == argc-1) {
						cc_log(""missing argument to %s\n"",
						       argv[i]);
						stats_update(STATS_ARGS);
						failed();
					}

					args_add(stripped_args, argv[i]);
					args_add(stripped_args, argv[i+1]);
					i++;
					break;
				}
			}
			if (opts[j]) continue;
		}

		/* other options */
		if (argv[i][0] == '-') {
			args_add(stripped_args, argv[i]);
			continue;
		}

		/* if an argument isn't a plain file then assume its
		   an option, not an input file. This allows us to
		   cope better with unusual compiler options */
		if (stat(argv[i], &st) != 0 || !S_ISREG(st.st_mode)) {
			args_add(stripped_args, argv[i]);
			continue;
		}

		if (input_file) {
			if (check_extension(argv[i], NULL)) {
				cc_log(""multiple input files (%s and %s)\n"",
				       input_file, argv[i]);
				stats_update(STATS_MULTIPLE);
			} else if (!found_c_opt) {
				cc_log(""called for link with %s\n"", argv[i]);
				if (strstr(argv[i], ""conftest."")) {
					stats_update(STATS_CONFTEST);
				} else {
					stats_update(STATS_LINK);
				}
			} else {
				cc_log(""non C/C++ file %s\n"", argv[i]);
				stats_update(STATS_NOTC);
			}
			failed();
		}

		/* Rewrite to relative to increase hit rate. */
		input_file = make_relative_path(x_strdup(argv[i]));
	}

	if (!input_file) {
		cc_log(""No input file found\n"");
		stats_update(STATS_NOINPUT);
		failed();
	}

	i_extension = check_extension(input_file, &direct_i_file);
	if (i_extension == NULL) {
		cc_log(""Not a C/C++ file - %s\n"", input_file);
		stats_update(STATS_NOTC);
		failed();
	}

	if (!found_c_opt) {
		cc_log(""No -c option found for %s\n"", input_file);
		/* I find that having a separate statistic for autoconf tests is useful,
		   as they are the dominant form of ""called for link"" in many cases */
		if (strstr(input_file, ""conftest."")) {
			stats_update(STATS_CONFTEST);
		} else {
			stats_update(STATS_LINK);
		}
		failed();
	}


	/* don't try to second guess the compilers heuristics for stdout handling */
	if (output_file && strcmp(output_file, ""-"") == 0) {
		stats_update(STATS_OUTSTDOUT);
		cc_log(""Output file is -\n"");
		failed();
	}

	if (!output_file) {
		char *p;
		output_file = x_strdup(input_file);
		if ((p = strrchr(output_file, '/'))) {
			output_file = p+1;
		}
		p = strrchr(output_file, '.');
		if (!p || !p[1]) {
			cc_log(""badly formed output_file %s\n"", output_file);
			stats_update(STATS_ARGS);
			failed();
		}
		p[1] = found_S_opt ? 's' : 'o';
		p[2] = 0;
	}

	/* If dependencies are generated, configure the preprocessor */

	if (generating_dependencies && output_file) {
		if (!dependency_filename_specified) {
			char *default_depfile_name = x_strdup(output_file);
			char *p = strrchr(default_depfile_name, '.');

			if (p) {
				if (strlen(p) < 2) {
					stats_update(STATS_ARGS);
					cc_log(""Too short file extension in %s\n"",
					       default_depfile_name);
					failed();
					return;
				}
				*p = 0;
			}
			else  {
				int len = p - default_depfile_name;

				p = x_malloc(len + 3);
				strncpy(default_depfile_name, p, len - 1);
				free(default_depfile_name);
				default_depfile_name = p;
			}

			strcat(default_depfile_name, "".d"");
			args_add(stripped_args, ""-MF"");
			args_add(stripped_args, default_depfile_name);
			dependency_path = make_relative_path(
				x_strdup(default_depfile_name));
		}

		if (!dependency_target_specified) {
			args_add(stripped_args, ""-MT"");
			args_add(stripped_args, output_file);
		}
	}

	/* cope with -o /dev/null */
	if (strcmp(output_file,""/dev/null"") != 0 && stat(output_file, &st) == 0 && !S_ISREG(st.st_mode)) {
		cc_log(""Not a regular file %s\n"", output_file);
		stats_update(STATS_DEVICE);
		failed();
	}
}

/* the main ccache driver function */
static void ccache(int argc, char *argv[])
{
	char *prefix;
	char now[64];
	time_t t;
	struct tm *tm;
	int put_object_in_manifest = 0;
	struct file_hash *object_hash_from_manifest = NULL;

	t = time(NULL);
	tm = localtime(&t);
	if (!tm) {
		cc_log(""localtime failed\n"");
		failed();
	}

	if (strftime(now, sizeof(now), ""%Y-%m-%d %H:%M:%S"", tm) == 0) {
		cc_log(""strftime failed\n"");
		failed();
	}

	cc_log(""=== %s ===\n"", now);

	cc_log(""Base directory: %s\n"", base_dir);

	/* find the real compiler */
	find_compiler(argc, argv);

	/* use the real compiler if HOME is not set */
	if (!cache_dir) {
		cc_log(""Unable to determine home directory\n"");
		cc_log(""ccache is disabled\n"");
		failed();
	}

	/* we might be disabled */
	if (getenv(""CCACHE_DISABLE"")) {
		cc_log(""ccache is disabled\n"");
		failed();
	}

	if (getenv(""CCACHE_UNIFY"")) {
		enable_unify = 1;
	}

	if (getenv(""CCACHE_NODIRECT"") || enable_unify) {
		cc_log(""Direct mode disabled\n"");
		enable_direct = 0;
	}

	/* process argument list, returning a new set of arguments for
	   pre-processing */
	process_args(orig_args->argc, orig_args->argv);

	cc_log(""Source file: %s\n"", input_file);
	if (generating_dependencies) {
		cc_log(""Dependency file: %s\n"", dependency_path);
	}
	cc_log(""Object file: %s\n"", output_file);

	/* try to find the hash using the manifest */
	if (enable_direct) {
		if (find_hash(stripped_args, FINDHASH_DIRECT_MODE)) {
			/*
			 * If we can return from cache at this point then do
			 * so.
			 */
			from_cache(FROMCACHE_DIRECT_MODE, 0);

			/*
			 * Wasn't able to return from cache at this point.
			 * However, the object was already found in manifest,
			 * so don't readd it later.
			 */
			put_object_in_manifest = 0;

			object_hash_from_manifest = object_hash;
			object_hash = NULL;
		} else {
			/* Add object to manifest later. */
			put_object_in_manifest = 1;
		}
	}

	/*
	 * Find the hash using the preprocessed output. Also updates
	 * included_files.
	 */
	find_hash(stripped_args, FINDHASH_CPP_MODE);

	if (object_hash_from_manifest
	    && !file_hashes_equal(object_hash_from_manifest, object_hash)) {
		/*
		 * The hash from manifest differs from the hash of the
		 * preprocessor output. This could be because:
		 *
		 * - The preprocessor produces different output for the same
		 *   input (not likely).
		 * - There's a bug in ccache (maybe incorrect handling of
		 *   compiler arguments).
		 * - The user has used a different CCACHE_BASEDIR (most
		 *   likely).
		 *
		 * The best thing here would probably be to remove the hash
		 * entry from the manifest. For now, we use a simpler method:
		 * just remove the manifest file.
		 */
		cc_log(""Hash from manifest doesn't match preprocessor output\n"");
		cc_log(""Likely reason: different CCACHE_BASEDIRs used\n"");
		cc_log(""Removing manifest as a safety measure\n"");
		unlink(manifest_path);

		put_object_in_manifest = 1;
	}

	/* if we can return from cache at this point then do */
	from_cache(FROMCACHE_CPP_MODE, put_object_in_manifest);

	if (getenv(""CCACHE_READONLY"")) {
		cc_log(""read-only set - doing real compile\n"");
		failed();
	}

	prefix = getenv(""CCACHE_PREFIX"");
	if (prefix) {
		char *p = find_executable(prefix, MYNAME);
		if (!p) {
			perror(prefix);
			exit(1);
		}
		args_add_prefix(stripped_args, p);
	}

	/* run real compiler, sending output to cache */
	to_cache(stripped_args);

	/* return from cache */
	from_cache(FROMCACHE_COMPILED_MODE, put_object_in_manifest);

	/* oh oh! */
	cc_log(""secondary from_cache failed!\n"");
	stats_update(STATS_ERROR);
	failed();
}


static void usage(void)
{
	printf(""ccache, a compiler cache. Version %s\n"", CCACHE_VERSION);
	printf(""Copyright Andrew Tridgell, 2002\n\n"");

	printf(""Usage:\n"");
	printf(""\tccache [options]\n"");
	printf(""\tccache compiler [compile options]\n"");
	printf(""\tcompiler [compile options]    (via symbolic link)\n"");
	printf(""\nOptions:\n"");

	printf(""-s, --show-stats         show statistics summary\n"");
	printf(""-z, --zero-stats         zero statistics\n"");
	printf(""-c, --cleanup            run a cache cleanup\n"");
	printf(""-C, --clear              clear the cache completely\n"");
	printf(""-F <n>, --max-files=<n>  set maximum number of files in cache (0: no limit)\n"");
	printf(""-M <n>, --max-size=<n>   set maximum size of cache (use G, M or K; 0: no limit)\n"");
	printf(""-h, --help               this help page\n"");
	printf(""-V, --version            print version number\n"");
}

static void check_cache_dir(void)
{
	if (!cache_dir) {
		fatal(""Unable to determine home directory\n"");
	}
}

/* the main program when not doing a compile */
static int ccache_main(int argc, char *argv[])
{
	int c;
	size_t v;

	static struct option long_options[] = {
		{""show-stats"", no_argument,       0, 's'},
		{""zero-stats"", no_argument,       0, 'z'},
		{""cleanup"",    no_argument,       0, 'c'},
		{""clear"",      no_argument,       0, 'C'},
		{""max-files"",  required_argument, 0, 'F'},
		{""max-size"",   required_argument, 0, 'M'},
		{""help"",       no_argument,       0, 'h'},
		{""version"",    no_argument,       0, 'V'},
		{0, 0, 0, 0}
	};
	int option_index = 0;

	while ((c = getopt_long(argc, argv, ""hszcCF:M:V"", long_options, &option_index)) != -1) {
		switch (c) {
		case 'V':
			printf(""ccache version %s\n"", CCACHE_VERSION);
			printf(""\n"");
			printf(""See http://ccache.samba.org.\n"");
			printf(""\n"");
			printf(""Copyright (C) Andrew Tridgell 2002-2007\n"");
			printf(""Copyright (C) Joel Rosdahl 2009-2010\n"");
			printf(""\n"");
			printf(""This program is free software; you can"");
			printf("" redistribute it and/or modify it under\nthe"");
			printf("" terms of the GNU General Public License as"");
			printf("" published by the Free Software\nFoundation;"");
			printf("" either version 2 of the License, or (at"");
			printf("" your option) any later\nversion.\n"");
			exit(0);

		case 'h':
			usage();
			exit(0);

		case 's':
			check_cache_dir();
			stats_summary();
			break;

		case 'c':
			check_cache_dir();
			cleanup_all(cache_dir);
			printf(""Cleaned cache\n"");
			break;

		case 'C':
			check_cache_dir();
			wipe_all(cache_dir);
			printf(""Cleared cache\n"");
			break;

		case 'z':
			check_cache_dir();
			stats_zero();
			printf(""Statistics cleared\n"");
			break;

		case 'F':
			check_cache_dir();
			v = atoi(optarg);
			if (stats_set_limits(v, -1) == 0) {
				if (v == 0) {
					printf(""Unset cache file limit\n"");
				} else {
					printf(""Set cache file limit to %u\n"", (unsigned)v);
				}
			} else {
				printf(""Could not set cache file limit.\n"");
				exit(1);
			}
			break;

		case 'M':
			check_cache_dir();
			v = value_units(optarg);
			if (stats_set_limits(-1, v) == 0) {
				if (v == 0) {
					printf(""Unset cache size limit\n"");
				} else {
					printf(""Set cache size limit to %uk\n"", (unsigned)v);
				}
			} else {
				printf(""Could not set cache size limit.\n"");
				exit(1);
			}
			break;

		default:
			usage();
			exit(1);
		}
	}

	return 0;
}


/* Make a copy of stderr that will not be cached, so things like
   distcc can send networking errors to it. */
static void setup_uncached_err(void)
{
	char *buf;
	int uncached_fd;

	uncached_fd = dup(2);
	if (uncached_fd == -1) {
		cc_log(""dup(2) failed\n"");
		failed();
	}

	/* leak a pointer to the environment */
	x_asprintf(&buf, ""UNCACHED_ERR_FD=%d"", uncached_fd);

	if (putenv(buf) == -1) {
		cc_log(""putenv failed\n"");
		failed();
	}
}


int main(int argc, char *argv[])
{
	char *p;

	current_working_dir = get_cwd();

	cache_dir = getenv(""CCACHE_DIR"");
	if (!cache_dir) {
		const char *home_directory = get_home_directory();
		if (home_directory) {
			x_asprintf(&cache_dir, ""%s/.ccache"", home_directory);
		}
	}

	temp_dir = getenv(""CCACHE_TEMPDIR"");
	if (!temp_dir) {
		x_asprintf(&temp_dir, ""%s/tmp"", cache_dir);
	}

	cache_logfile = getenv(""CCACHE_LOGFILE"");

	base_dir = getenv(""CCACHE_BASEDIR"");
	if (base_dir) {
		if (strcmp(base_dir, """") == 0) {
			base_dir = NULL;
		}
	} else {
		base_dir = get_cwd();
	}

	setup_uncached_err();

	/* the user might have set CCACHE_UMASK */
	p = getenv(""CCACHE_UMASK"");
	if (p) {
		mode_t mask;
		errno = 0;
		mask = strtol(p, NULL, 8);
		if (errno == 0) {
			umask(mask);
		}
	}


	/* check if we are being invoked as ""ccache"" */
	if (strlen(argv[0]) >= strlen(MYNAME) &&
	    strcmp(argv[0] + strlen(argv[0]) - strlen(MYNAME), MYNAME) == 0) {
		if (argc < 2) {
			usage();
			exit(1);
		}
		/* if the first argument isn't an option, then assume we are
		   being passed a compiler name and options */
		if (argv[1][0] == '-') {
			return ccache_main(argc, argv);
		}
	}

	/* make sure the cache dir exists */
	if (create_dir(cache_dir) != 0) {
		fprintf(stderr,""ccache: failed to create %s (%s)\n"",
			cache_dir, strerror(errno));
		exit(1);
	}

	/* make sure the temp dir exists */
	if (create_dir(temp_dir) != 0) {
		fprintf(stderr,""ccache: failed to create %s (%s)\n"",
			temp_dir, strerror(errno));
		exit(1);
	}

	if (!getenv(""CCACHE_READONLY"")) {
		if (create_cachedirtag(cache_dir) != 0) {
			fprintf(stderr,""ccache: failed to create %s/CACHEDIR.TAG (%s)\n"",
				cache_dir, strerror(errno));
			exit(1);
		}
	}

	ccache(argc, argv);
	return 1;
}
""",process_args,[1106:1449]
ccache,https://github.com/ccache/ccache/commit/aa16483c4792a030646b36ce3edd5c5dd935c919,"""Removed time_of_compilation check wrt SLOPPY_FILE_STAT_MATCHES

The whole code seems to be a thinko.  For a hit, neither ctime
nor mtime should be greater than or equal to time_of_compilation.
The code only seems to work because time_of_compilation is 0
at this stage (i.e. has not been initialized).

While at it, I also introduce an optimization: when sizes do
not match, it's a good chance to bail out early; there is no
point in further hashing the file.""","""// Copyright (C) 2009-2016 Joel Rosdahl
//
// This program is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by the Free
// Software Foundation; either version 3 of the License, or (at your option)
// any later version.
//
// This program is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
// more details.
//
// You should have received a copy of the GNU General Public License along with
// this program; if not, write to the Free Software Foundation, Inc., 51
// Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA

#include ""ccache.h""
#include ""hashtable_itr.h""
#include ""hashutil.h""
#include ""manifest.h""
#include ""murmurhashneutral2.h""

#include <zlib.h>

// Sketchy specification of the manifest disk format:
//
// <magic>         magic number                        (4 bytes)
// <version>       file format version                 (1 byte unsigned int)
// <hash_size>     size of the hash fields (in bytes)  (1 byte unsigned int)
// <reserved>      reserved for future use             (2 bytes)
// ----------------------------------------------------------------------------
// <n>             number of include file paths        (4 bytes unsigned int)
// <path_0>        path to include file                (NUL-terminated string,
// ...                                                  at most 1024 bytes)
// <path_n-1>
// ----------------------------------------------------------------------------
// <n>             number of include file hash entries (4 bytes unsigned int)
// <index[0]>      index of include file path          (4 bytes unsigned int)
// <hash[0]>       hash of include file                (<hash_size> bytes)
// <size[0]>       size of include file                (4 bytes unsigned int)
// <mtime[0]>      mtime of include file               (8 bytes signed int)
// <ctime[0]>      ctime of include file               (8 bytes signed int)
// ...
// <index[n-1]>
// <hash[n-1]>
// <size[n-1]>
// <mtime[n-1]>
// <ctime[n-1]>
// ----------------------------------------------------------------------------
// <n>             number of object name entries       (4 bytes unsigned int)
// <m[0]>          number of include file hash indexes (4 bytes unsigned int)
// <index[0][0]>   include file hash index             (4 bytes unsigned int)
// ...
// <index[0][m[0]-1]>
// <hash[0]>       hash part of object name            (<hash_size> bytes)
// <size[0]>       size part of object name            (4 bytes unsigned int)
// ...
// <m[n-1]>        number of include file hash indexes
// <index[n-1][0]> include file hash index
// ...
// <index[n-1][m[n-1]]>
// <hash[n-1]>
// <size[n-1]>

static const uint32_t MAGIC = 0x63436d46U;
static const uint32_t MAX_MANIFEST_ENTRIES = 100;
static const uint32_t MAX_MANIFEST_FILE_INFO_ENTRIES = 10000;

#define ccache_static_assert(e) \
  do { enum { ccache_static_assert__ = 1/(e) }; } while (false)

struct file_info {
	// Index to n_files.
	uint32_t index;
	// Hash of referenced file.
	uint8_t hash[16];
	// Size of referenced file.
	uint32_t size;
	// mtime of referenced file.
	int64_t mtime;
	// ctime of referenced file.
	int64_t ctime;
};

struct object {
	// Number of entries in file_info_indexes.
	uint32_t n_file_info_indexes;
	// Indexes to file_infos.
	uint32_t *file_info_indexes;
	// Hash of the object itself.
	struct file_hash hash;
};

struct manifest {
	// Version of decoded file.
	uint8_t version;

	// Reserved for future use.
	uint16_t reserved;

	// Size of hash fields (in bytes).
	uint8_t hash_size;

	// Referenced include files.
	uint32_t n_files;
	char **files;

	// Information about referenced include files.
	uint32_t n_file_infos;
	struct file_info *file_infos;

	// Object names plus references to include file hashes.
	uint32_t n_objects;
	struct object *objects;
};

struct file_stats {
	uint32_t size;
	int64_t mtime;
	int64_t ctime;
};

static unsigned int
hash_from_file_info(void *key)
{
	ccache_static_assert(sizeof(struct file_info) == 40); // No padding.
	return murmurhashneutral2(key, sizeof(struct file_info), 0);
}

static int
file_infos_equal(void *key1, void *key2)
{
	struct file_info *fi1 = (struct file_info *)key1;
	struct file_info *fi2 = (struct file_info *)key2;
	return fi1->index == fi2->index
	       && memcmp(fi1->hash, fi2->hash, 16) == 0
	       && fi1->size == fi2->size
	       && fi1->mtime == fi2->mtime
	       && fi1->ctime == fi2->ctime;
}

static void
free_manifest(struct manifest *mf)
{
	for (uint32_t i = 0; i < mf->n_files; i++) {
		free(mf->files[i]);
	}
	free(mf->files);
	free(mf->file_infos);
	for (uint32_t i = 0; i < mf->n_objects; i++) {
		free(mf->objects[i].file_info_indexes);
	}
	free(mf->objects);
	free(mf);
}

#define READ_BYTE(var) \
  do { \
		int ch_ = gzgetc(f); \
		if (ch_ == EOF) { \
			goto error; \
		} \
		(var) = ch_ & 0xFF; \
	} while (false)

#define READ_INT(size, var) \
  do { \
		uint64_t u_ = 0; \
		for (size_t i_ = 0; i_ < (size); i_++) { \
			int ch_ = gzgetc(f); \
			if (ch_ == EOF) { \
				goto error; \
			} \
			u_ <<= 8; \
			u_ |= ch_ & 0xFF; \
		} \
		(var) = u_; \
	} while (false)

#define READ_STR(var) \
  do { \
		char buf_[1024]; \
		size_t i_; \
		for (i_ = 0; i_ < sizeof(buf_); i_++) { \
			int ch_ = gzgetc(f); \
			if (ch_ == EOF) { \
				goto error; \
			} \
			buf_[i_] = ch_; \
			if (ch_ == '\0') { \
				break; \
			} \
		} \
		if (i_ == sizeof(buf_)) { \
			goto error; \
		} \
		(var) = x_strdup(buf_); \
	} while (false)

#define READ_BYTES(n, var) \
  do { \
		for (size_t i_ = 0; i_ < (n); i_++) { \
			int ch_ = gzgetc(f); \
			if (ch_ == EOF) { \
				goto error; \
			} \
			(var)[i_] = ch_; \
		} \
	} while (false)

static struct manifest *
create_empty_manifest(void)
{
	struct manifest *mf = x_malloc(sizeof(*mf));
	mf->hash_size = 16;
	mf->n_files = 0;
	mf->files = NULL;
	mf->n_file_infos = 0;
	mf->file_infos = NULL;
	mf->n_objects = 0;
	mf->objects = NULL;

	return mf;
}

static struct manifest *
read_manifest(gzFile f)
{
	struct manifest *mf = create_empty_manifest();

	uint32_t magic;
	READ_INT(4, magic);
	if (magic != MAGIC) {
		cc_log(""Manifest file has bad magic number %u"", magic);
		goto error;
	}

	READ_BYTE(mf->version);
	if (mf->version != MANIFEST_VERSION) {
		cc_log(""Manifest file has unknown version %u"", mf->version);
		goto error;
	}

	READ_BYTE(mf->hash_size);
	if (mf->hash_size != 16) {
		// Temporary measure until we support different hash algorithms.
		cc_log(""Manifest file has unsupported hash size %u"", mf->hash_size);
		goto error;
	}

	READ_INT(2, mf->reserved);

	READ_INT(4, mf->n_files);
	mf->files = x_calloc(mf->n_files, sizeof(*mf->files));
	for (uint32_t i = 0; i < mf->n_files; i++) {
		READ_STR(mf->files[i]);
	}

	READ_INT(4, mf->n_file_infos);
	mf->file_infos = x_calloc(mf->n_file_infos, sizeof(*mf->file_infos));
	for (uint32_t i = 0; i < mf->n_file_infos; i++) {
		READ_INT(4, mf->file_infos[i].index);
		READ_BYTES(mf->hash_size, mf->file_infos[i].hash);
		READ_INT(4, mf->file_infos[i].size);
		READ_INT(8, mf->file_infos[i].mtime);
		READ_INT(8, mf->file_infos[i].ctime);
	}

	READ_INT(4, mf->n_objects);
	mf->objects = x_calloc(mf->n_objects, sizeof(*mf->objects));
	for (uint32_t i = 0; i < mf->n_objects; i++) {
		READ_INT(4, mf->objects[i].n_file_info_indexes);
		mf->objects[i].file_info_indexes =
		  x_calloc(mf->objects[i].n_file_info_indexes,
		           sizeof(*mf->objects[i].file_info_indexes));
		for (uint32_t j = 0; j < mf->objects[i].n_file_info_indexes; j++) {
			READ_INT(4, mf->objects[i].file_info_indexes[j]);
		}
		READ_BYTES(mf->hash_size, mf->objects[i].hash.hash);
		READ_INT(4, mf->objects[i].hash.size);
	}

	return mf;

error:
	cc_log(""Corrupt manifest file"");
	free_manifest(mf);
	return NULL;
}

#define WRITE_INT(size, var) \
  do { \
		uint64_t u_ = (var); \
		uint8_t ch_; \
		size_t i_; \
		for (i_ = 0; i_ < (size); i_++) { \
			ch_ = (u_ >> (8 * ((size) - i_ - 1))); \
			if (gzputc(f, ch_) == EOF) { \
				goto error; \
			} \
		} \
	} while (false)

#define WRITE_STR(var) \
  do { \
		if (gzputs(f, var) == EOF || gzputc(f, '\0') == EOF) { \
			goto error; \
		} \
	} while (false)

#define WRITE_BYTES(n, var) \
  do { \
		size_t i_; \
		for (i_ = 0; i_ < (n); i_++) { \
			if (gzputc(f, (var)[i_]) == EOF) { \
				goto error; \
			} \
		} \
	} while (false)

static int
write_manifest(gzFile f, const struct manifest *mf)
{
	WRITE_INT(4, MAGIC);
	WRITE_INT(1, MANIFEST_VERSION);
	WRITE_INT(1, 16);
	WRITE_INT(2, 0);

	WRITE_INT(4, mf->n_files);
	for (uint32_t i = 0; i < mf->n_files; i++) {
		WRITE_STR(mf->files[i]);
	}

	WRITE_INT(4, mf->n_file_infos);
	for (uint32_t i = 0; i < mf->n_file_infos; i++) {
		WRITE_INT(4, mf->file_infos[i].index);
		WRITE_BYTES(mf->hash_size, mf->file_infos[i].hash);
		WRITE_INT(4, mf->file_infos[i].size);
		WRITE_INT(8, mf->file_infos[i].mtime);
		WRITE_INT(8, mf->file_infos[i].ctime);
	}

	WRITE_INT(4, mf->n_objects);
	for (uint32_t i = 0; i < mf->n_objects; i++) {
		WRITE_INT(4, mf->objects[i].n_file_info_indexes);
		for (uint32_t j = 0; j < mf->objects[i].n_file_info_indexes; j++) {
			WRITE_INT(4, mf->objects[i].file_info_indexes[j]);
		}
		WRITE_BYTES(mf->hash_size, mf->objects[i].hash.hash);
		WRITE_INT(4, mf->objects[i].hash.size);
	}

	return 1;

error:
	cc_log(""Error writing to manifest file"");
	return 0;
}

static int
verify_object(struct conf *conf, struct manifest *mf, struct object *obj,
              struct hashtable *stated_files, struct hashtable *hashed_files)
{
	for (uint32_t i = 0; i < obj->n_file_info_indexes; i++) {
		struct file_info *fi = &mf->file_infos[obj->file_info_indexes[i]];
		char *path = mf->files[fi->index];
		struct file_stats *st = hashtable_search(stated_files, path);
		if (!st) {
			struct stat file_stat;
			if (x_stat(path, &file_stat) != 0) {
				return 0;
			}
			st = x_malloc(sizeof(*st));
			st->size = file_stat.st_size;
			st->mtime = file_stat.st_mtime;
			st->ctime = file_stat.st_ctime;
			hashtable_insert(stated_files, x_strdup(path), st);
		}

		if (conf->sloppiness & SLOPPY_FILE_STAT_MATCHES) {
			// st->ctime is sometimes 0, so we can't check that both st->ctime and
			// st->mtime are greater than time_of_compilation. But it's sufficient to
			// check that either is.
			if (fi->size == st->size
			    && fi->mtime == st->mtime
			    && fi->ctime == st->ctime
			    && MAX(st->mtime, st->ctime) >= time_of_compilation) {
				cc_log(""size/mtime/ctime hit for %s"", path);
				continue;
			} else {
				cc_log(""size/mtime/ctime miss for %s"", path);
			}
		}

		struct file_hash *actual = hashtable_search(hashed_files, path);
		if (!actual) {
			struct mdfour hash;
			hash_start(&hash);
			int result = hash_source_code_file(conf, &hash, path);
			if (result & HASH_SOURCE_CODE_ERROR) {
				cc_log(""Failed hashing %s"", path);
				return 0;
			}
			if (result & HASH_SOURCE_CODE_FOUND_TIME) {
				return 0;
			}
			actual = x_malloc(sizeof(*actual));
			hash_result_as_bytes(&hash, actual->hash);
			actual->size = hash.totalN;
			hashtable_insert(hashed_files, x_strdup(path), actual);
		}
		if (memcmp(fi->hash, actual->hash, mf->hash_size) != 0
		    || fi->size != actual->size) {
			return 0;
		}
	}

	return 1;
}

static struct hashtable *
create_string_index_map(char **strings, uint32_t len)
{
	struct hashtable *h =
	  create_hashtable(1000, hash_from_string, strings_equal);
	for (uint32_t i = 0; i < len; i++) {
		uint32_t *index = x_malloc(sizeof(*index));
		*index = i;
		hashtable_insert(h, x_strdup(strings[i]), index);
	}
	return h;
}

static struct hashtable *
create_file_info_index_map(struct file_info *infos, uint32_t len)
{
	struct hashtable *h =
	  create_hashtable(1000, hash_from_file_info, file_infos_equal);
	for (uint32_t i = 0; i < len; i++) {
		struct file_info *fi = x_malloc(sizeof(*fi));
		*fi = infos[i];
		uint32_t *index = x_malloc(sizeof(*index));
		*index = i;
		hashtable_insert(h, fi, index);
	}
	return h;
}

static uint32_t
get_include_file_index(struct manifest *mf, char *path,
                       struct hashtable *mf_files)
{
	uint32_t *index = hashtable_search(mf_files, path);
	if (index) {
		return *index;
	}

	uint32_t n = mf->n_files;
	mf->files = x_realloc(mf->files, (n + 1) * sizeof(*mf->files));
	mf->n_files++;
	mf->files[n] = x_strdup(path);
	return n;
}

static uint32_t
get_file_hash_index(struct manifest *mf,
                    char *path,
                    struct file_hash *file_hash,
                    struct hashtable *mf_files,
                    struct hashtable *mf_file_infos)
{
	struct file_info fi;
	fi.index = get_include_file_index(mf, path, mf_files);
	memcpy(fi.hash, file_hash->hash, sizeof(fi.hash));
	fi.size = file_hash->size;

	// file_stat.st_{m,c}time has a resolution of 1 second, so we can cache the
	// file's mtime and ctime only if they're at least one second older than
	// time_of_compilation.
	//
	// st->ctime may be 0, so we have to check time_of_compilation against
	// MAX(mtime, ctime).

	struct stat file_stat;
	if (stat(path, &file_stat) != -1
	    && time_of_compilation > MAX(file_stat.st_mtime, file_stat.st_ctime)) {
		fi.mtime = file_stat.st_mtime;
		fi.ctime = file_stat.st_ctime;
	} else {
		fi.mtime = -1;
		fi.ctime = -1;
	}

	uint32_t *fi_index = hashtable_search(mf_file_infos, &fi);
	if (fi_index) {
		return *fi_index;
	}

	uint32_t n = mf->n_file_infos;
	mf->file_infos = x_realloc(mf->file_infos, (n + 1) * sizeof(*mf->file_infos));
	mf->n_file_infos++;
	mf->file_infos[n] = fi;
	return n;
}

static void
add_file_info_indexes(uint32_t *indexes, uint32_t size,
                      struct manifest *mf, struct hashtable *included_files)
{
	if (size == 0) {
		return;
	}

	// path --> index
	struct hashtable *mf_files =
	  create_string_index_map(mf->files, mf->n_files);
	// struct file_info --> index
	struct hashtable *mf_file_infos =
	  create_file_info_index_map(mf->file_infos, mf->n_file_infos);
	struct hashtable_itr *iter = hashtable_iterator(included_files);
	uint32_t i = 0;
	do {
		char *path = hashtable_iterator_key(iter);
		struct file_hash *file_hash = hashtable_iterator_value(iter);
		indexes[i] = get_file_hash_index(mf, path, file_hash, mf_files,
		                                 mf_file_infos);
		i++;
	} while (hashtable_iterator_advance(iter));
	assert(i == size);

	hashtable_destroy(mf_file_infos, 1);
	hashtable_destroy(mf_files, 1);
}

static void
add_object_entry(struct manifest *mf,
                 struct file_hash *object_hash,
                 struct hashtable *included_files)
{
	uint32_t n_objs = mf->n_objects;
	mf->objects = x_realloc(mf->objects, (n_objs + 1) * sizeof(*mf->objects));
	mf->n_objects++;
	struct object *obj = &mf->objects[n_objs];

	uint32_t n_fii = hashtable_count(included_files);
	obj->n_file_info_indexes = n_fii;
	obj->file_info_indexes = x_malloc(n_fii * sizeof(*obj->file_info_indexes));
	add_file_info_indexes(obj->file_info_indexes, n_fii, mf, included_files);
	memcpy(obj->hash.hash, object_hash->hash, mf->hash_size);
	obj->hash.size = object_hash->size;
}

// Try to get the object hash from a manifest file. Caller frees. Returns NULL
// on failure.
struct file_hash *
manifest_get(struct conf *conf, const char *manifest_path)
{
	gzFile f = NULL;
	struct manifest *mf = NULL;
	struct hashtable *hashed_files = NULL; // path --> struct file_hash
	struct hashtable *stated_files = NULL; // path --> struct file_stats
	struct file_hash *fh = NULL;

	int fd = open(manifest_path, O_RDONLY | O_BINARY);
	if (fd == -1) {
		// Cache miss.
		cc_log(""No such manifest file"");
		goto out;
	}
	f = gzdopen(fd, ""rb"");
	if (!f) {
		close(fd);
		cc_log(""Failed to gzdopen manifest file"");
		goto out;
	}
	mf = read_manifest(f);
	if (!mf) {
		cc_log(""Error reading manifest file"");
		goto out;
	}

	hashed_files = create_hashtable(1000, hash_from_string, strings_equal);
	stated_files = create_hashtable(1000, hash_from_string, strings_equal);

	// Check newest object first since it's a bit more likely to match.
	for (uint32_t i = mf->n_objects; i > 0; i--) {
		if (verify_object(conf, mf, &mf->objects[i - 1],
		                  stated_files, hashed_files)) {
			fh = x_malloc(sizeof(*fh));
			*fh = mf->objects[i - 1].hash;
			goto out;
		}
	}

out:
	if (hashed_files) {
		hashtable_destroy(hashed_files, 1);
	}
	if (stated_files) {
		hashtable_destroy(stated_files, 1);
	}
	if (f) {
		gzclose(f);
	}
	if (mf) {
		free_manifest(mf);
	}
	return fh;
}

// Put the object name into a manifest file given a set of included files.
// Returns true on success, otherwise false.
bool
manifest_put(const char *manifest_path, struct file_hash *object_hash,
             struct hashtable *included_files)
{
	int ret = 0;
	gzFile f2 = NULL;
	struct manifest *mf = NULL;
	char *tmp_file = NULL;

	// We don't bother to acquire a lock when writing the manifest to disk. A
	// race between two processes will only result in one lost entry, which is
	// not a big deal, and it's also very unlikely.

	int fd1 = open(manifest_path, O_RDONLY | O_BINARY);
	if (fd1 == -1) {
		// New file.
		mf = create_empty_manifest();
	} else {
		gzFile f1 = gzdopen(fd1, ""rb"");
		if (!f1) {
			cc_log(""Failed to gzdopen manifest file"");
			close(fd1);
			goto out;
		}
		mf = read_manifest(f1);
		gzclose(f1);
		if (!mf) {
			cc_log(""Failed to read manifest file; deleting it"");
			x_unlink(manifest_path);
			mf = create_empty_manifest();
		}
	}

	if (mf->n_objects > MAX_MANIFEST_ENTRIES) {
		// Normally, there shouldn't be many object entries in the manifest since
		// new entries are added only if an include file has changed but not the
		// source file, and you typically change source files more often than
		// header files. However, it's certainly possible to imagine cases where
		// the manifest will grow large (for instance, a generated header file that
		// changes for every build), and this must be taken care of since
		// processing an ever growing manifest eventually will take too much time.
		// A good way of solving this would be to maintain the object entries in
		// LRU order and discarding the old ones. An easy way is to throw away all
		// entries when there are too many. Let's do that for now.
		cc_log(""More than %u entries in manifest file; discarding"",
		       MAX_MANIFEST_ENTRIES);
		free_manifest(mf);
		mf = create_empty_manifest();
	} else if (mf->n_file_infos > MAX_MANIFEST_FILE_INFO_ENTRIES) {
		// Rarely, file_info entries can grow large in pathological cases where
		// many included files change, but the main file does not. This also puts
		// an upper bound on the number of file_info entries.
		cc_log(""More than %u file_info entries in manifest file; discarding"",
		       MAX_MANIFEST_FILE_INFO_ENTRIES);
		free_manifest(mf);
		mf = create_empty_manifest();
	}

	tmp_file = format(""%s.tmp"", manifest_path);
	int fd2 = create_tmp_fd(&tmp_file);
	f2 = gzdopen(fd2, ""wb"");
	if (!f2) {
		cc_log(""Failed to gzdopen %s"", tmp_file);
		goto out;
	}

	add_object_entry(mf, object_hash, included_files);
	if (write_manifest(f2, mf)) {
		gzclose(f2);
		f2 = NULL;
		if (x_rename(tmp_file, manifest_path) == 0) {
			ret = 1;
		} else {
			cc_log(""Failed to rename %s to %s"", tmp_file, manifest_path);
			goto out;
		}
	} else {
		cc_log(""Failed to write manifest file"");
		goto out;
	}

out:
	if (mf) {
		free_manifest(mf);
	}
	if (tmp_file) {
		free(tmp_file);
	}
	if (f2) {
		gzclose(f2);
	}
	return ret;
}

bool
manifest_dump(const char *manifest_path, FILE *stream)
{
	struct manifest *mf = NULL;
	gzFile f = NULL;
	bool ret = false;

	int fd = open(manifest_path, O_RDONLY | O_BINARY);
	if (fd == -1) {
		fprintf(stderr, ""No such manifest file: %s\n"", manifest_path);
		goto out;
	}
	f = gzdopen(fd, ""rb"");
	if (!f) {
		fprintf(stderr, ""Failed to dzopen manifest file\n"");
		close(fd);
		goto out;
	}
	mf = read_manifest(f);
	if (!mf) {
		fprintf(stderr, ""Error reading manifest file\n"");
		goto out;
	}

	fprintf(stream, ""Magic: %c%c%c%c\n"",
	        (MAGIC >> 24) & 0xFF,
	        (MAGIC >> 16) & 0xFF,
	        (MAGIC >> 8) & 0xFF,
	        MAGIC & 0xFF);
	fprintf(stream, ""Version: %u\n"", mf->version);
	fprintf(stream, ""Hash size: %u\n"", (unsigned)mf->hash_size);
	fprintf(stream, ""Reserved field: %u\n"", (unsigned)mf->reserved);
	fprintf(stream, ""File paths (%u):\n"", (unsigned)mf->n_files);
	for (unsigned i = 0; i < mf->n_files; ++i) {
		fprintf(stream, ""  %u: %s\n"", i, mf->files[i]);
	}
	fprintf(stream, ""File infos (%u):\n"", (unsigned)mf->n_file_infos);
	for (unsigned i = 0; i < mf->n_file_infos; ++i) {
		char *hash;
		fprintf(stream, ""  %u:\n"", i);
		fprintf(stream, ""    Path index: %u\n"", mf->file_infos[i].index);
		hash = format_hash_as_string(mf->file_infos[i].hash, -1);
		fprintf(stream, ""    Hash: %s\n"", hash);
		free(hash);
		fprintf(stream, ""    Size: %u\n"", mf->file_infos[i].size);
		fprintf(stream, ""    Mtime: %lld\n"", (long long)mf->file_infos[i].mtime);
		fprintf(stream, ""    Ctime: %lld\n"", (long long)mf->file_infos[i].ctime);
	}
	fprintf(stream, ""Results (%u):\n"", (unsigned)mf->n_objects);
	for (unsigned i = 0; i < mf->n_objects; ++i) {
		char *hash;
		fprintf(stream, ""  %u:\n"", i);
		fprintf(stream, ""    File info indexes:"");
		for (unsigned j = 0; j < mf->objects[i].n_file_info_indexes; ++j) {
			fprintf(stream, "" %u"", mf->objects[i].file_info_indexes[j]);
		}
		fprintf(stream, ""\n"");
		hash = format_hash_as_string(mf->objects[i].hash.hash, -1);
		fprintf(stream, ""    Hash: %s\n"", hash);
		free(hash);
		fprintf(stream, ""    Size: %u\n"", (unsigned)mf->objects[i].hash.size);
	}

	ret = true;

out:
	if (mf) {
		free_manifest(mf);
	}
	if (f) {
		gzclose(f);
	}
	return ret;
}
""","""// Copyright (C) 2009-2016 Joel Rosdahl
//
// This program is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by the Free
// Software Foundation; either version 3 of the License, or (at your option)
// any later version.
//
// This program is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
// more details.
//
// You should have received a copy of the GNU General Public License along with
// this program; if not, write to the Free Software Foundation, Inc., 51
// Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA

#include ""ccache.h""
#include ""hashtable_itr.h""
#include ""hashutil.h""
#include ""manifest.h""
#include ""murmurhashneutral2.h""

#include <zlib.h>

// Sketchy specification of the manifest disk format:
//
// <magic>         magic number                        (4 bytes)
// <version>       file format version                 (1 byte unsigned int)
// <hash_size>     size of the hash fields (in bytes)  (1 byte unsigned int)
// <reserved>      reserved for future use             (2 bytes)
// ----------------------------------------------------------------------------
// <n>             number of include file paths        (4 bytes unsigned int)
// <path_0>        path to include file                (NUL-terminated string,
// ...                                                  at most 1024 bytes)
// <path_n-1>
// ----------------------------------------------------------------------------
// <n>             number of include file hash entries (4 bytes unsigned int)
// <index[0]>      index of include file path          (4 bytes unsigned int)
// <hash[0]>       hash of include file                (<hash_size> bytes)
// <size[0]>       size of include file                (4 bytes unsigned int)
// <mtime[0]>      mtime of include file               (8 bytes signed int)
// <ctime[0]>      ctime of include file               (8 bytes signed int)
// ...
// <index[n-1]>
// <hash[n-1]>
// <size[n-1]>
// <mtime[n-1]>
// <ctime[n-1]>
// ----------------------------------------------------------------------------
// <n>             number of object name entries       (4 bytes unsigned int)
// <m[0]>          number of include file hash indexes (4 bytes unsigned int)
// <index[0][0]>   include file hash index             (4 bytes unsigned int)
// ...
// <index[0][m[0]-1]>
// <hash[0]>       hash part of object name            (<hash_size> bytes)
// <size[0]>       size part of object name            (4 bytes unsigned int)
// ...
// <m[n-1]>        number of include file hash indexes
// <index[n-1][0]> include file hash index
// ...
// <index[n-1][m[n-1]]>
// <hash[n-1]>
// <size[n-1]>

static const uint32_t MAGIC = 0x63436d46U;
static const uint32_t MAX_MANIFEST_ENTRIES = 100;
static const uint32_t MAX_MANIFEST_FILE_INFO_ENTRIES = 10000;

#define ccache_static_assert(e) \
  do { enum { ccache_static_assert__ = 1/(e) }; } while (false)

struct file_info {
	// Index to n_files.
	uint32_t index;
	// Hash of referenced file.
	uint8_t hash[16];
	// Size of referenced file.
	uint32_t size;
	// mtime of referenced file.
	int64_t mtime;
	// ctime of referenced file.
	int64_t ctime;
};

struct object {
	// Number of entries in file_info_indexes.
	uint32_t n_file_info_indexes;
	// Indexes to file_infos.
	uint32_t *file_info_indexes;
	// Hash of the object itself.
	struct file_hash hash;
};

struct manifest {
	// Version of decoded file.
	uint8_t version;

	// Reserved for future use.
	uint16_t reserved;

	// Size of hash fields (in bytes).
	uint8_t hash_size;

	// Referenced include files.
	uint32_t n_files;
	char **files;

	// Information about referenced include files.
	uint32_t n_file_infos;
	struct file_info *file_infos;

	// Object names plus references to include file hashes.
	uint32_t n_objects;
	struct object *objects;
};

struct file_stats {
	uint32_t size;
	int64_t mtime;
	int64_t ctime;
};

static unsigned int
hash_from_file_info(void *key)
{
	ccache_static_assert(sizeof(struct file_info) == 40); // No padding.
	return murmurhashneutral2(key, sizeof(struct file_info), 0);
}

static int
file_infos_equal(void *key1, void *key2)
{
	struct file_info *fi1 = (struct file_info *)key1;
	struct file_info *fi2 = (struct file_info *)key2;
	return fi1->index == fi2->index
	       && memcmp(fi1->hash, fi2->hash, 16) == 0
	       && fi1->size == fi2->size
	       && fi1->mtime == fi2->mtime
	       && fi1->ctime == fi2->ctime;
}

static void
free_manifest(struct manifest *mf)
{
	for (uint32_t i = 0; i < mf->n_files; i++) {
		free(mf->files[i]);
	}
	free(mf->files);
	free(mf->file_infos);
	for (uint32_t i = 0; i < mf->n_objects; i++) {
		free(mf->objects[i].file_info_indexes);
	}
	free(mf->objects);
	free(mf);
}

#define READ_BYTE(var) \
  do { \
		int ch_ = gzgetc(f); \
		if (ch_ == EOF) { \
			goto error; \
		} \
		(var) = ch_ & 0xFF; \
	} while (false)

#define READ_INT(size, var) \
  do { \
		uint64_t u_ = 0; \
		for (size_t i_ = 0; i_ < (size); i_++) { \
			int ch_ = gzgetc(f); \
			if (ch_ == EOF) { \
				goto error; \
			} \
			u_ <<= 8; \
			u_ |= ch_ & 0xFF; \
		} \
		(var) = u_; \
	} while (false)

#define READ_STR(var) \
  do { \
		char buf_[1024]; \
		size_t i_; \
		for (i_ = 0; i_ < sizeof(buf_); i_++) { \
			int ch_ = gzgetc(f); \
			if (ch_ == EOF) { \
				goto error; \
			} \
			buf_[i_] = ch_; \
			if (ch_ == '\0') { \
				break; \
			} \
		} \
		if (i_ == sizeof(buf_)) { \
			goto error; \
		} \
		(var) = x_strdup(buf_); \
	} while (false)

#define READ_BYTES(n, var) \
  do { \
		for (size_t i_ = 0; i_ < (n); i_++) { \
			int ch_ = gzgetc(f); \
			if (ch_ == EOF) { \
				goto error; \
			} \
			(var)[i_] = ch_; \
		} \
	} while (false)

static struct manifest *
create_empty_manifest(void)
{
	struct manifest *mf = x_malloc(sizeof(*mf));
	mf->hash_size = 16;
	mf->n_files = 0;
	mf->files = NULL;
	mf->n_file_infos = 0;
	mf->file_infos = NULL;
	mf->n_objects = 0;
	mf->objects = NULL;

	return mf;
}

static struct manifest *
read_manifest(gzFile f)
{
	struct manifest *mf = create_empty_manifest();

	uint32_t magic;
	READ_INT(4, magic);
	if (magic != MAGIC) {
		cc_log(""Manifest file has bad magic number %u"", magic);
		goto error;
	}

	READ_BYTE(mf->version);
	if (mf->version != MANIFEST_VERSION) {
		cc_log(""Manifest file has unknown version %u"", mf->version);
		goto error;
	}

	READ_BYTE(mf->hash_size);
	if (mf->hash_size != 16) {
		// Temporary measure until we support different hash algorithms.
		cc_log(""Manifest file has unsupported hash size %u"", mf->hash_size);
		goto error;
	}

	READ_INT(2, mf->reserved);

	READ_INT(4, mf->n_files);
	mf->files = x_calloc(mf->n_files, sizeof(*mf->files));
	for (uint32_t i = 0; i < mf->n_files; i++) {
		READ_STR(mf->files[i]);
	}

	READ_INT(4, mf->n_file_infos);
	mf->file_infos = x_calloc(mf->n_file_infos, sizeof(*mf->file_infos));
	for (uint32_t i = 0; i < mf->n_file_infos; i++) {
		READ_INT(4, mf->file_infos[i].index);
		READ_BYTES(mf->hash_size, mf->file_infos[i].hash);
		READ_INT(4, mf->file_infos[i].size);
		READ_INT(8, mf->file_infos[i].mtime);
		READ_INT(8, mf->file_infos[i].ctime);
	}

	READ_INT(4, mf->n_objects);
	mf->objects = x_calloc(mf->n_objects, sizeof(*mf->objects));
	for (uint32_t i = 0; i < mf->n_objects; i++) {
		READ_INT(4, mf->objects[i].n_file_info_indexes);
		mf->objects[i].file_info_indexes =
		  x_calloc(mf->objects[i].n_file_info_indexes,
		           sizeof(*mf->objects[i].file_info_indexes));
		for (uint32_t j = 0; j < mf->objects[i].n_file_info_indexes; j++) {
			READ_INT(4, mf->objects[i].file_info_indexes[j]);
		}
		READ_BYTES(mf->hash_size, mf->objects[i].hash.hash);
		READ_INT(4, mf->objects[i].hash.size);
	}

	return mf;

error:
	cc_log(""Corrupt manifest file"");
	free_manifest(mf);
	return NULL;
}

#define WRITE_INT(size, var) \
  do { \
		uint64_t u_ = (var); \
		uint8_t ch_; \
		size_t i_; \
		for (i_ = 0; i_ < (size); i_++) { \
			ch_ = (u_ >> (8 * ((size) - i_ - 1))); \
			if (gzputc(f, ch_) == EOF) { \
				goto error; \
			} \
		} \
	} while (false)

#define WRITE_STR(var) \
  do { \
		if (gzputs(f, var) == EOF || gzputc(f, '\0') == EOF) { \
			goto error; \
		} \
	} while (false)

#define WRITE_BYTES(n, var) \
  do { \
		size_t i_; \
		for (i_ = 0; i_ < (n); i_++) { \
			if (gzputc(f, (var)[i_]) == EOF) { \
				goto error; \
			} \
		} \
	} while (false)

static int
write_manifest(gzFile f, const struct manifest *mf)
{
	WRITE_INT(4, MAGIC);
	WRITE_INT(1, MANIFEST_VERSION);
	WRITE_INT(1, 16);
	WRITE_INT(2, 0);

	WRITE_INT(4, mf->n_files);
	for (uint32_t i = 0; i < mf->n_files; i++) {
		WRITE_STR(mf->files[i]);
	}

	WRITE_INT(4, mf->n_file_infos);
	for (uint32_t i = 0; i < mf->n_file_infos; i++) {
		WRITE_INT(4, mf->file_infos[i].index);
		WRITE_BYTES(mf->hash_size, mf->file_infos[i].hash);
		WRITE_INT(4, mf->file_infos[i].size);
		WRITE_INT(8, mf->file_infos[i].mtime);
		WRITE_INT(8, mf->file_infos[i].ctime);
	}

	WRITE_INT(4, mf->n_objects);
	for (uint32_t i = 0; i < mf->n_objects; i++) {
		WRITE_INT(4, mf->objects[i].n_file_info_indexes);
		for (uint32_t j = 0; j < mf->objects[i].n_file_info_indexes; j++) {
			WRITE_INT(4, mf->objects[i].file_info_indexes[j]);
		}
		WRITE_BYTES(mf->hash_size, mf->objects[i].hash.hash);
		WRITE_INT(4, mf->objects[i].hash.size);
	}

	return 1;

error:
	cc_log(""Error writing to manifest file"");
	return 0;
}

static int
verify_object(struct conf *conf, struct manifest *mf, struct object *obj,
              struct hashtable *stated_files, struct hashtable *hashed_files)
{
	for (uint32_t i = 0; i < obj->n_file_info_indexes; i++) {
		struct file_info *fi = &mf->file_infos[obj->file_info_indexes[i]];
		char *path = mf->files[fi->index];
		struct file_stats *st = hashtable_search(stated_files, path);
		if (!st) {
			struct stat file_stat;
			if (x_stat(path, &file_stat) != 0) {
				return 0;
			}
			st = x_malloc(sizeof(*st));
			st->size = file_stat.st_size;
			st->mtime = file_stat.st_mtime;
			st->ctime = file_stat.st_ctime;
			hashtable_insert(stated_files, x_strdup(path), st);
		}

		if (fi->size != st->size) {
			return 0;
		}

		if (conf->sloppiness & SLOPPY_FILE_STAT_MATCHES) {
			if (fi->mtime == st->mtime && fi->ctime == st->ctime) {
				cc_log(""size/mtime/ctime hit for %s"", path);
				continue;
			} else {
				cc_log(""size/mtime/ctime miss for %s"", path);
			}
		}

		struct file_hash *actual = hashtable_search(hashed_files, path);
		if (!actual) {
			struct mdfour hash;
			hash_start(&hash);
			int result = hash_source_code_file(conf, &hash, path);
			if (result & HASH_SOURCE_CODE_ERROR) {
				cc_log(""Failed hashing %s"", path);
				return 0;
			}
			if (result & HASH_SOURCE_CODE_FOUND_TIME) {
				return 0;
			}
			actual = x_malloc(sizeof(*actual));
			hash_result_as_bytes(&hash, actual->hash);
			actual->size = hash.totalN;
			hashtable_insert(hashed_files, x_strdup(path), actual);
		}
		if (memcmp(fi->hash, actual->hash, mf->hash_size) != 0
		    || fi->size != actual->size) {
			return 0;
		}
	}

	return 1;
}

static struct hashtable *
create_string_index_map(char **strings, uint32_t len)
{
	struct hashtable *h =
	  create_hashtable(1000, hash_from_string, strings_equal);
	for (uint32_t i = 0; i < len; i++) {
		uint32_t *index = x_malloc(sizeof(*index));
		*index = i;
		hashtable_insert(h, x_strdup(strings[i]), index);
	}
	return h;
}

static struct hashtable *
create_file_info_index_map(struct file_info *infos, uint32_t len)
{
	struct hashtable *h =
	  create_hashtable(1000, hash_from_file_info, file_infos_equal);
	for (uint32_t i = 0; i < len; i++) {
		struct file_info *fi = x_malloc(sizeof(*fi));
		*fi = infos[i];
		uint32_t *index = x_malloc(sizeof(*index));
		*index = i;
		hashtable_insert(h, fi, index);
	}
	return h;
}

static uint32_t
get_include_file_index(struct manifest *mf, char *path,
                       struct hashtable *mf_files)
{
	uint32_t *index = hashtable_search(mf_files, path);
	if (index) {
		return *index;
	}

	uint32_t n = mf->n_files;
	mf->files = x_realloc(mf->files, (n + 1) * sizeof(*mf->files));
	mf->n_files++;
	mf->files[n] = x_strdup(path);
	return n;
}

static uint32_t
get_file_hash_index(struct manifest *mf,
                    char *path,
                    struct file_hash *file_hash,
                    struct hashtable *mf_files,
                    struct hashtable *mf_file_infos)
{
	struct file_info fi;
	fi.index = get_include_file_index(mf, path, mf_files);
	memcpy(fi.hash, file_hash->hash, sizeof(fi.hash));
	fi.size = file_hash->size;

	// file_stat.st_{m,c}time has a resolution of 1 second, so we can cache the
	// file's mtime and ctime only if they're at least one second older than
	// time_of_compilation.
	//
	// st->ctime may be 0, so we have to check time_of_compilation against
	// MAX(mtime, ctime).

	struct stat file_stat;
	if (stat(path, &file_stat) != -1
	    && time_of_compilation > MAX(file_stat.st_mtime, file_stat.st_ctime)) {
		fi.mtime = file_stat.st_mtime;
		fi.ctime = file_stat.st_ctime;
	} else {
		fi.mtime = -1;
		fi.ctime = -1;
	}

	uint32_t *fi_index = hashtable_search(mf_file_infos, &fi);
	if (fi_index) {
		return *fi_index;
	}

	uint32_t n = mf->n_file_infos;
	mf->file_infos = x_realloc(mf->file_infos, (n + 1) * sizeof(*mf->file_infos));
	mf->n_file_infos++;
	mf->file_infos[n] = fi;
	return n;
}

static void
add_file_info_indexes(uint32_t *indexes, uint32_t size,
                      struct manifest *mf, struct hashtable *included_files)
{
	if (size == 0) {
		return;
	}

	// path --> index
	struct hashtable *mf_files =
	  create_string_index_map(mf->files, mf->n_files);
	// struct file_info --> index
	struct hashtable *mf_file_infos =
	  create_file_info_index_map(mf->file_infos, mf->n_file_infos);
	struct hashtable_itr *iter = hashtable_iterator(included_files);
	uint32_t i = 0;
	do {
		char *path = hashtable_iterator_key(iter);
		struct file_hash *file_hash = hashtable_iterator_value(iter);
		indexes[i] = get_file_hash_index(mf, path, file_hash, mf_files,
		                                 mf_file_infos);
		i++;
	} while (hashtable_iterator_advance(iter));
	assert(i == size);

	hashtable_destroy(mf_file_infos, 1);
	hashtable_destroy(mf_files, 1);
}

static void
add_object_entry(struct manifest *mf,
                 struct file_hash *object_hash,
                 struct hashtable *included_files)
{
	uint32_t n_objs = mf->n_objects;
	mf->objects = x_realloc(mf->objects, (n_objs + 1) * sizeof(*mf->objects));
	mf->n_objects++;
	struct object *obj = &mf->objects[n_objs];

	uint32_t n_fii = hashtable_count(included_files);
	obj->n_file_info_indexes = n_fii;
	obj->file_info_indexes = x_malloc(n_fii * sizeof(*obj->file_info_indexes));
	add_file_info_indexes(obj->file_info_indexes, n_fii, mf, included_files);
	memcpy(obj->hash.hash, object_hash->hash, mf->hash_size);
	obj->hash.size = object_hash->size;
}

// Try to get the object hash from a manifest file. Caller frees. Returns NULL
// on failure.
struct file_hash *
manifest_get(struct conf *conf, const char *manifest_path)
{
	gzFile f = NULL;
	struct manifest *mf = NULL;
	struct hashtable *hashed_files = NULL; // path --> struct file_hash
	struct hashtable *stated_files = NULL; // path --> struct file_stats
	struct file_hash *fh = NULL;

	int fd = open(manifest_path, O_RDONLY | O_BINARY);
	if (fd == -1) {
		// Cache miss.
		cc_log(""No such manifest file"");
		goto out;
	}
	f = gzdopen(fd, ""rb"");
	if (!f) {
		close(fd);
		cc_log(""Failed to gzdopen manifest file"");
		goto out;
	}
	mf = read_manifest(f);
	if (!mf) {
		cc_log(""Error reading manifest file"");
		goto out;
	}

	hashed_files = create_hashtable(1000, hash_from_string, strings_equal);
	stated_files = create_hashtable(1000, hash_from_string, strings_equal);

	// Check newest object first since it's a bit more likely to match.
	for (uint32_t i = mf->n_objects; i > 0; i--) {
		if (verify_object(conf, mf, &mf->objects[i - 1],
		                  stated_files, hashed_files)) {
			fh = x_malloc(sizeof(*fh));
			*fh = mf->objects[i - 1].hash;
			goto out;
		}
	}

out:
	if (hashed_files) {
		hashtable_destroy(hashed_files, 1);
	}
	if (stated_files) {
		hashtable_destroy(stated_files, 1);
	}
	if (f) {
		gzclose(f);
	}
	if (mf) {
		free_manifest(mf);
	}
	return fh;
}

// Put the object name into a manifest file given a set of included files.
// Returns true on success, otherwise false.
bool
manifest_put(const char *manifest_path, struct file_hash *object_hash,
             struct hashtable *included_files)
{
	int ret = 0;
	gzFile f2 = NULL;
	struct manifest *mf = NULL;
	char *tmp_file = NULL;

	// We don't bother to acquire a lock when writing the manifest to disk. A
	// race between two processes will only result in one lost entry, which is
	// not a big deal, and it's also very unlikely.

	int fd1 = open(manifest_path, O_RDONLY | O_BINARY);
	if (fd1 == -1) {
		// New file.
		mf = create_empty_manifest();
	} else {
		gzFile f1 = gzdopen(fd1, ""rb"");
		if (!f1) {
			cc_log(""Failed to gzdopen manifest file"");
			close(fd1);
			goto out;
		}
		mf = read_manifest(f1);
		gzclose(f1);
		if (!mf) {
			cc_log(""Failed to read manifest file; deleting it"");
			x_unlink(manifest_path);
			mf = create_empty_manifest();
		}
	}

	if (mf->n_objects > MAX_MANIFEST_ENTRIES) {
		// Normally, there shouldn't be many object entries in the manifest since
		// new entries are added only if an include file has changed but not the
		// source file, and you typically change source files more often than
		// header files. However, it's certainly possible to imagine cases where
		// the manifest will grow large (for instance, a generated header file that
		// changes for every build), and this must be taken care of since
		// processing an ever growing manifest eventually will take too much time.
		// A good way of solving this would be to maintain the object entries in
		// LRU order and discarding the old ones. An easy way is to throw away all
		// entries when there are too many. Let's do that for now.
		cc_log(""More than %u entries in manifest file; discarding"",
		       MAX_MANIFEST_ENTRIES);
		free_manifest(mf);
		mf = create_empty_manifest();
	} else if (mf->n_file_infos > MAX_MANIFEST_FILE_INFO_ENTRIES) {
		// Rarely, file_info entries can grow large in pathological cases where
		// many included files change, but the main file does not. This also puts
		// an upper bound on the number of file_info entries.
		cc_log(""More than %u file_info entries in manifest file; discarding"",
		       MAX_MANIFEST_FILE_INFO_ENTRIES);
		free_manifest(mf);
		mf = create_empty_manifest();
	}

	tmp_file = format(""%s.tmp"", manifest_path);
	int fd2 = create_tmp_fd(&tmp_file);
	f2 = gzdopen(fd2, ""wb"");
	if (!f2) {
		cc_log(""Failed to gzdopen %s"", tmp_file);
		goto out;
	}

	add_object_entry(mf, object_hash, included_files);
	if (write_manifest(f2, mf)) {
		gzclose(f2);
		f2 = NULL;
		if (x_rename(tmp_file, manifest_path) == 0) {
			ret = 1;
		} else {
			cc_log(""Failed to rename %s to %s"", tmp_file, manifest_path);
			goto out;
		}
	} else {
		cc_log(""Failed to write manifest file"");
		goto out;
	}

out:
	if (mf) {
		free_manifest(mf);
	}
	if (tmp_file) {
		free(tmp_file);
	}
	if (f2) {
		gzclose(f2);
	}
	return ret;
}

bool
manifest_dump(const char *manifest_path, FILE *stream)
{
	struct manifest *mf = NULL;
	gzFile f = NULL;
	bool ret = false;

	int fd = open(manifest_path, O_RDONLY | O_BINARY);
	if (fd == -1) {
		fprintf(stderr, ""No such manifest file: %s\n"", manifest_path);
		goto out;
	}
	f = gzdopen(fd, ""rb"");
	if (!f) {
		fprintf(stderr, ""Failed to dzopen manifest file\n"");
		close(fd);
		goto out;
	}
	mf = read_manifest(f);
	if (!mf) {
		fprintf(stderr, ""Error reading manifest file\n"");
		goto out;
	}

	fprintf(stream, ""Magic: %c%c%c%c\n"",
	        (MAGIC >> 24) & 0xFF,
	        (MAGIC >> 16) & 0xFF,
	        (MAGIC >> 8) & 0xFF,
	        MAGIC & 0xFF);
	fprintf(stream, ""Version: %u\n"", mf->version);
	fprintf(stream, ""Hash size: %u\n"", (unsigned)mf->hash_size);
	fprintf(stream, ""Reserved field: %u\n"", (unsigned)mf->reserved);
	fprintf(stream, ""File paths (%u):\n"", (unsigned)mf->n_files);
	for (unsigned i = 0; i < mf->n_files; ++i) {
		fprintf(stream, ""  %u: %s\n"", i, mf->files[i]);
	}
	fprintf(stream, ""File infos (%u):\n"", (unsigned)mf->n_file_infos);
	for (unsigned i = 0; i < mf->n_file_infos; ++i) {
		char *hash;
		fprintf(stream, ""  %u:\n"", i);
		fprintf(stream, ""    Path index: %u\n"", mf->file_infos[i].index);
		hash = format_hash_as_string(mf->file_infos[i].hash, -1);
		fprintf(stream, ""    Hash: %s\n"", hash);
		free(hash);
		fprintf(stream, ""    Size: %u\n"", mf->file_infos[i].size);
		fprintf(stream, ""    Mtime: %lld\n"", (long long)mf->file_infos[i].mtime);
		fprintf(stream, ""    Ctime: %lld\n"", (long long)mf->file_infos[i].ctime);
	}
	fprintf(stream, ""Results (%u):\n"", (unsigned)mf->n_objects);
	for (unsigned i = 0; i < mf->n_objects; ++i) {
		char *hash;
		fprintf(stream, ""  %u:\n"", i);
		fprintf(stream, ""    File info indexes:"");
		for (unsigned j = 0; j < mf->objects[i].n_file_info_indexes; ++j) {
			fprintf(stream, "" %u"", mf->objects[i].file_info_indexes[j]);
		}
		fprintf(stream, ""\n"");
		hash = format_hash_as_string(mf->objects[i].hash.hash, -1);
		fprintf(stream, ""    Hash: %s\n"", hash);
		free(hash);
		fprintf(stream, ""    Size: %u\n"", (unsigned)mf->objects[i].hash.size);
	}

	ret = true;

out:
	if (mf) {
		free_manifest(mf);
	}
	if (f) {
		gzclose(f);
	}
	return ret;
}
""",verify_object,[361:417]
ccache,https://github.com/ccache/ccache/commit/dde3543c6a556909c8c2092e6fbfcc14d9f5f5ac,"""process_preprocessed_file: Move gnu_getcwd() out of tight loop

Change process_preprocessed_file from calling getcwd() once per line
in the preprocessed source file to once at the start of the function.
The performance of getcwd() on Mac seems to be terrible compared to
Linux.  On a macOS 10.13 build machine, this change improves
process_preprocessed_file runtime on a 10MB preprocessed file from 75
seconds to .75 seconds.""","""// ccache -- a fast C/C++ compiler cache
//
// Copyright (C) 2002-2007 Andrew Tridgell
// Copyright (C) 2009-2018 Joel Rosdahl
//
// This program is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by the Free
// Software Foundation; either version 3 of the License, or (at your option)
// any later version.
//
// This program is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
// more details.
//
// You should have received a copy of the GNU General Public License along with
// this program; if not, write to the Free Software Foundation, Inc., 51
// Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA

#include ""ccache.h""
#include ""compopt.h""
#ifdef HAVE_GETOPT_LONG
#include <getopt.h>
#else
#include ""getopt_long.h""
#endif
#include ""hashtable.h""
#include ""hashtable_itr.h""
#include ""hashutil.h""
#include ""language.h""
#include ""manifest.h""

#define STRINGIFY(x) #x
#define TO_STRING(x) STRINGIFY(x)

static const char VERSION_TEXT[] =
  MYNAME "" version %s\n""
  ""\n""
  ""Copyright (C) 2002-2007 Andrew Tridgell\n""
  ""Copyright (C) 2009-2018 Joel Rosdahl\n""
  ""\n""
  ""This program is free software; you can redistribute it and/or modify it under\n""
  ""the terms of the GNU General Public License as published by the Free Software\n""
  ""Foundation; either version 3 of the License, or (at your option) any later\n""
  ""version.\n"";

static const char USAGE_TEXT[] =
  ""Usage:\n""
  ""    "" MYNAME "" [options]\n""
  ""    "" MYNAME "" compiler [compiler options]\n""
  ""    compiler [compiler options]          (via symbolic link)\n""
  ""\n""
  ""Options:\n""
  ""    -c, --cleanup         delete old files and recalculate size counters\n""
  ""                          (normally not needed as this is done automatically)\n""
  ""    -C, --clear           clear the cache completely (except configuration)\n""
  ""    -F, --max-files=N     set maximum number of files in cache to N (use 0 for\n""
  ""                          no limit)\n""
  ""    -M, --max-size=SIZE   set maximum size of cache to SIZE (use 0 for no\n""
  ""                          limit); available suffixes: k, M, G, T (decimal) and\n""
  ""                          Ki, Mi, Gi, Ti (binary); default suffix: G\n""
  ""    -o, --set-config=K=V  set configuration key K to value V\n""
  ""    -p, --print-config    print current configuration options\n""
  ""    -s, --show-stats      show statistics summary\n""
  ""    -z, --zero-stats      zero statistics counters\n""
  ""\n""
  ""    -h, --help            print this help text\n""
  ""    -V, --version         print version and copyright information\n""
  ""\n""
  ""See also <https://ccache.samba.org>.\n"";

// Global configuration data.
struct conf *conf = NULL;

// Where to write configuration changes.
char *primary_config_path = NULL;

// Secondary, read-only configuration file (if any).
char *secondary_config_path = NULL;

// Current working directory taken from $PWD, or getcwd() if $PWD is bad.
char *current_working_dir = NULL;

// The original argument list.
static struct args *orig_args;

// The source file.
static char *input_file;

// The output file being compiled to.
static char *output_obj;

// The path to the dependency file (implicit or specified with -MF).
static char *output_dep;

// The path to the coverage file (implicit when using -ftest-coverage).
static char *output_cov;

// The path to the stack usage (implicit when using -fstack-usage).
static char *output_su;

// Diagnostic generation information (clang). Contains pathname if not NULL.
static char *output_dia;

// Split dwarf information (GCC 4.8 and up). Contains pathname if not NULL.
static char *output_dwo;

// Language to use for the compilation target (see language.c).
static const char *actual_language;

// Array for storing -arch options.
#define MAX_ARCH_ARGS 10
static size_t arch_args_size = 0;
static char *arch_args[MAX_ARCH_ARGS] = {NULL};

// Name (represented as a struct file_hash) of the file containing the cached
// object code.
static struct file_hash *cached_obj_hash;

// Full path to the file containing the cached object code
// (cachedir/a/b/cdef[...]-size.o).
static char *cached_obj;

// Full path to the file containing the standard error output
// (cachedir/a/b/cdef[...]-size.stderr).
static char *cached_stderr;

// Full path to the file containing the dependency information
// (cachedir/a/b/cdef[...]-size.d).
static char *cached_dep;

// Full path to the file containing the coverage information
// (cachedir/a/b/cdef[...]-size.gcno).
static char *cached_cov;

// Full path to the file containing the stack usage
// (cachedir/a/b/cdef[...]-size.su).
static char *cached_su;

// Full path to the file containing the diagnostic information (for clang)
// (cachedir/a/b/cdef[...]-size.dia).
static char *cached_dia;

// Full path to the file containing the split dwarf (for GCC 4.8 and above)
// (cachedir/a/b/cdef[...]-size.dwo).
//
// Contains NULL if -gsplit-dwarf is not given.
static char *cached_dwo;

// Full path to the file containing the manifest
// (cachedir/a/b/cdef[...]-size.manifest).
static char *manifest_path;

// Time of compilation. Used to see if include files have changed after
// compilation.
time_t time_of_compilation;

// Files included by the preprocessor and their hashes/sizes. Key: file path.
// Value: struct file_hash.
static struct hashtable *included_files = NULL;

// Uses absolute path for some include files.
static bool has_absolute_include_headers = false;

// List of headers to ignore.
static char **ignore_headers;

// Size of headers to ignore list.
static size_t ignore_headers_len;

// Is the compiler being asked to output debug info?
static bool generating_debuginfo;

// Is the compiler being asked to output dependencies?
static bool generating_dependencies;

// Is the compiler being asked to output coverage?
static bool generating_coverage;

// Is the compiler being asked to output stack usage?
static bool generating_stackusage;

// Us the compiler being asked to generate diagnostics
// (--serialize-diagnostics)?
static bool generating_diagnostics;

// Is the compiler being asked to separate dwarf debug info into a separate
// file (-gsplit-dwarf)""?
static bool using_split_dwarf;

// Relocating debuginfo in the format old=new.
static char **debug_prefix_maps = NULL;

// Size of debug_prefix_maps list.
static size_t debug_prefix_maps_len = 0;

// Is the compiler being asked to output coverage data (.gcda) at runtime?
static bool profile_arcs;

// Name of the custom profile directory (default: object dirname).
static char *profile_dir;

// The name of the temporary preprocessed file.
static char *i_tmpfile;

// Are we compiling a .i or .ii file directly?
static bool direct_i_file;

// The name of the cpp stderr file.
static char *cpp_stderr;

// Full path to the statistics file in the subdirectory where the cached result
// belongs (<cache_dir>/<x>/stats).
char *stats_file = NULL;

// Whether the output is a precompiled header.
bool output_is_precompiled_header = false;

// Compiler guessing is currently only based on the compiler name, so nothing
// should hard-depend on it if possible.
enum guessed_compiler guessed_compiler = GUESSED_UNKNOWN;

// Profile generation / usage information.
static char *profile_dir = NULL;
static bool profile_use = false;
static bool profile_generate = false;

// Sanitize blacklist
static char *sanitize_blacklist = NULL;

// Whether we are using a precompiled header (either via -include, #include or
// clang's -include-pch or -include-pth).
static bool using_precompiled_header = false;

// The .gch/.pch/.pth file used for compilation.
static char *included_pch_file = NULL;

// How long (in microseconds) to wait before breaking a stale lock.
unsigned lock_staleness_limit = 2000000;

enum fromcache_call_mode {
	FROMCACHE_DIRECT_MODE,
	FROMCACHE_CPP_MODE
};

struct pending_tmp_file {
	char *path;
	struct pending_tmp_file *next;
};

// Temporary files to remove at program exit.
static struct pending_tmp_file *pending_tmp_files = NULL;

#ifndef _WIN32
static sigset_t fatal_signal_set;

// PID of currently executing compiler that we have started, if any. 0 means no
// ongoing compilation.
static pid_t compiler_pid = 0;
#endif

// This is a string that identifies the current ""version"" of the hash sum
// computed by ccache. If, for any reason, we want to force the hash sum to be
// different for the same input in a new ccache version, we can just change
// this string. A typical example would be if the format of one of the files
// stored in the cache changes in a backwards-incompatible way.
static const char HASH_PREFIX[] = ""3"";

static void
add_prefix(struct args *args, char *prefix_command)
{
	if (str_eq(prefix_command, """")) {
		return;
	}

	struct args *prefix = args_init(0, NULL);
	char *e = x_strdup(prefix_command);
	char *saveptr = NULL;
	for (char *tok = strtok_r(e, "" "", &saveptr);
	     tok;
	     tok = strtok_r(NULL, "" "", &saveptr)) {
		char *p;

		p = find_executable(tok, MYNAME);
		if (!p) {
			fatal(""%s: %s"", tok, strerror(errno));
		}

		args_add(prefix, p);
		free(p);
	}
	free(e);

	cc_log(""Using command-line prefix %s"", prefix_command);
	for (int i = prefix->argc; i != 0; i--) {
		args_add_prefix(args, prefix->argv[i-1]);
	}
	args_free(prefix);
}

// Something went badly wrong - just execute the real compiler.
static void
failed(void)
{
	assert(orig_args);

	args_strip(orig_args, ""--ccache-"");
	add_prefix(orig_args, conf->prefix_command);

	cc_log(""Failed; falling back to running the real compiler"");
	cc_log_argv(""Executing "", orig_args->argv);
	exitfn_call();
	execv(orig_args->argv[0], orig_args->argv);
	fatal(""execv of %s failed: %s"", orig_args->argv[0], strerror(errno));
}

static const char *
temp_dir()
{
	static char *path = NULL;
	if (path) {
		return path; // Memoize
	}
	path = conf->temporary_dir;
	if (str_eq(path, """")) {
		path = format(""%s/tmp"", conf->cache_dir);
	}
	return path;
}

void
block_signals(void)
{
#ifndef _WIN32
	sigprocmask(SIG_BLOCK, &fatal_signal_set, NULL);
#endif
}

void
unblock_signals(void)
{
#ifndef _WIN32
	sigset_t empty;
	sigemptyset(&empty);
	sigprocmask(SIG_SETMASK, &empty, NULL);
#endif
}

static void
add_pending_tmp_file(const char *path)
{
	block_signals();
	struct pending_tmp_file *e = x_malloc(sizeof(*e));
	e->path = x_strdup(path);
	e->next = pending_tmp_files;
	pending_tmp_files = e;
	unblock_signals();
}

static void
do_clean_up_pending_tmp_files(void)
{
	struct pending_tmp_file *p = pending_tmp_files;
	while (p) {
		// Can't call tmp_unlink here since its cc_log calls aren't signal safe.
		unlink(p->path);
		p = p->next;
		// Leak p->path and p here because clean_up_pending_tmp_files needs to be
		// signal safe.
	}
}

static void
clean_up_pending_tmp_files(void)
{
	block_signals();
	do_clean_up_pending_tmp_files();
	unblock_signals();
}

#ifndef _WIN32
static void
signal_handler(int signum)
{
	// Unregister handler for this signal so that we can send the signal to
	// ourselves at the end of the handler.
	signal(signum, SIG_DFL);

	// If ccache was killed explicitly, then bring the compiler subprocess (if
	// any) with us as well.
	if (signum == SIGTERM
	    && compiler_pid != 0
	    && waitpid(compiler_pid, NULL, WNOHANG) == 0) {
		kill(compiler_pid, signum);
	}

	do_clean_up_pending_tmp_files();

	if (compiler_pid != 0) {
		// Wait for compiler subprocess to exit before we snuff it.
		waitpid(compiler_pid, NULL, 0);
	}

	// Resend signal to ourselves to exit properly after returning from the
	// handler.
	kill(getpid(), signum);
}

static void
register_signal_handler(int signum)
{
	struct sigaction act;
	memset(&act, 0, sizeof(act));
	act.sa_handler = signal_handler;
	act.sa_mask = fatal_signal_set;
#ifdef SA_RESTART
	act.sa_flags = SA_RESTART;
#endif
	sigaction(signum, &act, NULL);
}

static void
set_up_signal_handlers(void)
{
	sigemptyset(&fatal_signal_set);
	sigaddset(&fatal_signal_set, SIGINT);
	sigaddset(&fatal_signal_set, SIGTERM);
#ifdef SIGHUP
	sigaddset(&fatal_signal_set, SIGHUP);
#endif
#ifdef SIGQUIT
	sigaddset(&fatal_signal_set, SIGQUIT);
#endif

	register_signal_handler(SIGINT);
	register_signal_handler(SIGTERM);
#ifdef SIGHUP
	register_signal_handler(SIGHUP);
#endif
#ifdef SIGQUIT
	register_signal_handler(SIGQUIT);
#endif
}
#endif // _WIN32

static void
clean_up_internal_tempdir(void)
{
	time_t now = time(NULL);
	struct stat st;
	if (x_stat(conf->cache_dir, &st) != 0 || st.st_mtime + 3600 >= now) {
		// No cleanup needed.
		return;
	}

	update_mtime(conf->cache_dir);

	DIR *dir = opendir(temp_dir());
	if (!dir) {
		return;
	}

	struct dirent *entry;
	while ((entry = readdir(dir))) {
		if (str_eq(entry->d_name, ""."") || str_eq(entry->d_name, "".."")) {
			continue;
		}

		char *path = format(""%s/%s"", temp_dir(), entry->d_name);
		if (x_lstat(path, &st) == 0 && st.st_mtime + 3600 < now) {
			tmp_unlink(path);
		}
		free(path);
	}

	closedir(dir);
}

static enum guessed_compiler
guess_compiler(const char *path)
{
	char *name = basename(path);
	enum guessed_compiler result = GUESSED_UNKNOWN;
	if (strstr(name, ""clang"")) {
		result = GUESSED_CLANG;
	} else if (strstr(name, ""gcc"") || strstr(name, ""g++"")) {
		result = GUESSED_GCC;
	} else if (strstr(name, ""nvcc"")) {
		result = GUESSED_NVCC;
	} else if (str_eq(name, ""pump"") || str_eq(name, ""distcc-pump"")) {
		result = GUESSED_PUMP;
	}
	free(name);
	return result;
}

static char *
get_current_working_dir(void)
{
	if (!current_working_dir) {
		char *cwd = get_cwd();
		if (cwd) {
			current_working_dir = x_realpath(cwd);
			free(cwd);
		}
		if (!current_working_dir) {
			cc_log(""Unable to determine current working directory: %s"",
			       strerror(errno));
			failed();
		}
	}
	return current_working_dir;
}

// Transform a name to a full path into the cache directory, creating needed
// sublevels if needed. Caller frees.
static char *
get_path_in_cache(const char *name, const char *suffix)
{
	char *path = x_strdup(conf->cache_dir);
	for (unsigned i = 0; i < conf->cache_dir_levels; ++i) {
		char *p = format(""%s/%c"", path, name[i]);
		free(path);
		path = p;
	}

	char *result =
	  format(""%s/%s%s"", path, name + conf->cache_dir_levels, suffix);
	free(path);
	return result;
}

// This function hashes an include file and stores the path and hash in the
// global included_files variable. If the include file is a PCH, cpp_hash is
// also updated. Takes over ownership of path.
static void
remember_include_file(char *path, struct mdfour *cpp_hash, bool system)
{
	size_t path_len = strlen(path);
	if (path_len >= 2 && (path[0] == '<' && path[path_len - 1] == '>')) {
		// Typically <built-in> or <command-line>.
		goto ignore;
	}

	if (str_eq(path, input_file)) {
		// Don't remember the input file.
		goto ignore;
	}

	if (system && (conf->sloppiness & SLOPPY_NO_SYSTEM_HEADERS)) {
		// Don't remember this system header.
		goto ignore;
	}

	if (hashtable_search(included_files, path)) {
		// Already known include file.
		goto ignore;
	}

#ifdef _WIN32
	// stat fails on directories on win32.
	DWORD attributes = GetFileAttributes(path);
	if (attributes != INVALID_FILE_ATTRIBUTES &&
	    attributes & FILE_ATTRIBUTE_DIRECTORY) {
		goto ignore;
	}
#endif

	struct stat st;
	if (x_stat(path, &st) != 0) {
		goto failure;
	}
	if (S_ISDIR(st.st_mode)) {
		// Ignore directory, typically $PWD.
		goto ignore;
	}
	if (!S_ISREG(st.st_mode)) {
		// Device, pipe, socket or other strange creature.
		cc_log(""Non-regular include file %s"", path);
		goto failure;
	}

	// Canonicalize path for comparison; clang uses ./header.h.
	char *canonical = path;
	size_t canonical_len = path_len;
	if (canonical[0] == '.' && canonical[1] == '/') {
		canonical += 2;
		canonical_len -= 2;
	}

	for (size_t i = 0; i < ignore_headers_len; i++) {
		char *ignore = ignore_headers[i];
		size_t ignore_len = strlen(ignore);
		if (ignore_len > canonical_len) {
			continue;
		}
		if (strncmp(canonical, ignore, ignore_len) == 0
		    && (ignore[ignore_len-1] == DIR_DELIM_CH
		        || canonical[ignore_len] == DIR_DELIM_CH
		        || canonical[ignore_len] == '\0')) {
			goto ignore;
		}
	}

	// The comparison using >= is intentional, due to a possible race between
	// starting compilation and writing the include file. See also the notes
	// under ""Performance"" in doc/MANUAL.adoc.
	if (!(conf->sloppiness & SLOPPY_INCLUDE_FILE_MTIME)
	    && st.st_mtime >= time_of_compilation) {
		cc_log(""Include file %s too new"", path);
		goto failure;
	}

	// The same >= logic as above applies to the change time of the file.
	if (!(conf->sloppiness & SLOPPY_INCLUDE_FILE_CTIME)
	    && st.st_ctime >= time_of_compilation) {
		cc_log(""Include file %s ctime too new"", path);
		goto failure;
	}

	// Let's hash the include file content.
	struct mdfour fhash;
	hash_start(&fhash);

	bool is_pch = is_precompiled_header(path);
	if (is_pch) {
		bool using_pch_sum = false;
		if (conf->pch_external_checksum) {
			// hash pch.sum instead of pch when it exists
			// to prevent hashing a very large .pch file every time
			char *pch_sum_path = format(""%s.sum"", path);
			if (x_stat(pch_sum_path, &st) == 0) {
				char *old_path = path;
				path = pch_sum_path;
				pch_sum_path = old_path;
				using_pch_sum = true;
				cc_log(""Using pch.sum file %s"", path);
			}
			free(pch_sum_path);
		}

		if (!hash_file(&fhash, path)) {
			goto failure;
		}
		struct file_hash pch_hash;
		hash_result_as_bytes(&fhash, pch_hash.hash);
		pch_hash.size = fhash.totalN;
		hash_delimiter(cpp_hash, using_pch_sum ? ""pch_sum_hash"" : ""pch_hash"");
		hash_buffer(cpp_hash, pch_hash.hash, sizeof(pch_hash.hash));
	}

	if (conf->direct_mode) {
		if (!is_pch) { // else: the file has already been hashed.
			char *source = NULL;
			size_t size;
			if (st.st_size > 0) {
				if (!read_file(path, st.st_size, &source, &size)) {
					goto failure;
				}
			} else {
				source = x_strdup("""");
				size = 0;
			}

			int result = hash_source_code_string(conf, &fhash, source, size, path);
			free(source);
			if (result & HASH_SOURCE_CODE_ERROR
			    || result & HASH_SOURCE_CODE_FOUND_TIME) {
				goto failure;
			}
		}

		struct file_hash *h = x_malloc(sizeof(*h));
		hash_result_as_bytes(&fhash, h->hash);
		h->size = fhash.totalN;
		hashtable_insert(included_files, path, h);
	} else {
		free(path);
	}

	return;

failure:
	if (conf->direct_mode) {
		cc_log(""Disabling direct mode"");
		conf->direct_mode = false;
	}
	// Fall through.
ignore:
	free(path);
}

// Make a relative path from current working directory to path if path is under
// the base directory. Takes over ownership of path. Caller frees.
static char *
make_relative_path(char *path)
{
	if (str_eq(conf->base_dir, """") || !str_startswith(path, conf->base_dir)) {
		return path;
	}

#ifdef _WIN32
	if (path[0] == '/') {
		path++;  // Skip leading slash.
	}
#endif

	// x_realpath only works for existing paths, so if path doesn't exist, try
	// dirname(path) and assemble the path afterwards. We only bother to try
	// canonicalizing one of these two paths since a compiler path argument
	// typically only makes sense if path or dirname(path) exists.
	char *path_suffix = NULL;
	struct stat st;
	if (stat(path, &st) != 0) {
		// path doesn't exist.
		char *dir = dirname(path);
		if (stat(dir, &st) != 0) {
			// And neither does its parent directory, so no action to take.
			free(dir);
			return path;
		}
		free(dir);
		path_suffix = basename(path);
		char *p = path;
		path = dirname(path);
		free(p);
	}

	char *canon_path = x_realpath(path);
	if (canon_path) {
		free(path);
		char *relpath = get_relative_path(get_current_working_dir(), canon_path);
		free(canon_path);
		if (path_suffix) {
			path = format(""%s/%s"", relpath, path_suffix);
			free(relpath);
			free(path_suffix);
			return path;
		} else {
			return relpath;
		}
	} else {
		// path doesn't exist, so leave it as it is.
		free(path_suffix);
		return path;
	}
}

// This function reads and hashes a file. While doing this, it also does these
// things:
//
// - Makes include file paths for which the base directory is a prefix relative
//   when computing the hash sum.
// - Stores the paths and hashes of included files in the global variable
//   included_files.
static bool
process_preprocessed_file(struct mdfour *hash, const char *path, bool pump)
{
	char *data;
	size_t size;
	if (!read_file(path, 0, &data, &size)) {
		return false;
	}

	ignore_headers = NULL;
	ignore_headers_len = 0;
	if (!str_eq(conf->ignore_headers_in_manifest, """")) {
		char *header, *p, *q, *saveptr = NULL;
		p = x_strdup(conf->ignore_headers_in_manifest);
		q = p;
		while ((header = strtok_r(q, PATH_DELIM, &saveptr))) {
			ignore_headers = x_realloc(ignore_headers,
			                           (ignore_headers_len+1) * sizeof(char *));
			ignore_headers[ignore_headers_len++] = x_strdup(header);
			q = NULL;
		}
		free(p);
	}

	if (!included_files) {
		included_files = create_hashtable(1000, hash_from_string, strings_equal);
	}

	// Bytes between p and q are pending to be hashed.
	char *p = data;
	char *q = data;
	char *end = data + size;

	// There must be at least 7 characters (# 1 ""x"") left to potentially find an
	// include file path.
	while (q < end - 7) {
		// Check if we look at a line containing the file name of an included file.
		// At least the following formats exist (where N is a positive integer):
		//
		// GCC:
		//
		//   # N ""file""
		//   # N ""file"" N
		//   #pragma GCC pch_preprocess ""file""
		//
		// HP's compiler:
		//
		//   #line N ""file""
		//
		// AIX's compiler:
		//
		//   #line N ""file""
		//   #line N
		//
		// Note that there may be other lines starting with '#' left after
		// preprocessing as well, for instance ""#    pragma"".
		if (q[0] == '#'
		    // GCC:
		    && ((q[1] == ' ' && q[2] >= '0' && q[2] <= '9')
		        // GCC precompiled header:
		        || (q[1] == 'p'
		            && str_startswith(&q[2], ""ragma GCC pch_preprocess ""))
		        // HP/AIX:
		        || (q[1] == 'l' && q[2] == 'i' && q[3] == 'n' && q[4] == 'e'
		            && q[5] == ' '))
		    && (q == data || q[-1] == '\n')) {
			// Workarounds for preprocessor linemarker bugs in GCC version 6.
			if (q[2] == '3') {
				if (str_startswith(q, ""# 31 \""<command-line>\""\n"")) {
					// Bogus extra line with #31, after the regular #1: Ignore the whole
					// line, and continue parsing.
					hash_buffer(hash, p, q - p);
					while (q < end && *q != '\n') {
						q++;
					}
					q++;
					p = q;
					continue;
				} else if (str_startswith(q, ""# 32 \""<command-line>\"" 2\n"")) {
					// Bogus wrong line with #32, instead of regular #1: Replace the line
					// number with the usual one.
					hash_buffer(hash, p, q - p);
					q += 1;
					q[0] = '#';
					q[1] = ' ';
					q[2] = '1';
					p = q;
				}
			}

			while (q < end && *q != '""' && *q != '\n') {
				q++;
			}
			if (q < end && *q == '\n') {
				// A newline before the quotation mark -> no match.
				continue;
			}
			q++;
			if (q >= end) {
				cc_log(""Failed to parse included file path"");
				free(data);
				return false;
			}
			// q points to the beginning of an include file path
			hash_buffer(hash, p, q - p);
			p = q;
			while (q < end && *q != '""') {
				q++;
			}
			// Look for preprocessor flags, after the ""filename"".
			bool system = false;
			char *r = q + 1;
			while (r < end && *r != '\n') {
				if (*r == '3') { // System header.
					system = true;
				}
				r++;
			}
			// p and q span the include file path.
			char *inc_path = x_strndup(p, q - p);
			if (!has_absolute_include_headers) {
				has_absolute_include_headers = is_absolute_path(inc_path);
			}
			inc_path = make_relative_path(inc_path);

			bool should_hash_inc_path = true;
			if (!conf->hash_dir) {
				char *cwd = gnu_getcwd();
				if (str_startswith(inc_path, cwd) && str_endswith(inc_path, ""//"")) {
					// When compiling with -g or similar, GCC adds the absolute path to
					// CWD like this:
					//
					//   # 1 ""CWD//""
					//
					// If the user has opted out of including the CWD in the hash, don't
					// hash it. See also how debug_prefix_map is handled.
					should_hash_inc_path = false;
				}
				free(cwd);
			}
			if (should_hash_inc_path) {
				hash_string(hash, inc_path);
			}

			remember_include_file(inc_path, hash, system);
			p = q; // Everything of interest between p and q has been hashed now.
		} else if (q[0] == '.' && q[1] == 'i' && q[2] == 'n' && q[3] == 'c'
		           && q[4] == 'b' && q[5] == 'i' && q[6] == 'n') {
			// An assembler .inc bin (without the space) statement, which could be
			// part of inline assembly, refers to an external file. If the file
			// changes, the hash should change as well, but finding out what file to
			// hash is too hard for ccache, so just bail out.
			cc_log(""Found unsupported .inc"" ""bin directive in source code"");
			stats_update(STATS_UNSUPPORTED_DIRECTIVE);
			failed();
		} else if (pump && strncmp(q, ""_________"", 9) == 0) {
			// Unfortunately the distcc-pump wrapper outputs standard output lines:
			// __________Using distcc-pump from /usr/bin
			// __________Using # distcc servers in pump mode
			// __________Shutting down distcc-pump include server
			while (q < end && *q != '\n') {
				q++;
			}
			if (*q == '\n') {
				q++;
			}
			p = q;
			continue;
		} else {
			q++;
		}
	}

	hash_buffer(hash, p, (end - p));
	free(data);

	// Explicitly check the .gch/.pch/.pth file, Clang does not include any
	// mention of it in the preprocessed output.
	if (included_pch_file) {
		char *path = x_strdup(included_pch_file);
		path = make_relative_path(path);
		hash_string(hash, path);
		remember_include_file(path, hash, false);
	}

	return true;
}

// Replace absolute paths with relative paths in the provided dependency file.
static void
use_relative_paths_in_depfile(const char *depfile)
{
	if (str_eq(conf->base_dir, """")) {
		cc_log(""Base dir not set, skip using relative paths"");
		return; // nothing to do
	}
	if (!has_absolute_include_headers) {
		cc_log(""No absolute path for included files found, skip using relative""
		       "" paths"");
		return; // nothing to do
	}

	FILE *f;
	f = fopen(depfile, ""r"");
	if (!f) {
		cc_log(""Cannot open dependency file: %s (%s)"", depfile, strerror(errno));
		return;
	}

	char *tmp_file = format(""%s.tmp"", depfile);
	FILE *tmpf = create_tmp_file(&tmp_file, ""w"");

	bool result = false;
	char buf[10000];
	while (fgets(buf, sizeof(buf), f) && !ferror(tmpf)) {
		char *saveptr;
		char *token = strtok_r(buf, "" \t"", &saveptr);
		while (token) {
			char *relpath;
			if (is_absolute_path(token) && str_startswith(token, conf->base_dir)) {
				relpath = make_relative_path(x_strdup(token));
				result = true;
			} else {
				relpath = token;
			}
			if (token != buf) { // This is a dependency file.
				fputc(' ', tmpf);
			}
			fputs(relpath, tmpf);
			if (relpath != token) {
				free(relpath);
			}
			token = strtok_r(NULL, "" \t"", &saveptr);
		}
	}

	if (ferror(f)) {
		cc_log(""Error reading dependency file: %s, skip relative path usage"",
		       depfile);
		result = false;
		goto out;
	}
	if (ferror(tmpf)) {
		cc_log(""Error writing temporary dependency file: %s, skip relative path""
		       "" usage"", tmp_file);
		result = false;
		goto out;
	}

out:
	fclose(tmpf);
	fclose(f);
	if (result) {
		if (x_rename(tmp_file, depfile) != 0) {
			cc_log(""Error renaming dependency file: %s -> %s (%s), skip relative""
			       "" path usage"", tmp_file, depfile, strerror(errno));
			result = false;
		} else {
			cc_log(""Renamed dependency file: %s -> %s"", tmp_file, depfile);
		}
	}
	if (!result) {
		cc_log(""Removing temporary dependency file: %s"", tmp_file);
		x_unlink(tmp_file);
	}
	free(tmp_file);
}

// Helper method for copy_file_to_cache and move_file_to_cache_same_fs.
static void
do_copy_or_move_file_to_cache(const char *source, const char *dest, bool copy)
{
	assert(!conf->read_only);
	assert(!conf->read_only_direct);

	struct stat orig_dest_st;
	bool orig_dest_existed = stat(dest, &orig_dest_st) == 0;
	int compression_level = conf->compression ? conf->compression_level : 0;
	bool do_move = !copy && !conf->compression;
	bool do_link = copy && conf->hard_link && !conf->compression;

	if (do_move) {
		move_uncompressed_file(source, dest, compression_level);
	} else {
		if (do_link) {
			x_unlink(dest);
			int ret = link(source, dest);
			if (ret == 0) {
			} else {
				cc_log(""Failed to link %s to %s: %s"", source, dest, strerror(errno));
				cc_log(""Falling back to copying"");
				do_link = false;
			}
		}
		if (!do_link) {
			int ret = copy_file(source, dest, compression_level);
			if (ret != 0) {
				cc_log(""Failed to copy %s to %s: %s"", source, dest, strerror(errno));
				stats_update(STATS_ERROR);
				failed();
			}
		}
	}

	if (!copy && conf->compression) {
		// We fell back to copying since dest should be compressed, so clean up.
		x_unlink(source);
	}

	cc_log(""Stored in cache: %s -> %s (%s)"",
	       source,
	       dest,
	       do_move ? ""moved"" : (do_link ? ""linked"" : ""copied""));

	struct stat st;
	if (x_stat(dest, &st) != 0) {
		stats_update(STATS_ERROR);
		failed();
	}
	stats_update_size(
	  file_size(&st) - (orig_dest_existed ? file_size(&orig_dest_st) : 0),
	  orig_dest_existed ? 0 : 1);
}

// Copy a file into the cache.
//
// dest must be a path in the cache (see get_path_in_cache). source does not
// have to be on the same file system as dest.
//
// An attempt will be made to hard link source to dest if conf->hard_link is
// true and conf->compression is false, otherwise copy. dest will be compressed
// if conf->compression is true.
static void
copy_file_to_cache(const char *source, const char *dest)
{
	do_copy_or_move_file_to_cache(source, dest, true);
}

// Move a file into the cache.
//
// dest must be a path in the cache (see get_path_in_cache). source must be on
// the same file system as dest. dest will be compressed if conf->compression
// is true.
static void
move_file_to_cache_same_fs(const char *source, const char *dest)
{
	do_copy_or_move_file_to_cache(source, dest, false);
}

// Copy or link a file from the cache.
static void
get_file_from_cache(const char *source, const char *dest)
{
	int ret;
	bool do_link = conf->hard_link && !file_is_compressed(source);
	if (do_link) {
		x_unlink(dest);
		ret = link(source, dest);
	} else {
		ret = copy_file(source, dest, 0);
	}

	if (ret == -1) {
		if (errno == ENOENT || errno == ESTALE) {
			cc_log(""File missing in cache: %s"", source);
			stats_update(STATS_MISSING);
		} else {
			cc_log(""Failed to %s %s to %s: %s"",
			       do_link ? ""link"" : ""copy"",
			       source,
			       dest,
			       strerror(errno));
			stats_update(STATS_ERROR);
		}

		// If there was trouble getting a file from the cached result, wipe the
		// whole cached result for consistency.
		x_unlink(cached_stderr);
		x_unlink(cached_obj);
		x_unlink(cached_dep);
		x_unlink(cached_cov);
		x_unlink(cached_su);
		x_unlink(cached_dia);
		x_unlink(cached_dwo);

		failed();
	}

	cc_log(""Created from cache: %s -> %s"", source, dest);
}

// Send cached stderr, if any, to stderr.
static void
send_cached_stderr(void)
{
	int fd_stderr = open(cached_stderr, O_RDONLY | O_BINARY);
	if (fd_stderr != -1) {
		copy_fd(fd_stderr, 2);
		close(fd_stderr);
	}
}

// Create or update the manifest file.
void update_manifest_file(void)
{
	if (!conf->direct_mode
	    || !included_files
	    || conf->read_only
	    || conf->read_only_direct) {
		return;
	}

	struct stat st;
	size_t old_size = 0; // in bytes
	if (stat(manifest_path, &st) == 0) {
		old_size = file_size(&st);
	}
	if (manifest_put(manifest_path, cached_obj_hash, included_files)) {
		cc_log(""Added object file hash to %s"", manifest_path);
		update_mtime(manifest_path);
		if (x_stat(manifest_path, &st) == 0) {
			stats_update_size(file_size(&st) - old_size, old_size == 0 ? 1 : 0);
		}
	} else {
		cc_log(""Failed to add object file hash to %s"", manifest_path);
	}
}

// Run the real compiler and put the result in cache.
static void
to_cache(struct args *args)
{
	char *tmp_stdout = format(""%s.tmp.stdout"", cached_obj);
	int tmp_stdout_fd = create_tmp_fd(&tmp_stdout);
	char *tmp_stderr = format(""%s.tmp.stderr"", cached_obj);
	int tmp_stderr_fd = create_tmp_fd(&tmp_stderr);

	args_add(args, ""-o"");
	args_add(args, output_obj);

	if (generating_diagnostics) {
		args_add(args, ""--serialize-diagnostics"");
		args_add(args, output_dia);
	}

	// Turn off DEPENDENCIES_OUTPUT when running cc1, because otherwise it will
	// emit a line like this:
	//
	//   tmp.stdout.vexed.732.o: /home/mbp/.ccache/tmp.stdout.vexed.732.i
	x_unsetenv(""DEPENDENCIES_OUTPUT"");

	if (conf->run_second_cpp) {
		args_add(args, input_file);
	} else {
		args_add(args, i_tmpfile);
	}

	cc_log(""Running real compiler"");
	int status =
	  execute(args->argv, tmp_stdout_fd, tmp_stderr_fd, &compiler_pid);
	args_pop(args, 3);

	struct stat st;
	if (x_stat(tmp_stdout, &st) != 0) {
		// The stdout file was removed - cleanup in progress? Better bail out.
		stats_update(STATS_MISSING);
		tmp_unlink(tmp_stdout);
		tmp_unlink(tmp_stderr);
		failed();
	}

	// distcc-pump outputs lines like this:
	// __________Using # distcc servers in pump mode
	if (st.st_size != 0 && guessed_compiler != GUESSED_PUMP) {
		cc_log(""Compiler produced stdout"");
		stats_update(STATS_STDOUT);
		tmp_unlink(tmp_stdout);
		tmp_unlink(tmp_stderr);
		failed();
	}
	tmp_unlink(tmp_stdout);

	// Merge stderr from the preprocessor (if any) and stderr from the real
	// compiler into tmp_stderr.
	if (cpp_stderr) {
		char *tmp_stderr2 = format(""%s.2"", tmp_stderr);
		if (x_rename(tmp_stderr, tmp_stderr2)) {
			cc_log(""Failed to rename %s to %s: %s"", tmp_stderr, tmp_stderr2,
			       strerror(errno));
			failed();
		}

		int fd_cpp_stderr = open(cpp_stderr, O_RDONLY | O_BINARY);
		if (fd_cpp_stderr == -1) {
			cc_log(""Failed opening %s: %s"", cpp_stderr, strerror(errno));
			failed();
		}

		int fd_real_stderr = open(tmp_stderr2, O_RDONLY | O_BINARY);
		if (fd_real_stderr == -1) {
			cc_log(""Failed opening %s: %s"", tmp_stderr2, strerror(errno));
			failed();
		}

		int fd_result =
		  open(tmp_stderr, O_WRONLY | O_CREAT | O_TRUNC | O_BINARY, 0666);
		if (fd_result == -1) {
			cc_log(""Failed opening %s: %s"", tmp_stderr, strerror(errno));
			failed();
		}

		copy_fd(fd_cpp_stderr, fd_result);
		copy_fd(fd_real_stderr, fd_result);
		close(fd_cpp_stderr);
		close(fd_real_stderr);
		close(fd_result);
		tmp_unlink(tmp_stderr2);
		free(tmp_stderr2);
	}

	if (status != 0) {
		cc_log(""Compiler gave exit status %d"", status);
		stats_update(STATS_STATUS);

		int fd = open(tmp_stderr, O_RDONLY | O_BINARY);
		if (fd != -1) {
			// We can output stderr immediately instead of rerunning the compiler.
			copy_fd(fd, 2);
			close(fd);
			tmp_unlink(tmp_stderr);

			x_exit(status);
		}

		tmp_unlink(tmp_stderr);
		failed();
	}

	if (stat(output_obj, &st) != 0) {
		cc_log(""Compiler didn't produce an object file"");
		stats_update(STATS_NOOUTPUT);
		failed();
	}
	if (st.st_size == 0) {
		cc_log(""Compiler produced an empty object file"");
		stats_update(STATS_EMPTYOUTPUT);
		failed();
	}

	if (x_stat(tmp_stderr, &st) != 0) {
		stats_update(STATS_ERROR);
		failed();
	}
	if (st.st_size > 0) {
		move_file_to_cache_same_fs(tmp_stderr, cached_stderr);
	} else {
		tmp_unlink(tmp_stderr);
		if (conf->recache) {
			// If recaching, we need to remove any previous .stderr.
			x_unlink(cached_stderr);
		}
	}

	copy_file_to_cache(output_obj, cached_obj);
	if (generating_dependencies) {
		use_relative_paths_in_depfile(output_dep);
		copy_file_to_cache(output_dep, cached_dep);
	}
	if (generating_coverage) {
		copy_file_to_cache(output_cov, cached_cov);
	}
	if (generating_stackusage) {
		copy_file_to_cache(output_su, cached_su);
	}
	if (generating_diagnostics) {
		copy_file_to_cache(output_dia, cached_dia);
	}
	if (using_split_dwarf) {
		copy_file_to_cache(output_dwo, cached_dwo);
	}

	stats_update(STATS_TOCACHE);

	// Make sure we have a CACHEDIR.TAG in the cache part of cache_dir. This can
	// be done almost anywhere, but we might as well do it near the end as we
	// save the stat call if we exit early.
	{
		char *first_level_dir = dirname(stats_file);
		if (create_cachedirtag(first_level_dir) != 0) {
			cc_log(""Failed to create %s/CACHEDIR.TAG (%s)\n"",
			       first_level_dir, strerror(errno));
			stats_update(STATS_ERROR);
			failed();
		}
		free(first_level_dir);

		// Remove any CACHEDIR.TAG on the cache_dir level where it was located in
		// previous ccache versions.
		if (getpid() % 1000 == 0) {
			char *path = format(""%s/CACHEDIR.TAG"", conf->cache_dir);
			x_unlink(path);
			free(path);
		}
	}

	// Everything OK.
	send_cached_stderr();
	update_manifest_file();

	free(tmp_stderr);
	free(tmp_stdout);
}

// Find the object file name by running the compiler in preprocessor mode.
// Returns the hash as a heap-allocated hex string.
static struct file_hash *
get_object_name_from_cpp(struct args *args, struct mdfour *hash)
{
	time_of_compilation = time(NULL);

	char *path_stderr = NULL;
	char *path_stdout;
	int status;
	if (direct_i_file) {
		// We are compiling a .i or .ii file - that means we can skip the cpp stage
		// and directly form the correct i_tmpfile.
		path_stdout = input_file;
		status = 0;
	} else {
		// Run cpp on the input file to obtain the .i.

		// Limit the basename to 10 characters in order to cope with filesystem with
		// small maximum filename length limits.
		char *input_base = basename(input_file);
		char *tmp = strchr(input_base, '.');
		if (tmp) {
			*tmp = 0;
		}
		if (strlen(input_base) > 10) {
			input_base[10] = 0;
		}

		path_stdout = format(""%s/%s.stdout"", temp_dir(), input_base);
		int path_stdout_fd = create_tmp_fd(&path_stdout);
		add_pending_tmp_file(path_stdout);

		path_stderr = format(""%s/tmp.cpp_stderr"", temp_dir());
		int path_stderr_fd = create_tmp_fd(&path_stderr);
		add_pending_tmp_file(path_stderr);

		int args_added = 2;
		args_add(args, ""-E"");
		if (conf->keep_comments_cpp) {
			args_add(args, ""-C"");
			args_added = 3;
		}
		args_add(args, input_file);
		add_prefix(args, conf->prefix_command_cpp);
		cc_log(""Running preprocessor"");
		status = execute(args->argv, path_stdout_fd, path_stderr_fd, &compiler_pid);
		args_pop(args, args_added);
	}

	if (status != 0) {
		cc_log(""Preprocessor gave exit status %d"", status);
		stats_update(STATS_PREPROCESSOR);
		failed();
	}

	if (conf->unify) {
		// When we are doing the unifying tricks we need to include the input file
		// name in the hash to get the warnings right.
		hash_delimiter(hash, ""unifyfilename"");
		hash_string(hash, input_file);

		hash_delimiter(hash, ""unifycpp"");

		bool debug_unify = getenv(""CCACHE_DEBUG_UNIFY"");
		if (unify_hash(hash, path_stdout, debug_unify) != 0) {
			stats_update(STATS_ERROR);
			cc_log(""Failed to unify %s"", path_stdout);
			failed();
		}
	} else {
		hash_delimiter(hash, ""cpp"");
		if (!process_preprocessed_file(hash, path_stdout,
		                               guessed_compiler == GUESSED_PUMP)) {
			stats_update(STATS_ERROR);
			failed();
		}
	}

	hash_delimiter(hash, ""cppstderr"");
	if (!direct_i_file && !hash_file(hash, path_stderr)) {
		fatal(""Failed to open %s: %s"", path_stderr, strerror(errno));
	}

	if (direct_i_file) {
		i_tmpfile = input_file;
	} else {
		// i_tmpfile needs the proper cpp_extension for the compiler to do its
		// thing correctly
		i_tmpfile = format(""%s.%s"", path_stdout, conf->cpp_extension);
		x_rename(path_stdout, i_tmpfile);
		add_pending_tmp_file(i_tmpfile);
	}

	if (conf->run_second_cpp) {
		free(path_stderr);
	} else {
		// If we are using the CPP trick, we need to remember this stderr data and
		// output it just before the main stderr from the compiler pass.
		cpp_stderr = path_stderr;
		hash_delimiter(hash, ""runsecondcpp"");
		hash_string(hash, ""false"");
	}

	struct file_hash *result = x_malloc(sizeof(*result));
	hash_result_as_bytes(hash, result->hash);
	result->size = hash->totalN;
	return result;
}

static void
update_cached_result_globals(struct file_hash *hash)
{
	char *object_name = format_hash_as_string(hash->hash, hash->size);
	cached_obj_hash = hash;
	cached_obj = get_path_in_cache(object_name, "".o"");
	cached_stderr = get_path_in_cache(object_name, "".stderr"");
	cached_dep = get_path_in_cache(object_name, "".d"");
	cached_cov = get_path_in_cache(object_name, "".gcno"");
	cached_su = get_path_in_cache(object_name, "".su"");
	cached_dia = get_path_in_cache(object_name, "".dia"");
	cached_dwo = get_path_in_cache(object_name, "".dwo"");

	stats_file = format(""%s/%c/stats"", conf->cache_dir, object_name[0]);
	free(object_name);
}

// Hash mtime or content of a file, or the output of a command, according to
// the CCACHE_COMPILERCHECK setting.
static void
hash_compiler(struct mdfour *hash, struct stat *st, const char *path,
              bool allow_command)
{
	if (str_eq(conf->compiler_check, ""none"")) {
		// Do nothing.
	} else if (str_eq(conf->compiler_check, ""mtime"")) {
		hash_delimiter(hash, ""cc_mtime"");
		hash_int(hash, st->st_size);
		hash_int(hash, st->st_mtime);
	} else if (str_startswith(conf->compiler_check, ""string:"")) {
		hash_delimiter(hash, ""cc_hash"");
		hash_string(hash, conf->compiler_check + strlen(""string:""));
	} else if (str_eq(conf->compiler_check, ""content"") || !allow_command) {
		hash_delimiter(hash, ""cc_content"");
		hash_file(hash, path);
	} else { // command string
		if (!hash_multicommand_output(
		      hash, conf->compiler_check, orig_args->argv[0])) {
			fatal(""Failure running compiler check command: %s"", conf->compiler_check);
		}
	}
}

// Hash the host compiler(s) invoked by nvcc.
//
// If ccbin_st and ccbin are set, they refer to a directory or compiler set
// with -ccbin/--compiler-bindir. If they are NULL, the compilers are looked up
// in PATH instead.
static void
hash_nvcc_host_compiler(struct mdfour *hash, struct stat *ccbin_st,
                        const char *ccbin)
{
	// From <http://docs.nvidia.com/cuda/cuda-compiler-driver-nvcc/index.html>:
	//
	//   ""[...] Specify the directory in which the compiler executable resides.
	//   The host compiler executable name can be also specified to ensure that
	//   the correct host compiler is selected.""
	//
	// and
	//
	//   ""On all platforms, the default host compiler executable (gcc and g++ on
	//   Linux, clang and clang++ on Mac OS X, and cl.exe on Windows) found in
	//   the current execution search path will be used"".

	if (!ccbin || S_ISDIR(ccbin_st->st_mode)) {
#if defined(__APPLE__)
		const char *compilers[] = {""clang"", ""clang++""};
#elif defined(_WIN32)
		const char *compilers[] = {""cl.exe""};
#else
		const char *compilers[] = {""gcc"", ""g++""};
#endif
		for (size_t i = 0; i < ARRAY_SIZE(compilers); i++) {
			if (ccbin) {
				char *path = format(""%s/%s"", ccbin, compilers[i]);
				struct stat st;
				if (stat(path, &st) == 0) {
					hash_compiler(hash, &st, path, false);
				}
				free(path);
			} else {
				char *path = find_executable(compilers[i], MYNAME);
				if (path) {
					struct stat st;
					x_stat(path, &st);
					hash_compiler(hash, &st, ccbin, false);
					free(path);
				}
			}
		}
	} else {
		hash_compiler(hash, ccbin_st, ccbin, false);
	}
}

// Update a hash sum with information common for the direct and preprocessor
// modes.
static void
calculate_common_hash(struct args *args, struct mdfour *hash)
{
	hash_string(hash, HASH_PREFIX);

	// We have to hash the extension, as a .i file isn't treated the same by the
	// compiler as a .ii file.
	hash_delimiter(hash, ""ext"");
	hash_string(hash, conf->cpp_extension);

#ifdef _WIN32
	const char *ext = strrchr(args->argv[0], '.');
	char full_path_win_ext[MAX_PATH + 1] = {0};
	add_exe_ext_if_no_to_fullpath(full_path_win_ext, MAX_PATH, ext,
	                              args->argv[0]);
	const char *full_path = full_path_win_ext;
#else
	const char *full_path = args->argv[0];
#endif

	struct stat st;
	if (x_stat(full_path, &st) != 0) {
		stats_update(STATS_COMPILER);
		failed();
	}

	// Hash information about the compiler.
	hash_compiler(hash, &st, args->argv[0], true);

	// Also hash the compiler name as some compilers use hard links and behave
	// differently depending on the real name.
	hash_delimiter(hash, ""cc_name"");
	char *p = basename(args->argv[0]);
	hash_string(hash, p);
	free(p);

	// Possibly hash the current working directory.
	if (generating_debuginfo && conf->hash_dir) {
		char *cwd = gnu_getcwd();
		for (size_t i = 0; i < debug_prefix_maps_len; i++) {
			char *map = debug_prefix_maps[i];
			char *sep = strchr(map, '=');
			if (sep) {
				char *old = x_strndup(map, sep - map);
				char *new = x_strdup(sep + 1);
				cc_log(""Relocating debuginfo CWD %s from %s to %s"", cwd, old, new);
				if (str_startswith(cwd, old)) {
					char *dir = format(""%s%s"", new, cwd + strlen(old));
					free(cwd);
					cwd = dir;
				}
				free(old);
				free(new);
			}
		}
		if (cwd) {
			cc_log(""Hashing CWD %s"", cwd);
			hash_delimiter(hash, ""cwd"");
			hash_string(hash, cwd);
			free(cwd);
		}
	}

	// Possibly hash the coverage data file path.
	if (generating_coverage && profile_arcs) {
		char *dir = dirname(output_obj);
		if (profile_dir) {
			dir = x_strdup(profile_dir);
		} else {
			char *real_dir = x_realpath(dir);
			free(dir);
			dir = real_dir;
		}
		if (dir) {
			char *base_name = basename(output_obj);
			p = remove_extension(base_name);
			free(base_name);
			char *gcda_path = format(""%s/%s.gcda"", dir, p);
			cc_log(""Hashing coverage path %s"", gcda_path);
			free(p);
			hash_delimiter(hash, ""gcda"");
			hash_string(hash, gcda_path);
			free(dir);
		}
	}

	// Possibly hash the sanitize blacklist file path.
	if (sanitize_blacklist) {
		cc_log(""Hashing sanitize blacklist %s"", sanitize_blacklist);
		hash_delimiter(hash, ""sanitizeblacklist"");
		if (!hash_file(hash, sanitize_blacklist)) {
			stats_update(STATS_BADEXTRAFILE);
			failed();
		}
	}

	if (!str_eq(conf->extra_files_to_hash, """")) {
		char *p = x_strdup(conf->extra_files_to_hash);
		char *q = p;
		char *path;
		char *saveptr = NULL;
		while ((path = strtok_r(q, PATH_DELIM, &saveptr))) {
			cc_log(""Hashing extra file %s"", path);
			hash_delimiter(hash, ""extrafile"");
			if (!hash_file(hash, path)) {
				stats_update(STATS_BADEXTRAFILE);
				failed();
			}
			q = NULL;
		}
		free(p);
	}

	// Possibly hash GCC_COLORS (for color diagnostics).
	if (guessed_compiler == GUESSED_GCC) {
		const char *gcc_colors = getenv(""GCC_COLORS"");
		if (gcc_colors) {
			hash_delimiter(hash, ""gcccolors"");
			hash_string(hash, gcc_colors);
		}
	}
}

// Update a hash sum with information specific to the direct and preprocessor
// modes and calculate the object hash. Returns the object hash on success,
// otherwise NULL. Caller frees.
static struct file_hash *
calculate_object_hash(struct args *args, struct mdfour *hash, int direct_mode)
{
	bool found_ccbin = false;

	if (direct_mode) {
		hash_delimiter(hash, ""manifest version"");
		hash_int(hash, MANIFEST_VERSION);
	}

	// clang will emit warnings for unused linker flags, so we shouldn't skip
	// those arguments.
	int is_clang = (guessed_compiler == GUESSED_CLANG || guessed_compiler == GUESSED_UNKNOWN);

	// First the arguments.
	for (int i = 1; i < args->argc; i++) {
		// -L doesn't affect compilation (except for clang).
		if (i < args->argc-1 && str_eq(args->argv[i], ""-L"") && !is_clang) {
			i++;
			continue;
		}
		if (str_startswith(args->argv[i], ""-L"") && !is_clang) {
			continue;
		}

		// -Wl,... doesn't affect compilation (except for clang).
		if (str_startswith(args->argv[i], ""-Wl,"") && !is_clang) {
			continue;
		}

		// The -fdebug-prefix-map option may be used in combination with
		// CCACHE_BASEDIR to reuse results across different directories. Skip it
		// from hashing.
		if (str_startswith(args->argv[i], ""-fdebug-prefix-map="")) {
			continue;
		}

		// When using the preprocessor, some arguments don't contribute to the
		// hash. The theory is that these arguments will change the output of -E if
		// they are going to have any effect at all. For precompiled headers this
		// might not be the case.
		if (!direct_mode && !output_is_precompiled_header
		    && !using_precompiled_header) {
			if (compopt_affects_cpp(args->argv[i])) {
				if (compopt_takes_arg(args->argv[i])) {
					i++;
				}
				continue;
			}
			if (compopt_short(compopt_affects_cpp, args->argv[i])) {
				continue;
			}
		}

		// If we're generating dependencies, we make sure to skip the filename of
		// the dependency file, since it doesn't impact the output.
		if (generating_dependencies) {
			if (str_startswith(args->argv[i], ""-Wp,"")) {
				if (str_startswith(args->argv[i], ""-Wp,-MD,"")
				    && !strchr(args->argv[i] + 8, ',')) {
					hash_string_length(hash, args->argv[i], 8);
					continue;
				} else if (str_startswith(args->argv[i], ""-Wp,-MMD,"")
				           && !strchr(args->argv[i] + 9, ',')) {
					hash_string_length(hash, args->argv[i], 9);
					continue;
				}
			} else if (str_startswith(args->argv[i], ""-MF"")) {
				// In either case, hash the ""-MF"" part.
				hash_delimiter(hash, ""arg"");
				hash_string_length(hash, args->argv[i], 3);

				bool separate_argument = (strlen(args->argv[i]) == 3);
				if (separate_argument) {
					// Next argument is dependency name, so skip it.
					i++;
				}
				continue;
			}
		}

		char *p = NULL;
		if (str_startswith(args->argv[i], ""-specs="")) {
			p = args->argv[i] + 7;
		} else if (str_startswith(args->argv[i], ""--specs="")) {
			p = args->argv[i] + 8;
		}

		struct stat st;
		if (p && x_stat(p, &st) == 0) {
			// If given an explicit specs file, then hash that file, but don't
			// include the path to it in the hash.
			hash_delimiter(hash, ""specs"");
			hash_compiler(hash, &st, p, false);
			continue;
		}

		if (str_startswith(args->argv[i], ""-fplugin="")
		    && x_stat(args->argv[i] + 9, &st) == 0) {
			hash_delimiter(hash, ""plugin"");
			hash_compiler(hash, &st, args->argv[i] + 9, false);
			continue;
		}

		if (str_eq(args->argv[i], ""-Xclang"")
		    && i + 3 < args->argc
		    && str_eq(args->argv[i+1], ""-load"")
		    && str_eq(args->argv[i+2], ""-Xclang"")
		    && x_stat(args->argv[i+3], &st) == 0) {
			hash_delimiter(hash, ""plugin"");
			hash_compiler(hash, &st, args->argv[i+3], false);
			i += 3;
			continue;
		}

		if ((str_eq(args->argv[i], ""-ccbin"")
		     || str_eq(args->argv[i], ""--compiler-bindir""))
		    && i + 1 < args->argc
		    && x_stat(args->argv[i+1], &st) == 0) {
			found_ccbin = true;
			hash_delimiter(hash, ""ccbin"");
			hash_nvcc_host_compiler(hash, &st, args->argv[i+1]);
			i++;
			continue;
		}

		// All other arguments are included in the hash.
		hash_delimiter(hash, ""arg"");
		hash_string(hash, args->argv[i]);
		if (i + 1 < args->argc && compopt_takes_arg(args->argv[i])) {
			i++;
			hash_delimiter(hash, ""arg"");
			hash_string(hash, args->argv[i]);
		}
	}

	if (!found_ccbin && str_eq(actual_language, ""cuda"")) {
		hash_nvcc_host_compiler(hash, NULL, NULL);
	}

	// For profile generation (-fprofile-arcs, -fprofile-generate):
	// - hash profile directory
	//
	// For profile usage (-fprofile-use):
	// - hash profile data
	//
	// -fbranch-probabilities and -fvpt usage is covered by
	// -fprofile-generate/-fprofile-use.
	//
	// The profile directory can be specified as an argument to
	// -fprofile-generate=, -fprofile-use= or -fprofile-dir=.
	if (profile_generate) {
		if (!profile_dir) {
			profile_dir = get_cwd();
		}
		cc_log(""Adding profile directory %s to our hash"", profile_dir);
		hash_delimiter(hash, ""-fprofile-dir"");
		hash_string(hash, profile_dir);
	}

	if (profile_use) {
		// Calculate gcda name.
		if (!profile_dir) {
			profile_dir = get_cwd();
		}
		char *base_name = remove_extension(output_obj);
		char *gcda_name = format(""%s/%s.gcda"", profile_dir, base_name);
		cc_log(""Adding profile data %s to our hash"", gcda_name);
		// Add the gcda to our hash.
		hash_delimiter(hash, ""-fprofile-use"");
		hash_file(hash, gcda_name);
		free(base_name);
		free(gcda_name);
	}

	// Adding -arch to hash since cpp output is affected.
	for (size_t i = 0; i < arch_args_size; ++i) {
		hash_delimiter(hash, ""-arch"");
		hash_string(hash, arch_args[i]);
	}

	struct file_hash *object_hash = NULL;
	if (direct_mode) {
		// Hash environment variables that affect the preprocessor output.
		const char *envvars[] = {
			""CPATH"",
			""C_INCLUDE_PATH"",
			""CPLUS_INCLUDE_PATH"",
			""OBJC_INCLUDE_PATH"",
			""OBJCPLUS_INCLUDE_PATH"", // clang
			NULL
		};
		for (const char **p = envvars; *p; ++p) {
			char *v = getenv(*p);
			if (v) {
				hash_delimiter(hash, *p);
				hash_string(hash, v);
			}
		}

		if (!(conf->sloppiness & SLOPPY_FILE_MACRO)) {
			// The source code file or an include file may contain __FILE__, so make
			// sure that the hash is unique for the file name.
			hash_delimiter(hash, ""inputfile"");
			hash_string(hash, input_file);
		}

		hash_delimiter(hash, ""sourcecode"");
		int result = hash_source_code_file(conf, hash, input_file);
		if (result & HASH_SOURCE_CODE_ERROR) {
			failed();
		}
		if (result & HASH_SOURCE_CODE_FOUND_TIME) {
			cc_log(""Disabling direct mode"");
			conf->direct_mode = false;
			return NULL;
		}
		char *manifest_name = hash_result(hash);
		manifest_path = get_path_in_cache(manifest_name, "".manifest"");
		free(manifest_name);
		cc_log(""Looking for object file hash in %s"", manifest_path);
		object_hash = manifest_get(conf, manifest_path);
		if (object_hash) {
			cc_log(""Got object file hash from manifest"");
		} else {
			cc_log(""Did not find object file hash in manifest"");
		}
	} else {
		if (arch_args_size == 0) {
			object_hash = get_object_name_from_cpp(args, hash);
			cc_log(""Got object file hash from preprocessor"");
		} else {
			args_add(args, ""-arch"");
			for (size_t i = 0; i < arch_args_size; ++i) {
				args_add(args, arch_args[i]);
				object_hash = get_object_name_from_cpp(args, hash);
				cc_log(""Got object file hash from preprocessor with -arch %s"",
				       arch_args[i]);
				if (i != arch_args_size - 1) {
					free(object_hash);
					object_hash = NULL;
				}
				args_pop(args, 1);
			}
			args_pop(args, 1);
		}
		if (generating_dependencies) {
			cc_log(""Preprocessor created %s"", output_dep);
		}
	}

	return object_hash;
}

// Try to return the compile result from cache. If we can return from cache
// then this function exits with the correct status code, otherwise it returns.
static void
from_cache(enum fromcache_call_mode mode, bool put_object_in_manifest)
{
	// The user might be disabling cache hits.
	if (conf->recache) {
		return;
	}

	// If we're using Clang, we can't trust a precompiled header object based on
	// running the preprocessor since clang will produce a fatal error when the
	// precompiled header is used and one of the included files has an updated
	// timestamp:
	//
	//     file 'foo.h' has been modified since the precompiled header 'foo.pch'
	//     was built
	if ((guessed_compiler == GUESSED_CLANG || guessed_compiler == GUESSED_UNKNOWN)
	    && output_is_precompiled_header
	    && mode == FROMCACHE_CPP_MODE) {
		cc_log(""Not considering cached precompiled header in preprocessor mode"");
		return;
	}

	// Occasionally, e.g. on hard reset, our cache ends up as just filesystem
	// meta-data with no content. Catch an easy case of this.
	struct stat st;
	if (stat(cached_obj, &st) != 0) {
		cc_log(""Object file %s not in cache"", cached_obj);
		return;
	}
	if (st.st_size == 0) {
		cc_log(""Invalid (empty) object file %s in cache"", cached_obj);
		x_unlink(cached_obj);
		return;
	}

	// (If mode != FROMCACHE_DIRECT_MODE, the dependency file is created by gcc.)
	bool produce_dep_file =
	  generating_dependencies && mode == FROMCACHE_DIRECT_MODE;

	// Get result from cache.
	if (!str_eq(output_obj, ""/dev/null"")) {
		get_file_from_cache(cached_obj, output_obj);
		if (using_split_dwarf) {
			get_file_from_cache(cached_dwo, output_dwo);
		}
	}
	if (produce_dep_file) {
		get_file_from_cache(cached_dep, output_dep);
	}
	if (generating_coverage) {
		get_file_from_cache(cached_cov, output_cov);
	}
	if (generating_stackusage) {
		get_file_from_cache(cached_su, output_su);
	}
	if (generating_diagnostics) {
		get_file_from_cache(cached_dia, output_dia);
	}

	// Update modification timestamps to save files from LRU cleanup. Also gives
	// files a sensible mtime when hard-linking.
	update_mtime(cached_obj);
	update_mtime(cached_stderr);
	if (produce_dep_file) {
		update_mtime(cached_dep);
	}
	if (generating_coverage) {
		update_mtime(cached_cov);
	}
	if (generating_stackusage) {
		update_mtime(cached_su);
	}
	if (generating_diagnostics) {
		update_mtime(cached_dia);
	}
	if (cached_dwo) {
		update_mtime(cached_dwo);
	}

	send_cached_stderr();

	if (put_object_in_manifest) {
		update_manifest_file();
	}

	// Log the cache hit.
	switch (mode) {
	case FROMCACHE_DIRECT_MODE:
		cc_log(""Succeeded getting cached result"");
		stats_update(STATS_CACHEHIT_DIR);
		break;

	case FROMCACHE_CPP_MODE:
		cc_log(""Succeeded getting cached result"");
		stats_update(STATS_CACHEHIT_CPP);
		break;
	}

	// And exit with the right status code.
	x_exit(0);
}

// Find the real compiler. We just search the PATH to find an executable of the
// same name that isn't a link to ourselves.
static void
find_compiler(char **argv)
{
	// We might be being invoked like ""ccache gcc -c foo.c"".
	char *base = basename(argv[0]);
	if (same_executable_name(base, MYNAME)) {
		args_remove_first(orig_args);
		free(base);
		if (is_full_path(orig_args->argv[0])) {
			// A full path was given.
			return;
		}
		base = basename(orig_args->argv[0]);
	}

	// Support user override of the compiler.
	if (!str_eq(conf->compiler, """")) {
		base = conf->compiler;
	}

	char *compiler = find_executable(base, MYNAME);
	if (!compiler) {
		stats_update(STATS_COMPILER);
		fatal(""Could not find compiler \""%s\"" in PATH"", base);
	}
	if (str_eq(compiler, argv[0])) {
		fatal(""Recursive invocation (the name of the ccache binary must be \""%s\"")"",
		      MYNAME);
	}
	orig_args->argv[0] = compiler;
}

bool
is_precompiled_header(const char *path)
{
	const char *ext = get_extension(path);
	char *dir = dirname(path);
	const char *dir_ext = get_extension(dir);
	bool result =
		str_eq(ext, "".gch"")
		|| str_eq(ext, "".pch"")
		|| str_eq(ext, "".pth"")
		|| str_eq(dir_ext, "".gch""); // See ""Precompiled Headers"" in GCC docs.
	free(dir);
	return result;
}

static bool
color_output_possible(void)
{
	const char *term_env = getenv(""TERM"");
	return isatty(STDERR_FILENO) && term_env && strcasecmp(term_env, ""DUMB"") != 0;
}

static bool
detect_pch(const char *option, const char *arg, bool *found_pch)
{
	struct stat st;

	// Try to be smart about detecting precompiled headers.
	char *pch_file = NULL;
	if (str_eq(option, ""-include-pch"") || str_eq(option, ""-include-pth"")) {
		if (stat(arg, &st) == 0) {
			cc_log(""Detected use of precompiled header: %s"", arg);
			pch_file = x_strdup(arg);
		}
	} else {
		char *gchpath = format(""%s.gch"", arg);
		if (stat(gchpath, &st) == 0) {
			cc_log(""Detected use of precompiled header: %s"", gchpath);
			pch_file = x_strdup(gchpath);
		} else {
			char *pchpath = format(""%s.pch"", arg);
			if (stat(pchpath, &st) == 0) {
				cc_log(""Detected use of precompiled header: %s"", pchpath);
				pch_file = x_strdup(pchpath);
			} else {
				// clang may use pretokenized headers.
				char *pthpath = format(""%s.pth"", arg);
				if (stat(pthpath, &st) == 0) {
					cc_log(""Detected use of pretokenized header: %s"", pthpath);
					pch_file = x_strdup(pthpath);
				}
				free(pthpath);
			}
			free(pchpath);
		}
		free(gchpath);
	}

	if (pch_file) {
		if (included_pch_file) {
			cc_log(""Multiple precompiled headers used: %s and %s\n"",
			       included_pch_file, pch_file);
			stats_update(STATS_ARGS);
			return false;
		}
		included_pch_file = pch_file;
		*found_pch = true;
	}
	return true;
}

// Process the compiler options into options suitable for passing to the
// preprocessor and the real compiler. The preprocessor options don't include
// -E; this is added later. Returns true on success, otherwise false.
bool
cc_process_args(struct args *args, struct args **preprocessor_args,
                struct args **compiler_args)
{
	bool found_c_opt = false;
	bool found_S_opt = false;
	bool found_pch = false;
	bool found_fpch_preprocess = false;
	const char *explicit_language = NULL; // As specified with -x.
	const char *file_language;            // As deduced from file extension.
	const char *input_charset = NULL;
	// Is the dependency makefile name overridden with -MF?
	bool dependency_filename_specified = false;
	// Is the dependency makefile target name specified with -MT or -MQ?
	bool dependency_target_specified = false;
	// expanded_args is a copy of the original arguments given to the compiler
	// but with arguments from @file and similar constructs expanded. It's only
	// used as a temporary data structure to loop over.
	struct args *expanded_args = args_copy(args);
	// stripped_args essentially contains all original arguments except those
	// that only should be passed to the preprocessor (if run_second_cpp is
	// false) and except dependency options (like -MD and friends).
	struct args *stripped_args = args_init(0, NULL);
	// cpp_args contains arguments that were not added to stripped_args, i.e.
	// those that should only be passed to the preprocessor if run_second_cpp is
	// false. If run_second_cpp is true, they will be passed to the compiler as
	// well.
	struct args *cpp_args = args_init(0, NULL);
	// dep_args contains dependency options like -MD. They only passed to the
	// preprocessor, never to the compiler.
	struct args *dep_args = args_init(0, NULL);

	bool found_color_diagnostics = false;

	bool found_directives_only = false;
	bool found_rewrite_includes = false;

	int argc = expanded_args->argc;
	char **argv = expanded_args->argv;
	args_add(stripped_args, argv[0]);

	bool result = true;
	for (int i = 1; i < argc; i++) {
		// The user knows best: just swallow the next arg.
		if (str_eq(argv[i], ""--ccache-skip"")) {
			i++;
			if (i == argc) {
				cc_log(""--ccache-skip lacks an argument"");
				result = false;
				goto out;
			}
			args_add(stripped_args, argv[i]);
			continue;
		}

		// Special case for -E.
		if (str_eq(argv[i], ""-E"")) {
			stats_update(STATS_PREPROCESSING);
			result = false;
			goto out;
		}

		// Handle ""@file"" argument.
		if (str_startswith(argv[i], ""@"") || str_startswith(argv[i], ""-@"")) {
			char *argpath = argv[i] + 1;

			if (argpath[-1] == '-') {
				++argpath;
			}
			struct args *file_args = args_init_from_gcc_atfile(argpath);
			if (!file_args) {
				cc_log(""Couldn't read arg file %s"", argpath);
				stats_update(STATS_ARGS);
				result = false;
				goto out;
			}

			args_insert(expanded_args, i, file_args, true);
			argc = expanded_args->argc;
			argv = expanded_args->argv;
			i--;
			continue;
		}

		// Handle cuda ""-optf"" and ""--options-file"" argument.
		if (guessed_compiler == GUESSED_NVCC
		    && (str_eq(argv[i], ""-optf"") || str_eq(argv[i], ""--options-file""))) {
			if (i == argc - 1) {
				cc_log(""Expected argument after %s"", argv[i]);
				stats_update(STATS_ARGS);
				result = false;
				goto out;
			}
			++i;

			// Argument is a comma-separated list of files.
			char *str_start = argv[i];
			char *str_end = strchr(str_start, ',');
			int index = i + 1;

			if (!str_end) {
				str_end = str_start + strlen(str_start);
			}

			while (str_end) {
				*str_end = '\0';
				struct args *file_args = args_init_from_gcc_atfile(str_start);
				if (!file_args) {
					cc_log(""Couldn't read cuda options file %s"", str_start);
					stats_update(STATS_ARGS);
					result = false;
					goto out;
				}

				int new_index = file_args->argc + index;
				args_insert(expanded_args, index, file_args, false);
				index = new_index;
				str_start = str_end;
				str_end = strchr(str_start, ',');
			}

			argc = expanded_args->argc;
			argv = expanded_args->argv;
			continue;
		}

		// These are always too hard.
		if (compopt_too_hard(argv[i]) || str_startswith(argv[i], ""-fdump-"")) {
			cc_log(""Compiler option %s is unsupported"", argv[i]);
			stats_update(STATS_UNSUPPORTED_OPTION);
			result = false;
			goto out;
		}

		// These are too hard in direct mode.
		if (conf->direct_mode && compopt_too_hard_for_direct_mode(argv[i])) {
			cc_log(""Unsupported compiler option for direct mode: %s"", argv[i]);
			conf->direct_mode = false;
		}

		// -Xarch_* options are too hard.
		if (str_startswith(argv[i], ""-Xarch_"")) {
			cc_log(""Unsupported compiler option :%s"", argv[i]);
			stats_update(STATS_UNSUPPORTED_OPTION);
			result = false;
			goto out;
		}

		// Handle -arch options.
		if (str_eq(argv[i], ""-arch"")) {
			if (arch_args_size == MAX_ARCH_ARGS - 1) {
				cc_log(""Too many -arch compiler options; ccache supports at most %d"",
				       MAX_ARCH_ARGS);
				stats_update(STATS_UNSUPPORTED_OPTION);
				result = false;
				goto out;
			}

			++i;
			arch_args[arch_args_size] = x_strdup(argv[i]); // It will leak.
			++arch_args_size;
			if (arch_args_size == 2) {
				conf->run_second_cpp = true;
			}
			continue;
		}

		if (str_eq(argv[i], ""-fpch-preprocess"")
		    || str_eq(argv[i], ""-emit-pch"")
		    || str_eq(argv[i], ""-emit-pth"")) {
			found_fpch_preprocess = true;
		}

		// We must have -c.
		if (str_eq(argv[i], ""-c"")) {
			found_c_opt = true;
			continue;
		}

		// -S changes the default extension.
		if (str_eq(argv[i], ""-S"")) {
			args_add(stripped_args, argv[i]);
			found_S_opt = true;
			continue;
		}

		// Special handling for -x: remember the last specified language before the
		// input file and strip all -x options from the arguments.
		if (str_eq(argv[i], ""-x"")) {
			if (i == argc - 1) {
				cc_log(""Missing argument to %s"", argv[i]);
				stats_update(STATS_ARGS);
				result = false;
				goto out;
			}
			if (!input_file) {
				explicit_language = argv[i+1];
			}
			i++;
			continue;
		}
		if (str_startswith(argv[i], ""-x"")) {
			if (!input_file) {
				explicit_language = &argv[i][2];
			}
			continue;
		}

		// We need to work out where the output was meant to go.
		if (str_eq(argv[i], ""-o"")) {
			if (i == argc - 1) {
				cc_log(""Missing argument to %s"", argv[i]);
				stats_update(STATS_ARGS);
				result = false;
				goto out;
			}
			output_obj = make_relative_path(x_strdup(argv[i+1]));
			i++;
			continue;
		}

		// Alternate form of -o with no space. Nvcc does not support this.
		if (str_startswith(argv[i], ""-o"") && guessed_compiler != GUESSED_NVCC) {
			output_obj = make_relative_path(x_strdup(&argv[i][2]));
			continue;
		}

		if (str_eq(argv[i], ""-gsplit-dwarf"")) {
			cc_log(""Enabling caching of dwarf files since -gsplit-dwarf is used"");
			using_split_dwarf = true;
			args_add(stripped_args, argv[i]);
			continue;
		}
		if (str_startswith(argv[i], ""-fdebug-prefix-map="")) {
			debug_prefix_maps = x_realloc(
			  debug_prefix_maps,
			  (debug_prefix_maps_len + 1) * sizeof(char *));
			debug_prefix_maps[debug_prefix_maps_len++] = x_strdup(argv[i] + 19);
			args_add(stripped_args, argv[i]);
			continue;
		}

		// Debugging is handled specially, so that we know if we can strip line
		// number info.
		if (str_startswith(argv[i], ""-g"")) {
			generating_debuginfo = true;
			args_add(stripped_args, argv[i]);
			if (conf->unify && !str_eq(argv[i], ""-g0"")) {
				cc_log(""%s used; disabling unify mode"", argv[i]);
				conf->unify = false;
			}
			if (str_eq(argv[i], ""-g3"")) {
				cc_log(""%s used; not compiling preprocessed code"", argv[i]);
				conf->run_second_cpp = true;
			}
			continue;
		}

		// These options require special handling, because they behave differently
		// with gcc -E, when the output file is not specified.
		if (str_eq(argv[i], ""-MD"") || str_eq(argv[i], ""-MMD"")) {
			generating_dependencies = true;
			args_add(dep_args, argv[i]);
			continue;
		}
		if (str_startswith(argv[i], ""-MF"")) {
			dependency_filename_specified = true;
			free(output_dep);

			char *arg;
			bool separate_argument = (strlen(argv[i]) == 3);
			if (separate_argument) {
				// -MF arg
				if (i == argc - 1) {
					cc_log(""Missing argument to %s"", argv[i]);
					stats_update(STATS_ARGS);
					result = false;
					goto out;
				}
				arg = argv[i + 1];
				i++;
			} else {
				// -MFarg
				arg = &argv[i][3];
			}
			output_dep = make_relative_path(x_strdup(arg));
			// Keep the format of the args the same.
			if (separate_argument) {
				args_add(dep_args, ""-MF"");
				args_add(dep_args, output_dep);
			} else {
				char *option = format(""-MF%s"", output_dep);
				args_add(dep_args, option);
				free(option);
			}
			continue;
		}
		if (str_startswith(argv[i], ""-MQ"") || str_startswith(argv[i], ""-MT"")) {
			dependency_target_specified = true;

			char *relpath;
			if (strlen(argv[i]) == 3) {
				// -MQ arg or -MT arg
				if (i == argc - 1) {
					cc_log(""Missing argument to %s"", argv[i]);
					stats_update(STATS_ARGS);
					result = false;
					goto out;
				}
				args_add(dep_args, argv[i]);
				relpath = make_relative_path(x_strdup(argv[i + 1]));
				args_add(dep_args, relpath);
				free(relpath);
				i++;
			} else {
				char *arg_opt = x_strndup(argv[i], 3);
				relpath = make_relative_path(x_strdup(argv[i] + 3));
				char *option = format(""%s%s"", arg_opt, relpath);
				args_add(dep_args, option);
				free(arg_opt);
				free(relpath);
				free(option);
			}
			continue;
		}
		if (str_eq(argv[i], ""-fprofile-arcs"")) {
			profile_arcs = true;
			args_add(stripped_args, argv[i]);
			continue;
		}
		if (str_eq(argv[i], ""-ftest-coverage"")) {
			generating_coverage = true;
			args_add(stripped_args, argv[i]);
			continue;
		}
		if (str_eq(argv[i], ""-fstack-usage"")) {
			generating_stackusage = true;
			args_add(stripped_args, argv[i]);
			continue;
		}
		if (str_eq(argv[i], ""--coverage"") // = -fprofile-arcs -ftest-coverage
		    || str_eq(argv[i], ""-coverage"")) { // Undocumented but still works.
			profile_arcs = true;
			generating_coverage = true;
			args_add(stripped_args, argv[i]);
			continue;
		}
		if (str_startswith(argv[i], ""-fprofile-dir="")) {
			profile_dir = x_strdup(argv[i] + 14);
			args_add(stripped_args, argv[i]);
			continue;
		}
		if (str_startswith(argv[i], ""-fsanitize-blacklist="")) {
			sanitize_blacklist = x_strdup(argv[i] + 21);
			args_add(stripped_args, argv[i]);
			continue;
		}
		if (str_startswith(argv[i], ""--sysroot="")) {
			char *relpath = make_relative_path(x_strdup(argv[i] + 10));
			char *option = format(""--sysroot=%s"", relpath);
			args_add(stripped_args, option);
			free(relpath);
			free(option);
			continue;
		}
		// Alternate form of specifying sysroot without =
		if (str_eq(argv[i], ""--sysroot"")) {
			if (i == argc-1) {
				cc_log(""Missing argument to %s"", argv[i]);
				stats_update(STATS_ARGS);
				result = false;
				goto out;
			}
			args_add(stripped_args, argv[i]);
			char *relpath = make_relative_path(x_strdup(argv[i+1]));
			args_add(stripped_args, relpath);
			i++;
			free(relpath);
			continue;
		}
		// Alternate form of specifying target without =
		if (str_eq(argv[i], ""-target"")) {
			if (i == argc-1) {
				cc_log(""Missing argument to %s"", argv[i]);
				stats_update(STATS_ARGS);
				result = false;
				goto out;
			}
			args_add(stripped_args, argv[i]);
			args_add(stripped_args, argv[i+1]);
			i++;
			continue;
		}
		if (str_startswith(argv[i], ""-Wp,"")) {
			if (str_eq(argv[i], ""-Wp,-P"")
			    || strstr(argv[i], "",-P,"")
			    || str_endswith(argv[i], "",-P"")) {
				// -P removes preprocessor information in such a way that the object
				// file from compiling the preprocessed file will not be equal to the
				// object file produced when compiling without ccache.
				cc_log(""Too hard option -Wp,-P detected"");
				stats_update(STATS_UNSUPPORTED_OPTION);
				failed();
			} else if (str_startswith(argv[i], ""-Wp,-MD,"")
			           && !strchr(argv[i] + 8, ',')) {
				generating_dependencies = true;
				dependency_filename_specified = true;
				free(output_dep);
				output_dep = make_relative_path(x_strdup(argv[i] + 8));
				args_add(dep_args, argv[i]);
				continue;
			} else if (str_startswith(argv[i], ""-Wp,-MMD,"")
			           && !strchr(argv[i] + 9, ',')) {
				generating_dependencies = true;
				dependency_filename_specified = true;
				free(output_dep);
				output_dep = make_relative_path(x_strdup(argv[i] + 9));
				args_add(dep_args, argv[i]);
				continue;
			} else if (str_startswith(argv[i], ""-Wp,-D"")
			           && !strchr(argv[i] + 6, ',')) {
				// Treat it like -D.
				args_add(cpp_args, argv[i] + 4);
				continue;
			} else if (str_eq(argv[i], ""-Wp,-MP"")
			           || (strlen(argv[i]) > 8
			               && str_startswith(argv[i], ""-Wp,-M"")
			               && argv[i][7] == ','
			               && (argv[i][6] == 'F'
			                   || argv[i][6] == 'Q'
			                   || argv[i][6] == 'T')
			               && !strchr(argv[i] + 8, ','))) {
				// TODO: Make argument to MF/MQ/MT relative.
				args_add(dep_args, argv[i]);
				continue;
			} else if (conf->direct_mode) {
				// -Wp, can be used to pass too hard options to the preprocessor.
				// Hence, disable direct mode.
				cc_log(""Unsupported compiler option for direct mode: %s"", argv[i]);
				conf->direct_mode = false;
			}

			// Any other -Wp,* arguments are only relevant for the preprocessor.
			args_add(cpp_args, argv[i]);
			continue;
		}
		if (str_eq(argv[i], ""-MP"")) {
			args_add(dep_args, argv[i]);
			continue;
		}

		// Input charset needs to be handled specially.
		if (str_startswith(argv[i], ""-finput-charset="")) {
			input_charset = argv[i];
			continue;
		}

		if (str_eq(argv[i], ""--serialize-diagnostics"")) {
			if (i == argc - 1) {
				cc_log(""Missing argument to %s"", argv[i]);
				stats_update(STATS_ARGS);
				result = false;
				goto out;
			}
			generating_diagnostics = true;
			output_dia = make_relative_path(x_strdup(argv[i+1]));
			i++;
			continue;
		}

		if (str_startswith(argv[i], ""-fprofile-"")) {
			char *arg = x_strdup(argv[i]);
			const char *arg_profile_dir = strchr(argv[i], '=');
			if (arg_profile_dir) {
				// Convert to absolute path.
				char *dir = x_realpath(arg_profile_dir + 1);
				if (!dir) {
					// Directory doesn't exist.
					dir = x_strdup(arg_profile_dir + 1);
				}

				// We can get a better hit rate by using the real path here.
				free(arg);
				char *option = x_strndup(argv[i], arg_profile_dir - argv[i]);
				arg = format(""%s=%s"", option, dir);
				cc_log(""Rewriting %s to %s"", argv[i], arg);
				free(option);
				free(dir);
			}

			bool supported_profile_option = false;
			if (str_startswith(argv[i], ""-fprofile-generate"")
			    || str_eq(argv[i], ""-fprofile-arcs"")) {
				profile_generate = true;
				supported_profile_option = true;
			} else if (str_startswith(argv[i], ""-fprofile-use"")
			           || str_eq(argv[i], ""-fbranch-probabilities"")) {
				profile_use = true;
				supported_profile_option = true;
			} else if (str_eq(argv[i], ""-fprofile-dir"")) {
				supported_profile_option = true;
			}

			if (supported_profile_option) {
				args_add(stripped_args, arg);
				free(arg);

				// If the profile directory has already been set, give up... Hard to
				// know what the user means, and what the compiler will do.
				if (arg_profile_dir && profile_dir) {
					cc_log(""Profile directory already set; giving up"");
					result = false;
					goto out;
				} else if (arg_profile_dir) {
					cc_log(""Setting profile directory to %s"", profile_dir);
					profile_dir = x_strdup(arg_profile_dir);
				}
				continue;
			}
			cc_log(""Unknown profile option: %s"", argv[i]);
			free(arg);
		}

		if (str_eq(argv[i], ""-fcolor-diagnostics"")
		    || str_eq(argv[i], ""-fno-color-diagnostics"")
		    || str_eq(argv[i], ""-fdiagnostics-color"")
		    || str_eq(argv[i], ""-fdiagnostics-color=always"")
		    || str_eq(argv[i], ""-fno-diagnostics-color"")
		    || str_eq(argv[i], ""-fdiagnostics-color=never"")) {
			args_add(stripped_args, argv[i]);
			found_color_diagnostics = true;
			continue;
		}
		if (str_eq(argv[i], ""-fdiagnostics-color=auto"")) {
			if (color_output_possible()) {
				// Output is redirected, so color output must be forced.
				args_add(stripped_args, ""-fdiagnostics-color=always"");
				cc_log(""Automatically forcing colors"");
			} else {
				args_add(stripped_args, argv[i]);
			}
			found_color_diagnostics = true;
			continue;
		}

		// GCC
		if (str_eq(argv[i], ""-fdirectives-only"")) {
			found_directives_only = true;
			continue;
		}
		// Clang
		if (str_eq(argv[i], ""-frewrite-includes"")) {
			found_rewrite_includes = true;
			continue;
		}

		// Options taking an argument that we may want to rewrite to relative paths
		// to get better hit rate. A secondary effect is that paths in the standard
		// error output produced by the compiler will be normalized.
		if (compopt_takes_path(argv[i])) {
			if (i == argc - 1) {
				cc_log(""Missing argument to %s"", argv[i]);
				stats_update(STATS_ARGS);
				result = false;
				goto out;
			}

			if (!detect_pch(argv[i], argv[i+1], &found_pch)) {
				result = false;
				goto out;
			}

			char *relpath = make_relative_path(x_strdup(argv[i+1]));
			if (compopt_affects_cpp(argv[i])) {
				args_add(cpp_args, argv[i]);
				args_add(cpp_args, relpath);
			} else {
				args_add(stripped_args, argv[i]);
				args_add(stripped_args, relpath);
			}
			free(relpath);

			i++;
			continue;
		}

		// Same as above but options with concatenated argument beginning with a
		// slash.
		if (argv[i][0] == '-') {
			char *slash_pos = strchr(argv[i], '/');
			if (slash_pos) {
				char *option = x_strndup(argv[i], slash_pos - argv[i]);
				if (compopt_takes_concat_arg(option) && compopt_takes_path(option)) {
					char *relpath = make_relative_path(x_strdup(slash_pos));
					char *new_option = format(""%s%s"", option, relpath);
					if (compopt_affects_cpp(option)) {
						args_add(cpp_args, new_option);
					} else {
						args_add(stripped_args, new_option);
					}
					free(new_option);
					free(relpath);
					free(option);
					continue;
				} else {
					free(option);
				}
			}
		}

		// Options that take an argument.
		if (compopt_takes_arg(argv[i])) {
			if (i == argc - 1) {
				cc_log(""Missing argument to %s"", argv[i]);
				stats_update(STATS_ARGS);
				result = false;
				goto out;
			}

			if (compopt_affects_cpp(argv[i])) {
				args_add(cpp_args, argv[i]);
				args_add(cpp_args, argv[i+1]);
			} else {
				args_add(stripped_args, argv[i]);
				args_add(stripped_args, argv[i+1]);
			}

			i++;
			continue;
		}

		// Other options.
		if (argv[i][0] == '-') {
			if (compopt_affects_cpp(argv[i])
			    || compopt_prefix_affects_cpp(argv[i])) {
				args_add(cpp_args, argv[i]);
			} else {
				args_add(stripped_args, argv[i]);
			}
			continue;
		}

		// If an argument isn't a plain file then assume its an option, not an
		// input file. This allows us to cope better with unusual compiler options.
		struct stat st;
		if (stat(argv[i], &st) != 0 || !S_ISREG(st.st_mode)) {
			cc_log(""%s is not a regular file, not considering as input file"",
			       argv[i]);
			args_add(stripped_args, argv[i]);
			continue;
		}

		if (input_file) {
			if (language_for_file(argv[i])) {
				cc_log(""Multiple input files: %s and %s"", input_file, argv[i]);
				stats_update(STATS_MULTIPLE);
			} else if (!found_c_opt) {
				cc_log(""Called for link with %s"", argv[i]);
				if (strstr(argv[i], ""conftest."")) {
					stats_update(STATS_CONFTEST);
				} else {
					stats_update(STATS_LINK);
				}
			} else {
				cc_log(""Unsupported source extension: %s"", argv[i]);
				stats_update(STATS_SOURCELANG);
			}
			result = false;
			goto out;
		}

		// The source code file path gets put into the notes.
		if (generating_coverage) {
			input_file = x_strdup(argv[i]);
			continue;
		}

		if (is_symlink(argv[i])) {
			// Don't rewrite source file path if it's a symlink since
			// make_relative_path resolves symlinks using realpath(3) and this leads
			// to potentially choosing incorrect relative header files. See the
			// ""symlink to source file"" test.
			input_file = x_strdup(argv[i]);
		} else {
			// Rewrite to relative to increase hit rate.
			input_file = make_relative_path(x_strdup(argv[i]));
		}
	} // for

	if (found_S_opt) {
		// Even if -gsplit-dwarf is given, the .dwo file is not generated when -S
		// is also given.
		using_split_dwarf = false;
		cc_log(""Disabling caching of dwarf files since -S is used"");
	}

	if (!input_file) {
		cc_log(""No input file found"");
		stats_update(STATS_NOINPUT);
		result = false;
		goto out;
	}

	if (found_pch || found_fpch_preprocess) {
		using_precompiled_header = true;
		if (!(conf->sloppiness & SLOPPY_TIME_MACROS)) {
			cc_log(""You have to specify \""time_macros\"" sloppiness when using""
			       "" precompiled headers to get direct hits"");
			cc_log(""Disabling direct mode"");
			stats_update(STATS_CANTUSEPCH);
			result = false;
			goto out;
		}
	}

	if (explicit_language && str_eq(explicit_language, ""none"")) {
		explicit_language = NULL;
	}
	file_language = language_for_file(input_file);
	if (explicit_language) {
		if (!language_is_supported(explicit_language)) {
			cc_log(""Unsupported language: %s"", explicit_language);
			stats_update(STATS_SOURCELANG);
			result = false;
			goto out;
		}
		actual_language = x_strdup(explicit_language);
	} else {
		actual_language = file_language;
	}

	output_is_precompiled_header =
	  actual_language && strstr(actual_language, ""-header"");

	if (output_is_precompiled_header
	    && !(conf->sloppiness & SLOPPY_PCH_DEFINES)) {
		cc_log(""You have to specify \""pch_defines,time_macros\"" sloppiness when""
		       "" creating precompiled headers"");
		stats_update(STATS_CANTUSEPCH);
		result = false;
		goto out;
	}

	if (!found_c_opt && !found_S_opt) {
		if (output_is_precompiled_header) {
			args_add(stripped_args, ""-c"");
		} else {
			cc_log(""No -c option found"");
			// I find that having a separate statistic for autoconf tests is useful,
			// as they are the dominant form of ""called for link"" in many cases.
			if (strstr(input_file, ""conftest."")) {
				stats_update(STATS_CONFTEST);
			} else {
				stats_update(STATS_LINK);
			}
			result = false;
			goto out;
		}
	}

	if (!actual_language) {
		cc_log(""Unsupported source extension: %s"", input_file);
		stats_update(STATS_SOURCELANG);
		result = false;
		goto out;
	}

	if (!conf->run_second_cpp && str_eq(actual_language, ""cuda"")) {
		cc_log(""Using CUDA compiler; not compiling preprocessed code"");
		conf->run_second_cpp = true;
	}

	direct_i_file = language_is_preprocessed(actual_language);

	if (output_is_precompiled_header && !conf->run_second_cpp) {
		// It doesn't work to create the .gch from preprocessed source.
		cc_log(""Creating precompiled header; not compiling preprocessed code"");
		conf->run_second_cpp = true;
	}

	if (str_eq(conf->cpp_extension, """")) {
		const char *p_language = p_language_for_language(actual_language);
		free(conf->cpp_extension);
		conf->cpp_extension = x_strdup(extension_for_language(p_language) + 1);
	}

	// Don't try to second guess the compilers heuristics for stdout handling.
	if (output_obj && str_eq(output_obj, ""-"")) {
		stats_update(STATS_OUTSTDOUT);
		cc_log(""Output file is -"");
		result = false;
		goto out;
	}

	if (!output_obj) {
		if (output_is_precompiled_header) {
			output_obj = format(""%s.gch"", input_file);
		} else {
			output_obj = basename(input_file);
			char *p = strrchr(output_obj, '.');
			if (!p || !p[1]) {
				cc_log(""Badly formed object filename"");
				stats_update(STATS_ARGS);
				result = false;
				goto out;
			}
			p[1] = found_S_opt ? 's' : 'o';
			p[2] = 0;
		}
	}

	if (using_split_dwarf) {
		char *p = strrchr(output_obj, '.');
		if (!p || !p[1]) {
			cc_log(""Badly formed object filename"");
			stats_update(STATS_ARGS);
			result = false;
			goto out;
		}

		char *base_name = remove_extension(output_obj);
		output_dwo = format(""%s.dwo"", base_name);
		free(base_name);
	}

	// Cope with -o /dev/null.
	struct stat st;
	if (!str_eq(output_obj, ""/dev/null"")
	    && stat(output_obj, &st) == 0
	    && !S_ISREG(st.st_mode)) {
		cc_log(""Not a regular file: %s"", output_obj);
		stats_update(STATS_DEVICE);
		result = false;
		goto out;
	}

	// Some options shouldn't be passed to the real compiler when it compiles
	// preprocessed code:
	//
	// -finput-charset=XXX (otherwise conversion happens twice)
	// -x XXX (otherwise the wrong language is selected)
	if (input_charset) {
		args_add(cpp_args, input_charset);
	}
	if (found_pch) {
		args_add(cpp_args, ""-fpch-preprocess"");
	}
	if (explicit_language) {
		args_add(cpp_args, ""-x"");
		args_add(cpp_args, explicit_language);
	}

	// Since output is redirected, compilers will not color their output by
	// default, so force it explicitly if it would be otherwise done.
	if (!found_color_diagnostics && color_output_possible()) {
		if (guessed_compiler == GUESSED_CLANG) {
			if (!str_eq(actual_language, ""assembler"")) {
				args_add(stripped_args, ""-fcolor-diagnostics"");
				cc_log(""Automatically enabling colors"");
			}
		} else if (guessed_compiler == GUESSED_GCC) {
			// GCC has it since 4.9, but that'd require detecting what GCC version is
			// used for the actual compile. However it requires also GCC_COLORS to be
			// set (and not empty), so use that for detecting if GCC would use
			// colors.
			if (getenv(""GCC_COLORS"") && getenv(""GCC_COLORS"")[0] != '\0') {
				args_add(stripped_args, ""-fdiagnostics-color"");
				cc_log(""Automatically enabling colors"");
			}
		}
	}

	// Add flags for dependency generation only to the preprocessor command line.
	if (generating_dependencies) {
		if (!dependency_filename_specified) {
			char *base_name = remove_extension(output_obj);
			char *default_depfile_name = format(""%s.d"", base_name);
			free(base_name);
			args_add(dep_args, ""-MF"");
			args_add(dep_args, default_depfile_name);
			output_dep = make_relative_path(x_strdup(default_depfile_name));
		}

		if (!dependency_target_specified
		    && !str_eq(get_extension(output_dep), "".o"")) {
			args_add(dep_args, ""-MQ"");
			args_add(dep_args, output_obj);
		}
	}
	if (generating_coverage) {
		char *base_name = remove_extension(output_obj);
		char *default_covfile_name = format(""%s.gcno"", base_name);
		free(base_name);
		output_cov = make_relative_path(default_covfile_name);
	}
	if (generating_stackusage) {
		char *base_name = remove_extension(output_obj);
		char *default_sufile_name = format(""%s.su"", base_name);
		free(base_name);
		output_su = make_relative_path(default_sufile_name);
	}

	*compiler_args = args_copy(stripped_args);
	if (conf->run_second_cpp) {
		args_extend(*compiler_args, cpp_args);
	} else if (found_directives_only || found_rewrite_includes) {
		// Need to pass the macros and any other preprocessor directives again.
		args_extend(*compiler_args, cpp_args);
		if (found_directives_only) {
			args_add(cpp_args, ""-fdirectives-only"");
			// The preprocessed source code still needs some more preprocessing.
			args_add(*compiler_args, ""-fpreprocessed"");
			args_add(*compiler_args, ""-fdirectives-only"");
		}
		if (found_rewrite_includes) {
			args_add(cpp_args, ""-frewrite-includes"");
			// The preprocessed source code still needs some more preprocessing.
			args_add(*compiler_args, ""-x"");
			args_add(*compiler_args, actual_language);
		}
	} else if (explicit_language) {
		// Workaround for a bug in Apple's patched distcc -- it doesn't properly
		// reset the language specified with -x, so if -x is given, we have to
		// specify the preprocessed language explicitly.
		args_add(*compiler_args, ""-x"");
		args_add(*compiler_args, p_language_for_language(explicit_language));
	}

	if (found_c_opt) {
		args_add(*compiler_args, ""-c"");
	}

	for (size_t i = 0; i < arch_args_size; ++i) {
		args_add(*compiler_args, ""-arch"");
		args_add(*compiler_args, arch_args[i]);
	}

	// Only pass dependency arguments to the preprocesor since Intel's C++
	// compiler doesn't produce a correct .d file when compiling preprocessed
	// source.
	args_extend(cpp_args, dep_args);

	*preprocessor_args = args_copy(stripped_args);
	args_extend(*preprocessor_args, cpp_args);

out:
	args_free(expanded_args);
	args_free(stripped_args);
	args_free(dep_args);
	args_free(cpp_args);
	return result;
}

static void
create_initial_config_file(struct conf *conf, const char *path)
{
	if (create_parent_dirs(path) != 0) {
		return;
	}

	unsigned max_files;
	uint64_t max_size;
	char *stats_dir = format(""%s/0"", conf->cache_dir);
	struct stat st;
	if (stat(stats_dir, &st) == 0) {
		stats_get_obsolete_limits(stats_dir, &max_files, &max_size);
		// STATS_MAXFILES and STATS_MAXSIZE was stored for each top directory.
		max_files *= 16;
		max_size *= 16;
	} else {
		max_files = 0;
		max_size = conf->max_size;
	}
	free(stats_dir);

	FILE *f = fopen(path, ""w"");
	if (!f) {
		return;
	}
	if (max_files != 0) {
		fprintf(f, ""max_files = %u\n"", max_files);
		conf->max_files = max_files;
	}
	if (max_size != 0) {
		char *size = format_parsable_size_with_suffix(max_size);
		fprintf(f, ""max_size = %s\n"", size);
		free(size);
		conf->max_size = max_size;
	}
	fclose(f);
}

// Read config file(s), populate variables, create configuration file in cache
// directory if missing, etc.
static void
initialize(void)
{
	conf_free(conf);
	conf = conf_create();

	char *errmsg;
	char *p = getenv(""CCACHE_CONFIGPATH"");
	if (p) {
		primary_config_path = x_strdup(p);
	} else {
		secondary_config_path = format(""%s/ccache.conf"", TO_STRING(SYSCONFDIR));
		if (!conf_read(conf, secondary_config_path, &errmsg)) {
			if (errno == 0) {
				// We could read the file but it contained errors.
				fatal(""%s"", errmsg);
			}
			// A missing config file in SYSCONFDIR is OK.
			free(errmsg);
		}

		if (str_eq(conf->cache_dir, """")) {
			fatal(""configuration setting \""cache_dir\"" must not be the empty string"");
		}
		if ((p = getenv(""CCACHE_DIR""))) {
			free(conf->cache_dir);
			conf->cache_dir = strdup(p);
		}
		if (str_eq(conf->cache_dir, """")) {
			fatal(""CCACHE_DIR must not be the empty string"");
		}

		primary_config_path = format(""%s/ccache.conf"", conf->cache_dir);
	}

	bool should_create_initial_config = false;
	if (!conf_read(conf, primary_config_path, &errmsg)) {
		if (errno == 0) {
			// We could read the file but it contained errors.
			fatal(""%s"", errmsg);
		}
		if (!conf->disable) {
			should_create_initial_config = true;
		}
	}

	if (!conf_update_from_environment(conf, &errmsg)) {
		fatal(""%s"", errmsg);
	}

	if (should_create_initial_config) {
		create_initial_config_file(conf, primary_config_path);
	}

	exitfn_init();
	exitfn_add_nullary(stats_flush);
	exitfn_add_nullary(clean_up_pending_tmp_files);

	cc_log(""=== CCACHE %s STARTED ========================================="",
	       CCACHE_VERSION);

	if (conf->umask != UINT_MAX) {
		umask(conf->umask);
	}
}

// Reset the global state. Used by the test suite.
void
cc_reset(void)
{
	conf_free(conf); conf = NULL;
	free(primary_config_path); primary_config_path = NULL;
	free(secondary_config_path); secondary_config_path = NULL;
	free(current_working_dir); current_working_dir = NULL;
	for (size_t i = 0; i < debug_prefix_maps_len; i++) {
		free(debug_prefix_maps[i]);
		debug_prefix_maps[i] = NULL;
	}
	free(debug_prefix_maps); debug_prefix_maps = NULL;
	debug_prefix_maps_len = 0;
	free(profile_dir); profile_dir = NULL;
	free(sanitize_blacklist); sanitize_blacklist = NULL;
	free(included_pch_file); included_pch_file = NULL;
	args_free(orig_args); orig_args = NULL;
	free(input_file); input_file = NULL;
	free(output_obj); output_obj = NULL;
	free(output_dep); output_dep = NULL;
	free(output_cov); output_cov = NULL;
	free(output_su); output_su = NULL;
	free(output_dia); output_dia = NULL;
	free(output_dwo); output_dwo = NULL;
	free(cached_obj_hash); cached_obj_hash = NULL;
	free(cached_stderr); cached_stderr = NULL;
	free(cached_obj); cached_obj = NULL;
	free(cached_dep); cached_dep = NULL;
	free(cached_cov); cached_cov = NULL;
	free(cached_su); cached_su = NULL;
	free(cached_dia); cached_dia = NULL;
	free(cached_dwo); cached_dwo = NULL;
	free(manifest_path); manifest_path = NULL;
	time_of_compilation = 0;
	for (size_t i = 0; i < ignore_headers_len; i++) {
		free(ignore_headers[i]);
		ignore_headers[i] = NULL;
	}
	free(ignore_headers); ignore_headers = NULL;
	ignore_headers_len = 0;
	if (included_files) {
		hashtable_destroy(included_files, 1); included_files = NULL;
	}
	has_absolute_include_headers = false;
	generating_debuginfo = false;
	generating_dependencies = false;
	generating_coverage = false;
	generating_stackusage = false;
	profile_arcs = false;
	free(profile_dir); profile_dir = NULL;
	i_tmpfile = NULL;
	direct_i_file = false;
	free(cpp_stderr); cpp_stderr = NULL;
	free(stats_file); stats_file = NULL;
	output_is_precompiled_header = false;

	conf = conf_create();
	using_split_dwarf = false;
}

// Make a copy of stderr that will not be cached, so things like distcc can
// send networking errors to it.
static void
set_up_uncached_err(void)
{
	int uncached_fd = dup(2); // The file descriptor is intentionally leaked.
	if (uncached_fd == -1) {
		cc_log(""dup(2) failed: %s"", strerror(errno));
		failed();
	}

	// Leak a pointer to the environment.
	char *buf = format(""UNCACHED_ERR_FD=%d"", uncached_fd);
	if (putenv(buf) == -1) {
		cc_log(""putenv failed: %s"", strerror(errno));
		failed();
	}
}

static void
configuration_logger(const char *descr, const char *origin, void *context)
{
	(void)context;
	cc_bulklog(""Config: (%s) %s"", origin, descr);
}

// The main ccache driver function.
static void
ccache(int argc, char *argv[])
{
#ifndef _WIN32
	set_up_signal_handlers();
#endif

	orig_args = args_init(argc, argv);

	initialize();
	find_compiler(argv);

	if (str_eq(conf->temporary_dir, """")) {
		clean_up_internal_tempdir();
	}

	if (!str_eq(conf->log_file, """")) {
		conf_print_items(conf, configuration_logger, NULL);
	}

	if (conf->disable) {
		cc_log(""ccache is disabled"");
		failed();
	}

	set_up_uncached_err();

	cc_log_argv(""Command line: "", argv);
	cc_log(""Hostname: %s"", get_hostname());
	cc_log(""Working directory: %s"", get_current_working_dir());

	conf->limit_multiple = MIN(MAX(conf->limit_multiple, 0.0), 1.0);

	guessed_compiler = guess_compiler(orig_args->argv[0]);

	// Arguments (except -E) to send to the preprocessor.
	struct args *preprocessor_args;
	// Arguments to send to the real compiler.
	struct args *compiler_args;
	if (!cc_process_args(orig_args, &preprocessor_args, &compiler_args)) {
		failed();
	}

	cc_log(""Source file: %s"", input_file);
	if (generating_dependencies) {
		cc_log(""Dependency file: %s"", output_dep);
	}
	if (generating_coverage) {
		cc_log(""Coverage file: %s"", output_cov);
	}
	if (generating_stackusage) {
		cc_log(""Stack usage file: %s"", output_su);
	}
	if (generating_diagnostics) {
		cc_log(""Diagnostics file: %s"", output_dia);
	}
	if (output_dwo) {
		cc_log(""Split dwarf file: %s"", output_dwo);
	}

	cc_log(""Object file: %s"", output_obj);

	struct mdfour common_hash;
	hash_start(&common_hash);
	calculate_common_hash(preprocessor_args, &common_hash);

	// Try to find the hash using the manifest.
	struct mdfour direct_hash = common_hash;
	bool put_object_in_manifest = false;
	struct file_hash *object_hash = NULL;
	struct file_hash *object_hash_from_manifest = NULL;
	if (conf->direct_mode) {
		cc_log(""Trying direct lookup"");
		object_hash = calculate_object_hash(preprocessor_args, &direct_hash, 1);
		if (object_hash) {
			update_cached_result_globals(object_hash);

			// If we can return from cache at this point then do so.
			from_cache(FROMCACHE_DIRECT_MODE, 0);

			// Wasn't able to return from cache at this point. However, the object
			// was already found in manifest, so don't readd it later.
			put_object_in_manifest = false;

			object_hash_from_manifest = object_hash;
		} else {
			// Add object to manifest later.
			put_object_in_manifest = true;
		}
	}

	if (conf->read_only_direct) {
		cc_log(""Read-only direct mode; running real compiler"");
		failed();
	}

	// Find the hash using the preprocessed output. Also updates included_files.
	struct mdfour cpp_hash = common_hash;
	object_hash = calculate_object_hash(preprocessor_args, &cpp_hash, 0);
	if (!object_hash) {
		fatal(""internal error: object hash from cpp returned NULL"");
	}
	update_cached_result_globals(object_hash);

	if (object_hash_from_manifest
	    && !file_hashes_equal(object_hash_from_manifest, object_hash)) {
		// The hash from manifest differs from the hash of the preprocessor output.
		// This could be because:
		//
		// - The preprocessor produces different output for the same input (not
		//   likely).
		// - There's a bug in ccache (maybe incorrect handling of compiler
		//   arguments).
		// - The user has used a different CCACHE_BASEDIR (most likely).
		//
		// The best thing here would probably be to remove the hash entry from the
		// manifest. For now, we use a simpler method: just remove the manifest
		// file.
		cc_log(""Hash from manifest doesn't match preprocessor output"");
		cc_log(""Likely reason: different CCACHE_BASEDIRs used"");
		cc_log(""Removing manifest as a safety measure"");
		x_unlink(manifest_path);

		put_object_in_manifest = true;
	}

	// If we can return from cache at this point then do.
	from_cache(FROMCACHE_CPP_MODE, put_object_in_manifest);

	if (conf->read_only) {
		cc_log(""Read-only mode; running real compiler"");
		failed();
	}

	add_prefix(compiler_args, conf->prefix_command);

	// Run real compiler, sending output to cache.
	to_cache(compiler_args);

	x_exit(0);
}

static void
configuration_printer(const char *descr, const char *origin, void *context)
{
	assert(context);
	fprintf(context, ""(%s) %s\n"", origin, descr);
}

// The main program when not doing a compile.
static int
ccache_main_options(int argc, char *argv[])
{
	enum longopts {
		DUMP_MANIFEST
	};
	static const struct option options[] = {
		{""cleanup"",       no_argument,       0, 'c'},
		{""clear"",         no_argument,       0, 'C'},
		{""dump-manifest"", required_argument, 0, DUMP_MANIFEST},
		{""help"",          no_argument,       0, 'h'},
		{""max-files"",     required_argument, 0, 'F'},
		{""max-size"",      required_argument, 0, 'M'},
		{""set-config"",    required_argument, 0, 'o'},
		{""print-config"",  no_argument,       0, 'p'},
		{""show-stats"",    no_argument,       0, 's'},
		{""version"",       no_argument,       0, 'V'},
		{""zero-stats"",    no_argument,       0, 'z'},
		{0, 0, 0, 0}
	};

	int c;
	while ((c = getopt_long(argc, argv, ""cChF:M:o:psVz"", options, NULL)) != -1) {
		switch (c) {
		case DUMP_MANIFEST:
			manifest_dump(optarg, stdout);
			break;

		case 'c': // --cleanup
			initialize();
			clean_up_all(conf);
			printf(""Cleaned cache\n"");
			break;

		case 'C': // --clear
			initialize();
			wipe_all(conf);
			printf(""Cleared cache\n"");
			break;

		case 'h': // --help
			fputs(USAGE_TEXT, stdout);
			x_exit(0);

		case 'F': // --max-files
		{
			initialize();
			char *errmsg;
			if (conf_set_value_in_file(primary_config_path, ""max_files"", optarg,
			                           &errmsg)) {
				unsigned files = atoi(optarg);
				if (files == 0) {
					printf(""Unset cache file limit\n"");
				} else {
					printf(""Set cache file limit to %u\n"", files);
				}
			} else {
				fatal(""could not set cache file limit: %s"", errmsg);
			}
		}
		break;

		case 'M': // --max-size
		{
			initialize();
			uint64_t size;
			if (!parse_size_with_suffix(optarg, &size)) {
				fatal(""invalid size: %s"", optarg);
			}
			char *errmsg;
			if (conf_set_value_in_file(primary_config_path, ""max_size"", optarg,
			                           &errmsg)) {
				if (size == 0) {
					printf(""Unset cache size limit\n"");
				} else {
					char *s = format_human_readable_size(size);
					printf(""Set cache size limit to %s\n"", s);
					free(s);
				}
			} else {
				fatal(""could not set cache size limit: %s"", errmsg);
			}
		}
		break;

		case 'o': // --set-config
		{
			initialize();
			char *p = strchr(optarg, '=');
			if (!p) {
				fatal(""missing equal sign in \""%s\"""", optarg);
			}
			char *key = x_strndup(optarg, p - optarg);
			char *value = p + 1;
			char *errmsg;
			if (!conf_set_value_in_file(primary_config_path, key, value, &errmsg)) {
				fatal(""%s"", errmsg);
			}
			free(key);
		}
		break;

		case 'p': // --print-config
			initialize();
			conf_print_items(conf, configuration_printer, stdout);
			break;

		case 's': // --show-stats
			initialize();
			stats_summary(conf);
			break;

		case 'V': // --version
			fprintf(stdout, VERSION_TEXT, CCACHE_VERSION);
			x_exit(0);

		case 'z': // --zero-stats
			initialize();
			stats_zero();
			printf(""Statistics zeroed\n"");
			break;

		default:
			fputs(USAGE_TEXT, stderr);
			x_exit(1);
		}
	}

	return 0;
}

int
ccache_main(int argc, char *argv[])
{
	// Check if we are being invoked as ""ccache"".
	char *program_name = basename(argv[0]);
	if (same_executable_name(program_name, MYNAME)) {
		if (argc < 2) {
			fputs(USAGE_TEXT, stderr);
			x_exit(1);
		}
		// If the first argument isn't an option, then assume we are being passed a
		// compiler name and options.
		if (argv[1][0] == '-') {
			return ccache_main_options(argc, argv);
		}
	}
	free(program_name);

	ccache(argc, argv);
	return 1;
}
""","""// ccache -- a fast C/C++ compiler cache
//
// Copyright (C) 2002-2007 Andrew Tridgell
// Copyright (C) 2009-2018 Joel Rosdahl
//
// This program is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by the Free
// Software Foundation; either version 3 of the License, or (at your option)
// any later version.
//
// This program is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
// more details.
//
// You should have received a copy of the GNU General Public License along with
// this program; if not, write to the Free Software Foundation, Inc., 51
// Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA

#include ""ccache.h""
#include ""compopt.h""
#ifdef HAVE_GETOPT_LONG
#include <getopt.h>
#else
#include ""getopt_long.h""
#endif
#include ""hashtable.h""
#include ""hashtable_itr.h""
#include ""hashutil.h""
#include ""language.h""
#include ""manifest.h""

#define STRINGIFY(x) #x
#define TO_STRING(x) STRINGIFY(x)

static const char VERSION_TEXT[] =
  MYNAME "" version %s\n""
  ""\n""
  ""Copyright (C) 2002-2007 Andrew Tridgell\n""
  ""Copyright (C) 2009-2018 Joel Rosdahl\n""
  ""\n""
  ""This program is free software; you can redistribute it and/or modify it under\n""
  ""the terms of the GNU General Public License as published by the Free Software\n""
  ""Foundation; either version 3 of the License, or (at your option) any later\n""
  ""version.\n"";

static const char USAGE_TEXT[] =
  ""Usage:\n""
  ""    "" MYNAME "" [options]\n""
  ""    "" MYNAME "" compiler [compiler options]\n""
  ""    compiler [compiler options]          (via symbolic link)\n""
  ""\n""
  ""Options:\n""
  ""    -c, --cleanup         delete old files and recalculate size counters\n""
  ""                          (normally not needed as this is done automatically)\n""
  ""    -C, --clear           clear the cache completely (except configuration)\n""
  ""    -F, --max-files=N     set maximum number of files in cache to N (use 0 for\n""
  ""                          no limit)\n""
  ""    -M, --max-size=SIZE   set maximum size of cache to SIZE (use 0 for no\n""
  ""                          limit); available suffixes: k, M, G, T (decimal) and\n""
  ""                          Ki, Mi, Gi, Ti (binary); default suffix: G\n""
  ""    -o, --set-config=K=V  set configuration key K to value V\n""
  ""    -p, --print-config    print current configuration options\n""
  ""    -s, --show-stats      show statistics summary\n""
  ""    -z, --zero-stats      zero statistics counters\n""
  ""\n""
  ""    -h, --help            print this help text\n""
  ""    -V, --version         print version and copyright information\n""
  ""\n""
  ""See also <https://ccache.samba.org>.\n"";

// Global configuration data.
struct conf *conf = NULL;

// Where to write configuration changes.
char *primary_config_path = NULL;

// Secondary, read-only configuration file (if any).
char *secondary_config_path = NULL;

// Current working directory taken from $PWD, or getcwd() if $PWD is bad.
char *current_working_dir = NULL;

// The original argument list.
static struct args *orig_args;

// The source file.
static char *input_file;

// The output file being compiled to.
static char *output_obj;

// The path to the dependency file (implicit or specified with -MF).
static char *output_dep;

// The path to the coverage file (implicit when using -ftest-coverage).
static char *output_cov;

// The path to the stack usage (implicit when using -fstack-usage).
static char *output_su;

// Diagnostic generation information (clang). Contains pathname if not NULL.
static char *output_dia;

// Split dwarf information (GCC 4.8 and up). Contains pathname if not NULL.
static char *output_dwo;

// Language to use for the compilation target (see language.c).
static const char *actual_language;

// Array for storing -arch options.
#define MAX_ARCH_ARGS 10
static size_t arch_args_size = 0;
static char *arch_args[MAX_ARCH_ARGS] = {NULL};

// Name (represented as a struct file_hash) of the file containing the cached
// object code.
static struct file_hash *cached_obj_hash;

// Full path to the file containing the cached object code
// (cachedir/a/b/cdef[...]-size.o).
static char *cached_obj;

// Full path to the file containing the standard error output
// (cachedir/a/b/cdef[...]-size.stderr).
static char *cached_stderr;

// Full path to the file containing the dependency information
// (cachedir/a/b/cdef[...]-size.d).
static char *cached_dep;

// Full path to the file containing the coverage information
// (cachedir/a/b/cdef[...]-size.gcno).
static char *cached_cov;

// Full path to the file containing the stack usage
// (cachedir/a/b/cdef[...]-size.su).
static char *cached_su;

// Full path to the file containing the diagnostic information (for clang)
// (cachedir/a/b/cdef[...]-size.dia).
static char *cached_dia;

// Full path to the file containing the split dwarf (for GCC 4.8 and above)
// (cachedir/a/b/cdef[...]-size.dwo).
//
// Contains NULL if -gsplit-dwarf is not given.
static char *cached_dwo;

// Full path to the file containing the manifest
// (cachedir/a/b/cdef[...]-size.manifest).
static char *manifest_path;

// Time of compilation. Used to see if include files have changed after
// compilation.
time_t time_of_compilation;

// Files included by the preprocessor and their hashes/sizes. Key: file path.
// Value: struct file_hash.
static struct hashtable *included_files = NULL;

// Uses absolute path for some include files.
static bool has_absolute_include_headers = false;

// List of headers to ignore.
static char **ignore_headers;

// Size of headers to ignore list.
static size_t ignore_headers_len;

// Is the compiler being asked to output debug info?
static bool generating_debuginfo;

// Is the compiler being asked to output dependencies?
static bool generating_dependencies;

// Is the compiler being asked to output coverage?
static bool generating_coverage;

// Is the compiler being asked to output stack usage?
static bool generating_stackusage;

// Us the compiler being asked to generate diagnostics
// (--serialize-diagnostics)?
static bool generating_diagnostics;

// Is the compiler being asked to separate dwarf debug info into a separate
// file (-gsplit-dwarf)""?
static bool using_split_dwarf;

// Relocating debuginfo in the format old=new.
static char **debug_prefix_maps = NULL;

// Size of debug_prefix_maps list.
static size_t debug_prefix_maps_len = 0;

// Is the compiler being asked to output coverage data (.gcda) at runtime?
static bool profile_arcs;

// Name of the custom profile directory (default: object dirname).
static char *profile_dir;

// The name of the temporary preprocessed file.
static char *i_tmpfile;

// Are we compiling a .i or .ii file directly?
static bool direct_i_file;

// The name of the cpp stderr file.
static char *cpp_stderr;

// Full path to the statistics file in the subdirectory where the cached result
// belongs (<cache_dir>/<x>/stats).
char *stats_file = NULL;

// Whether the output is a precompiled header.
bool output_is_precompiled_header = false;

// Compiler guessing is currently only based on the compiler name, so nothing
// should hard-depend on it if possible.
enum guessed_compiler guessed_compiler = GUESSED_UNKNOWN;

// Profile generation / usage information.
static char *profile_dir = NULL;
static bool profile_use = false;
static bool profile_generate = false;

// Sanitize blacklist
static char *sanitize_blacklist = NULL;

// Whether we are using a precompiled header (either via -include, #include or
// clang's -include-pch or -include-pth).
static bool using_precompiled_header = false;

// The .gch/.pch/.pth file used for compilation.
static char *included_pch_file = NULL;

// How long (in microseconds) to wait before breaking a stale lock.
unsigned lock_staleness_limit = 2000000;

enum fromcache_call_mode {
	FROMCACHE_DIRECT_MODE,
	FROMCACHE_CPP_MODE
};

struct pending_tmp_file {
	char *path;
	struct pending_tmp_file *next;
};

// Temporary files to remove at program exit.
static struct pending_tmp_file *pending_tmp_files = NULL;

#ifndef _WIN32
static sigset_t fatal_signal_set;

// PID of currently executing compiler that we have started, if any. 0 means no
// ongoing compilation.
static pid_t compiler_pid = 0;
#endif

// This is a string that identifies the current ""version"" of the hash sum
// computed by ccache. If, for any reason, we want to force the hash sum to be
// different for the same input in a new ccache version, we can just change
// this string. A typical example would be if the format of one of the files
// stored in the cache changes in a backwards-incompatible way.
static const char HASH_PREFIX[] = ""3"";

static void
add_prefix(struct args *args, char *prefix_command)
{
	if (str_eq(prefix_command, """")) {
		return;
	}

	struct args *prefix = args_init(0, NULL);
	char *e = x_strdup(prefix_command);
	char *saveptr = NULL;
	for (char *tok = strtok_r(e, "" "", &saveptr);
	     tok;
	     tok = strtok_r(NULL, "" "", &saveptr)) {
		char *p;

		p = find_executable(tok, MYNAME);
		if (!p) {
			fatal(""%s: %s"", tok, strerror(errno));
		}

		args_add(prefix, p);
		free(p);
	}
	free(e);

	cc_log(""Using command-line prefix %s"", prefix_command);
	for (int i = prefix->argc; i != 0; i--) {
		args_add_prefix(args, prefix->argv[i-1]);
	}
	args_free(prefix);
}

// Something went badly wrong - just execute the real compiler.
static void
failed(void)
{
	assert(orig_args);

	args_strip(orig_args, ""--ccache-"");
	add_prefix(orig_args, conf->prefix_command);

	cc_log(""Failed; falling back to running the real compiler"");
	cc_log_argv(""Executing "", orig_args->argv);
	exitfn_call();
	execv(orig_args->argv[0], orig_args->argv);
	fatal(""execv of %s failed: %s"", orig_args->argv[0], strerror(errno));
}

static const char *
temp_dir()
{
	static char *path = NULL;
	if (path) {
		return path; // Memoize
	}
	path = conf->temporary_dir;
	if (str_eq(path, """")) {
		path = format(""%s/tmp"", conf->cache_dir);
	}
	return path;
}

void
block_signals(void)
{
#ifndef _WIN32
	sigprocmask(SIG_BLOCK, &fatal_signal_set, NULL);
#endif
}

void
unblock_signals(void)
{
#ifndef _WIN32
	sigset_t empty;
	sigemptyset(&empty);
	sigprocmask(SIG_SETMASK, &empty, NULL);
#endif
}

static void
add_pending_tmp_file(const char *path)
{
	block_signals();
	struct pending_tmp_file *e = x_malloc(sizeof(*e));
	e->path = x_strdup(path);
	e->next = pending_tmp_files;
	pending_tmp_files = e;
	unblock_signals();
}

static void
do_clean_up_pending_tmp_files(void)
{
	struct pending_tmp_file *p = pending_tmp_files;
	while (p) {
		// Can't call tmp_unlink here since its cc_log calls aren't signal safe.
		unlink(p->path);
		p = p->next;
		// Leak p->path and p here because clean_up_pending_tmp_files needs to be
		// signal safe.
	}
}

static void
clean_up_pending_tmp_files(void)
{
	block_signals();
	do_clean_up_pending_tmp_files();
	unblock_signals();
}

#ifndef _WIN32
static void
signal_handler(int signum)
{
	// Unregister handler for this signal so that we can send the signal to
	// ourselves at the end of the handler.
	signal(signum, SIG_DFL);

	// If ccache was killed explicitly, then bring the compiler subprocess (if
	// any) with us as well.
	if (signum == SIGTERM
	    && compiler_pid != 0
	    && waitpid(compiler_pid, NULL, WNOHANG) == 0) {
		kill(compiler_pid, signum);
	}

	do_clean_up_pending_tmp_files();

	if (compiler_pid != 0) {
		// Wait for compiler subprocess to exit before we snuff it.
		waitpid(compiler_pid, NULL, 0);
	}

	// Resend signal to ourselves to exit properly after returning from the
	// handler.
	kill(getpid(), signum);
}

static void
register_signal_handler(int signum)
{
	struct sigaction act;
	memset(&act, 0, sizeof(act));
	act.sa_handler = signal_handler;
	act.sa_mask = fatal_signal_set;
#ifdef SA_RESTART
	act.sa_flags = SA_RESTART;
#endif
	sigaction(signum, &act, NULL);
}

static void
set_up_signal_handlers(void)
{
	sigemptyset(&fatal_signal_set);
	sigaddset(&fatal_signal_set, SIGINT);
	sigaddset(&fatal_signal_set, SIGTERM);
#ifdef SIGHUP
	sigaddset(&fatal_signal_set, SIGHUP);
#endif
#ifdef SIGQUIT
	sigaddset(&fatal_signal_set, SIGQUIT);
#endif

	register_signal_handler(SIGINT);
	register_signal_handler(SIGTERM);
#ifdef SIGHUP
	register_signal_handler(SIGHUP);
#endif
#ifdef SIGQUIT
	register_signal_handler(SIGQUIT);
#endif
}
#endif // _WIN32

static void
clean_up_internal_tempdir(void)
{
	time_t now = time(NULL);
	struct stat st;
	if (x_stat(conf->cache_dir, &st) != 0 || st.st_mtime + 3600 >= now) {
		// No cleanup needed.
		return;
	}

	update_mtime(conf->cache_dir);

	DIR *dir = opendir(temp_dir());
	if (!dir) {
		return;
	}

	struct dirent *entry;
	while ((entry = readdir(dir))) {
		if (str_eq(entry->d_name, ""."") || str_eq(entry->d_name, "".."")) {
			continue;
		}

		char *path = format(""%s/%s"", temp_dir(), entry->d_name);
		if (x_lstat(path, &st) == 0 && st.st_mtime + 3600 < now) {
			tmp_unlink(path);
		}
		free(path);
	}

	closedir(dir);
}

static enum guessed_compiler
guess_compiler(const char *path)
{
	char *name = basename(path);
	enum guessed_compiler result = GUESSED_UNKNOWN;
	if (strstr(name, ""clang"")) {
		result = GUESSED_CLANG;
	} else if (strstr(name, ""gcc"") || strstr(name, ""g++"")) {
		result = GUESSED_GCC;
	} else if (strstr(name, ""nvcc"")) {
		result = GUESSED_NVCC;
	} else if (str_eq(name, ""pump"") || str_eq(name, ""distcc-pump"")) {
		result = GUESSED_PUMP;
	}
	free(name);
	return result;
}

static char *
get_current_working_dir(void)
{
	if (!current_working_dir) {
		char *cwd = get_cwd();
		if (cwd) {
			current_working_dir = x_realpath(cwd);
			free(cwd);
		}
		if (!current_working_dir) {
			cc_log(""Unable to determine current working directory: %s"",
			       strerror(errno));
			failed();
		}
	}
	return current_working_dir;
}

// Transform a name to a full path into the cache directory, creating needed
// sublevels if needed. Caller frees.
static char *
get_path_in_cache(const char *name, const char *suffix)
{
	char *path = x_strdup(conf->cache_dir);
	for (unsigned i = 0; i < conf->cache_dir_levels; ++i) {
		char *p = format(""%s/%c"", path, name[i]);
		free(path);
		path = p;
	}

	char *result =
	  format(""%s/%s%s"", path, name + conf->cache_dir_levels, suffix);
	free(path);
	return result;
}

// This function hashes an include file and stores the path and hash in the
// global included_files variable. If the include file is a PCH, cpp_hash is
// also updated. Takes over ownership of path.
static void
remember_include_file(char *path, struct mdfour *cpp_hash, bool system)
{
	size_t path_len = strlen(path);
	if (path_len >= 2 && (path[0] == '<' && path[path_len - 1] == '>')) {
		// Typically <built-in> or <command-line>.
		goto ignore;
	}

	if (str_eq(path, input_file)) {
		// Don't remember the input file.
		goto ignore;
	}

	if (system && (conf->sloppiness & SLOPPY_NO_SYSTEM_HEADERS)) {
		// Don't remember this system header.
		goto ignore;
	}

	if (hashtable_search(included_files, path)) {
		// Already known include file.
		goto ignore;
	}

#ifdef _WIN32
	// stat fails on directories on win32.
	DWORD attributes = GetFileAttributes(path);
	if (attributes != INVALID_FILE_ATTRIBUTES &&
	    attributes & FILE_ATTRIBUTE_DIRECTORY) {
		goto ignore;
	}
#endif

	struct stat st;
	if (x_stat(path, &st) != 0) {
		goto failure;
	}
	if (S_ISDIR(st.st_mode)) {
		// Ignore directory, typically $PWD.
		goto ignore;
	}
	if (!S_ISREG(st.st_mode)) {
		// Device, pipe, socket or other strange creature.
		cc_log(""Non-regular include file %s"", path);
		goto failure;
	}

	// Canonicalize path for comparison; clang uses ./header.h.
	char *canonical = path;
	size_t canonical_len = path_len;
	if (canonical[0] == '.' && canonical[1] == '/') {
		canonical += 2;
		canonical_len -= 2;
	}

	for (size_t i = 0; i < ignore_headers_len; i++) {
		char *ignore = ignore_headers[i];
		size_t ignore_len = strlen(ignore);
		if (ignore_len > canonical_len) {
			continue;
		}
		if (strncmp(canonical, ignore, ignore_len) == 0
		    && (ignore[ignore_len-1] == DIR_DELIM_CH
		        || canonical[ignore_len] == DIR_DELIM_CH
		        || canonical[ignore_len] == '\0')) {
			goto ignore;
		}
	}

	// The comparison using >= is intentional, due to a possible race between
	// starting compilation and writing the include file. See also the notes
	// under ""Performance"" in doc/MANUAL.adoc.
	if (!(conf->sloppiness & SLOPPY_INCLUDE_FILE_MTIME)
	    && st.st_mtime >= time_of_compilation) {
		cc_log(""Include file %s too new"", path);
		goto failure;
	}

	// The same >= logic as above applies to the change time of the file.
	if (!(conf->sloppiness & SLOPPY_INCLUDE_FILE_CTIME)
	    && st.st_ctime >= time_of_compilation) {
		cc_log(""Include file %s ctime too new"", path);
		goto failure;
	}

	// Let's hash the include file content.
	struct mdfour fhash;
	hash_start(&fhash);

	bool is_pch = is_precompiled_header(path);
	if (is_pch) {
		bool using_pch_sum = false;
		if (conf->pch_external_checksum) {
			// hash pch.sum instead of pch when it exists
			// to prevent hashing a very large .pch file every time
			char *pch_sum_path = format(""%s.sum"", path);
			if (x_stat(pch_sum_path, &st) == 0) {
				char *old_path = path;
				path = pch_sum_path;
				pch_sum_path = old_path;
				using_pch_sum = true;
				cc_log(""Using pch.sum file %s"", path);
			}
			free(pch_sum_path);
		}

		if (!hash_file(&fhash, path)) {
			goto failure;
		}
		struct file_hash pch_hash;
		hash_result_as_bytes(&fhash, pch_hash.hash);
		pch_hash.size = fhash.totalN;
		hash_delimiter(cpp_hash, using_pch_sum ? ""pch_sum_hash"" : ""pch_hash"");
		hash_buffer(cpp_hash, pch_hash.hash, sizeof(pch_hash.hash));
	}

	if (conf->direct_mode) {
		if (!is_pch) { // else: the file has already been hashed.
			char *source = NULL;
			size_t size;
			if (st.st_size > 0) {
				if (!read_file(path, st.st_size, &source, &size)) {
					goto failure;
				}
			} else {
				source = x_strdup("""");
				size = 0;
			}

			int result = hash_source_code_string(conf, &fhash, source, size, path);
			free(source);
			if (result & HASH_SOURCE_CODE_ERROR
			    || result & HASH_SOURCE_CODE_FOUND_TIME) {
				goto failure;
			}
		}

		struct file_hash *h = x_malloc(sizeof(*h));
		hash_result_as_bytes(&fhash, h->hash);
		h->size = fhash.totalN;
		hashtable_insert(included_files, path, h);
	} else {
		free(path);
	}

	return;

failure:
	if (conf->direct_mode) {
		cc_log(""Disabling direct mode"");
		conf->direct_mode = false;
	}
	// Fall through.
ignore:
	free(path);
}

// Make a relative path from current working directory to path if path is under
// the base directory. Takes over ownership of path. Caller frees.
static char *
make_relative_path(char *path)
{
	if (str_eq(conf->base_dir, """") || !str_startswith(path, conf->base_dir)) {
		return path;
	}

#ifdef _WIN32
	if (path[0] == '/') {
		path++;  // Skip leading slash.
	}
#endif

	// x_realpath only works for existing paths, so if path doesn't exist, try
	// dirname(path) and assemble the path afterwards. We only bother to try
	// canonicalizing one of these two paths since a compiler path argument
	// typically only makes sense if path or dirname(path) exists.
	char *path_suffix = NULL;
	struct stat st;
	if (stat(path, &st) != 0) {
		// path doesn't exist.
		char *dir = dirname(path);
		if (stat(dir, &st) != 0) {
			// And neither does its parent directory, so no action to take.
			free(dir);
			return path;
		}
		free(dir);
		path_suffix = basename(path);
		char *p = path;
		path = dirname(path);
		free(p);
	}

	char *canon_path = x_realpath(path);
	if (canon_path) {
		free(path);
		char *relpath = get_relative_path(get_current_working_dir(), canon_path);
		free(canon_path);
		if (path_suffix) {
			path = format(""%s/%s"", relpath, path_suffix);
			free(relpath);
			free(path_suffix);
			return path;
		} else {
			return relpath;
		}
	} else {
		// path doesn't exist, so leave it as it is.
		free(path_suffix);
		return path;
	}
}

// This function reads and hashes a file. While doing this, it also does these
// things:
//
// - Makes include file paths for which the base directory is a prefix relative
//   when computing the hash sum.
// - Stores the paths and hashes of included files in the global variable
//   included_files.
static bool
process_preprocessed_file(struct mdfour *hash, const char *path, bool pump)
{
	char *data;
	size_t size;
	if (!read_file(path, 0, &data, &size)) {
		return false;
	}

	ignore_headers = NULL;
	ignore_headers_len = 0;
	if (!str_eq(conf->ignore_headers_in_manifest, """")) {
		char *header, *p, *q, *saveptr = NULL;
		p = x_strdup(conf->ignore_headers_in_manifest);
		q = p;
		while ((header = strtok_r(q, PATH_DELIM, &saveptr))) {
			ignore_headers = x_realloc(ignore_headers,
			                           (ignore_headers_len+1) * sizeof(char *));
			ignore_headers[ignore_headers_len++] = x_strdup(header);
			q = NULL;
		}
		free(p);
	}

	if (!included_files) {
		included_files = create_hashtable(1000, hash_from_string, strings_equal);
	}

	char *cwd = NULL;
	if (!conf->hash_dir) {
		cwd = gnu_getcwd();
	}

	// Bytes between p and q are pending to be hashed.
	char *p = data;
	char *q = data;
	char *end = data + size;

	// There must be at least 7 characters (# 1 ""x"") left to potentially find an
	// include file path.
	while (q < end - 7) {
		// Check if we look at a line containing the file name of an included file.
		// At least the following formats exist (where N is a positive integer):
		//
		// GCC:
		//
		//   # N ""file""
		//   # N ""file"" N
		//   #pragma GCC pch_preprocess ""file""
		//
		// HP's compiler:
		//
		//   #line N ""file""
		//
		// AIX's compiler:
		//
		//   #line N ""file""
		//   #line N
		//
		// Note that there may be other lines starting with '#' left after
		// preprocessing as well, for instance ""#    pragma"".
		if (q[0] == '#'
		    // GCC:
		    && ((q[1] == ' ' && q[2] >= '0' && q[2] <= '9')
		        // GCC precompiled header:
		        || (q[1] == 'p'
		            && str_startswith(&q[2], ""ragma GCC pch_preprocess ""))
		        // HP/AIX:
		        || (q[1] == 'l' && q[2] == 'i' && q[3] == 'n' && q[4] == 'e'
		            && q[5] == ' '))
		    && (q == data || q[-1] == '\n')) {
			// Workarounds for preprocessor linemarker bugs in GCC version 6.
			if (q[2] == '3') {
				if (str_startswith(q, ""# 31 \""<command-line>\""\n"")) {
					// Bogus extra line with #31, after the regular #1: Ignore the whole
					// line, and continue parsing.
					hash_buffer(hash, p, q - p);
					while (q < end && *q != '\n') {
						q++;
					}
					q++;
					p = q;
					continue;
				} else if (str_startswith(q, ""# 32 \""<command-line>\"" 2\n"")) {
					// Bogus wrong line with #32, instead of regular #1: Replace the line
					// number with the usual one.
					hash_buffer(hash, p, q - p);
					q += 1;
					q[0] = '#';
					q[1] = ' ';
					q[2] = '1';
					p = q;
				}
			}

			while (q < end && *q != '""' && *q != '\n') {
				q++;
			}
			if (q < end && *q == '\n') {
				// A newline before the quotation mark -> no match.
				continue;
			}
			q++;
			if (q >= end) {
				cc_log(""Failed to parse included file path"");
				free(data);
				return false;
			}
			// q points to the beginning of an include file path
			hash_buffer(hash, p, q - p);
			p = q;
			while (q < end && *q != '""') {
				q++;
			}
			// Look for preprocessor flags, after the ""filename"".
			bool system = false;
			char *r = q + 1;
			while (r < end && *r != '\n') {
				if (*r == '3') { // System header.
					system = true;
				}
				r++;
			}
			// p and q span the include file path.
			char *inc_path = x_strndup(p, q - p);
			if (!has_absolute_include_headers) {
				has_absolute_include_headers = is_absolute_path(inc_path);
			}
			inc_path = make_relative_path(inc_path);

			bool should_hash_inc_path = true;
			if (!conf->hash_dir) {
				if (str_startswith(inc_path, cwd) && str_endswith(inc_path, ""//"")) {
					// When compiling with -g or similar, GCC adds the absolute path to
					// CWD like this:
					//
					//   # 1 ""CWD//""
					//
					// If the user has opted out of including the CWD in the hash, don't
					// hash it. See also how debug_prefix_map is handled.
					should_hash_inc_path = false;
				}
			}
			if (should_hash_inc_path) {
				hash_string(hash, inc_path);
			}

			remember_include_file(inc_path, hash, system);
			p = q; // Everything of interest between p and q has been hashed now.
		} else if (q[0] == '.' && q[1] == 'i' && q[2] == 'n' && q[3] == 'c'
		           && q[4] == 'b' && q[5] == 'i' && q[6] == 'n') {
			// An assembler .inc bin (without the space) statement, which could be
			// part of inline assembly, refers to an external file. If the file
			// changes, the hash should change as well, but finding out what file to
			// hash is too hard for ccache, so just bail out.
			cc_log(""Found unsupported .inc"" ""bin directive in source code"");
			stats_update(STATS_UNSUPPORTED_DIRECTIVE);
			failed();
		} else if (pump && strncmp(q, ""_________"", 9) == 0) {
			// Unfortunately the distcc-pump wrapper outputs standard output lines:
			// __________Using distcc-pump from /usr/bin
			// __________Using # distcc servers in pump mode
			// __________Shutting down distcc-pump include server
			while (q < end && *q != '\n') {
				q++;
			}
			if (*q == '\n') {
				q++;
			}
			p = q;
			continue;
		} else {
			q++;
		}
	}

	hash_buffer(hash, p, (end - p));
	free(data);
	free(cwd);

	// Explicitly check the .gch/.pch/.pth file, Clang does not include any
	// mention of it in the preprocessed output.
	if (included_pch_file) {
		char *path = x_strdup(included_pch_file);
		path = make_relative_path(path);
		hash_string(hash, path);
		remember_include_file(path, hash, false);
	}

	return true;
}

// Replace absolute paths with relative paths in the provided dependency file.
static void
use_relative_paths_in_depfile(const char *depfile)
{
	if (str_eq(conf->base_dir, """")) {
		cc_log(""Base dir not set, skip using relative paths"");
		return; // nothing to do
	}
	if (!has_absolute_include_headers) {
		cc_log(""No absolute path for included files found, skip using relative""
		       "" paths"");
		return; // nothing to do
	}

	FILE *f;
	f = fopen(depfile, ""r"");
	if (!f) {
		cc_log(""Cannot open dependency file: %s (%s)"", depfile, strerror(errno));
		return;
	}

	char *tmp_file = format(""%s.tmp"", depfile);
	FILE *tmpf = create_tmp_file(&tmp_file, ""w"");

	bool result = false;
	char buf[10000];
	while (fgets(buf, sizeof(buf), f) && !ferror(tmpf)) {
		char *saveptr;
		char *token = strtok_r(buf, "" \t"", &saveptr);
		while (token) {
			char *relpath;
			if (is_absolute_path(token) && str_startswith(token, conf->base_dir)) {
				relpath = make_relative_path(x_strdup(token));
				result = true;
			} else {
				relpath = token;
			}
			if (token != buf) { // This is a dependency file.
				fputc(' ', tmpf);
			}
			fputs(relpath, tmpf);
			if (relpath != token) {
				free(relpath);
			}
			token = strtok_r(NULL, "" \t"", &saveptr);
		}
	}

	if (ferror(f)) {
		cc_log(""Error reading dependency file: %s, skip relative path usage"",
		       depfile);
		result = false;
		goto out;
	}
	if (ferror(tmpf)) {
		cc_log(""Error writing temporary dependency file: %s, skip relative path""
		       "" usage"", tmp_file);
		result = false;
		goto out;
	}

out:
	fclose(tmpf);
	fclose(f);
	if (result) {
		if (x_rename(tmp_file, depfile) != 0) {
			cc_log(""Error renaming dependency file: %s -> %s (%s), skip relative""
			       "" path usage"", tmp_file, depfile, strerror(errno));
			result = false;
		} else {
			cc_log(""Renamed dependency file: %s -> %s"", tmp_file, depfile);
		}
	}
	if (!result) {
		cc_log(""Removing temporary dependency file: %s"", tmp_file);
		x_unlink(tmp_file);
	}
	free(tmp_file);
}

// Helper method for copy_file_to_cache and move_file_to_cache_same_fs.
static void
do_copy_or_move_file_to_cache(const char *source, const char *dest, bool copy)
{
	assert(!conf->read_only);
	assert(!conf->read_only_direct);

	struct stat orig_dest_st;
	bool orig_dest_existed = stat(dest, &orig_dest_st) == 0;
	int compression_level = conf->compression ? conf->compression_level : 0;
	bool do_move = !copy && !conf->compression;
	bool do_link = copy && conf->hard_link && !conf->compression;

	if (do_move) {
		move_uncompressed_file(source, dest, compression_level);
	} else {
		if (do_link) {
			x_unlink(dest);
			int ret = link(source, dest);
			if (ret == 0) {
			} else {
				cc_log(""Failed to link %s to %s: %s"", source, dest, strerror(errno));
				cc_log(""Falling back to copying"");
				do_link = false;
			}
		}
		if (!do_link) {
			int ret = copy_file(source, dest, compression_level);
			if (ret != 0) {
				cc_log(""Failed to copy %s to %s: %s"", source, dest, strerror(errno));
				stats_update(STATS_ERROR);
				failed();
			}
		}
	}

	if (!copy && conf->compression) {
		// We fell back to copying since dest should be compressed, so clean up.
		x_unlink(source);
	}

	cc_log(""Stored in cache: %s -> %s (%s)"",
	       source,
	       dest,
	       do_move ? ""moved"" : (do_link ? ""linked"" : ""copied""));

	struct stat st;
	if (x_stat(dest, &st) != 0) {
		stats_update(STATS_ERROR);
		failed();
	}
	stats_update_size(
	  file_size(&st) - (orig_dest_existed ? file_size(&orig_dest_st) : 0),
	  orig_dest_existed ? 0 : 1);
}

// Copy a file into the cache.
//
// dest must be a path in the cache (see get_path_in_cache). source does not
// have to be on the same file system as dest.
//
// An attempt will be made to hard link source to dest if conf->hard_link is
// true and conf->compression is false, otherwise copy. dest will be compressed
// if conf->compression is true.
static void
copy_file_to_cache(const char *source, const char *dest)
{
	do_copy_or_move_file_to_cache(source, dest, true);
}

// Move a file into the cache.
//
// dest must be a path in the cache (see get_path_in_cache). source must be on
// the same file system as dest. dest will be compressed if conf->compression
// is true.
static void
move_file_to_cache_same_fs(const char *source, const char *dest)
{
	do_copy_or_move_file_to_cache(source, dest, false);
}

// Copy or link a file from the cache.
static void
get_file_from_cache(const char *source, const char *dest)
{
	int ret;
	bool do_link = conf->hard_link && !file_is_compressed(source);
	if (do_link) {
		x_unlink(dest);
		ret = link(source, dest);
	} else {
		ret = copy_file(source, dest, 0);
	}

	if (ret == -1) {
		if (errno == ENOENT || errno == ESTALE) {
			cc_log(""File missing in cache: %s"", source);
			stats_update(STATS_MISSING);
		} else {
			cc_log(""Failed to %s %s to %s: %s"",
			       do_link ? ""link"" : ""copy"",
			       source,
			       dest,
			       strerror(errno));
			stats_update(STATS_ERROR);
		}

		// If there was trouble getting a file from the cached result, wipe the
		// whole cached result for consistency.
		x_unlink(cached_stderr);
		x_unlink(cached_obj);
		x_unlink(cached_dep);
		x_unlink(cached_cov);
		x_unlink(cached_su);
		x_unlink(cached_dia);
		x_unlink(cached_dwo);

		failed();
	}

	cc_log(""Created from cache: %s -> %s"", source, dest);
}

// Send cached stderr, if any, to stderr.
static void
send_cached_stderr(void)
{
	int fd_stderr = open(cached_stderr, O_RDONLY | O_BINARY);
	if (fd_stderr != -1) {
		copy_fd(fd_stderr, 2);
		close(fd_stderr);
	}
}

// Create or update the manifest file.
void update_manifest_file(void)
{
	if (!conf->direct_mode
	    || !included_files
	    || conf->read_only
	    || conf->read_only_direct) {
		return;
	}

	struct stat st;
	size_t old_size = 0; // in bytes
	if (stat(manifest_path, &st) == 0) {
		old_size = file_size(&st);
	}
	if (manifest_put(manifest_path, cached_obj_hash, included_files)) {
		cc_log(""Added object file hash to %s"", manifest_path);
		update_mtime(manifest_path);
		if (x_stat(manifest_path, &st) == 0) {
			stats_update_size(file_size(&st) - old_size, old_size == 0 ? 1 : 0);
		}
	} else {
		cc_log(""Failed to add object file hash to %s"", manifest_path);
	}
}

// Run the real compiler and put the result in cache.
static void
to_cache(struct args *args)
{
	char *tmp_stdout = format(""%s.tmp.stdout"", cached_obj);
	int tmp_stdout_fd = create_tmp_fd(&tmp_stdout);
	char *tmp_stderr = format(""%s.tmp.stderr"", cached_obj);
	int tmp_stderr_fd = create_tmp_fd(&tmp_stderr);

	args_add(args, ""-o"");
	args_add(args, output_obj);

	if (generating_diagnostics) {
		args_add(args, ""--serialize-diagnostics"");
		args_add(args, output_dia);
	}

	// Turn off DEPENDENCIES_OUTPUT when running cc1, because otherwise it will
	// emit a line like this:
	//
	//   tmp.stdout.vexed.732.o: /home/mbp/.ccache/tmp.stdout.vexed.732.i
	x_unsetenv(""DEPENDENCIES_OUTPUT"");

	if (conf->run_second_cpp) {
		args_add(args, input_file);
	} else {
		args_add(args, i_tmpfile);
	}

	cc_log(""Running real compiler"");
	int status =
	  execute(args->argv, tmp_stdout_fd, tmp_stderr_fd, &compiler_pid);
	args_pop(args, 3);

	struct stat st;
	if (x_stat(tmp_stdout, &st) != 0) {
		// The stdout file was removed - cleanup in progress? Better bail out.
		stats_update(STATS_MISSING);
		tmp_unlink(tmp_stdout);
		tmp_unlink(tmp_stderr);
		failed();
	}

	// distcc-pump outputs lines like this:
	// __________Using # distcc servers in pump mode
	if (st.st_size != 0 && guessed_compiler != GUESSED_PUMP) {
		cc_log(""Compiler produced stdout"");
		stats_update(STATS_STDOUT);
		tmp_unlink(tmp_stdout);
		tmp_unlink(tmp_stderr);
		failed();
	}
	tmp_unlink(tmp_stdout);

	// Merge stderr from the preprocessor (if any) and stderr from the real
	// compiler into tmp_stderr.
	if (cpp_stderr) {
		char *tmp_stderr2 = format(""%s.2"", tmp_stderr);
		if (x_rename(tmp_stderr, tmp_stderr2)) {
			cc_log(""Failed to rename %s to %s: %s"", tmp_stderr, tmp_stderr2,
			       strerror(errno));
			failed();
		}

		int fd_cpp_stderr = open(cpp_stderr, O_RDONLY | O_BINARY);
		if (fd_cpp_stderr == -1) {
			cc_log(""Failed opening %s: %s"", cpp_stderr, strerror(errno));
			failed();
		}

		int fd_real_stderr = open(tmp_stderr2, O_RDONLY | O_BINARY);
		if (fd_real_stderr == -1) {
			cc_log(""Failed opening %s: %s"", tmp_stderr2, strerror(errno));
			failed();
		}

		int fd_result =
		  open(tmp_stderr, O_WRONLY | O_CREAT | O_TRUNC | O_BINARY, 0666);
		if (fd_result == -1) {
			cc_log(""Failed opening %s: %s"", tmp_stderr, strerror(errno));
			failed();
		}

		copy_fd(fd_cpp_stderr, fd_result);
		copy_fd(fd_real_stderr, fd_result);
		close(fd_cpp_stderr);
		close(fd_real_stderr);
		close(fd_result);
		tmp_unlink(tmp_stderr2);
		free(tmp_stderr2);
	}

	if (status != 0) {
		cc_log(""Compiler gave exit status %d"", status);
		stats_update(STATS_STATUS);

		int fd = open(tmp_stderr, O_RDONLY | O_BINARY);
		if (fd != -1) {
			// We can output stderr immediately instead of rerunning the compiler.
			copy_fd(fd, 2);
			close(fd);
			tmp_unlink(tmp_stderr);

			x_exit(status);
		}

		tmp_unlink(tmp_stderr);
		failed();
	}

	if (stat(output_obj, &st) != 0) {
		cc_log(""Compiler didn't produce an object file"");
		stats_update(STATS_NOOUTPUT);
		failed();
	}
	if (st.st_size == 0) {
		cc_log(""Compiler produced an empty object file"");
		stats_update(STATS_EMPTYOUTPUT);
		failed();
	}

	if (x_stat(tmp_stderr, &st) != 0) {
		stats_update(STATS_ERROR);
		failed();
	}
	if (st.st_size > 0) {
		move_file_to_cache_same_fs(tmp_stderr, cached_stderr);
	} else {
		tmp_unlink(tmp_stderr);
		if (conf->recache) {
			// If recaching, we need to remove any previous .stderr.
			x_unlink(cached_stderr);
		}
	}

	copy_file_to_cache(output_obj, cached_obj);
	if (generating_dependencies) {
		use_relative_paths_in_depfile(output_dep);
		copy_file_to_cache(output_dep, cached_dep);
	}
	if (generating_coverage) {
		copy_file_to_cache(output_cov, cached_cov);
	}
	if (generating_stackusage) {
		copy_file_to_cache(output_su, cached_su);
	}
	if (generating_diagnostics) {
		copy_file_to_cache(output_dia, cached_dia);
	}
	if (using_split_dwarf) {
		copy_file_to_cache(output_dwo, cached_dwo);
	}

	stats_update(STATS_TOCACHE);

	// Make sure we have a CACHEDIR.TAG in the cache part of cache_dir. This can
	// be done almost anywhere, but we might as well do it near the end as we
	// save the stat call if we exit early.
	{
		char *first_level_dir = dirname(stats_file);
		if (create_cachedirtag(first_level_dir) != 0) {
			cc_log(""Failed to create %s/CACHEDIR.TAG (%s)\n"",
			       first_level_dir, strerror(errno));
			stats_update(STATS_ERROR);
			failed();
		}
		free(first_level_dir);

		// Remove any CACHEDIR.TAG on the cache_dir level where it was located in
		// previous ccache versions.
		if (getpid() % 1000 == 0) {
			char *path = format(""%s/CACHEDIR.TAG"", conf->cache_dir);
			x_unlink(path);
			free(path);
		}
	}

	// Everything OK.
	send_cached_stderr();
	update_manifest_file();

	free(tmp_stderr);
	free(tmp_stdout);
}

// Find the object file name by running the compiler in preprocessor mode.
// Returns the hash as a heap-allocated hex string.
static struct file_hash *
get_object_name_from_cpp(struct args *args, struct mdfour *hash)
{
	time_of_compilation = time(NULL);

	char *path_stderr = NULL;
	char *path_stdout;
	int status;
	if (direct_i_file) {
		// We are compiling a .i or .ii file - that means we can skip the cpp stage
		// and directly form the correct i_tmpfile.
		path_stdout = input_file;
		status = 0;
	} else {
		// Run cpp on the input file to obtain the .i.

		// Limit the basename to 10 characters in order to cope with filesystem with
		// small maximum filename length limits.
		char *input_base = basename(input_file);
		char *tmp = strchr(input_base, '.');
		if (tmp) {
			*tmp = 0;
		}
		if (strlen(input_base) > 10) {
			input_base[10] = 0;
		}

		path_stdout = format(""%s/%s.stdout"", temp_dir(), input_base);
		int path_stdout_fd = create_tmp_fd(&path_stdout);
		add_pending_tmp_file(path_stdout);

		path_stderr = format(""%s/tmp.cpp_stderr"", temp_dir());
		int path_stderr_fd = create_tmp_fd(&path_stderr);
		add_pending_tmp_file(path_stderr);

		int args_added = 2;
		args_add(args, ""-E"");
		if (conf->keep_comments_cpp) {
			args_add(args, ""-C"");
			args_added = 3;
		}
		args_add(args, input_file);
		add_prefix(args, conf->prefix_command_cpp);
		cc_log(""Running preprocessor"");
		status = execute(args->argv, path_stdout_fd, path_stderr_fd, &compiler_pid);
		args_pop(args, args_added);
	}

	if (status != 0) {
		cc_log(""Preprocessor gave exit status %d"", status);
		stats_update(STATS_PREPROCESSOR);
		failed();
	}

	if (conf->unify) {
		// When we are doing the unifying tricks we need to include the input file
		// name in the hash to get the warnings right.
		hash_delimiter(hash, ""unifyfilename"");
		hash_string(hash, input_file);

		hash_delimiter(hash, ""unifycpp"");

		bool debug_unify = getenv(""CCACHE_DEBUG_UNIFY"");
		if (unify_hash(hash, path_stdout, debug_unify) != 0) {
			stats_update(STATS_ERROR);
			cc_log(""Failed to unify %s"", path_stdout);
			failed();
		}
	} else {
		hash_delimiter(hash, ""cpp"");
		if (!process_preprocessed_file(hash, path_stdout,
		                               guessed_compiler == GUESSED_PUMP)) {
			stats_update(STATS_ERROR);
			failed();
		}
	}

	hash_delimiter(hash, ""cppstderr"");
	if (!direct_i_file && !hash_file(hash, path_stderr)) {
		fatal(""Failed to open %s: %s"", path_stderr, strerror(errno));
	}

	if (direct_i_file) {
		i_tmpfile = input_file;
	} else {
		// i_tmpfile needs the proper cpp_extension for the compiler to do its
		// thing correctly
		i_tmpfile = format(""%s.%s"", path_stdout, conf->cpp_extension);
		x_rename(path_stdout, i_tmpfile);
		add_pending_tmp_file(i_tmpfile);
	}

	if (conf->run_second_cpp) {
		free(path_stderr);
	} else {
		// If we are using the CPP trick, we need to remember this stderr data and
		// output it just before the main stderr from the compiler pass.
		cpp_stderr = path_stderr;
		hash_delimiter(hash, ""runsecondcpp"");
		hash_string(hash, ""false"");
	}

	struct file_hash *result = x_malloc(sizeof(*result));
	hash_result_as_bytes(hash, result->hash);
	result->size = hash->totalN;
	return result;
}

static void
update_cached_result_globals(struct file_hash *hash)
{
	char *object_name = format_hash_as_string(hash->hash, hash->size);
	cached_obj_hash = hash;
	cached_obj = get_path_in_cache(object_name, "".o"");
	cached_stderr = get_path_in_cache(object_name, "".stderr"");
	cached_dep = get_path_in_cache(object_name, "".d"");
	cached_cov = get_path_in_cache(object_name, "".gcno"");
	cached_su = get_path_in_cache(object_name, "".su"");
	cached_dia = get_path_in_cache(object_name, "".dia"");
	cached_dwo = get_path_in_cache(object_name, "".dwo"");

	stats_file = format(""%s/%c/stats"", conf->cache_dir, object_name[0]);
	free(object_name);
}

// Hash mtime or content of a file, or the output of a command, according to
// the CCACHE_COMPILERCHECK setting.
static void
hash_compiler(struct mdfour *hash, struct stat *st, const char *path,
              bool allow_command)
{
	if (str_eq(conf->compiler_check, ""none"")) {
		// Do nothing.
	} else if (str_eq(conf->compiler_check, ""mtime"")) {
		hash_delimiter(hash, ""cc_mtime"");
		hash_int(hash, st->st_size);
		hash_int(hash, st->st_mtime);
	} else if (str_startswith(conf->compiler_check, ""string:"")) {
		hash_delimiter(hash, ""cc_hash"");
		hash_string(hash, conf->compiler_check + strlen(""string:""));
	} else if (str_eq(conf->compiler_check, ""content"") || !allow_command) {
		hash_delimiter(hash, ""cc_content"");
		hash_file(hash, path);
	} else { // command string
		if (!hash_multicommand_output(
		      hash, conf->compiler_check, orig_args->argv[0])) {
			fatal(""Failure running compiler check command: %s"", conf->compiler_check);
		}
	}
}

// Hash the host compiler(s) invoked by nvcc.
//
// If ccbin_st and ccbin are set, they refer to a directory or compiler set
// with -ccbin/--compiler-bindir. If they are NULL, the compilers are looked up
// in PATH instead.
static void
hash_nvcc_host_compiler(struct mdfour *hash, struct stat *ccbin_st,
                        const char *ccbin)
{
	// From <http://docs.nvidia.com/cuda/cuda-compiler-driver-nvcc/index.html>:
	//
	//   ""[...] Specify the directory in which the compiler executable resides.
	//   The host compiler executable name can be also specified to ensure that
	//   the correct host compiler is selected.""
	//
	// and
	//
	//   ""On all platforms, the default host compiler executable (gcc and g++ on
	//   Linux, clang and clang++ on Mac OS X, and cl.exe on Windows) found in
	//   the current execution search path will be used"".

	if (!ccbin || S_ISDIR(ccbin_st->st_mode)) {
#if defined(__APPLE__)
		const char *compilers[] = {""clang"", ""clang++""};
#elif defined(_WIN32)
		const char *compilers[] = {""cl.exe""};
#else
		const char *compilers[] = {""gcc"", ""g++""};
#endif
		for (size_t i = 0; i < ARRAY_SIZE(compilers); i++) {
			if (ccbin) {
				char *path = format(""%s/%s"", ccbin, compilers[i]);
				struct stat st;
				if (stat(path, &st) == 0) {
					hash_compiler(hash, &st, path, false);
				}
				free(path);
			} else {
				char *path = find_executable(compilers[i], MYNAME);
				if (path) {
					struct stat st;
					x_stat(path, &st);
					hash_compiler(hash, &st, ccbin, false);
					free(path);
				}
			}
		}
	} else {
		hash_compiler(hash, ccbin_st, ccbin, false);
	}
}

// Update a hash sum with information common for the direct and preprocessor
// modes.
static void
calculate_common_hash(struct args *args, struct mdfour *hash)
{
	hash_string(hash, HASH_PREFIX);

	// We have to hash the extension, as a .i file isn't treated the same by the
	// compiler as a .ii file.
	hash_delimiter(hash, ""ext"");
	hash_string(hash, conf->cpp_extension);

#ifdef _WIN32
	const char *ext = strrchr(args->argv[0], '.');
	char full_path_win_ext[MAX_PATH + 1] = {0};
	add_exe_ext_if_no_to_fullpath(full_path_win_ext, MAX_PATH, ext,
	                              args->argv[0]);
	const char *full_path = full_path_win_ext;
#else
	const char *full_path = args->argv[0];
#endif

	struct stat st;
	if (x_stat(full_path, &st) != 0) {
		stats_update(STATS_COMPILER);
		failed();
	}

	// Hash information about the compiler.
	hash_compiler(hash, &st, args->argv[0], true);

	// Also hash the compiler name as some compilers use hard links and behave
	// differently depending on the real name.
	hash_delimiter(hash, ""cc_name"");
	char *p = basename(args->argv[0]);
	hash_string(hash, p);
	free(p);

	// Possibly hash the current working directory.
	if (generating_debuginfo && conf->hash_dir) {
		char *cwd = gnu_getcwd();
		for (size_t i = 0; i < debug_prefix_maps_len; i++) {
			char *map = debug_prefix_maps[i];
			char *sep = strchr(map, '=');
			if (sep) {
				char *old = x_strndup(map, sep - map);
				char *new = x_strdup(sep + 1);
				cc_log(""Relocating debuginfo CWD %s from %s to %s"", cwd, old, new);
				if (str_startswith(cwd, old)) {
					char *dir = format(""%s%s"", new, cwd + strlen(old));
					free(cwd);
					cwd = dir;
				}
				free(old);
				free(new);
			}
		}
		if (cwd) {
			cc_log(""Hashing CWD %s"", cwd);
			hash_delimiter(hash, ""cwd"");
			hash_string(hash, cwd);
			free(cwd);
		}
	}

	// Possibly hash the coverage data file path.
	if (generating_coverage && profile_arcs) {
		char *dir = dirname(output_obj);
		if (profile_dir) {
			dir = x_strdup(profile_dir);
		} else {
			char *real_dir = x_realpath(dir);
			free(dir);
			dir = real_dir;
		}
		if (dir) {
			char *base_name = basename(output_obj);
			p = remove_extension(base_name);
			free(base_name);
			char *gcda_path = format(""%s/%s.gcda"", dir, p);
			cc_log(""Hashing coverage path %s"", gcda_path);
			free(p);
			hash_delimiter(hash, ""gcda"");
			hash_string(hash, gcda_path);
			free(dir);
		}
	}

	// Possibly hash the sanitize blacklist file path.
	if (sanitize_blacklist) {
		cc_log(""Hashing sanitize blacklist %s"", sanitize_blacklist);
		hash_delimiter(hash, ""sanitizeblacklist"");
		if (!hash_file(hash, sanitize_blacklist)) {
			stats_update(STATS_BADEXTRAFILE);
			failed();
		}
	}

	if (!str_eq(conf->extra_files_to_hash, """")) {
		char *p = x_strdup(conf->extra_files_to_hash);
		char *q = p;
		char *path;
		char *saveptr = NULL;
		while ((path = strtok_r(q, PATH_DELIM, &saveptr))) {
			cc_log(""Hashing extra file %s"", path);
			hash_delimiter(hash, ""extrafile"");
			if (!hash_file(hash, path)) {
				stats_update(STATS_BADEXTRAFILE);
				failed();
			}
			q = NULL;
		}
		free(p);
	}

	// Possibly hash GCC_COLORS (for color diagnostics).
	if (guessed_compiler == GUESSED_GCC) {
		const char *gcc_colors = getenv(""GCC_COLORS"");
		if (gcc_colors) {
			hash_delimiter(hash, ""gcccolors"");
			hash_string(hash, gcc_colors);
		}
	}
}

// Update a hash sum with information specific to the direct and preprocessor
// modes and calculate the object hash. Returns the object hash on success,
// otherwise NULL. Caller frees.
static struct file_hash *
calculate_object_hash(struct args *args, struct mdfour *hash, int direct_mode)
{
	bool found_ccbin = false;

	if (direct_mode) {
		hash_delimiter(hash, ""manifest version"");
		hash_int(hash, MANIFEST_VERSION);
	}

	// clang will emit warnings for unused linker flags, so we shouldn't skip
	// those arguments.
	int is_clang = (guessed_compiler == GUESSED_CLANG || guessed_compiler == GUESSED_UNKNOWN);

	// First the arguments.
	for (int i = 1; i < args->argc; i++) {
		// -L doesn't affect compilation (except for clang).
		if (i < args->argc-1 && str_eq(args->argv[i], ""-L"") && !is_clang) {
			i++;
			continue;
		}
		if (str_startswith(args->argv[i], ""-L"") && !is_clang) {
			continue;
		}

		// -Wl,... doesn't affect compilation (except for clang).
		if (str_startswith(args->argv[i], ""-Wl,"") && !is_clang) {
			continue;
		}

		// The -fdebug-prefix-map option may be used in combination with
		// CCACHE_BASEDIR to reuse results across different directories. Skip it
		// from hashing.
		if (str_startswith(args->argv[i], ""-fdebug-prefix-map="")) {
			continue;
		}

		// When using the preprocessor, some arguments don't contribute to the
		// hash. The theory is that these arguments will change the output of -E if
		// they are going to have any effect at all. For precompiled headers this
		// might not be the case.
		if (!direct_mode && !output_is_precompiled_header
		    && !using_precompiled_header) {
			if (compopt_affects_cpp(args->argv[i])) {
				if (compopt_takes_arg(args->argv[i])) {
					i++;
				}
				continue;
			}
			if (compopt_short(compopt_affects_cpp, args->argv[i])) {
				continue;
			}
		}

		// If we're generating dependencies, we make sure to skip the filename of
		// the dependency file, since it doesn't impact the output.
		if (generating_dependencies) {
			if (str_startswith(args->argv[i], ""-Wp,"")) {
				if (str_startswith(args->argv[i], ""-Wp,-MD,"")
				    && !strchr(args->argv[i] + 8, ',')) {
					hash_string_length(hash, args->argv[i], 8);
					continue;
				} else if (str_startswith(args->argv[i], ""-Wp,-MMD,"")
				           && !strchr(args->argv[i] + 9, ',')) {
					hash_string_length(hash, args->argv[i], 9);
					continue;
				}
			} else if (str_startswith(args->argv[i], ""-MF"")) {
				// In either case, hash the ""-MF"" part.
				hash_delimiter(hash, ""arg"");
				hash_string_length(hash, args->argv[i], 3);

				bool separate_argument = (strlen(args->argv[i]) == 3);
				if (separate_argument) {
					// Next argument is dependency name, so skip it.
					i++;
				}
				continue;
			}
		}

		char *p = NULL;
		if (str_startswith(args->argv[i], ""-specs="")) {
			p = args->argv[i] + 7;
		} else if (str_startswith(args->argv[i], ""--specs="")) {
			p = args->argv[i] + 8;
		}

		struct stat st;
		if (p && x_stat(p, &st) == 0) {
			// If given an explicit specs file, then hash that file, but don't
			// include the path to it in the hash.
			hash_delimiter(hash, ""specs"");
			hash_compiler(hash, &st, p, false);
			continue;
		}

		if (str_startswith(args->argv[i], ""-fplugin="")
		    && x_stat(args->argv[i] + 9, &st) == 0) {
			hash_delimiter(hash, ""plugin"");
			hash_compiler(hash, &st, args->argv[i] + 9, false);
			continue;
		}

		if (str_eq(args->argv[i], ""-Xclang"")
		    && i + 3 < args->argc
		    && str_eq(args->argv[i+1], ""-load"")
		    && str_eq(args->argv[i+2], ""-Xclang"")
		    && x_stat(args->argv[i+3], &st) == 0) {
			hash_delimiter(hash, ""plugin"");
			hash_compiler(hash, &st, args->argv[i+3], false);
			i += 3;
			continue;
		}

		if ((str_eq(args->argv[i], ""-ccbin"")
		     || str_eq(args->argv[i], ""--compiler-bindir""))
		    && i + 1 < args->argc
		    && x_stat(args->argv[i+1], &st) == 0) {
			found_ccbin = true;
			hash_delimiter(hash, ""ccbin"");
			hash_nvcc_host_compiler(hash, &st, args->argv[i+1]);
			i++;
			continue;
		}

		// All other arguments are included in the hash.
		hash_delimiter(hash, ""arg"");
		hash_string(hash, args->argv[i]);
		if (i + 1 < args->argc && compopt_takes_arg(args->argv[i])) {
			i++;
			hash_delimiter(hash, ""arg"");
			hash_string(hash, args->argv[i]);
		}
	}

	if (!found_ccbin && str_eq(actual_language, ""cuda"")) {
		hash_nvcc_host_compiler(hash, NULL, NULL);
	}

	// For profile generation (-fprofile-arcs, -fprofile-generate):
	// - hash profile directory
	//
	// For profile usage (-fprofile-use):
	// - hash profile data
	//
	// -fbranch-probabilities and -fvpt usage is covered by
	// -fprofile-generate/-fprofile-use.
	//
	// The profile directory can be specified as an argument to
	// -fprofile-generate=, -fprofile-use= or -fprofile-dir=.
	if (profile_generate) {
		if (!profile_dir) {
			profile_dir = get_cwd();
		}
		cc_log(""Adding profile directory %s to our hash"", profile_dir);
		hash_delimiter(hash, ""-fprofile-dir"");
		hash_string(hash, profile_dir);
	}

	if (profile_use) {
		// Calculate gcda name.
		if (!profile_dir) {
			profile_dir = get_cwd();
		}
		char *base_name = remove_extension(output_obj);
		char *gcda_name = format(""%s/%s.gcda"", profile_dir, base_name);
		cc_log(""Adding profile data %s to our hash"", gcda_name);
		// Add the gcda to our hash.
		hash_delimiter(hash, ""-fprofile-use"");
		hash_file(hash, gcda_name);
		free(base_name);
		free(gcda_name);
	}

	// Adding -arch to hash since cpp output is affected.
	for (size_t i = 0; i < arch_args_size; ++i) {
		hash_delimiter(hash, ""-arch"");
		hash_string(hash, arch_args[i]);
	}

	struct file_hash *object_hash = NULL;
	if (direct_mode) {
		// Hash environment variables that affect the preprocessor output.
		const char *envvars[] = {
			""CPATH"",
			""C_INCLUDE_PATH"",
			""CPLUS_INCLUDE_PATH"",
			""OBJC_INCLUDE_PATH"",
			""OBJCPLUS_INCLUDE_PATH"", // clang
			NULL
		};
		for (const char **p = envvars; *p; ++p) {
			char *v = getenv(*p);
			if (v) {
				hash_delimiter(hash, *p);
				hash_string(hash, v);
			}
		}

		if (!(conf->sloppiness & SLOPPY_FILE_MACRO)) {
			// The source code file or an include file may contain __FILE__, so make
			// sure that the hash is unique for the file name.
			hash_delimiter(hash, ""inputfile"");
			hash_string(hash, input_file);
		}

		hash_delimiter(hash, ""sourcecode"");
		int result = hash_source_code_file(conf, hash, input_file);
		if (result & HASH_SOURCE_CODE_ERROR) {
			failed();
		}
		if (result & HASH_SOURCE_CODE_FOUND_TIME) {
			cc_log(""Disabling direct mode"");
			conf->direct_mode = false;
			return NULL;
		}
		char *manifest_name = hash_result(hash);
		manifest_path = get_path_in_cache(manifest_name, "".manifest"");
		free(manifest_name);
		cc_log(""Looking for object file hash in %s"", manifest_path);
		object_hash = manifest_get(conf, manifest_path);
		if (object_hash) {
			cc_log(""Got object file hash from manifest"");
		} else {
			cc_log(""Did not find object file hash in manifest"");
		}
	} else {
		if (arch_args_size == 0) {
			object_hash = get_object_name_from_cpp(args, hash);
			cc_log(""Got object file hash from preprocessor"");
		} else {
			args_add(args, ""-arch"");
			for (size_t i = 0; i < arch_args_size; ++i) {
				args_add(args, arch_args[i]);
				object_hash = get_object_name_from_cpp(args, hash);
				cc_log(""Got object file hash from preprocessor with -arch %s"",
				       arch_args[i]);
				if (i != arch_args_size - 1) {
					free(object_hash);
					object_hash = NULL;
				}
				args_pop(args, 1);
			}
			args_pop(args, 1);
		}
		if (generating_dependencies) {
			cc_log(""Preprocessor created %s"", output_dep);
		}
	}

	return object_hash;
}

// Try to return the compile result from cache. If we can return from cache
// then this function exits with the correct status code, otherwise it returns.
static void
from_cache(enum fromcache_call_mode mode, bool put_object_in_manifest)
{
	// The user might be disabling cache hits.
	if (conf->recache) {
		return;
	}

	// If we're using Clang, we can't trust a precompiled header object based on
	// running the preprocessor since clang will produce a fatal error when the
	// precompiled header is used and one of the included files has an updated
	// timestamp:
	//
	//     file 'foo.h' has been modified since the precompiled header 'foo.pch'
	//     was built
	if ((guessed_compiler == GUESSED_CLANG || guessed_compiler == GUESSED_UNKNOWN)
	    && output_is_precompiled_header
	    && mode == FROMCACHE_CPP_MODE) {
		cc_log(""Not considering cached precompiled header in preprocessor mode"");
		return;
	}

	// Occasionally, e.g. on hard reset, our cache ends up as just filesystem
	// meta-data with no content. Catch an easy case of this.
	struct stat st;
	if (stat(cached_obj, &st) != 0) {
		cc_log(""Object file %s not in cache"", cached_obj);
		return;
	}
	if (st.st_size == 0) {
		cc_log(""Invalid (empty) object file %s in cache"", cached_obj);
		x_unlink(cached_obj);
		return;
	}

	// (If mode != FROMCACHE_DIRECT_MODE, the dependency file is created by gcc.)
	bool produce_dep_file =
	  generating_dependencies && mode == FROMCACHE_DIRECT_MODE;

	// Get result from cache.
	if (!str_eq(output_obj, ""/dev/null"")) {
		get_file_from_cache(cached_obj, output_obj);
		if (using_split_dwarf) {
			get_file_from_cache(cached_dwo, output_dwo);
		}
	}
	if (produce_dep_file) {
		get_file_from_cache(cached_dep, output_dep);
	}
	if (generating_coverage) {
		get_file_from_cache(cached_cov, output_cov);
	}
	if (generating_stackusage) {
		get_file_from_cache(cached_su, output_su);
	}
	if (generating_diagnostics) {
		get_file_from_cache(cached_dia, output_dia);
	}

	// Update modification timestamps to save files from LRU cleanup. Also gives
	// files a sensible mtime when hard-linking.
	update_mtime(cached_obj);
	update_mtime(cached_stderr);
	if (produce_dep_file) {
		update_mtime(cached_dep);
	}
	if (generating_coverage) {
		update_mtime(cached_cov);
	}
	if (generating_stackusage) {
		update_mtime(cached_su);
	}
	if (generating_diagnostics) {
		update_mtime(cached_dia);
	}
	if (cached_dwo) {
		update_mtime(cached_dwo);
	}

	send_cached_stderr();

	if (put_object_in_manifest) {
		update_manifest_file();
	}

	// Log the cache hit.
	switch (mode) {
	case FROMCACHE_DIRECT_MODE:
		cc_log(""Succeeded getting cached result"");
		stats_update(STATS_CACHEHIT_DIR);
		break;

	case FROMCACHE_CPP_MODE:
		cc_log(""Succeeded getting cached result"");
		stats_update(STATS_CACHEHIT_CPP);
		break;
	}

	// And exit with the right status code.
	x_exit(0);
}

// Find the real compiler. We just search the PATH to find an executable of the
// same name that isn't a link to ourselves.
static void
find_compiler(char **argv)
{
	// We might be being invoked like ""ccache gcc -c foo.c"".
	char *base = basename(argv[0]);
	if (same_executable_name(base, MYNAME)) {
		args_remove_first(orig_args);
		free(base);
		if (is_full_path(orig_args->argv[0])) {
			// A full path was given.
			return;
		}
		base = basename(orig_args->argv[0]);
	}

	// Support user override of the compiler.
	if (!str_eq(conf->compiler, """")) {
		base = conf->compiler;
	}

	char *compiler = find_executable(base, MYNAME);
	if (!compiler) {
		stats_update(STATS_COMPILER);
		fatal(""Could not find compiler \""%s\"" in PATH"", base);
	}
	if (str_eq(compiler, argv[0])) {
		fatal(""Recursive invocation (the name of the ccache binary must be \""%s\"")"",
		      MYNAME);
	}
	orig_args->argv[0] = compiler;
}

bool
is_precompiled_header(const char *path)
{
	const char *ext = get_extension(path);
	char *dir = dirname(path);
	const char *dir_ext = get_extension(dir);
	bool result =
		str_eq(ext, "".gch"")
		|| str_eq(ext, "".pch"")
		|| str_eq(ext, "".pth"")
		|| str_eq(dir_ext, "".gch""); // See ""Precompiled Headers"" in GCC docs.
	free(dir);
	return result;
}

static bool
color_output_possible(void)
{
	const char *term_env = getenv(""TERM"");
	return isatty(STDERR_FILENO) && term_env && strcasecmp(term_env, ""DUMB"") != 0;
}

static bool
detect_pch(const char *option, const char *arg, bool *found_pch)
{
	struct stat st;

	// Try to be smart about detecting precompiled headers.
	char *pch_file = NULL;
	if (str_eq(option, ""-include-pch"") || str_eq(option, ""-include-pth"")) {
		if (stat(arg, &st) == 0) {
			cc_log(""Detected use of precompiled header: %s"", arg);
			pch_file = x_strdup(arg);
		}
	} else {
		char *gchpath = format(""%s.gch"", arg);
		if (stat(gchpath, &st) == 0) {
			cc_log(""Detected use of precompiled header: %s"", gchpath);
			pch_file = x_strdup(gchpath);
		} else {
			char *pchpath = format(""%s.pch"", arg);
			if (stat(pchpath, &st) == 0) {
				cc_log(""Detected use of precompiled header: %s"", pchpath);
				pch_file = x_strdup(pchpath);
			} else {
				// clang may use pretokenized headers.
				char *pthpath = format(""%s.pth"", arg);
				if (stat(pthpath, &st) == 0) {
					cc_log(""Detected use of pretokenized header: %s"", pthpath);
					pch_file = x_strdup(pthpath);
				}
				free(pthpath);
			}
			free(pchpath);
		}
		free(gchpath);
	}

	if (pch_file) {
		if (included_pch_file) {
			cc_log(""Multiple precompiled headers used: %s and %s\n"",
			       included_pch_file, pch_file);
			stats_update(STATS_ARGS);
			return false;
		}
		included_pch_file = pch_file;
		*found_pch = true;
	}
	return true;
}

// Process the compiler options into options suitable for passing to the
// preprocessor and the real compiler. The preprocessor options don't include
// -E; this is added later. Returns true on success, otherwise false.
bool
cc_process_args(struct args *args, struct args **preprocessor_args,
                struct args **compiler_args)
{
	bool found_c_opt = false;
	bool found_S_opt = false;
	bool found_pch = false;
	bool found_fpch_preprocess = false;
	const char *explicit_language = NULL; // As specified with -x.
	const char *file_language;            // As deduced from file extension.
	const char *input_charset = NULL;
	// Is the dependency makefile name overridden with -MF?
	bool dependency_filename_specified = false;
	// Is the dependency makefile target name specified with -MT or -MQ?
	bool dependency_target_specified = false;
	// expanded_args is a copy of the original arguments given to the compiler
	// but with arguments from @file and similar constructs expanded. It's only
	// used as a temporary data structure to loop over.
	struct args *expanded_args = args_copy(args);
	// stripped_args essentially contains all original arguments except those
	// that only should be passed to the preprocessor (if run_second_cpp is
	// false) and except dependency options (like -MD and friends).
	struct args *stripped_args = args_init(0, NULL);
	// cpp_args contains arguments that were not added to stripped_args, i.e.
	// those that should only be passed to the preprocessor if run_second_cpp is
	// false. If run_second_cpp is true, they will be passed to the compiler as
	// well.
	struct args *cpp_args = args_init(0, NULL);
	// dep_args contains dependency options like -MD. They only passed to the
	// preprocessor, never to the compiler.
	struct args *dep_args = args_init(0, NULL);

	bool found_color_diagnostics = false;

	bool found_directives_only = false;
	bool found_rewrite_includes = false;

	int argc = expanded_args->argc;
	char **argv = expanded_args->argv;
	args_add(stripped_args, argv[0]);

	bool result = true;
	for (int i = 1; i < argc; i++) {
		// The user knows best: just swallow the next arg.
		if (str_eq(argv[i], ""--ccache-skip"")) {
			i++;
			if (i == argc) {
				cc_log(""--ccache-skip lacks an argument"");
				result = false;
				goto out;
			}
			args_add(stripped_args, argv[i]);
			continue;
		}

		// Special case for -E.
		if (str_eq(argv[i], ""-E"")) {
			stats_update(STATS_PREPROCESSING);
			result = false;
			goto out;
		}

		// Handle ""@file"" argument.
		if (str_startswith(argv[i], ""@"") || str_startswith(argv[i], ""-@"")) {
			char *argpath = argv[i] + 1;

			if (argpath[-1] == '-') {
				++argpath;
			}
			struct args *file_args = args_init_from_gcc_atfile(argpath);
			if (!file_args) {
				cc_log(""Couldn't read arg file %s"", argpath);
				stats_update(STATS_ARGS);
				result = false;
				goto out;
			}

			args_insert(expanded_args, i, file_args, true);
			argc = expanded_args->argc;
			argv = expanded_args->argv;
			i--;
			continue;
		}

		// Handle cuda ""-optf"" and ""--options-file"" argument.
		if (guessed_compiler == GUESSED_NVCC
		    && (str_eq(argv[i], ""-optf"") || str_eq(argv[i], ""--options-file""))) {
			if (i == argc - 1) {
				cc_log(""Expected argument after %s"", argv[i]);
				stats_update(STATS_ARGS);
				result = false;
				goto out;
			}
			++i;

			// Argument is a comma-separated list of files.
			char *str_start = argv[i];
			char *str_end = strchr(str_start, ',');
			int index = i + 1;

			if (!str_end) {
				str_end = str_start + strlen(str_start);
			}

			while (str_end) {
				*str_end = '\0';
				struct args *file_args = args_init_from_gcc_atfile(str_start);
				if (!file_args) {
					cc_log(""Couldn't read cuda options file %s"", str_start);
					stats_update(STATS_ARGS);
					result = false;
					goto out;
				}

				int new_index = file_args->argc + index;
				args_insert(expanded_args, index, file_args, false);
				index = new_index;
				str_start = str_end;
				str_end = strchr(str_start, ',');
			}

			argc = expanded_args->argc;
			argv = expanded_args->argv;
			continue;
		}

		// These are always too hard.
		if (compopt_too_hard(argv[i]) || str_startswith(argv[i], ""-fdump-"")) {
			cc_log(""Compiler option %s is unsupported"", argv[i]);
			stats_update(STATS_UNSUPPORTED_OPTION);
			result = false;
			goto out;
		}

		// These are too hard in direct mode.
		if (conf->direct_mode && compopt_too_hard_for_direct_mode(argv[i])) {
			cc_log(""Unsupported compiler option for direct mode: %s"", argv[i]);
			conf->direct_mode = false;
		}

		// -Xarch_* options are too hard.
		if (str_startswith(argv[i], ""-Xarch_"")) {
			cc_log(""Unsupported compiler option :%s"", argv[i]);
			stats_update(STATS_UNSUPPORTED_OPTION);
			result = false;
			goto out;
		}

		// Handle -arch options.
		if (str_eq(argv[i], ""-arch"")) {
			if (arch_args_size == MAX_ARCH_ARGS - 1) {
				cc_log(""Too many -arch compiler options; ccache supports at most %d"",
				       MAX_ARCH_ARGS);
				stats_update(STATS_UNSUPPORTED_OPTION);
				result = false;
				goto out;
			}

			++i;
			arch_args[arch_args_size] = x_strdup(argv[i]); // It will leak.
			++arch_args_size;
			if (arch_args_size == 2) {
				conf->run_second_cpp = true;
			}
			continue;
		}

		if (str_eq(argv[i], ""-fpch-preprocess"")
		    || str_eq(argv[i], ""-emit-pch"")
		    || str_eq(argv[i], ""-emit-pth"")) {
			found_fpch_preprocess = true;
		}

		// We must have -c.
		if (str_eq(argv[i], ""-c"")) {
			found_c_opt = true;
			continue;
		}

		// -S changes the default extension.
		if (str_eq(argv[i], ""-S"")) {
			args_add(stripped_args, argv[i]);
			found_S_opt = true;
			continue;
		}

		// Special handling for -x: remember the last specified language before the
		// input file and strip all -x options from the arguments.
		if (str_eq(argv[i], ""-x"")) {
			if (i == argc - 1) {
				cc_log(""Missing argument to %s"", argv[i]);
				stats_update(STATS_ARGS);
				result = false;
				goto out;
			}
			if (!input_file) {
				explicit_language = argv[i+1];
			}
			i++;
			continue;
		}
		if (str_startswith(argv[i], ""-x"")) {
			if (!input_file) {
				explicit_language = &argv[i][2];
			}
			continue;
		}

		// We need to work out where the output was meant to go.
		if (str_eq(argv[i], ""-o"")) {
			if (i == argc - 1) {
				cc_log(""Missing argument to %s"", argv[i]);
				stats_update(STATS_ARGS);
				result = false;
				goto out;
			}
			output_obj = make_relative_path(x_strdup(argv[i+1]));
			i++;
			continue;
		}

		// Alternate form of -o with no space. Nvcc does not support this.
		if (str_startswith(argv[i], ""-o"") && guessed_compiler != GUESSED_NVCC) {
			output_obj = make_relative_path(x_strdup(&argv[i][2]));
			continue;
		}

		if (str_eq(argv[i], ""-gsplit-dwarf"")) {
			cc_log(""Enabling caching of dwarf files since -gsplit-dwarf is used"");
			using_split_dwarf = true;
			args_add(stripped_args, argv[i]);
			continue;
		}
		if (str_startswith(argv[i], ""-fdebug-prefix-map="")) {
			debug_prefix_maps = x_realloc(
			  debug_prefix_maps,
			  (debug_prefix_maps_len + 1) * sizeof(char *));
			debug_prefix_maps[debug_prefix_maps_len++] = x_strdup(argv[i] + 19);
			args_add(stripped_args, argv[i]);
			continue;
		}

		// Debugging is handled specially, so that we know if we can strip line
		// number info.
		if (str_startswith(argv[i], ""-g"")) {
			generating_debuginfo = true;
			args_add(stripped_args, argv[i]);
			if (conf->unify && !str_eq(argv[i], ""-g0"")) {
				cc_log(""%s used; disabling unify mode"", argv[i]);
				conf->unify = false;
			}
			if (str_eq(argv[i], ""-g3"")) {
				cc_log(""%s used; not compiling preprocessed code"", argv[i]);
				conf->run_second_cpp = true;
			}
			continue;
		}

		// These options require special handling, because they behave differently
		// with gcc -E, when the output file is not specified.
		if (str_eq(argv[i], ""-MD"") || str_eq(argv[i], ""-MMD"")) {
			generating_dependencies = true;
			args_add(dep_args, argv[i]);
			continue;
		}
		if (str_startswith(argv[i], ""-MF"")) {
			dependency_filename_specified = true;
			free(output_dep);

			char *arg;
			bool separate_argument = (strlen(argv[i]) == 3);
			if (separate_argument) {
				// -MF arg
				if (i == argc - 1) {
					cc_log(""Missing argument to %s"", argv[i]);
					stats_update(STATS_ARGS);
					result = false;
					goto out;
				}
				arg = argv[i + 1];
				i++;
			} else {
				// -MFarg
				arg = &argv[i][3];
			}
			output_dep = make_relative_path(x_strdup(arg));
			// Keep the format of the args the same.
			if (separate_argument) {
				args_add(dep_args, ""-MF"");
				args_add(dep_args, output_dep);
			} else {
				char *option = format(""-MF%s"", output_dep);
				args_add(dep_args, option);
				free(option);
			}
			continue;
		}
		if (str_startswith(argv[i], ""-MQ"") || str_startswith(argv[i], ""-MT"")) {
			dependency_target_specified = true;

			char *relpath;
			if (strlen(argv[i]) == 3) {
				// -MQ arg or -MT arg
				if (i == argc - 1) {
					cc_log(""Missing argument to %s"", argv[i]);
					stats_update(STATS_ARGS);
					result = false;
					goto out;
				}
				args_add(dep_args, argv[i]);
				relpath = make_relative_path(x_strdup(argv[i + 1]));
				args_add(dep_args, relpath);
				free(relpath);
				i++;
			} else {
				char *arg_opt = x_strndup(argv[i], 3);
				relpath = make_relative_path(x_strdup(argv[i] + 3));
				char *option = format(""%s%s"", arg_opt, relpath);
				args_add(dep_args, option);
				free(arg_opt);
				free(relpath);
				free(option);
			}
			continue;
		}
		if (str_eq(argv[i], ""-fprofile-arcs"")) {
			profile_arcs = true;
			args_add(stripped_args, argv[i]);
			continue;
		}
		if (str_eq(argv[i], ""-ftest-coverage"")) {
			generating_coverage = true;
			args_add(stripped_args, argv[i]);
			continue;
		}
		if (str_eq(argv[i], ""-fstack-usage"")) {
			generating_stackusage = true;
			args_add(stripped_args, argv[i]);
			continue;
		}
		if (str_eq(argv[i], ""--coverage"") // = -fprofile-arcs -ftest-coverage
		    || str_eq(argv[i], ""-coverage"")) { // Undocumented but still works.
			profile_arcs = true;
			generating_coverage = true;
			args_add(stripped_args, argv[i]);
			continue;
		}
		if (str_startswith(argv[i], ""-fprofile-dir="")) {
			profile_dir = x_strdup(argv[i] + 14);
			args_add(stripped_args, argv[i]);
			continue;
		}
		if (str_startswith(argv[i], ""-fsanitize-blacklist="")) {
			sanitize_blacklist = x_strdup(argv[i] + 21);
			args_add(stripped_args, argv[i]);
			continue;
		}
		if (str_startswith(argv[i], ""--sysroot="")) {
			char *relpath = make_relative_path(x_strdup(argv[i] + 10));
			char *option = format(""--sysroot=%s"", relpath);
			args_add(stripped_args, option);
			free(relpath);
			free(option);
			continue;
		}
		// Alternate form of specifying sysroot without =
		if (str_eq(argv[i], ""--sysroot"")) {
			if (i == argc-1) {
				cc_log(""Missing argument to %s"", argv[i]);
				stats_update(STATS_ARGS);
				result = false;
				goto out;
			}
			args_add(stripped_args, argv[i]);
			char *relpath = make_relative_path(x_strdup(argv[i+1]));
			args_add(stripped_args, relpath);
			i++;
			free(relpath);
			continue;
		}
		// Alternate form of specifying target without =
		if (str_eq(argv[i], ""-target"")) {
			if (i == argc-1) {
				cc_log(""Missing argument to %s"", argv[i]);
				stats_update(STATS_ARGS);
				result = false;
				goto out;
			}
			args_add(stripped_args, argv[i]);
			args_add(stripped_args, argv[i+1]);
			i++;
			continue;
		}
		if (str_startswith(argv[i], ""-Wp,"")) {
			if (str_eq(argv[i], ""-Wp,-P"")
			    || strstr(argv[i], "",-P,"")
			    || str_endswith(argv[i], "",-P"")) {
				// -P removes preprocessor information in such a way that the object
				// file from compiling the preprocessed file will not be equal to the
				// object file produced when compiling without ccache.
				cc_log(""Too hard option -Wp,-P detected"");
				stats_update(STATS_UNSUPPORTED_OPTION);
				failed();
			} else if (str_startswith(argv[i], ""-Wp,-MD,"")
			           && !strchr(argv[i] + 8, ',')) {
				generating_dependencies = true;
				dependency_filename_specified = true;
				free(output_dep);
				output_dep = make_relative_path(x_strdup(argv[i] + 8));
				args_add(dep_args, argv[i]);
				continue;
			} else if (str_startswith(argv[i], ""-Wp,-MMD,"")
			           && !strchr(argv[i] + 9, ',')) {
				generating_dependencies = true;
				dependency_filename_specified = true;
				free(output_dep);
				output_dep = make_relative_path(x_strdup(argv[i] + 9));
				args_add(dep_args, argv[i]);
				continue;
			} else if (str_startswith(argv[i], ""-Wp,-D"")
			           && !strchr(argv[i] + 6, ',')) {
				// Treat it like -D.
				args_add(cpp_args, argv[i] + 4);
				continue;
			} else if (str_eq(argv[i], ""-Wp,-MP"")
			           || (strlen(argv[i]) > 8
			               && str_startswith(argv[i], ""-Wp,-M"")
			               && argv[i][7] == ','
			               && (argv[i][6] == 'F'
			                   || argv[i][6] == 'Q'
			                   || argv[i][6] == 'T')
			               && !strchr(argv[i] + 8, ','))) {
				// TODO: Make argument to MF/MQ/MT relative.
				args_add(dep_args, argv[i]);
				continue;
			} else if (conf->direct_mode) {
				// -Wp, can be used to pass too hard options to the preprocessor.
				// Hence, disable direct mode.
				cc_log(""Unsupported compiler option for direct mode: %s"", argv[i]);
				conf->direct_mode = false;
			}

			// Any other -Wp,* arguments are only relevant for the preprocessor.
			args_add(cpp_args, argv[i]);
			continue;
		}
		if (str_eq(argv[i], ""-MP"")) {
			args_add(dep_args, argv[i]);
			continue;
		}

		// Input charset needs to be handled specially.
		if (str_startswith(argv[i], ""-finput-charset="")) {
			input_charset = argv[i];
			continue;
		}

		if (str_eq(argv[i], ""--serialize-diagnostics"")) {
			if (i == argc - 1) {
				cc_log(""Missing argument to %s"", argv[i]);
				stats_update(STATS_ARGS);
				result = false;
				goto out;
			}
			generating_diagnostics = true;
			output_dia = make_relative_path(x_strdup(argv[i+1]));
			i++;
			continue;
		}

		if (str_startswith(argv[i], ""-fprofile-"")) {
			char *arg = x_strdup(argv[i]);
			const char *arg_profile_dir = strchr(argv[i], '=');
			if (arg_profile_dir) {
				// Convert to absolute path.
				char *dir = x_realpath(arg_profile_dir + 1);
				if (!dir) {
					// Directory doesn't exist.
					dir = x_strdup(arg_profile_dir + 1);
				}

				// We can get a better hit rate by using the real path here.
				free(arg);
				char *option = x_strndup(argv[i], arg_profile_dir - argv[i]);
				arg = format(""%s=%s"", option, dir);
				cc_log(""Rewriting %s to %s"", argv[i], arg);
				free(option);
				free(dir);
			}

			bool supported_profile_option = false;
			if (str_startswith(argv[i], ""-fprofile-generate"")
			    || str_eq(argv[i], ""-fprofile-arcs"")) {
				profile_generate = true;
				supported_profile_option = true;
			} else if (str_startswith(argv[i], ""-fprofile-use"")
			           || str_eq(argv[i], ""-fbranch-probabilities"")) {
				profile_use = true;
				supported_profile_option = true;
			} else if (str_eq(argv[i], ""-fprofile-dir"")) {
				supported_profile_option = true;
			}

			if (supported_profile_option) {
				args_add(stripped_args, arg);
				free(arg);

				// If the profile directory has already been set, give up... Hard to
				// know what the user means, and what the compiler will do.
				if (arg_profile_dir && profile_dir) {
					cc_log(""Profile directory already set; giving up"");
					result = false;
					goto out;
				} else if (arg_profile_dir) {
					cc_log(""Setting profile directory to %s"", profile_dir);
					profile_dir = x_strdup(arg_profile_dir);
				}
				continue;
			}
			cc_log(""Unknown profile option: %s"", argv[i]);
			free(arg);
		}

		if (str_eq(argv[i], ""-fcolor-diagnostics"")
		    || str_eq(argv[i], ""-fno-color-diagnostics"")
		    || str_eq(argv[i], ""-fdiagnostics-color"")
		    || str_eq(argv[i], ""-fdiagnostics-color=always"")
		    || str_eq(argv[i], ""-fno-diagnostics-color"")
		    || str_eq(argv[i], ""-fdiagnostics-color=never"")) {
			args_add(stripped_args, argv[i]);
			found_color_diagnostics = true;
			continue;
		}
		if (str_eq(argv[i], ""-fdiagnostics-color=auto"")) {
			if (color_output_possible()) {
				// Output is redirected, so color output must be forced.
				args_add(stripped_args, ""-fdiagnostics-color=always"");
				cc_log(""Automatically forcing colors"");
			} else {
				args_add(stripped_args, argv[i]);
			}
			found_color_diagnostics = true;
			continue;
		}

		// GCC
		if (str_eq(argv[i], ""-fdirectives-only"")) {
			found_directives_only = true;
			continue;
		}
		// Clang
		if (str_eq(argv[i], ""-frewrite-includes"")) {
			found_rewrite_includes = true;
			continue;
		}

		// Options taking an argument that we may want to rewrite to relative paths
		// to get better hit rate. A secondary effect is that paths in the standard
		// error output produced by the compiler will be normalized.
		if (compopt_takes_path(argv[i])) {
			if (i == argc - 1) {
				cc_log(""Missing argument to %s"", argv[i]);
				stats_update(STATS_ARGS);
				result = false;
				goto out;
			}

			if (!detect_pch(argv[i], argv[i+1], &found_pch)) {
				result = false;
				goto out;
			}

			char *relpath = make_relative_path(x_strdup(argv[i+1]));
			if (compopt_affects_cpp(argv[i])) {
				args_add(cpp_args, argv[i]);
				args_add(cpp_args, relpath);
			} else {
				args_add(stripped_args, argv[i]);
				args_add(stripped_args, relpath);
			}
			free(relpath);

			i++;
			continue;
		}

		// Same as above but options with concatenated argument beginning with a
		// slash.
		if (argv[i][0] == '-') {
			char *slash_pos = strchr(argv[i], '/');
			if (slash_pos) {
				char *option = x_strndup(argv[i], slash_pos - argv[i]);
				if (compopt_takes_concat_arg(option) && compopt_takes_path(option)) {
					char *relpath = make_relative_path(x_strdup(slash_pos));
					char *new_option = format(""%s%s"", option, relpath);
					if (compopt_affects_cpp(option)) {
						args_add(cpp_args, new_option);
					} else {
						args_add(stripped_args, new_option);
					}
					free(new_option);
					free(relpath);
					free(option);
					continue;
				} else {
					free(option);
				}
			}
		}

		// Options that take an argument.
		if (compopt_takes_arg(argv[i])) {
			if (i == argc - 1) {
				cc_log(""Missing argument to %s"", argv[i]);
				stats_update(STATS_ARGS);
				result = false;
				goto out;
			}

			if (compopt_affects_cpp(argv[i])) {
				args_add(cpp_args, argv[i]);
				args_add(cpp_args, argv[i+1]);
			} else {
				args_add(stripped_args, argv[i]);
				args_add(stripped_args, argv[i+1]);
			}

			i++;
			continue;
		}

		// Other options.
		if (argv[i][0] == '-') {
			if (compopt_affects_cpp(argv[i])
			    || compopt_prefix_affects_cpp(argv[i])) {
				args_add(cpp_args, argv[i]);
			} else {
				args_add(stripped_args, argv[i]);
			}
			continue;
		}

		// If an argument isn't a plain file then assume its an option, not an
		// input file. This allows us to cope better with unusual compiler options.
		struct stat st;
		if (stat(argv[i], &st) != 0 || !S_ISREG(st.st_mode)) {
			cc_log(""%s is not a regular file, not considering as input file"",
			       argv[i]);
			args_add(stripped_args, argv[i]);
			continue;
		}

		if (input_file) {
			if (language_for_file(argv[i])) {
				cc_log(""Multiple input files: %s and %s"", input_file, argv[i]);
				stats_update(STATS_MULTIPLE);
			} else if (!found_c_opt) {
				cc_log(""Called for link with %s"", argv[i]);
				if (strstr(argv[i], ""conftest."")) {
					stats_update(STATS_CONFTEST);
				} else {
					stats_update(STATS_LINK);
				}
			} else {
				cc_log(""Unsupported source extension: %s"", argv[i]);
				stats_update(STATS_SOURCELANG);
			}
			result = false;
			goto out;
		}

		// The source code file path gets put into the notes.
		if (generating_coverage) {
			input_file = x_strdup(argv[i]);
			continue;
		}

		if (is_symlink(argv[i])) {
			// Don't rewrite source file path if it's a symlink since
			// make_relative_path resolves symlinks using realpath(3) and this leads
			// to potentially choosing incorrect relative header files. See the
			// ""symlink to source file"" test.
			input_file = x_strdup(argv[i]);
		} else {
			// Rewrite to relative to increase hit rate.
			input_file = make_relative_path(x_strdup(argv[i]));
		}
	} // for

	if (found_S_opt) {
		// Even if -gsplit-dwarf is given, the .dwo file is not generated when -S
		// is also given.
		using_split_dwarf = false;
		cc_log(""Disabling caching of dwarf files since -S is used"");
	}

	if (!input_file) {
		cc_log(""No input file found"");
		stats_update(STATS_NOINPUT);
		result = false;
		goto out;
	}

	if (found_pch || found_fpch_preprocess) {
		using_precompiled_header = true;
		if (!(conf->sloppiness & SLOPPY_TIME_MACROS)) {
			cc_log(""You have to specify \""time_macros\"" sloppiness when using""
			       "" precompiled headers to get direct hits"");
			cc_log(""Disabling direct mode"");
			stats_update(STATS_CANTUSEPCH);
			result = false;
			goto out;
		}
	}

	if (explicit_language && str_eq(explicit_language, ""none"")) {
		explicit_language = NULL;
	}
	file_language = language_for_file(input_file);
	if (explicit_language) {
		if (!language_is_supported(explicit_language)) {
			cc_log(""Unsupported language: %s"", explicit_language);
			stats_update(STATS_SOURCELANG);
			result = false;
			goto out;
		}
		actual_language = x_strdup(explicit_language);
	} else {
		actual_language = file_language;
	}

	output_is_precompiled_header =
	  actual_language && strstr(actual_language, ""-header"");

	if (output_is_precompiled_header
	    && !(conf->sloppiness & SLOPPY_PCH_DEFINES)) {
		cc_log(""You have to specify \""pch_defines,time_macros\"" sloppiness when""
		       "" creating precompiled headers"");
		stats_update(STATS_CANTUSEPCH);
		result = false;
		goto out;
	}

	if (!found_c_opt && !found_S_opt) {
		if (output_is_precompiled_header) {
			args_add(stripped_args, ""-c"");
		} else {
			cc_log(""No -c option found"");
			// I find that having a separate statistic for autoconf tests is useful,
			// as they are the dominant form of ""called for link"" in many cases.
			if (strstr(input_file, ""conftest."")) {
				stats_update(STATS_CONFTEST);
			} else {
				stats_update(STATS_LINK);
			}
			result = false;
			goto out;
		}
	}

	if (!actual_language) {
		cc_log(""Unsupported source extension: %s"", input_file);
		stats_update(STATS_SOURCELANG);
		result = false;
		goto out;
	}

	if (!conf->run_second_cpp && str_eq(actual_language, ""cuda"")) {
		cc_log(""Using CUDA compiler; not compiling preprocessed code"");
		conf->run_second_cpp = true;
	}

	direct_i_file = language_is_preprocessed(actual_language);

	if (output_is_precompiled_header && !conf->run_second_cpp) {
		// It doesn't work to create the .gch from preprocessed source.
		cc_log(""Creating precompiled header; not compiling preprocessed code"");
		conf->run_second_cpp = true;
	}

	if (str_eq(conf->cpp_extension, """")) {
		const char *p_language = p_language_for_language(actual_language);
		free(conf->cpp_extension);
		conf->cpp_extension = x_strdup(extension_for_language(p_language) + 1);
	}

	// Don't try to second guess the compilers heuristics for stdout handling.
	if (output_obj && str_eq(output_obj, ""-"")) {
		stats_update(STATS_OUTSTDOUT);
		cc_log(""Output file is -"");
		result = false;
		goto out;
	}

	if (!output_obj) {
		if (output_is_precompiled_header) {
			output_obj = format(""%s.gch"", input_file);
		} else {
			output_obj = basename(input_file);
			char *p = strrchr(output_obj, '.');
			if (!p || !p[1]) {
				cc_log(""Badly formed object filename"");
				stats_update(STATS_ARGS);
				result = false;
				goto out;
			}
			p[1] = found_S_opt ? 's' : 'o';
			p[2] = 0;
		}
	}

	if (using_split_dwarf) {
		char *p = strrchr(output_obj, '.');
		if (!p || !p[1]) {
			cc_log(""Badly formed object filename"");
			stats_update(STATS_ARGS);
			result = false;
			goto out;
		}

		char *base_name = remove_extension(output_obj);
		output_dwo = format(""%s.dwo"", base_name);
		free(base_name);
	}

	// Cope with -o /dev/null.
	struct stat st;
	if (!str_eq(output_obj, ""/dev/null"")
	    && stat(output_obj, &st) == 0
	    && !S_ISREG(st.st_mode)) {
		cc_log(""Not a regular file: %s"", output_obj);
		stats_update(STATS_DEVICE);
		result = false;
		goto out;
	}

	// Some options shouldn't be passed to the real compiler when it compiles
	// preprocessed code:
	//
	// -finput-charset=XXX (otherwise conversion happens twice)
	// -x XXX (otherwise the wrong language is selected)
	if (input_charset) {
		args_add(cpp_args, input_charset);
	}
	if (found_pch) {
		args_add(cpp_args, ""-fpch-preprocess"");
	}
	if (explicit_language) {
		args_add(cpp_args, ""-x"");
		args_add(cpp_args, explicit_language);
	}

	// Since output is redirected, compilers will not color their output by
	// default, so force it explicitly if it would be otherwise done.
	if (!found_color_diagnostics && color_output_possible()) {
		if (guessed_compiler == GUESSED_CLANG) {
			if (!str_eq(actual_language, ""assembler"")) {
				args_add(stripped_args, ""-fcolor-diagnostics"");
				cc_log(""Automatically enabling colors"");
			}
		} else if (guessed_compiler == GUESSED_GCC) {
			// GCC has it since 4.9, but that'd require detecting what GCC version is
			// used for the actual compile. However it requires also GCC_COLORS to be
			// set (and not empty), so use that for detecting if GCC would use
			// colors.
			if (getenv(""GCC_COLORS"") && getenv(""GCC_COLORS"")[0] != '\0') {
				args_add(stripped_args, ""-fdiagnostics-color"");
				cc_log(""Automatically enabling colors"");
			}
		}
	}

	// Add flags for dependency generation only to the preprocessor command line.
	if (generating_dependencies) {
		if (!dependency_filename_specified) {
			char *base_name = remove_extension(output_obj);
			char *default_depfile_name = format(""%s.d"", base_name);
			free(base_name);
			args_add(dep_args, ""-MF"");
			args_add(dep_args, default_depfile_name);
			output_dep = make_relative_path(x_strdup(default_depfile_name));
		}

		if (!dependency_target_specified
		    && !str_eq(get_extension(output_dep), "".o"")) {
			args_add(dep_args, ""-MQ"");
			args_add(dep_args, output_obj);
		}
	}
	if (generating_coverage) {
		char *base_name = remove_extension(output_obj);
		char *default_covfile_name = format(""%s.gcno"", base_name);
		free(base_name);
		output_cov = make_relative_path(default_covfile_name);
	}
	if (generating_stackusage) {
		char *base_name = remove_extension(output_obj);
		char *default_sufile_name = format(""%s.su"", base_name);
		free(base_name);
		output_su = make_relative_path(default_sufile_name);
	}

	*compiler_args = args_copy(stripped_args);
	if (conf->run_second_cpp) {
		args_extend(*compiler_args, cpp_args);
	} else if (found_directives_only || found_rewrite_includes) {
		// Need to pass the macros and any other preprocessor directives again.
		args_extend(*compiler_args, cpp_args);
		if (found_directives_only) {
			args_add(cpp_args, ""-fdirectives-only"");
			// The preprocessed source code still needs some more preprocessing.
			args_add(*compiler_args, ""-fpreprocessed"");
			args_add(*compiler_args, ""-fdirectives-only"");
		}
		if (found_rewrite_includes) {
			args_add(cpp_args, ""-frewrite-includes"");
			// The preprocessed source code still needs some more preprocessing.
			args_add(*compiler_args, ""-x"");
			args_add(*compiler_args, actual_language);
		}
	} else if (explicit_language) {
		// Workaround for a bug in Apple's patched distcc -- it doesn't properly
		// reset the language specified with -x, so if -x is given, we have to
		// specify the preprocessed language explicitly.
		args_add(*compiler_args, ""-x"");
		args_add(*compiler_args, p_language_for_language(explicit_language));
	}

	if (found_c_opt) {
		args_add(*compiler_args, ""-c"");
	}

	for (size_t i = 0; i < arch_args_size; ++i) {
		args_add(*compiler_args, ""-arch"");
		args_add(*compiler_args, arch_args[i]);
	}

	// Only pass dependency arguments to the preprocesor since Intel's C++
	// compiler doesn't produce a correct .d file when compiling preprocessed
	// source.
	args_extend(cpp_args, dep_args);

	*preprocessor_args = args_copy(stripped_args);
	args_extend(*preprocessor_args, cpp_args);

out:
	args_free(expanded_args);
	args_free(stripped_args);
	args_free(dep_args);
	args_free(cpp_args);
	return result;
}

static void
create_initial_config_file(struct conf *conf, const char *path)
{
	if (create_parent_dirs(path) != 0) {
		return;
	}

	unsigned max_files;
	uint64_t max_size;
	char *stats_dir = format(""%s/0"", conf->cache_dir);
	struct stat st;
	if (stat(stats_dir, &st) == 0) {
		stats_get_obsolete_limits(stats_dir, &max_files, &max_size);
		// STATS_MAXFILES and STATS_MAXSIZE was stored for each top directory.
		max_files *= 16;
		max_size *= 16;
	} else {
		max_files = 0;
		max_size = conf->max_size;
	}
	free(stats_dir);

	FILE *f = fopen(path, ""w"");
	if (!f) {
		return;
	}
	if (max_files != 0) {
		fprintf(f, ""max_files = %u\n"", max_files);
		conf->max_files = max_files;
	}
	if (max_size != 0) {
		char *size = format_parsable_size_with_suffix(max_size);
		fprintf(f, ""max_size = %s\n"", size);
		free(size);
		conf->max_size = max_size;
	}
	fclose(f);
}

// Read config file(s), populate variables, create configuration file in cache
// directory if missing, etc.
static void
initialize(void)
{
	conf_free(conf);
	conf = conf_create();

	char *errmsg;
	char *p = getenv(""CCACHE_CONFIGPATH"");
	if (p) {
		primary_config_path = x_strdup(p);
	} else {
		secondary_config_path = format(""%s/ccache.conf"", TO_STRING(SYSCONFDIR));
		if (!conf_read(conf, secondary_config_path, &errmsg)) {
			if (errno == 0) {
				// We could read the file but it contained errors.
				fatal(""%s"", errmsg);
			}
			// A missing config file in SYSCONFDIR is OK.
			free(errmsg);
		}

		if (str_eq(conf->cache_dir, """")) {
			fatal(""configuration setting \""cache_dir\"" must not be the empty string"");
		}
		if ((p = getenv(""CCACHE_DIR""))) {
			free(conf->cache_dir);
			conf->cache_dir = strdup(p);
		}
		if (str_eq(conf->cache_dir, """")) {
			fatal(""CCACHE_DIR must not be the empty string"");
		}

		primary_config_path = format(""%s/ccache.conf"", conf->cache_dir);
	}

	bool should_create_initial_config = false;
	if (!conf_read(conf, primary_config_path, &errmsg)) {
		if (errno == 0) {
			// We could read the file but it contained errors.
			fatal(""%s"", errmsg);
		}
		if (!conf->disable) {
			should_create_initial_config = true;
		}
	}

	if (!conf_update_from_environment(conf, &errmsg)) {
		fatal(""%s"", errmsg);
	}

	if (should_create_initial_config) {
		create_initial_config_file(conf, primary_config_path);
	}

	exitfn_init();
	exitfn_add_nullary(stats_flush);
	exitfn_add_nullary(clean_up_pending_tmp_files);

	cc_log(""=== CCACHE %s STARTED ========================================="",
	       CCACHE_VERSION);

	if (conf->umask != UINT_MAX) {
		umask(conf->umask);
	}
}

// Reset the global state. Used by the test suite.
void
cc_reset(void)
{
	conf_free(conf); conf = NULL;
	free(primary_config_path); primary_config_path = NULL;
	free(secondary_config_path); secondary_config_path = NULL;
	free(current_working_dir); current_working_dir = NULL;
	for (size_t i = 0; i < debug_prefix_maps_len; i++) {
		free(debug_prefix_maps[i]);
		debug_prefix_maps[i] = NULL;
	}
	free(debug_prefix_maps); debug_prefix_maps = NULL;
	debug_prefix_maps_len = 0;
	free(profile_dir); profile_dir = NULL;
	free(sanitize_blacklist); sanitize_blacklist = NULL;
	free(included_pch_file); included_pch_file = NULL;
	args_free(orig_args); orig_args = NULL;
	free(input_file); input_file = NULL;
	free(output_obj); output_obj = NULL;
	free(output_dep); output_dep = NULL;
	free(output_cov); output_cov = NULL;
	free(output_su); output_su = NULL;
	free(output_dia); output_dia = NULL;
	free(output_dwo); output_dwo = NULL;
	free(cached_obj_hash); cached_obj_hash = NULL;
	free(cached_stderr); cached_stderr = NULL;
	free(cached_obj); cached_obj = NULL;
	free(cached_dep); cached_dep = NULL;
	free(cached_cov); cached_cov = NULL;
	free(cached_su); cached_su = NULL;
	free(cached_dia); cached_dia = NULL;
	free(cached_dwo); cached_dwo = NULL;
	free(manifest_path); manifest_path = NULL;
	time_of_compilation = 0;
	for (size_t i = 0; i < ignore_headers_len; i++) {
		free(ignore_headers[i]);
		ignore_headers[i] = NULL;
	}
	free(ignore_headers); ignore_headers = NULL;
	ignore_headers_len = 0;
	if (included_files) {
		hashtable_destroy(included_files, 1); included_files = NULL;
	}
	has_absolute_include_headers = false;
	generating_debuginfo = false;
	generating_dependencies = false;
	generating_coverage = false;
	generating_stackusage = false;
	profile_arcs = false;
	free(profile_dir); profile_dir = NULL;
	i_tmpfile = NULL;
	direct_i_file = false;
	free(cpp_stderr); cpp_stderr = NULL;
	free(stats_file); stats_file = NULL;
	output_is_precompiled_header = false;

	conf = conf_create();
	using_split_dwarf = false;
}

// Make a copy of stderr that will not be cached, so things like distcc can
// send networking errors to it.
static void
set_up_uncached_err(void)
{
	int uncached_fd = dup(2); // The file descriptor is intentionally leaked.
	if (uncached_fd == -1) {
		cc_log(""dup(2) failed: %s"", strerror(errno));
		failed();
	}

	// Leak a pointer to the environment.
	char *buf = format(""UNCACHED_ERR_FD=%d"", uncached_fd);
	if (putenv(buf) == -1) {
		cc_log(""putenv failed: %s"", strerror(errno));
		failed();
	}
}

static void
configuration_logger(const char *descr, const char *origin, void *context)
{
	(void)context;
	cc_bulklog(""Config: (%s) %s"", origin, descr);
}

// The main ccache driver function.
static void
ccache(int argc, char *argv[])
{
#ifndef _WIN32
	set_up_signal_handlers();
#endif

	orig_args = args_init(argc, argv);

	initialize();
	find_compiler(argv);

	if (str_eq(conf->temporary_dir, """")) {
		clean_up_internal_tempdir();
	}

	if (!str_eq(conf->log_file, """")) {
		conf_print_items(conf, configuration_logger, NULL);
	}

	if (conf->disable) {
		cc_log(""ccache is disabled"");
		failed();
	}

	set_up_uncached_err();

	cc_log_argv(""Command line: "", argv);
	cc_log(""Hostname: %s"", get_hostname());
	cc_log(""Working directory: %s"", get_current_working_dir());

	conf->limit_multiple = MIN(MAX(conf->limit_multiple, 0.0), 1.0);

	guessed_compiler = guess_compiler(orig_args->argv[0]);

	// Arguments (except -E) to send to the preprocessor.
	struct args *preprocessor_args;
	// Arguments to send to the real compiler.
	struct args *compiler_args;
	if (!cc_process_args(orig_args, &preprocessor_args, &compiler_args)) {
		failed();
	}

	cc_log(""Source file: %s"", input_file);
	if (generating_dependencies) {
		cc_log(""Dependency file: %s"", output_dep);
	}
	if (generating_coverage) {
		cc_log(""Coverage file: %s"", output_cov);
	}
	if (generating_stackusage) {
		cc_log(""Stack usage file: %s"", output_su);
	}
	if (generating_diagnostics) {
		cc_log(""Diagnostics file: %s"", output_dia);
	}
	if (output_dwo) {
		cc_log(""Split dwarf file: %s"", output_dwo);
	}

	cc_log(""Object file: %s"", output_obj);

	struct mdfour common_hash;
	hash_start(&common_hash);
	calculate_common_hash(preprocessor_args, &common_hash);

	// Try to find the hash using the manifest.
	struct mdfour direct_hash = common_hash;
	bool put_object_in_manifest = false;
	struct file_hash *object_hash = NULL;
	struct file_hash *object_hash_from_manifest = NULL;
	if (conf->direct_mode) {
		cc_log(""Trying direct lookup"");
		object_hash = calculate_object_hash(preprocessor_args, &direct_hash, 1);
		if (object_hash) {
			update_cached_result_globals(object_hash);

			// If we can return from cache at this point then do so.
			from_cache(FROMCACHE_DIRECT_MODE, 0);

			// Wasn't able to return from cache at this point. However, the object
			// was already found in manifest, so don't readd it later.
			put_object_in_manifest = false;

			object_hash_from_manifest = object_hash;
		} else {
			// Add object to manifest later.
			put_object_in_manifest = true;
		}
	}

	if (conf->read_only_direct) {
		cc_log(""Read-only direct mode; running real compiler"");
		failed();
	}

	// Find the hash using the preprocessed output. Also updates included_files.
	struct mdfour cpp_hash = common_hash;
	object_hash = calculate_object_hash(preprocessor_args, &cpp_hash, 0);
	if (!object_hash) {
		fatal(""internal error: object hash from cpp returned NULL"");
	}
	update_cached_result_globals(object_hash);

	if (object_hash_from_manifest
	    && !file_hashes_equal(object_hash_from_manifest, object_hash)) {
		// The hash from manifest differs from the hash of the preprocessor output.
		// This could be because:
		//
		// - The preprocessor produces different output for the same input (not
		//   likely).
		// - There's a bug in ccache (maybe incorrect handling of compiler
		//   arguments).
		// - The user has used a different CCACHE_BASEDIR (most likely).
		//
		// The best thing here would probably be to remove the hash entry from the
		// manifest. For now, we use a simpler method: just remove the manifest
		// file.
		cc_log(""Hash from manifest doesn't match preprocessor output"");
		cc_log(""Likely reason: different CCACHE_BASEDIRs used"");
		cc_log(""Removing manifest as a safety measure"");
		x_unlink(manifest_path);

		put_object_in_manifest = true;
	}

	// If we can return from cache at this point then do.
	from_cache(FROMCACHE_CPP_MODE, put_object_in_manifest);

	if (conf->read_only) {
		cc_log(""Read-only mode; running real compiler"");
		failed();
	}

	add_prefix(compiler_args, conf->prefix_command);

	// Run real compiler, sending output to cache.
	to_cache(compiler_args);

	x_exit(0);
}

static void
configuration_printer(const char *descr, const char *origin, void *context)
{
	assert(context);
	fprintf(context, ""(%s) %s\n"", origin, descr);
}

// The main program when not doing a compile.
static int
ccache_main_options(int argc, char *argv[])
{
	enum longopts {
		DUMP_MANIFEST
	};
	static const struct option options[] = {
		{""cleanup"",       no_argument,       0, 'c'},
		{""clear"",         no_argument,       0, 'C'},
		{""dump-manifest"", required_argument, 0, DUMP_MANIFEST},
		{""help"",          no_argument,       0, 'h'},
		{""max-files"",     required_argument, 0, 'F'},
		{""max-size"",      required_argument, 0, 'M'},
		{""set-config"",    required_argument, 0, 'o'},
		{""print-config"",  no_argument,       0, 'p'},
		{""show-stats"",    no_argument,       0, 's'},
		{""version"",       no_argument,       0, 'V'},
		{""zero-stats"",    no_argument,       0, 'z'},
		{0, 0, 0, 0}
	};

	int c;
	while ((c = getopt_long(argc, argv, ""cChF:M:o:psVz"", options, NULL)) != -1) {
		switch (c) {
		case DUMP_MANIFEST:
			manifest_dump(optarg, stdout);
			break;

		case 'c': // --cleanup
			initialize();
			clean_up_all(conf);
			printf(""Cleaned cache\n"");
			break;

		case 'C': // --clear
			initialize();
			wipe_all(conf);
			printf(""Cleared cache\n"");
			break;

		case 'h': // --help
			fputs(USAGE_TEXT, stdout);
			x_exit(0);

		case 'F': // --max-files
		{
			initialize();
			char *errmsg;
			if (conf_set_value_in_file(primary_config_path, ""max_files"", optarg,
			                           &errmsg)) {
				unsigned files = atoi(optarg);
				if (files == 0) {
					printf(""Unset cache file limit\n"");
				} else {
					printf(""Set cache file limit to %u\n"", files);
				}
			} else {
				fatal(""could not set cache file limit: %s"", errmsg);
			}
		}
		break;

		case 'M': // --max-size
		{
			initialize();
			uint64_t size;
			if (!parse_size_with_suffix(optarg, &size)) {
				fatal(""invalid size: %s"", optarg);
			}
			char *errmsg;
			if (conf_set_value_in_file(primary_config_path, ""max_size"", optarg,
			                           &errmsg)) {
				if (size == 0) {
					printf(""Unset cache size limit\n"");
				} else {
					char *s = format_human_readable_size(size);
					printf(""Set cache size limit to %s\n"", s);
					free(s);
				}
			} else {
				fatal(""could not set cache size limit: %s"", errmsg);
			}
		}
		break;

		case 'o': // --set-config
		{
			initialize();
			char *p = strchr(optarg, '=');
			if (!p) {
				fatal(""missing equal sign in \""%s\"""", optarg);
			}
			char *key = x_strndup(optarg, p - optarg);
			char *value = p + 1;
			char *errmsg;
			if (!conf_set_value_in_file(primary_config_path, key, value, &errmsg)) {
				fatal(""%s"", errmsg);
			}
			free(key);
		}
		break;

		case 'p': // --print-config
			initialize();
			conf_print_items(conf, configuration_printer, stdout);
			break;

		case 's': // --show-stats
			initialize();
			stats_summary(conf);
			break;

		case 'V': // --version
			fprintf(stdout, VERSION_TEXT, CCACHE_VERSION);
			x_exit(0);

		case 'z': // --zero-stats
			initialize();
			stats_zero();
			printf(""Statistics zeroed\n"");
			break;

		default:
			fputs(USAGE_TEXT, stderr);
			x_exit(1);
		}
	}

	return 0;
}

int
ccache_main(int argc, char *argv[])
{
	// Check if we are being invoked as ""ccache"".
	char *program_name = basename(argv[0]);
	if (same_executable_name(program_name, MYNAME)) {
		if (argc < 2) {
			fputs(USAGE_TEXT, stderr);
			x_exit(1);
		}
		// If the first argument isn't an option, then assume we are being passed a
		// compiler name and options.
		if (argv[1][0] == '-') {
			return ccache_main_options(argc, argv);
		}
	}
	free(program_name);

	ccache(argc, argv);
	return 1;
}
""",process_preprocessed_file,[757:946]
ccache,https://github.com/ccache/ccache/commit/420652300055dce2a3001f2abb09f19473b8a880,"""Include the presence of ""-fxxx-prefix-map="" options in the hash (#370)

Recently I landed commit 980e032d14ba (""Allow treating ""/dev/null"" as
an input file (#365)"") which sped up my kernel build a bunch.

Unfortunately I tested my change in isolation on the newest ccache
(AKA I constructed a simple test case and saw that it worked).  I only
tested it together with the Linux kernel when backported to an older
version of ccache.  A bit later I managed to get the newer version of
ccache fully integrated into my build system and tested my path there.
Then I noticed a problem because the new ccache contained the commit
919af39ccaca (""Support gcc-8 -ffile-prefix-map"")

Specifically my compiler doesn't support the
-fmacro-prefix-map=... option and thus my change and the ccache change
to support -fmacro-prefix-map caused caused my kernel build to fail.
It couldn't detect that -fmacro-prefix-map wasn't supported.  The
kernel effectively will make these two calls:

  $(CC) $(opts)
  $(CC) $(opts) -fmacro-prefix-map=...

Since the newer ccache doesn't use ""-fmacro-prefix-map="" when
computing its hash it will return the cached results from the first
call: AKA no compiler error.  Now the kernel Makefile will decide that
the ""-fmacro-prefix-map="" is supported and will continue to use it,
which is bad.

It seems like an easy fix to all this is to add the _presence_ of the
""-fxxx-prefix-map="" options into the hash.  Those that want to use
these options to reuse cache objects still can--they just need to make
sure that none of the invocations of the compiler totally omit the
option.""","""// ccache -- a fast C/C++ compiler cache
//
// Copyright (C) 2002-2007 Andrew Tridgell
// Copyright (C) 2009-2019 Joel Rosdahl
//
// This program is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by the Free
// Software Foundation; either version 3 of the License, or (at your option)
// any later version.
//
// This program is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
// more details.
//
// You should have received a copy of the GNU General Public License along with
// this program; if not, write to the Free Software Foundation, Inc., 51
// Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA

#include ""ccache.h""
#include ""compopt.h""
#ifdef HAVE_GETOPT_LONG
#include <getopt.h>
#else
#include ""getopt_long.h""
#endif
#include ""hash.h""
#include ""hashtable.h""
#include ""hashtable_itr.h""
#include ""hashutil.h""
#include ""language.h""
#include ""manifest.h""
#include ""unify.h""

#define STRINGIFY(x) #x
#define TO_STRING(x) STRINGIFY(x)

// Global variables used by other compilation units.
extern struct conf *conf;
extern char *primary_config_path;
extern char *secondary_config_path;
extern char *current_working_dir;
extern char *stats_file;
extern unsigned lock_staleness_limit;

static const char VERSION_TEXT[] =
	MYNAME "" version %s\n""
	""\n""
	""Copyright (C) 2002-2007 Andrew Tridgell\n""
	""Copyright (C) 2009-2019 Joel Rosdahl\n""
	""\n""
	""This program is free software; you can redistribute it and/or modify it under\n""
	""the terms of the GNU General Public License as published by the Free Software\n""
	""Foundation; either version 3 of the License, or (at your option) any later\n""
	""version.\n"";

static const char USAGE_TEXT[] =
	""Usage:\n""
	""    "" MYNAME "" [options]\n""
	""    "" MYNAME "" compiler [compiler options]\n""
	""    compiler [compiler options]          (via symbolic link)\n""
	""\n""
	""Common options:\n""
	""    -c, --cleanup             delete old files and recalculate size counters\n""
	""                              (normally not needed as this is done\n""
	""                              automatically)\n""
	""    -C, --clear               clear the cache completely (except configuration)\n""
	""    -F, --max-files=N         set maximum number of files in cache to N (use 0\n""
	""                              for no limit)\n""
	""    -M, --max-size=SIZE       set maximum size of cache to SIZE (use 0 for no\n""
	""                              limit); available suffixes: k, M, G, T (decimal)\n""
	""                              and Ki, Mi, Gi, Ti (binary); default suffix: G\n""
	""    -p, --show-config         show current configuration options in\n""
	""                              human-readable format\n""
	""    -s, --show-stats          show summary of configuration and statistics\n""
	""                              counters in human-readable format\n""
	""    -z, --zero-stats          zero statistics counters\n""
	""\n""
	""    -h, --help                print this help text\n""
	""    -V, --version             print version and copyright information\n""
	""\n""
	""Options for scripting or debugging:\n""
	""        --dump-manifest=PATH  dump manifest file at PATH in text format\n""
	""    -k, --get-config=K        print the value of configuration key K\n""
	""        --hash-file=PATH      print the hash (<MD4>-<size>) of the file at PATH\n""
	""        --print-stats         print statistics counter IDs and corresponding\n""
	""                              values in machine-parsable format\n""
	""    -o, --set-config=K=V      set configuration item K to value V\n""
	""\n""
	""See also <https://ccache.samba.org>.\n"";

// Global configuration data.
struct conf *conf = NULL;

// Where to write configuration changes.
char *primary_config_path = NULL;

// Secondary, read-only configuration file (if any).
char *secondary_config_path = NULL;

// Current working directory taken from $PWD, or getcwd() if $PWD is bad.
char *current_working_dir = NULL;

// The original argument list.
static struct args *orig_args;

// The source file.
static char *input_file;

// The output file being compiled to.
static char *output_obj;

// The path to the dependency file (implicit or specified with -MF).
static char *output_dep;

// The path to the coverage file (implicit when using -ftest-coverage).
static char *output_cov;

// The path to the stack usage (implicit when using -fstack-usage).
static char *output_su;

// Diagnostic generation information (clang). Contains pathname if not NULL.
static char *output_dia;

// Split dwarf information (GCC 4.8 and up). Contains pathname if not NULL.
static char *output_dwo;

// Language to use for the compilation target (see language.c).
static const char *actual_language;

// Array for storing -arch options.
#define MAX_ARCH_ARGS 10
static size_t arch_args_size = 0;
static char *arch_args[MAX_ARCH_ARGS] = {NULL};

// Name (represented as a struct file_hash) of the file containing the cached
// object code.
static struct file_hash *cached_obj_hash;

// Full path to the file containing the cached object code
// (cachedir/a/b/cdef[...]-size.o).
static char *cached_obj;

// Full path to the file containing the standard error output
// (cachedir/a/b/cdef[...]-size.stderr).
static char *cached_stderr;

// Full path to the file containing the dependency information
// (cachedir/a/b/cdef[...]-size.d).
static char *cached_dep;

// Full path to the file containing the coverage information
// (cachedir/a/b/cdef[...]-size.gcno).
static char *cached_cov;

// Full path to the file containing the stack usage
// (cachedir/a/b/cdef[...]-size.su).
static char *cached_su;

// Full path to the file containing the diagnostic information (for clang)
// (cachedir/a/b/cdef[...]-size.dia).
static char *cached_dia;

// Full path to the file containing the split dwarf (for GCC 4.8 and above)
// (cachedir/a/b/cdef[...]-size.dwo).
//
// Contains NULL if -gsplit-dwarf is not given.
static char *cached_dwo;

// Full path to the file containing the manifest
// (cachedir/a/b/cdef[...]-size.manifest).
static char *manifest_path;

// Time of compilation. Used to see if include files have changed after
// compilation.
time_t time_of_compilation;

// Files included by the preprocessor and their hashes/sizes. Key: file path.
// Value: struct file_hash.
static struct hashtable *included_files = NULL;

// Uses absolute path for some include files.
static bool has_absolute_include_headers = false;

// List of headers to ignore.
static char **ignore_headers;

// Size of headers to ignore list.
static size_t ignore_headers_len;

// Is the compiler being asked to output debug info?
static bool generating_debuginfo;

// Is the compiler being asked to output dependencies?
static bool generating_dependencies;

// Is the compiler being asked to output coverage?
static bool generating_coverage;

// Is the compiler being asked to output stack usage?
static bool generating_stackusage;

// Us the compiler being asked to generate diagnostics
// (--serialize-diagnostics)?
static bool generating_diagnostics;

// Is the compiler being asked to separate dwarf debug info into a separate
// file (-gsplit-dwarf)""?
static bool using_split_dwarf;

// Relocating debuginfo in the format old=new.
static char **debug_prefix_maps = NULL;

// Size of debug_prefix_maps list.
static size_t debug_prefix_maps_len = 0;

// Is the compiler being asked to output coverage data (.gcda) at runtime?
static bool profile_arcs;

// Name of the custom profile directory (default: object dirname).
static char *profile_dir;

// The name of the temporary preprocessed file.
static char *i_tmpfile;

// Are we compiling a .i or .ii file directly?
static bool direct_i_file;

// The name of the cpp stderr file.
static char *cpp_stderr;

// Full path to the statistics file in the subdirectory where the cached result
// belongs (<cache_dir>/<x>/stats).
char *stats_file = NULL;

// Whether the output is a precompiled header.
bool output_is_precompiled_header = false;

// Compiler guessing is currently only based on the compiler name, so nothing
// should hard-depend on it if possible.
enum guessed_compiler guessed_compiler = GUESSED_UNKNOWN;

// Profile generation / usage information.
static char *profile_dir = NULL;
static bool profile_use = false;
static bool profile_generate = false;

// Sanitize blacklist
static char **sanitize_blacklists = NULL;

// Size of sanitize_blacklists
static size_t sanitize_blacklists_len = 0;

// Whether we are using a precompiled header (either via -include, #include or
// clang's -include-pch or -include-pth).
static bool using_precompiled_header = false;

// The .gch/.pch/.pth file used for compilation.
static char *included_pch_file = NULL;

// How long (in microseconds) to wait before breaking a stale lock.
unsigned lock_staleness_limit = 2000000;

enum fromcache_call_mode {
	FROMCACHE_DIRECT_MODE,
	FROMCACHE_CPP_MODE
};

struct pending_tmp_file {
	char *path;
	struct pending_tmp_file *next;
};

// Temporary files to remove at program exit.
static struct pending_tmp_file *pending_tmp_files = NULL;

#ifndef _WIN32
static sigset_t fatal_signal_set;

// PID of currently executing compiler that we have started, if any. 0 means no
// ongoing compilation.
static pid_t compiler_pid = 0;
#endif

// This is a string that identifies the current ""version"" of the hash sum
// computed by ccache. If, for any reason, we want to force the hash sum to be
// different for the same input in a new ccache version, we can just change
// this string. A typical example would be if the format of one of the files
// stored in the cache changes in a backwards-incompatible way.
static const char HASH_PREFIX[] = ""3"";

static void
add_prefix(struct args *args, char *prefix_command)
{
	if (str_eq(prefix_command, """")) {
		return;
	}

	struct args *prefix = args_init(0, NULL);
	char *e = x_strdup(prefix_command);
	char *saveptr = NULL;
	for (char *tok = strtok_r(e, "" "", &saveptr);
	     tok;
	     tok = strtok_r(NULL, "" "", &saveptr)) {
		char *p;

		p = find_executable(tok, MYNAME);
		if (!p) {
			fatal(""%s: %s"", tok, strerror(errno));
		}

		args_add(prefix, p);
		free(p);
	}
	free(e);

	cc_log(""Using command-line prefix %s"", prefix_command);
	for (int i = prefix->argc; i != 0; i--) {
		args_add_prefix(args, prefix->argv[i-1]);
	}
	args_free(prefix);
}


static void failed(void) ATTR_NORETURN;

// Something went badly wrong - just execute the real compiler.
static void
failed(void)
{
	assert(orig_args);

	args_strip(orig_args, ""--ccache-"");
	add_prefix(orig_args, conf->prefix_command);

	cc_log(""Failed; falling back to running the real compiler"");
	cc_log_argv(""Executing "", orig_args->argv);
	exitfn_call();
	execv(orig_args->argv[0], orig_args->argv);
	fatal(""execv of %s failed: %s"", orig_args->argv[0], strerror(errno));
}

static const char *
temp_dir()
{
	static char *path = NULL;
	if (path) {
		return path; // Memoize
	}
	path = conf->temporary_dir;
	if (str_eq(path, """")) {
		path = format(""%s/tmp"", conf->cache_dir);
	}
	return path;
}

void
block_signals(void)
{
#ifndef _WIN32
	sigprocmask(SIG_BLOCK, &fatal_signal_set, NULL);
#endif
}

void
unblock_signals(void)
{
#ifndef _WIN32
	sigset_t empty;
	sigemptyset(&empty);
	sigprocmask(SIG_SETMASK, &empty, NULL);
#endif
}

static void
add_pending_tmp_file(const char *path)
{
	block_signals();
	struct pending_tmp_file *e = x_malloc(sizeof(*e));
	e->path = x_strdup(path);
	e->next = pending_tmp_files;
	pending_tmp_files = e;
	unblock_signals();
}

static void
do_clean_up_pending_tmp_files(void)
{
	struct pending_tmp_file *p = pending_tmp_files;
	while (p) {
		// Can't call tmp_unlink here since its cc_log calls aren't signal safe.
		unlink(p->path);
		p = p->next;
		// Leak p->path and p here because clean_up_pending_tmp_files needs to be
		// signal safe.
	}
}

static void
clean_up_pending_tmp_files(void)
{
	block_signals();
	do_clean_up_pending_tmp_files();
	unblock_signals();
}

#ifndef _WIN32
static void
signal_handler(int signum)
{
	// Unregister handler for this signal so that we can send the signal to
	// ourselves at the end of the handler.
	signal(signum, SIG_DFL);

	// If ccache was killed explicitly, then bring the compiler subprocess (if
	// any) with us as well.
	if (signum == SIGTERM
	    && compiler_pid != 0
	    && waitpid(compiler_pid, NULL, WNOHANG) == 0) {
		kill(compiler_pid, signum);
	}

	do_clean_up_pending_tmp_files();

	if (compiler_pid != 0) {
		// Wait for compiler subprocess to exit before we snuff it.
		waitpid(compiler_pid, NULL, 0);
	}

	// Resend signal to ourselves to exit properly after returning from the
	// handler.
	kill(getpid(), signum);
}

static void
register_signal_handler(int signum)
{
	struct sigaction act;
	memset(&act, 0, sizeof(act));
	act.sa_handler = signal_handler;
	act.sa_mask = fatal_signal_set;
#ifdef SA_RESTART
	act.sa_flags = SA_RESTART;
#endif
	sigaction(signum, &act, NULL);
}

static void
set_up_signal_handlers(void)
{
	sigemptyset(&fatal_signal_set);
	sigaddset(&fatal_signal_set, SIGINT);
	sigaddset(&fatal_signal_set, SIGTERM);
#ifdef SIGHUP
	sigaddset(&fatal_signal_set, SIGHUP);
#endif
#ifdef SIGQUIT
	sigaddset(&fatal_signal_set, SIGQUIT);
#endif

	register_signal_handler(SIGINT);
	register_signal_handler(SIGTERM);
#ifdef SIGHUP
	register_signal_handler(SIGHUP);
#endif
#ifdef SIGQUIT
	register_signal_handler(SIGQUIT);
#endif
}
#endif // _WIN32

static void
clean_up_internal_tempdir(void)
{
	time_t now = time(NULL);
	struct stat st;
	if (x_stat(conf->cache_dir, &st) != 0 || st.st_mtime + 3600 >= now) {
		// No cleanup needed.
		return;
	}

	update_mtime(conf->cache_dir);

	DIR *dir = opendir(temp_dir());
	if (!dir) {
		return;
	}

	struct dirent *entry;
	while ((entry = readdir(dir))) {
		if (str_eq(entry->d_name, ""."") || str_eq(entry->d_name, "".."")) {
			continue;
		}

		char *path = format(""%s/%s"", temp_dir(), entry->d_name);
		if (x_lstat(path, &st) == 0 && st.st_mtime + 3600 < now) {
			tmp_unlink(path);
		}
		free(path);
	}

	closedir(dir);
}

static void
fclose_exitfn(void *context)
{
	fclose((FILE *)context);
}

static void
dump_debug_log_buffer_exitfn(void *context)
{
	if (!conf->debug) {
		return;
	}

	char *path = format(""%s.ccache-log"", (const char *)context);
	cc_dump_debug_log_buffer(path);
	free(path);
}

static void
init_hash_debug(struct hash *hash, const char *obj_path, char type,
                const char *section_name, FILE *debug_text_file)
{
	if (!conf->debug) {
		return;
	}

	char *path = format(""%s.ccache-input-%c"", obj_path, type);
	FILE *debug_binary_file = fopen(path, ""wb"");
	if (debug_binary_file) {
		hash_enable_debug(hash, section_name, debug_binary_file, debug_text_file);
		exitfn_add(fclose_exitfn, debug_binary_file);
	} else {
		cc_log(""Failed to open %s: %s"", path, strerror(errno));
	}
	free(path);
}

static enum guessed_compiler
guess_compiler(const char *path)
{
	char *name = basename(path);
	enum guessed_compiler result = GUESSED_UNKNOWN;
	if (strstr(name, ""clang"")) {
		result = GUESSED_CLANG;
	} else if (strstr(name, ""gcc"") || strstr(name, ""g++"")) {
		result = GUESSED_GCC;
	} else if (strstr(name, ""nvcc"")) {
		result = GUESSED_NVCC;
	} else if (str_eq(name, ""pump"") || str_eq(name, ""distcc-pump"")) {
		result = GUESSED_PUMP;
	}
	free(name);
	return result;
}

static char *
get_current_working_dir(void)
{
	if (!current_working_dir) {
		char *cwd = get_cwd();
		if (cwd) {
			current_working_dir = x_realpath(cwd);
			free(cwd);
		}
		if (!current_working_dir) {
			cc_log(""Unable to determine current working directory: %s"",
			       strerror(errno));
			failed();
		}
	}
	return current_working_dir;
}

// Transform a name to a full path into the cache directory, creating needed
// sublevels if needed. Caller frees.
static char *
get_path_in_cache(const char *name, const char *suffix)
{
	char *path = x_strdup(conf->cache_dir);
	for (unsigned i = 0; i < conf->cache_dir_levels; ++i) {
		char *p = format(""%s/%c"", path, name[i]);
		free(path);
		path = p;
	}

	char *result =
		format(""%s/%s%s"", path, name + conf->cache_dir_levels, suffix);
	free(path);
	return result;
}

// This function hashes an include file and stores the path and hash in the
// global included_files variable. If the include file is a PCH, cpp_hash is
// also updated. Takes over ownership of path.
static void
remember_include_file(char *path, struct hash *cpp_hash, bool system,
                      struct hash *depend_mode_hash)
{
	struct hash *fhash = NULL;

	size_t path_len = strlen(path);
	if (path_len >= 2 && (path[0] == '<' && path[path_len - 1] == '>')) {
		// Typically <built-in> or <command-line>.
		goto out;
	}

	if (str_eq(path, input_file)) {
		// Don't remember the input file.
		goto out;
	}

	if (system && (conf->sloppiness & SLOPPY_SYSTEM_HEADERS)) {
		// Don't remember this system header.
		goto out;
	}

	if (hashtable_search(included_files, path)) {
		// Already known include file.
		goto out;
	}

#ifdef _WIN32
	// stat fails on directories on win32.
	DWORD attributes = GetFileAttributes(path);
	if (attributes != INVALID_FILE_ATTRIBUTES &&
	    attributes & FILE_ATTRIBUTE_DIRECTORY) {
		goto out;
	}
#endif

	struct stat st;
	if (x_stat(path, &st) != 0) {
		goto failure;
	}
	if (S_ISDIR(st.st_mode)) {
		// Ignore directory, typically $PWD.
		goto out;
	}
	if (!S_ISREG(st.st_mode)) {
		// Device, pipe, socket or other strange creature.
		cc_log(""Non-regular include file %s"", path);
		goto failure;
	}

	// Canonicalize path for comparison; clang uses ./header.h.
	char *canonical = path;
	size_t canonical_len = path_len;
	if (canonical[0] == '.' && canonical[1] == '/') {
		canonical += 2;
		canonical_len -= 2;
	}

	for (size_t i = 0; i < ignore_headers_len; i++) {
		char *ignore = ignore_headers[i];
		size_t ignore_len = strlen(ignore);
		if (ignore_len > canonical_len) {
			continue;
		}
		if (strncmp(canonical, ignore, ignore_len) == 0
		    && (ignore[ignore_len-1] == DIR_DELIM_CH
		        || canonical[ignore_len] == DIR_DELIM_CH
		        || canonical[ignore_len] == '\0')) {
			goto out;
		}
	}

	// The comparison using >= is intentional, due to a possible race between
	// starting compilation and writing the include file. See also the notes
	// under ""Performance"" in doc/MANUAL.adoc.
	if (!(conf->sloppiness & SLOPPY_INCLUDE_FILE_MTIME)
	    && st.st_mtime >= time_of_compilation) {
		cc_log(""Include file %s too new"", path);
		goto failure;
	}

	// The same >= logic as above applies to the change time of the file.
	if (!(conf->sloppiness & SLOPPY_INCLUDE_FILE_CTIME)
	    && st.st_ctime >= time_of_compilation) {
		cc_log(""Include file %s ctime too new"", path);
		goto failure;
	}

	// Let's hash the include file content.
	fhash = hash_init();

	bool is_pch = is_precompiled_header(path);
	if (is_pch) {
		bool using_pch_sum = false;
		if (conf->pch_external_checksum) {
			// hash pch.sum instead of pch when it exists
			// to prevent hashing a very large .pch file every time
			char *pch_sum_path = format(""%s.sum"", path);
			if (x_stat(pch_sum_path, &st) == 0) {
				char *old_path = path;
				path = pch_sum_path;
				pch_sum_path = old_path;
				using_pch_sum = true;
				cc_log(""Using pch.sum file %s"", path);
			}
			free(pch_sum_path);
		}

		if (!hash_file(fhash, path)) {
			goto failure;
		}
		hash_delimiter(cpp_hash, using_pch_sum ? ""pch_sum_hash"" : ""pch_hash"");
		char *pch_hash_result = hash_result(fhash);
		hash_string(cpp_hash, pch_hash_result);
		free(pch_hash_result);
	}

	if (conf->direct_mode) {
		if (!is_pch) { // else: the file has already been hashed.
			char *source = NULL;
			size_t size;
			if (st.st_size > 0) {
				if (!read_file(path, st.st_size, &source, &size)) {
					goto failure;
				}
			} else {
				source = x_strdup("""");
				size = 0;
			}

			int result = hash_source_code_string(conf, fhash, source, size, path);
			free(source);
			if (result & HASH_SOURCE_CODE_ERROR
			    || result & HASH_SOURCE_CODE_FOUND_TIME) {
				goto failure;
			}
		}

		struct file_hash *h = x_malloc(sizeof(*h));
		hash_result_as_bytes(fhash, h->hash);
		h->size = hash_input_size(fhash);
		hashtable_insert(included_files, path, h);
		path = NULL; // Ownership transferred to included_files.

		if (depend_mode_hash) {
			hash_delimiter(depend_mode_hash, ""include"");
			hash_buffer(depend_mode_hash, h->hash, sizeof(h->hash));
		}
	}

	goto out;

failure:
	if (conf->direct_mode) {
		cc_log(""Disabling direct mode"");
		conf->direct_mode = false;
	}
	// Fall through.
out:
	hash_free(fhash);
	free(path);
}

static void
print_included_files(FILE *fp)
{
	struct hashtable_itr *iter = hashtable_iterator(included_files);
	do {
		char *path = hashtable_iterator_key(iter);
		fprintf(fp, ""%s\n"", path);
	} while (hashtable_iterator_advance(iter));
}

// Make a relative path from current working directory to path if path is under
// the base directory. Takes over ownership of path. Caller frees.
static char *
make_relative_path(char *path)
{
	if (str_eq(conf->base_dir, """") || !str_startswith(path, conf->base_dir)) {
		return path;
	}

#ifdef _WIN32
	if (path[0] == '/') {
		path++;  // Skip leading slash.
	}
#endif

	// x_realpath only works for existing paths, so if path doesn't exist, try
	// dirname(path) and assemble the path afterwards. We only bother to try
	// canonicalizing one of these two paths since a compiler path argument
	// typically only makes sense if path or dirname(path) exists.
	char *path_suffix = NULL;
	struct stat st;
	if (stat(path, &st) != 0) {
		// path doesn't exist.
		char *dir = dirname(path);
		// find the nearest existing directory in path
		while (stat(dir, &st) != 0) {
			char *parent_dir = dirname(dir);
			free(dir);
			dir = parent_dir;
		}

		// suffix is the remaining of the path, skip the first delimiter
		size_t dir_len = strlen(dir);
		if (path[dir_len] == '/' || path[dir_len] == '\\') {
			dir_len++;
		}
		path_suffix = x_strdup(&path[dir_len]);
		char *p = path;
		path = dir;
		free(p);
	}

	char *canon_path = x_realpath(path);
	if (canon_path) {
		free(path);
		char *relpath = get_relative_path(get_current_working_dir(), canon_path);
		free(canon_path);
		if (path_suffix) {
			path = format(""%s/%s"", relpath, path_suffix);
			free(relpath);
			free(path_suffix);
			return path;
		} else {
			return relpath;
		}
	} else {
		// path doesn't exist, so leave it as it is.
		free(path_suffix);
		return path;
	}
}

static void
init_included_files_table(void)
{
	// (This function may be called multiple times if several -arch options are
	// used.)
	if (!included_files) {
		included_files = create_hashtable(1000, hash_from_string, strings_equal);
	}
}

// This function reads and hashes a file. While doing this, it also does these
// things:
//
// - Makes include file paths for which the base directory is a prefix relative
//   when computing the hash sum.
// - Stores the paths and hashes of included files in the global variable
//   included_files.
static bool
process_preprocessed_file(struct hash *hash, const char *path, bool pump)
{
	char *data;
	size_t size;
	if (!read_file(path, 0, &data, &size)) {
		return false;
	}

	ignore_headers = NULL;
	ignore_headers_len = 0;
	if (!str_eq(conf->ignore_headers_in_manifest, """")) {
		char *header, *p, *q, *saveptr = NULL;
		p = x_strdup(conf->ignore_headers_in_manifest);
		q = p;
		while ((header = strtok_r(q, PATH_DELIM, &saveptr))) {
			ignore_headers = x_realloc(ignore_headers,
			                           (ignore_headers_len+1) * sizeof(char *));
			ignore_headers[ignore_headers_len++] = x_strdup(header);
			q = NULL;
		}
		free(p);
	}

	init_included_files_table();

	char *cwd = gnu_getcwd();

	// Bytes between p and q are pending to be hashed.
	char *p = data;
	char *q = data;
	char *end = data + size;

	// There must be at least 7 characters (# 1 ""x"") left to potentially find an
	// include file path.
	while (q < end - 7) {
		// Check if we look at a line containing the file name of an included file.
		// At least the following formats exist (where N is a positive integer):
		//
		// GCC:
		//
		//   # N ""file""
		//   # N ""file"" N
		//   #pragma GCC pch_preprocess ""file""
		//
		// HP's compiler:
		//
		//   #line N ""file""
		//
		// AIX's compiler:
		//
		//   #line N ""file""
		//   #line N
		//
		// Note that there may be other lines starting with '#' left after
		// preprocessing as well, for instance ""#    pragma"".
		if (q[0] == '#'
		    // GCC:
		    && ((q[1] == ' ' && q[2] >= '0' && q[2] <= '9')
		        // GCC precompiled header:
		        || (q[1] == 'p'
		            && str_startswith(&q[2], ""ragma GCC pch_preprocess ""))
		        // HP/AIX:
		        || (q[1] == 'l' && q[2] == 'i' && q[3] == 'n' && q[4] == 'e'
		            && q[5] == ' '))
		    && (q == data || q[-1] == '\n')) {
			// Workarounds for preprocessor linemarker bugs in GCC version 6.
			if (q[2] == '3') {
				if (str_startswith(q, ""# 31 \""<command-line>\""\n"")) {
					// Bogus extra line with #31, after the regular #1: Ignore the whole
					// line, and continue parsing.
					hash_string_buffer(hash, p, q - p);
					while (q < end && *q != '\n') {
						q++;
					}
					q++;
					p = q;
					continue;
				} else if (str_startswith(q, ""# 32 \""<command-line>\"" 2\n"")) {
					// Bogus wrong line with #32, instead of regular #1: Replace the line
					// number with the usual one.
					hash_string_buffer(hash, p, q - p);
					q += 1;
					q[0] = '#';
					q[1] = ' ';
					q[2] = '1';
					p = q;
				}
			}

			while (q < end && *q != '""' && *q != '\n') {
				q++;
			}
			if (q < end && *q == '\n') {
				// A newline before the quotation mark -> no match.
				continue;
			}
			q++;
			if (q >= end) {
				cc_log(""Failed to parse included file path"");
				free(data);
				free(cwd);
				return false;
			}
			// q points to the beginning of an include file path
			hash_string_buffer(hash, p, q - p);
			p = q;
			while (q < end && *q != '""') {
				q++;
			}
			// Look for preprocessor flags, after the ""filename"".
			bool system = false;
			char *r = q + 1;
			while (r < end && *r != '\n') {
				if (*r == '3') { // System header.
					system = true;
				}
				r++;
			}
			// p and q span the include file path.
			char *inc_path = x_strndup(p, q - p);
			if (!has_absolute_include_headers) {
				has_absolute_include_headers = is_absolute_path(inc_path);
			}
			inc_path = make_relative_path(inc_path);

			bool should_hash_inc_path = true;
			if (!conf->hash_dir) {
				if (str_startswith(inc_path, cwd) && str_endswith(inc_path, ""//"")) {
					// When compiling with -g or similar, GCC adds the absolute path to
					// CWD like this:
					//
					//   # 1 ""CWD//""
					//
					// If the user has opted out of including the CWD in the hash, don't
					// hash it. See also how debug_prefix_map is handled.
					should_hash_inc_path = false;
				}
			}
			if (should_hash_inc_path) {
				hash_string_buffer(hash, inc_path, strlen(inc_path));
			}

			remember_include_file(inc_path, hash, system, NULL);
			p = q; // Everything of interest between p and q has been hashed now.
		} else if (q[0] == '.' && q[1] == 'i' && q[2] == 'n' && q[3] == 'c'
		           && q[4] == 'b' && q[5] == 'i' && q[6] == 'n') {
			// An assembler .inc bin (without the space) statement, which could be
			// part of inline assembly, refers to an external file. If the file
			// changes, the hash should change as well, but finding out what file to
			// hash is too hard for ccache, so just bail out.
			cc_log(""Found unsupported .inc"" ""bin directive in source code"");
			stats_update(STATS_UNSUPPORTED_DIRECTIVE);
			failed();
		} else if (pump && strncmp(q, ""_________"", 9) == 0) {
			// Unfortunately the distcc-pump wrapper outputs standard output lines:
			// __________Using distcc-pump from /usr/bin
			// __________Using # distcc servers in pump mode
			// __________Shutting down distcc-pump include server
			while (q < end && *q != '\n') {
				q++;
			}
			if (*q == '\n') {
				q++;
			}
			p = q;
			continue;
		} else {
			q++;
		}
	}

	hash_string_buffer(hash, p, (end - p));
	free(data);
	free(cwd);

	// Explicitly check the .gch/.pch/.pth file, Clang does not include any
	// mention of it in the preprocessed output.
	if (included_pch_file) {
		char *pch_path = x_strdup(included_pch_file);
		pch_path = make_relative_path(pch_path);
		hash_string(hash, pch_path);
		remember_include_file(pch_path, hash, false, NULL);
	}

	bool debug_included = getenv(""CCACHE_DEBUG_INCLUDED"");
	if (debug_included) {
		print_included_files(stdout);
	}

	return true;
}

// Replace absolute paths with relative paths in the provided dependency file.
static void
use_relative_paths_in_depfile(const char *depfile)
{
	if (str_eq(conf->base_dir, """")) {
		cc_log(""Base dir not set, skip using relative paths"");
		return; // nothing to do
	}
	if (!has_absolute_include_headers) {
		cc_log(""No absolute path for included files found, skip using relative""
		       "" paths"");
		return; // nothing to do
	}

	FILE *f;
	f = fopen(depfile, ""r"");
	if (!f) {
		cc_log(""Cannot open dependency file: %s (%s)"", depfile, strerror(errno));
		return;
	}

	char *tmp_file = format(""%s.tmp"", depfile);
	FILE *tmpf = create_tmp_file(&tmp_file, ""w"");

	bool result = false;
	char buf[10000];
	while (fgets(buf, sizeof(buf), f) && !ferror(tmpf)) {
		char *saveptr;
		char *token = strtok_r(buf, "" \t"", &saveptr);
		while (token) {
			char *relpath;
			if (is_absolute_path(token) && str_startswith(token, conf->base_dir)) {
				relpath = make_relative_path(x_strdup(token));
				result = true;
			} else {
				relpath = token;
			}
			if (token != buf) { // This is a dependency file.
				fputc(' ', tmpf);
			}
			fputs(relpath, tmpf);
			if (relpath != token) {
				free(relpath);
			}
			token = strtok_r(NULL, "" \t"", &saveptr);
		}
	}

	if (ferror(f)) {
		cc_log(""Error reading dependency file: %s, skip relative path usage"",
		       depfile);
		result = false;
		goto out;
	}
	if (ferror(tmpf)) {
		cc_log(""Error writing temporary dependency file: %s, skip relative path""
		       "" usage"", tmp_file);
		result = false;
		goto out;
	}

out:
	fclose(tmpf);
	fclose(f);
	if (result) {
		if (x_rename(tmp_file, depfile) != 0) {
			cc_log(""Error renaming dependency file: %s -> %s (%s), skip relative""
			       "" path usage"", tmp_file, depfile, strerror(errno));
			result = false;
		} else {
			cc_log(""Renamed dependency file: %s -> %s"", tmp_file, depfile);
		}
	}
	if (!result) {
		cc_log(""Removing temporary dependency file: %s"", tmp_file);
		x_unlink(tmp_file);
	}
	free(tmp_file);
}

// Extract the used includes from the dependency file. Note that we cannot
// distinguish system headers from other includes here.
static struct file_hash *
object_hash_from_depfile(const char *depfile, struct hash *hash)
{
	FILE *f = fopen(depfile, ""r"");
	if (!f) {
		cc_log(""Cannot open dependency file %s: %s"", depfile, strerror(errno));
		return NULL;
	}

	init_included_files_table();

	char buf[10000];
	while (fgets(buf, sizeof(buf), f) && !ferror(f)) {
		char *saveptr;
		char *token;
		for (token = strtok_r(buf, "" \t\n"", &saveptr);
		     token;
		     token = strtok_r(NULL, "" \t\n"", &saveptr)) {
			if (str_endswith(token, "":"") || str_eq(token, ""\\"")) {
				continue;
			}
			if (!has_absolute_include_headers) {
				has_absolute_include_headers = is_absolute_path(token);
			}
			char *path = make_relative_path(x_strdup(token));
			remember_include_file(path, hash, false, hash);
		}
	}

	fclose(f);

	bool debug_included = getenv(""CCACHE_DEBUG_INCLUDED"");
	if (debug_included) {
		print_included_files(stdout);
	}

	struct file_hash *result = x_malloc(sizeof(*result));
	hash_result_as_bytes(hash, result->hash);
	result->size = hash_input_size(hash);
	return result;
}

// Helper method for copy_file_to_cache and move_file_to_cache_same_fs.
static void
do_copy_or_move_file_to_cache(const char *source, const char *dest, bool copy)
{
	assert(!conf->read_only);
	assert(!conf->read_only_direct);

	struct stat orig_dest_st;
	bool orig_dest_existed = stat(dest, &orig_dest_st) == 0;
	int compression_level = conf->compression ? conf->compression_level : 0;
	bool do_move = !copy && !conf->compression;
	bool do_link = copy && conf->hard_link && !conf->compression;

	if (do_move) {
		move_uncompressed_file(source, dest, compression_level);
	} else {
		if (do_link) {
			x_unlink(dest);
			int ret = link(source, dest);
			if (ret != 0) {
				cc_log(""Failed to link %s to %s: %s"", source, dest, strerror(errno));
				cc_log(""Falling back to copying"");
				do_link = false;
			}
		}
		if (!do_link) {
			int ret = copy_file(source, dest, compression_level);
			if (ret != 0) {
				cc_log(""Failed to copy %s to %s: %s"", source, dest, strerror(errno));
				stats_update(STATS_ERROR);
				failed();
			}
		}
	}

	if (!copy && conf->compression) {
		// We fell back to copying since dest should be compressed, so clean up.
		x_unlink(source);
	}

	cc_log(""Stored in cache: %s -> %s (%s)"",
	       source,
	       dest,
	       do_move ? ""moved"" : (do_link ? ""linked"" : ""copied""));

	struct stat st;
	if (x_stat(dest, &st) != 0) {
		stats_update(STATS_ERROR);
		failed();
	}
	stats_update_size(
		file_size(&st) - (orig_dest_existed ? file_size(&orig_dest_st) : 0),
		orig_dest_existed ? 0 : 1);
}

// Copy a file into the cache.
//
// dest must be a path in the cache (see get_path_in_cache). source does not
// have to be on the same file system as dest.
//
// An attempt will be made to hard link source to dest if conf->hard_link is
// true and conf->compression is false, otherwise copy. dest will be compressed
// if conf->compression is true.
static void
copy_file_to_cache(const char *source, const char *dest)
{
	do_copy_or_move_file_to_cache(source, dest, true);
}

// Move a file into the cache.
//
// dest must be a path in the cache (see get_path_in_cache). source must be on
// the same file system as dest. dest will be compressed if conf->compression
// is true.
static void
move_file_to_cache_same_fs(const char *source, const char *dest)
{
	do_copy_or_move_file_to_cache(source, dest, false);
}

// Copy or link a file from the cache.
static void
get_file_from_cache(const char *source, const char *dest)
{
	int ret;
	bool do_link = conf->hard_link && !file_is_compressed(source);
	if (do_link) {
		x_unlink(dest);
		ret = link(source, dest);
	} else {
		ret = copy_file(source, dest, 0);
	}

	if (ret == -1) {
		if (errno == ENOENT || errno == ESTALE) {
			cc_log(""File missing in cache: %s"", source);
			stats_update(STATS_MISSING);
		} else {
			cc_log(""Failed to %s %s to %s: %s"",
			       do_link ? ""link"" : ""copy"",
			       source,
			       dest,
			       strerror(errno));
			stats_update(STATS_ERROR);
		}

		// If there was trouble getting a file from the cached result, wipe the
		// whole cached result for consistency.
		x_unlink(cached_stderr);
		x_unlink(cached_obj);
		x_unlink(cached_dep);
		x_unlink(cached_cov);
		x_unlink(cached_su);
		x_unlink(cached_dia);
		x_unlink(cached_dwo);

		failed();
	}

	cc_log(""Created from cache: %s -> %s"", source, dest);
}

// Send cached stderr, if any, to stderr.
static void
send_cached_stderr(void)
{
	int fd_stderr = open(cached_stderr, O_RDONLY | O_BINARY);
	if (fd_stderr != -1) {
		copy_fd(fd_stderr, 2);
		close(fd_stderr);
	}
}

// Create or update the manifest file.
static void
update_manifest_file(void)
{
	if (!conf->direct_mode
	    || !included_files
	    || conf->read_only
	    || conf->read_only_direct) {
		return;
	}

	struct stat st;
	size_t old_size = 0; // in bytes
	if (stat(manifest_path, &st) == 0) {
		old_size = file_size(&st);
	}
	if (manifest_put(manifest_path, cached_obj_hash, included_files)) {
		cc_log(""Added object file hash to %s"", manifest_path);
		if (x_stat(manifest_path, &st) == 0) {
			stats_update_size(file_size(&st) - old_size, old_size == 0 ? 1 : 0);
		}
	} else {
		cc_log(""Failed to add object file hash to %s"", manifest_path);
	}
}

static void
update_cached_result_globals(struct file_hash *hash)
{
	char *object_name = format_hash_as_string(hash->hash, hash->size);
	cached_obj_hash = hash;
	cached_obj = get_path_in_cache(object_name, "".o"");
	cached_stderr = get_path_in_cache(object_name, "".stderr"");
	cached_dep = get_path_in_cache(object_name, "".d"");
	cached_cov = get_path_in_cache(object_name, "".gcno"");
	cached_su = get_path_in_cache(object_name, "".su"");
	cached_dia = get_path_in_cache(object_name, "".dia"");
	cached_dwo = get_path_in_cache(object_name, "".dwo"");

	stats_file = format(""%s/%c/stats"", conf->cache_dir, object_name[0]);
	free(object_name);
}

// Run the real compiler and put the result in cache.
static void
to_cache(struct args *args, struct hash *depend_mode_hash)
{
	args_add(args, ""-o"");
	args_add(args, output_obj);

	if (conf->hard_link) {
		x_unlink(output_obj);
	}

	if (generating_diagnostics) {
		args_add(args, ""--serialize-diagnostics"");
		args_add(args, output_dia);
	}

	// Turn off DEPENDENCIES_OUTPUT when running cc1, because otherwise it will
	// emit a line like this:
	//
	//   tmp.stdout.vexed.732.o: /home/mbp/.ccache/tmp.stdout.vexed.732.i
	x_unsetenv(""DEPENDENCIES_OUTPUT"");
	x_unsetenv(""SUNPRO_DEPENDENCIES"");

	if (conf->run_second_cpp) {
		args_add(args, input_file);
	} else {
		args_add(args, i_tmpfile);
	}

	cc_log(""Running real compiler"");
	char *tmp_stdout;
	int tmp_stdout_fd;
	char *tmp_stderr;
	int tmp_stderr_fd;
	int status;
	if (!conf->depend_mode) {
		tmp_stdout = format(""%s.tmp.stdout"", cached_obj);
		tmp_stdout_fd = create_tmp_fd(&tmp_stdout);
		tmp_stderr = format(""%s.tmp.stderr"", cached_obj);
		tmp_stderr_fd = create_tmp_fd(&tmp_stderr);

		status = execute(args->argv, tmp_stdout_fd, tmp_stderr_fd, &compiler_pid);
		args_pop(args, 3);
	} else {
		// The cached object path is not known yet, use temporary files.
		tmp_stdout = format(""%s/tmp.stdout"", temp_dir());
		tmp_stdout_fd = create_tmp_fd(&tmp_stdout);
		tmp_stderr = format(""%s/tmp.stderr"", temp_dir());
		tmp_stderr_fd = create_tmp_fd(&tmp_stderr);

		// Use the original arguments (including dependency options) in depend
		// mode.
		assert(orig_args);
		struct args *depend_mode_args = args_copy(orig_args);
		args_strip(depend_mode_args, ""--ccache-"");
		add_prefix(depend_mode_args, conf->prefix_command);

		time_of_compilation = time(NULL);
		status = execute(
			depend_mode_args->argv, tmp_stdout_fd, tmp_stderr_fd, &compiler_pid);
		args_free(depend_mode_args);
	}

	struct stat st;
	if (x_stat(tmp_stdout, &st) != 0) {
		// The stdout file was removed - cleanup in progress? Better bail out.
		stats_update(STATS_MISSING);
		tmp_unlink(tmp_stdout);
		tmp_unlink(tmp_stderr);
		failed();
	}

	// distcc-pump outputs lines like this:
	// __________Using # distcc servers in pump mode
	if (st.st_size != 0 && guessed_compiler != GUESSED_PUMP) {
		cc_log(""Compiler produced stdout"");
		stats_update(STATS_STDOUT);
		tmp_unlink(tmp_stdout);
		tmp_unlink(tmp_stderr);
		failed();
	}
	tmp_unlink(tmp_stdout);

	// Merge stderr from the preprocessor (if any) and stderr from the real
	// compiler into tmp_stderr.
	if (cpp_stderr) {
		char *tmp_stderr2 = format(""%s.2"", tmp_stderr);
		if (x_rename(tmp_stderr, tmp_stderr2)) {
			cc_log(""Failed to rename %s to %s: %s"", tmp_stderr, tmp_stderr2,
			       strerror(errno));
			failed();
		}

		int fd_cpp_stderr = open(cpp_stderr, O_RDONLY | O_BINARY);
		if (fd_cpp_stderr == -1) {
			cc_log(""Failed opening %s: %s"", cpp_stderr, strerror(errno));
			failed();
		}

		int fd_real_stderr = open(tmp_stderr2, O_RDONLY | O_BINARY);
		if (fd_real_stderr == -1) {
			cc_log(""Failed opening %s: %s"", tmp_stderr2, strerror(errno));
			failed();
		}

		int fd_result =
			open(tmp_stderr, O_WRONLY | O_CREAT | O_TRUNC | O_BINARY, 0666);
		if (fd_result == -1) {
			cc_log(""Failed opening %s: %s"", tmp_stderr, strerror(errno));
			failed();
		}

		copy_fd(fd_cpp_stderr, fd_result);
		copy_fd(fd_real_stderr, fd_result);
		close(fd_cpp_stderr);
		close(fd_real_stderr);
		close(fd_result);
		tmp_unlink(tmp_stderr2);
		free(tmp_stderr2);
	}

	if (status != 0) {
		cc_log(""Compiler gave exit status %d"", status);
		stats_update(STATS_STATUS);

		int fd = open(tmp_stderr, O_RDONLY | O_BINARY);
		if (fd != -1) {
			// We can output stderr immediately instead of rerunning the compiler.
			copy_fd(fd, 2);
			close(fd);
			tmp_unlink(tmp_stderr);

			x_exit(status);
		}

		tmp_unlink(tmp_stderr);
		failed();
	}

	if (conf->depend_mode) {
		struct file_hash *object_hash =
			object_hash_from_depfile(output_dep, depend_mode_hash);
		if (!object_hash) {
			failed();
		}
		update_cached_result_globals(object_hash);
	}

	if (generating_dependencies) {
		use_relative_paths_in_depfile(output_dep);
	}

	if (stat(output_obj, &st) != 0) {
		cc_log(""Compiler didn't produce an object file"");
		stats_update(STATS_NOOUTPUT);
		failed();
	}
	if (st.st_size == 0) {
		cc_log(""Compiler produced an empty object file"");
		stats_update(STATS_EMPTYOUTPUT);
		failed();
	}

	if (x_stat(tmp_stderr, &st) != 0) {
		stats_update(STATS_ERROR);
		failed();
	}
	if (st.st_size > 0) {
		if (!conf->depend_mode) {
			move_file_to_cache_same_fs(tmp_stderr, cached_stderr);
		} else {
			copy_file_to_cache(tmp_stderr, cached_stderr);
		}
	} else if (conf->recache) {
		// If recaching, we need to remove any previous .stderr.
		x_unlink(cached_stderr);
	}
	if (st.st_size == 0 || conf->depend_mode) {
		tmp_unlink(tmp_stderr);
	}

	copy_file_to_cache(output_obj, cached_obj);
	if (generating_dependencies) {
		copy_file_to_cache(output_dep, cached_dep);
	}
	if (generating_coverage) {
		copy_file_to_cache(output_cov, cached_cov);
	}
	if (generating_stackusage) {
		copy_file_to_cache(output_su, cached_su);
	}
	if (generating_diagnostics) {
		copy_file_to_cache(output_dia, cached_dia);
	}
	if (using_split_dwarf) {
		copy_file_to_cache(output_dwo, cached_dwo);
	}

	stats_update(STATS_TOCACHE);

	// Make sure we have a CACHEDIR.TAG in the cache part of cache_dir. This can
	// be done almost anywhere, but we might as well do it near the end as we
	// save the stat call if we exit early.
	{
		char *first_level_dir = dirname(stats_file);
		if (create_cachedirtag(first_level_dir) != 0) {
			cc_log(""Failed to create %s/CACHEDIR.TAG (%s)\n"",
			       first_level_dir, strerror(errno));
			stats_update(STATS_ERROR);
			failed();
		}
		free(first_level_dir);

		// Remove any CACHEDIR.TAG on the cache_dir level where it was located in
		// previous ccache versions.
		if (getpid() % 1000 == 0) {
			char *path = format(""%s/CACHEDIR.TAG"", conf->cache_dir);
			x_unlink(path);
			free(path);
		}
	}

	// Everything OK.
	send_cached_stderr();
	update_manifest_file();

	free(tmp_stderr);
	free(tmp_stdout);
}

// Find the object file name by running the compiler in preprocessor mode.
// Returns the hash as a heap-allocated hex string.
static struct file_hash *
get_object_name_from_cpp(struct args *args, struct hash *hash)
{
	time_of_compilation = time(NULL);

	char *path_stderr = NULL;
	char *path_stdout;
	int status;
	if (direct_i_file) {
		// We are compiling a .i or .ii file - that means we can skip the cpp stage
		// and directly form the correct i_tmpfile.
		path_stdout = input_file;
		status = 0;
	} else {
		// Run cpp on the input file to obtain the .i.

		// Limit the basename to 10 characters in order to cope with filesystem with
		// small maximum filename length limits.
		char *input_base = basename(input_file);
		char *tmp = strchr(input_base, '.');
		if (tmp) {
			*tmp = 0;
		}
		if (strlen(input_base) > 10) {
			input_base[10] = 0;
		}

		path_stdout = format(""%s/%s.stdout"", temp_dir(), input_base);
		free(input_base);
		int path_stdout_fd = create_tmp_fd(&path_stdout);
		add_pending_tmp_file(path_stdout);

		path_stderr = format(""%s/tmp.cpp_stderr"", temp_dir());
		int path_stderr_fd = create_tmp_fd(&path_stderr);
		add_pending_tmp_file(path_stderr);

		int args_added = 2;
		args_add(args, ""-E"");
		if (conf->keep_comments_cpp) {
			args_add(args, ""-C"");
			args_added = 3;
		}
		args_add(args, input_file);
		add_prefix(args, conf->prefix_command_cpp);
		cc_log(""Running preprocessor"");
		status = execute(args->argv, path_stdout_fd, path_stderr_fd, &compiler_pid);
		args_pop(args, args_added);
	}

	if (status != 0) {
		cc_log(""Preprocessor gave exit status %d"", status);
		stats_update(STATS_PREPROCESSOR);
		failed();
	}

	if (conf->unify) {
		// When we are doing the unifying tricks we need to include the input file
		// name in the hash to get the warnings right.
		hash_delimiter(hash, ""unifyfilename"");
		hash_string(hash, input_file);

		hash_delimiter(hash, ""unifycpp"");

		bool debug_unify = getenv(""CCACHE_DEBUG_UNIFY"");
		if (unify_hash(hash, path_stdout, debug_unify) != 0) {
			stats_update(STATS_ERROR);
			cc_log(""Failed to unify %s"", path_stdout);
			failed();
		}
	} else {
		hash_delimiter(hash, ""cpp"");
		if (!process_preprocessed_file(hash, path_stdout,
		                               guessed_compiler == GUESSED_PUMP)) {
			stats_update(STATS_ERROR);
			failed();
		}
	}

	hash_delimiter(hash, ""cppstderr"");
	if (!direct_i_file && !hash_file(hash, path_stderr)) {
		fatal(""Failed to open %s: %s"", path_stderr, strerror(errno));
	}

	if (direct_i_file) {
		i_tmpfile = input_file;
	} else {
		// i_tmpfile needs the proper cpp_extension for the compiler to do its
		// thing correctly
		i_tmpfile = format(""%s.%s"", path_stdout, conf->cpp_extension);
		x_rename(path_stdout, i_tmpfile);
		add_pending_tmp_file(i_tmpfile);
	}

	if (conf->run_second_cpp) {
		free(path_stderr);
	} else {
		// If we are using the CPP trick, we need to remember this stderr data and
		// output it just before the main stderr from the compiler pass.
		cpp_stderr = path_stderr;
		hash_delimiter(hash, ""runsecondcpp"");
		hash_string(hash, ""false"");
	}

	struct file_hash *result = x_malloc(sizeof(*result));
	hash_result_as_bytes(hash, result->hash);
	result->size = hash_input_size(hash);
	return result;
}

// Hash mtime or content of a file, or the output of a command, according to
// the CCACHE_COMPILERCHECK setting.
static void
hash_compiler(struct hash *hash, struct stat *st, const char *path,
              bool allow_command)
{
	if (str_eq(conf->compiler_check, ""none"")) {
		// Do nothing.
	} else if (str_eq(conf->compiler_check, ""mtime"")) {
		hash_delimiter(hash, ""cc_mtime"");
		hash_int(hash, st->st_size);
		hash_int(hash, st->st_mtime);
	} else if (str_startswith(conf->compiler_check, ""string:"")) {
		hash_delimiter(hash, ""cc_hash"");
		hash_string(hash, conf->compiler_check + strlen(""string:""));
	} else if (str_eq(conf->compiler_check, ""content"") || !allow_command) {
		hash_delimiter(hash, ""cc_content"");
		hash_file(hash, path);
	} else { // command string
		bool ok = hash_multicommand_output(
			hash, conf->compiler_check, orig_args->argv[0]);
		if (!ok) {
			fatal(""Failure running compiler check command: %s"", conf->compiler_check);
		}
	}
}

// Hash the host compiler(s) invoked by nvcc.
//
// If ccbin_st and ccbin are set, they refer to a directory or compiler set
// with -ccbin/--compiler-bindir. If they are NULL, the compilers are looked up
// in PATH instead.
static void
hash_nvcc_host_compiler(struct hash *hash, struct stat *ccbin_st,
                        const char *ccbin)
{
	// From <http://docs.nvidia.com/cuda/cuda-compiler-driver-nvcc/index.html>:
	//
	//   ""[...] Specify the directory in which the compiler executable resides.
	//   The host compiler executable name can be also specified to ensure that
	//   the correct host compiler is selected.""
	//
	// and
	//
	//   ""On all platforms, the default host compiler executable (gcc and g++ on
	//   Linux, clang and clang++ on Mac OS X, and cl.exe on Windows) found in
	//   the current execution search path will be used"".

	if (!ccbin || S_ISDIR(ccbin_st->st_mode)) {
#if defined(__APPLE__)
		const char *compilers[] = {""clang"", ""clang++""};
#elif defined(_WIN32)
		const char *compilers[] = {""cl.exe""};
#else
		const char *compilers[] = {""gcc"", ""g++""};
#endif
		for (size_t i = 0; i < ARRAY_SIZE(compilers); i++) {
			if (ccbin) {
				char *path = format(""%s/%s"", ccbin, compilers[i]);
				struct stat st;
				if (stat(path, &st) == 0) {
					hash_compiler(hash, &st, path, false);
				}
				free(path);
			} else {
				char *path = find_executable(compilers[i], MYNAME);
				if (path) {
					struct stat st;
					x_stat(path, &st);
					hash_compiler(hash, &st, ccbin, false);
					free(path);
				}
			}
		}
	} else {
		hash_compiler(hash, ccbin_st, ccbin, false);
	}
}

// Update a hash sum with information common for the direct and preprocessor
// modes.
static void
calculate_common_hash(struct args *args, struct hash *hash)
{
	hash_string(hash, HASH_PREFIX);

	// We have to hash the extension, as a .i file isn't treated the same by the
	// compiler as a .ii file.
	hash_delimiter(hash, ""ext"");
	hash_string(hash, conf->cpp_extension);

#ifdef _WIN32
	const char *ext = strrchr(args->argv[0], '.');
	char full_path_win_ext[MAX_PATH + 1] = {0};
	add_exe_ext_if_no_to_fullpath(full_path_win_ext, MAX_PATH, ext,
	                              args->argv[0]);
	const char *full_path = full_path_win_ext;
#else
	const char *full_path = args->argv[0];
#endif

	struct stat st;
	if (x_stat(full_path, &st) != 0) {
		stats_update(STATS_COMPILER);
		failed();
	}

	// Hash information about the compiler.
	hash_compiler(hash, &st, args->argv[0], true);

	// Also hash the compiler name as some compilers use hard links and behave
	// differently depending on the real name.
	hash_delimiter(hash, ""cc_name"");
	char *base = basename(args->argv[0]);
	hash_string(hash, base);
	free(base);

	if (!(conf->sloppiness & SLOPPY_LOCALE)) {
		// Hash environment variables that may affect localization of compiler
		// warning messages.
		const char *envvars[] = {
			""LANG"",
			""LC_ALL"",
			""LC_CTYPE"",
			""LC_MESSAGES"",
			NULL
		};
		for (const char **p = envvars; *p; ++p) {
			char *v = getenv(*p);
			if (v) {
				hash_delimiter(hash, *p);
				hash_string(hash, v);
			}
		}
	}

	// Possibly hash the current working directory.
	if (generating_debuginfo && conf->hash_dir) {
		char *cwd = gnu_getcwd();
		for (size_t i = 0; i < debug_prefix_maps_len; i++) {
			char *map = debug_prefix_maps[i];
			char *sep = strchr(map, '=');
			if (sep) {
				char *old = x_strndup(map, sep - map);
				char *new = x_strdup(sep + 1);
				cc_log(""Relocating debuginfo CWD %s from %s to %s"", cwd, old, new);
				if (str_startswith(cwd, old)) {
					char *dir = format(""%s%s"", new, cwd + strlen(old));
					free(cwd);
					cwd = dir;
				}
				free(old);
				free(new);
			}
		}
		if (cwd) {
			cc_log(""Hashing CWD %s"", cwd);
			hash_delimiter(hash, ""cwd"");
			hash_string(hash, cwd);
			free(cwd);
		}
	}

	if (using_split_dwarf) {
		// When using -gsplit-dwarf, object files include a link to the
		// corresponding .dwo file based on the target object filename, so we need
		// to include the target filename in the hash to avoid handing out an
		// object file with an incorrect .dwo link.
		hash_delimiter(hash, ""filename"");
		hash_string(hash, basename(output_obj));
	}

	// Possibly hash the coverage data file path.
	if (generating_coverage && profile_arcs) {
		char *dir = dirname(output_obj);
		if (profile_dir) {
			dir = x_strdup(profile_dir);
		} else {
			char *real_dir = x_realpath(dir);
			free(dir);
			dir = real_dir;
		}
		if (dir) {
			char *base_name = basename(output_obj);
			char *p = remove_extension(base_name);
			free(base_name);
			char *gcda_path = format(""%s/%s.gcda"", dir, p);
			cc_log(""Hashing coverage path %s"", gcda_path);
			free(p);
			hash_delimiter(hash, ""gcda"");
			hash_string(hash, gcda_path);
			free(dir);
		}
	}

	// Possibly hash the sanitize blacklist file path.
	for (size_t i = 0; i < sanitize_blacklists_len; i++) {
		char *sanitize_blacklist = sanitize_blacklists[i];
		cc_log(""Hashing sanitize blacklist %s"", sanitize_blacklist);
		hash_delimiter(hash, ""sanitizeblacklist"");
		if (!hash_file(hash, sanitize_blacklist)) {
			stats_update(STATS_BADEXTRAFILE);
			failed();
		}
	}

	if (!str_eq(conf->extra_files_to_hash, """")) {
		char *p = x_strdup(conf->extra_files_to_hash);
		char *q = p;
		char *path;
		char *saveptr = NULL;
		while ((path = strtok_r(q, PATH_DELIM, &saveptr))) {
			cc_log(""Hashing extra file %s"", path);
			hash_delimiter(hash, ""extrafile"");
			if (!hash_file(hash, path)) {
				stats_update(STATS_BADEXTRAFILE);
				failed();
			}
			q = NULL;
		}
		free(p);
	}

	// Possibly hash GCC_COLORS (for color diagnostics).
	if (guessed_compiler == GUESSED_GCC) {
		const char *gcc_colors = getenv(""GCC_COLORS"");
		if (gcc_colors) {
			hash_delimiter(hash, ""gcccolors"");
			hash_string(hash, gcc_colors);
		}
	}
}

// Update a hash sum with information specific to the direct and preprocessor
// modes and calculate the object hash. Returns the object hash on success,
// otherwise NULL. Caller frees.
static struct file_hash *
calculate_object_hash(struct args *args, struct hash *hash, int direct_mode)
{
	bool found_ccbin = false;

	if (direct_mode) {
		hash_delimiter(hash, ""manifest version"");
		hash_int(hash, MANIFEST_VERSION);
	}

	// clang will emit warnings for unused linker flags, so we shouldn't skip
	// those arguments.
	int is_clang =
		guessed_compiler == GUESSED_CLANG || guessed_compiler == GUESSED_UNKNOWN;

	// First the arguments.
	for (int i = 1; i < args->argc; i++) {
		// -L doesn't affect compilation (except for clang).
		if (i < args->argc-1 && str_eq(args->argv[i], ""-L"") && !is_clang) {
			i++;
			continue;
		}
		if (str_startswith(args->argv[i], ""-L"") && !is_clang) {
			continue;
		}

		// -Wl,... doesn't affect compilation (except for clang).
		if (str_startswith(args->argv[i], ""-Wl,"") && !is_clang) {
			continue;
		}

		// The -fdebug-prefix-map option may be used in combination with
		// CCACHE_BASEDIR to reuse results across different directories. Skip it
		// from hashing.
		if (str_startswith(args->argv[i], ""-fdebug-prefix-map="")) {
			continue;
		}
		if (str_startswith(args->argv[i], ""-ffile-prefix-map="")) {
			continue;
		}
		if (str_startswith(args->argv[i], ""-fmacro-prefix-map="")) {
			continue;
		}

		// When using the preprocessor, some arguments don't contribute to the
		// hash. The theory is that these arguments will change the output of -E if
		// they are going to have any effect at all. For precompiled headers this
		// might not be the case.
		if (!direct_mode && !output_is_precompiled_header
		    && !using_precompiled_header) {
			if (compopt_affects_cpp(args->argv[i])) {
				if (compopt_takes_arg(args->argv[i])) {
					i++;
				}
				continue;
			}
			if (compopt_short(compopt_affects_cpp, args->argv[i])) {
				continue;
			}
		}

		// If we're generating dependencies, we make sure to skip the filename of
		// the dependency file, since it doesn't impact the output.
		if (generating_dependencies) {
			if (str_startswith(args->argv[i], ""-Wp,"")) {
				if (str_startswith(args->argv[i], ""-Wp,-MD,"")
				    && !strchr(args->argv[i] + 8, ',')) {
					hash_string_buffer(hash, args->argv[i], 8);
					continue;
				} else if (str_startswith(args->argv[i], ""-Wp,-MMD,"")
				           && !strchr(args->argv[i] + 9, ',')) {
					hash_string_buffer(hash, args->argv[i], 9);
					continue;
				}
			} else if (str_startswith(args->argv[i], ""-MF"")) {
				// In either case, hash the ""-MF"" part.
				hash_delimiter(hash, ""arg"");
				hash_string_buffer(hash, args->argv[i], 3);

				bool separate_argument = (strlen(args->argv[i]) == 3);
				if (separate_argument) {
					// Next argument is dependency name, so skip it.
					i++;
				}
				continue;
			}
		}

		char *p = NULL;
		if (str_startswith(args->argv[i], ""-specs="")) {
			p = args->argv[i] + 7;
		} else if (str_startswith(args->argv[i], ""--specs="")) {
			p = args->argv[i] + 8;
		}

		struct stat st;
		if (p && x_stat(p, &st) == 0) {
			// If given an explicit specs file, then hash that file, but don't
			// include the path to it in the hash.
			hash_delimiter(hash, ""specs"");
			hash_compiler(hash, &st, p, false);
			continue;
		}

		if (str_startswith(args->argv[i], ""-fplugin="")
		    && x_stat(args->argv[i] + 9, &st) == 0) {
			hash_delimiter(hash, ""plugin"");
			hash_compiler(hash, &st, args->argv[i] + 9, false);
			continue;
		}

		if (str_eq(args->argv[i], ""-Xclang"")
		    && i + 3 < args->argc
		    && str_eq(args->argv[i+1], ""-load"")
		    && str_eq(args->argv[i+2], ""-Xclang"")
		    && x_stat(args->argv[i+3], &st) == 0) {
			hash_delimiter(hash, ""plugin"");
			hash_compiler(hash, &st, args->argv[i+3], false);
			i += 3;
			continue;
		}

		if ((str_eq(args->argv[i], ""-ccbin"")
		     || str_eq(args->argv[i], ""--compiler-bindir""))
		    && i + 1 < args->argc
		    && x_stat(args->argv[i+1], &st) == 0) {
			found_ccbin = true;
			hash_delimiter(hash, ""ccbin"");
			hash_nvcc_host_compiler(hash, &st, args->argv[i+1]);
			i++;
			continue;
		}

		// All other arguments are included in the hash.
		hash_delimiter(hash, ""arg"");
		hash_string(hash, args->argv[i]);
		if (i + 1 < args->argc && compopt_takes_arg(args->argv[i])) {
			i++;
			hash_delimiter(hash, ""arg"");
			hash_string(hash, args->argv[i]);
		}
	}

	if (!found_ccbin && str_eq(actual_language, ""cuda"")) {
		hash_nvcc_host_compiler(hash, NULL, NULL);
	}

	// For profile generation (-fprofile-arcs, -fprofile-generate):
	// - hash profile directory
	//
	// For profile usage (-fprofile-use):
	// - hash profile data
	//
	// -fbranch-probabilities and -fvpt usage is covered by
	// -fprofile-generate/-fprofile-use.
	//
	// The profile directory can be specified as an argument to
	// -fprofile-generate=, -fprofile-use= or -fprofile-dir=.
	if (profile_generate) {
		if (!profile_dir) {
			profile_dir = get_cwd();
		}
		cc_log(""Adding profile directory %s to our hash"", profile_dir);
		hash_delimiter(hash, ""-fprofile-dir"");
		hash_string(hash, profile_dir);
	}

	if (profile_use) {
		// Calculate gcda name.
		if (!profile_dir) {
			profile_dir = get_cwd();
		}
		char *base_name = remove_extension(output_obj);
		char *gcda_name = format(""%s/%s.gcda"", profile_dir, base_name);
		cc_log(""Adding profile data %s to our hash"", gcda_name);
		// Add the gcda to our hash.
		hash_delimiter(hash, ""-fprofile-use"");
		hash_file(hash, gcda_name);
		free(base_name);
		free(gcda_name);
	}

	// Adding -arch to hash since cpp output is affected.
	for (size_t i = 0; i < arch_args_size; ++i) {
		hash_delimiter(hash, ""-arch"");
		hash_string(hash, arch_args[i]);
	}

	struct file_hash *object_hash = NULL;
	if (direct_mode) {
		// Hash environment variables that affect the preprocessor output.
		const char *envvars[] = {
			""CPATH"",
			""C_INCLUDE_PATH"",
			""CPLUS_INCLUDE_PATH"",
			""OBJC_INCLUDE_PATH"",
			""OBJCPLUS_INCLUDE_PATH"", // clang
			NULL
		};
		for (const char **p = envvars; *p; ++p) {
			char *v = getenv(*p);
			if (v) {
				hash_delimiter(hash, *p);
				hash_string(hash, v);
			}
		}

		if (!(conf->sloppiness & SLOPPY_FILE_MACRO)) {
			// The source code file or an include file may contain __FILE__, so make
			// sure that the hash is unique for the file name.
			hash_delimiter(hash, ""inputfile"");
			hash_string(hash, input_file);
		}

		hash_delimiter(hash, ""sourcecode"");
		int result = hash_source_code_file(conf, hash, input_file);
		if (result & HASH_SOURCE_CODE_ERROR) {
			failed();
		}
		if (result & HASH_SOURCE_CODE_FOUND_TIME) {
			cc_log(""Disabling direct mode"");
			conf->direct_mode = false;
			return NULL;
		}
		char *manifest_name = hash_result(hash);
		manifest_path = get_path_in_cache(manifest_name, "".manifest"");
		free(manifest_name);
		cc_log(""Looking for object file hash in %s"", manifest_path);
		object_hash = manifest_get(conf, manifest_path);
		if (object_hash) {
			cc_log(""Got object file hash from manifest"");
			update_mtime(manifest_path);
		} else {
			cc_log(""Did not find object file hash in manifest"");
		}
	} else {
		if (arch_args_size == 0) {
			object_hash = get_object_name_from_cpp(args, hash);
			cc_log(""Got object file hash from preprocessor"");
		} else {
			args_add(args, ""-arch"");
			for (size_t i = 0; i < arch_args_size; ++i) {
				args_add(args, arch_args[i]);
				object_hash = get_object_name_from_cpp(args, hash);
				cc_log(""Got object file hash from preprocessor with -arch %s"",
				       arch_args[i]);
				if (i != arch_args_size - 1) {
					free(object_hash);
					object_hash = NULL;
				}
				args_pop(args, 1);
			}
			args_pop(args, 1);
		}
		if (generating_dependencies) {
			cc_log(""Preprocessor created %s"", output_dep);
		}
	}

	return object_hash;
}

// Try to return the compile result from cache. If we can return from cache
// then this function exits with the correct status code, otherwise it returns.
static void
from_cache(enum fromcache_call_mode mode, bool put_object_in_manifest)
{
	// The user might be disabling cache hits.
	if (conf->recache) {
		return;
	}

	// If we're using Clang, we can't trust a precompiled header object based on
	// running the preprocessor since clang will produce a fatal error when the
	// precompiled header is used and one of the included files has an updated
	// timestamp:
	//
	//     file 'foo.h' has been modified since the precompiled header 'foo.pch'
	//     was built
	if ((guessed_compiler == GUESSED_CLANG || guessed_compiler == GUESSED_UNKNOWN)
	    && output_is_precompiled_header
	    && mode == FROMCACHE_CPP_MODE) {
		cc_log(""Not considering cached precompiled header in preprocessor mode"");
		return;
	}

	// Occasionally, e.g. on hard reset, our cache ends up as just filesystem
	// meta-data with no content. Catch an easy case of this.
	struct stat st;
	if (stat(cached_obj, &st) != 0) {
		cc_log(""Object file %s not in cache"", cached_obj);
		return;
	}
	if (st.st_size == 0) {
		cc_log(""Invalid (empty) object file %s in cache"", cached_obj);
		x_unlink(cached_obj);
		return;
	}

	// (If mode != FROMCACHE_DIRECT_MODE, the dependency file is created by gcc.)
	bool produce_dep_file =
		generating_dependencies && mode == FROMCACHE_DIRECT_MODE;

	// Get result from cache.
	if (!str_eq(output_obj, ""/dev/null"")) {
		get_file_from_cache(cached_obj, output_obj);
		if (using_split_dwarf) {
			get_file_from_cache(cached_dwo, output_dwo);
		}
	}
	if (produce_dep_file) {
		get_file_from_cache(cached_dep, output_dep);
	}
	if (generating_coverage) {
		get_file_from_cache(cached_cov, output_cov);
	}
	if (generating_stackusage) {
		get_file_from_cache(cached_su, output_su);
	}
	if (generating_diagnostics) {
		get_file_from_cache(cached_dia, output_dia);
	}

	// Update modification timestamps to save files from LRU cleanup. Also gives
	// files a sensible mtime when hard-linking.
	update_mtime(cached_obj);
	update_mtime(cached_stderr);
	if (produce_dep_file) {
		update_mtime(cached_dep);
	}
	if (generating_coverage) {
		update_mtime(cached_cov);
	}
	if (generating_stackusage) {
		update_mtime(cached_su);
	}
	if (generating_diagnostics) {
		update_mtime(cached_dia);
	}
	if (cached_dwo) {
		update_mtime(cached_dwo);
	}

	send_cached_stderr();

	if (put_object_in_manifest) {
		update_manifest_file();
	}

	// Log the cache hit.
	switch (mode) {
	case FROMCACHE_DIRECT_MODE:
		cc_log(""Succeeded getting cached result"");
		stats_update(STATS_CACHEHIT_DIR);
		break;

	case FROMCACHE_CPP_MODE:
		cc_log(""Succeeded getting cached result"");
		stats_update(STATS_CACHEHIT_CPP);
		break;
	}

	// And exit with the right status code.
	x_exit(0);
}

// Find the real compiler. We just search the PATH to find an executable of the
// same name that isn't a link to ourselves.
static void
find_compiler(char **argv)
{
	// We might be being invoked like ""ccache gcc -c foo.c"".
	char *base = basename(argv[0]);
	if (same_executable_name(base, MYNAME)) {
		args_remove_first(orig_args);
		free(base);
		if (is_full_path(orig_args->argv[0])) {
			// A full path was given.
			return;
		}
		base = basename(orig_args->argv[0]);
	}

	// Support user override of the compiler.
	if (!str_eq(conf->compiler, """")) {
		base = conf->compiler;
	}

	char *compiler = find_executable(base, MYNAME);
	if (!compiler) {
		stats_update(STATS_COMPILER);
		fatal(""Could not find compiler \""%s\"" in PATH"", base);
	}
	if (str_eq(compiler, argv[0])) {
		fatal(""Recursive invocation (the name of the ccache binary must be \""%s\"")"",
		      MYNAME);
	}
	orig_args->argv[0] = compiler;
}

bool
is_precompiled_header(const char *path)
{
	const char *ext = get_extension(path);
	char *dir = dirname(path);
	const char *dir_ext = get_extension(dir);
	bool result =
		str_eq(ext, "".gch"")
		|| str_eq(ext, "".pch"")
		|| str_eq(ext, "".pth"")
		|| str_eq(dir_ext, "".gch""); // See ""Precompiled Headers"" in GCC docs.
	free(dir);
	return result;
}

static bool
color_output_possible(void)
{
	const char *term_env = getenv(""TERM"");
	return isatty(STDERR_FILENO) && term_env && strcasecmp(term_env, ""DUMB"") != 0;
}

static bool
detect_pch(const char *option, const char *arg, bool *found_pch)
{
	struct stat st;

	// Try to be smart about detecting precompiled headers.
	char *pch_file = NULL;
	if (str_eq(option, ""-include-pch"") || str_eq(option, ""-include-pth"")) {
		if (stat(arg, &st) == 0) {
			cc_log(""Detected use of precompiled header: %s"", arg);
			pch_file = x_strdup(arg);
		}
	} else {
		char *gchpath = format(""%s.gch"", arg);
		if (stat(gchpath, &st) == 0) {
			cc_log(""Detected use of precompiled header: %s"", gchpath);
			pch_file = x_strdup(gchpath);
		} else {
			char *pchpath = format(""%s.pch"", arg);
			if (stat(pchpath, &st) == 0) {
				cc_log(""Detected use of precompiled header: %s"", pchpath);
				pch_file = x_strdup(pchpath);
			} else {
				// clang may use pretokenized headers.
				char *pthpath = format(""%s.pth"", arg);
				if (stat(pthpath, &st) == 0) {
					cc_log(""Detected use of pretokenized header: %s"", pthpath);
					pch_file = x_strdup(pthpath);
				}
				free(pthpath);
			}
			free(pchpath);
		}
		free(gchpath);
	}

	if (pch_file) {
		if (included_pch_file) {
			cc_log(""Multiple precompiled headers used: %s and %s\n"",
			       included_pch_file, pch_file);
			stats_update(STATS_ARGS);
			return false;
		}
		included_pch_file = pch_file;
		*found_pch = true;
	}
	return true;
}

// Process the compiler options into options suitable for passing to the
// preprocessor and the real compiler. The preprocessor options don't include
// -E; this is added later. Returns true on success, otherwise false.
bool
cc_process_args(struct args *args, struct args **preprocessor_args,
                struct args **compiler_args)
{
	bool found_c_opt = false;
	bool found_S_opt = false;
	bool found_pch = false;
	bool found_fpch_preprocess = false;
	const char *explicit_language = NULL; // As specified with -x.
	const char *file_language;            // As deduced from file extension.
	const char *input_charset = NULL;
	// Is the dependency makefile name overridden with -MF?
	bool dependency_filename_specified = false;
	// Is the dependency makefile target name specified with -MT or -MQ?
	bool dependency_target_specified = false;
	// Is the dependency target name implicitly specified using
	// DEPENDENCIES_OUTPUT or SUNPRO_DEPENDENCIES?
	bool dependency_implicit_target_specified = false;
	// expanded_args is a copy of the original arguments given to the compiler
	// but with arguments from @file and similar constructs expanded. It's only
	// used as a temporary data structure to loop over.
	struct args *expanded_args = args_copy(args);
	// stripped_args essentially contains all original arguments except those
	// that only should be passed to the preprocessor (if run_second_cpp is
	// false) and except dependency options (like -MD and friends).
	struct args *stripped_args = args_init(0, NULL);
	// cpp_args contains arguments that were not added to stripped_args, i.e.
	// those that should only be passed to the preprocessor if run_second_cpp is
	// false. If run_second_cpp is true, they will be passed to the compiler as
	// well.
	struct args *cpp_args = args_init(0, NULL);
	// dep_args contains dependency options like -MD. They only passed to the
	// preprocessor, never to the compiler.
	struct args *dep_args = args_init(0, NULL);

	bool found_color_diagnostics = false;

	bool found_directives_only = false;
	bool found_rewrite_includes = false;

	int argc = expanded_args->argc;
	char **argv = expanded_args->argv;
	args_add(stripped_args, argv[0]);

	bool result = true;
	for (int i = 1; i < argc; i++) {
		// The user knows best: just swallow the next arg.
		if (str_eq(argv[i], ""--ccache-skip"")) {
			i++;
			if (i == argc) {
				cc_log(""--ccache-skip lacks an argument"");
				result = false;
				goto out;
			}
			args_add(stripped_args, argv[i]);
			continue;
		}

		// Special case for -E.
		if (str_eq(argv[i], ""-E"")) {
			stats_update(STATS_PREPROCESSING);
			result = false;
			goto out;
		}

		// Handle ""@file"" argument.
		if (str_startswith(argv[i], ""@"") || str_startswith(argv[i], ""-@"")) {
			char *argpath = argv[i] + 1;

			if (argpath[-1] == '-') {
				++argpath;
			}
			struct args *file_args = args_init_from_gcc_atfile(argpath);
			if (!file_args) {
				cc_log(""Couldn't read arg file %s"", argpath);
				stats_update(STATS_ARGS);
				result = false;
				goto out;
			}

			args_insert(expanded_args, i, file_args, true);
			argc = expanded_args->argc;
			argv = expanded_args->argv;
			i--;
			continue;
		}

		// Handle cuda ""-optf"" and ""--options-file"" argument.
		if (guessed_compiler == GUESSED_NVCC
		    && (str_eq(argv[i], ""-optf"") || str_eq(argv[i], ""--options-file""))) {
			if (i == argc - 1) {
				cc_log(""Expected argument after %s"", argv[i]);
				stats_update(STATS_ARGS);
				result = false;
				goto out;
			}
			++i;

			// Argument is a comma-separated list of files.
			char *str_start = argv[i];
			char *str_end = strchr(str_start, ',');
			int index = i + 1;

			if (!str_end) {
				str_end = str_start + strlen(str_start);
			}

			while (str_end) {
				*str_end = '\0';
				struct args *file_args = args_init_from_gcc_atfile(str_start);
				if (!file_args) {
					cc_log(""Couldn't read cuda options file %s"", str_start);
					stats_update(STATS_ARGS);
					result = false;
					goto out;
				}

				int new_index = file_args->argc + index;
				args_insert(expanded_args, index, file_args, false);
				index = new_index;
				str_start = str_end;
				str_end = strchr(str_start, ',');
			}

			argc = expanded_args->argc;
			argv = expanded_args->argv;
			continue;
		}

		// These are always too hard.
		if (compopt_too_hard(argv[i]) || str_startswith(argv[i], ""-fdump-"")) {
			cc_log(""Compiler option %s is unsupported"", argv[i]);
			stats_update(STATS_UNSUPPORTED_OPTION);
			result = false;
			goto out;
		}

		// These are too hard in direct mode.
		if (conf->direct_mode && compopt_too_hard_for_direct_mode(argv[i])) {
			cc_log(""Unsupported compiler option for direct mode: %s"", argv[i]);
			conf->direct_mode = false;
		}

		// -Xarch_* options are too hard.
		if (str_startswith(argv[i], ""-Xarch_"")) {
			cc_log(""Unsupported compiler option :%s"", argv[i]);
			stats_update(STATS_UNSUPPORTED_OPTION);
			result = false;
			goto out;
		}

		// Handle -arch options.
		if (str_eq(argv[i], ""-arch"")) {
			if (arch_args_size == MAX_ARCH_ARGS - 1) {
				cc_log(""Too many -arch compiler options; ccache supports at most %d"",
				       MAX_ARCH_ARGS);
				stats_update(STATS_UNSUPPORTED_OPTION);
				result = false;
				goto out;
			}

			++i;
			arch_args[arch_args_size] = x_strdup(argv[i]); // It will leak.
			++arch_args_size;
			if (arch_args_size == 2) {
				conf->run_second_cpp = true;
			}
			continue;
		}

		if (str_eq(argv[i], ""-fpch-preprocess"")
		    || str_eq(argv[i], ""-emit-pch"")
		    || str_eq(argv[i], ""-emit-pth"")) {
			found_fpch_preprocess = true;
		}

		// We must have -c.
		if (str_eq(argv[i], ""-c"")) {
			found_c_opt = true;
			continue;
		}

		// -S changes the default extension.
		if (str_eq(argv[i], ""-S"")) {
			args_add(stripped_args, argv[i]);
			found_S_opt = true;
			continue;
		}

		// Special handling for -x: remember the last specified language before the
		// input file and strip all -x options from the arguments.
		if (str_eq(argv[i], ""-x"")) {
			if (i == argc - 1) {
				cc_log(""Missing argument to %s"", argv[i]);
				stats_update(STATS_ARGS);
				result = false;
				goto out;
			}
			if (!input_file) {
				explicit_language = argv[i+1];
			}
			i++;
			continue;
		}
		if (str_startswith(argv[i], ""-x"")) {
			if (!input_file) {
				explicit_language = &argv[i][2];
			}
			continue;
		}

		// We need to work out where the output was meant to go.
		if (str_eq(argv[i], ""-o"")) {
			if (i == argc - 1) {
				cc_log(""Missing argument to %s"", argv[i]);
				stats_update(STATS_ARGS);
				result = false;
				goto out;
			}
			output_obj = make_relative_path(x_strdup(argv[i+1]));
			i++;
			continue;
		}

		// Alternate form of -o with no space. Nvcc does not support this.
		if (str_startswith(argv[i], ""-o"") && guessed_compiler != GUESSED_NVCC) {
			output_obj = make_relative_path(x_strdup(&argv[i][2]));
			continue;
		}

		if (str_startswith(argv[i], ""-fdebug-prefix-map="")
		    || str_startswith(argv[i], ""-ffile-prefix-map="")) {
			debug_prefix_maps = x_realloc(
				debug_prefix_maps,
				(debug_prefix_maps_len + 1) * sizeof(char *));
			debug_prefix_maps[debug_prefix_maps_len++] =
				x_strdup(&argv[i][argv[i][2] == 'f' ? 18 : 19]);
			args_add(stripped_args, argv[i]);
			continue;
		}

		// Debugging is handled specially, so that we know if we can strip line
		// number info.
		if (str_startswith(argv[i], ""-g"")) {
			generating_debuginfo = true;
			args_add(stripped_args, argv[i]);
			if (str_eq(argv[i], ""-gsplit-dwarf"")) {
				using_split_dwarf = true;
			}
			if (conf->unify && !str_eq(argv[i], ""-g0"")) {
				cc_log(""%s used; disabling unify mode"", argv[i]);
				conf->unify = false;
			}
			if (str_eq(argv[i], ""-g3"")) {
				cc_log(""%s used; not compiling preprocessed code"", argv[i]);
				conf->run_second_cpp = true;
			}
			continue;
		}

		// These options require special handling, because they behave differently
		// with gcc -E, when the output file is not specified.
		if (str_eq(argv[i], ""-MD"") || str_eq(argv[i], ""-MMD"")) {
			generating_dependencies = true;
			args_add(dep_args, argv[i]);
			continue;
		}
		if (str_startswith(argv[i], ""-MF"")) {
			dependency_filename_specified = true;
			free(output_dep);

			char *arg;
			bool separate_argument = (strlen(argv[i]) == 3);
			if (separate_argument) {
				// -MF arg
				if (i == argc - 1) {
					cc_log(""Missing argument to %s"", argv[i]);
					stats_update(STATS_ARGS);
					result = false;
					goto out;
				}
				arg = argv[i + 1];
				i++;
			} else {
				// -MFarg
				arg = &argv[i][3];
			}
			output_dep = make_relative_path(x_strdup(arg));
			// Keep the format of the args the same.
			if (separate_argument) {
				args_add(dep_args, ""-MF"");
				args_add(dep_args, output_dep);
			} else {
				char *option = format(""-MF%s"", output_dep);
				args_add(dep_args, option);
				free(option);
			}
			continue;
		}
		if (str_startswith(argv[i], ""-MQ"") || str_startswith(argv[i], ""-MT"")) {
			dependency_target_specified = true;

			char *relpath;
			if (strlen(argv[i]) == 3) {
				// -MQ arg or -MT arg
				if (i == argc - 1) {
					cc_log(""Missing argument to %s"", argv[i]);
					stats_update(STATS_ARGS);
					result = false;
					goto out;
				}
				args_add(dep_args, argv[i]);
				relpath = make_relative_path(x_strdup(argv[i + 1]));
				args_add(dep_args, relpath);
				free(relpath);
				i++;
			} else {
				char *arg_opt = x_strndup(argv[i], 3);
				relpath = make_relative_path(x_strdup(argv[i] + 3));
				char *option = format(""%s%s"", arg_opt, relpath);
				args_add(dep_args, option);
				free(arg_opt);
				free(relpath);
				free(option);
			}
			continue;
		}
		if (str_eq(argv[i], ""-fprofile-arcs"")) {
			profile_arcs = true;
			args_add(stripped_args, argv[i]);
			continue;
		}
		if (str_eq(argv[i], ""-ftest-coverage"")) {
			generating_coverage = true;
			args_add(stripped_args, argv[i]);
			continue;
		}
		if (str_eq(argv[i], ""-fstack-usage"")) {
			generating_stackusage = true;
			args_add(stripped_args, argv[i]);
			continue;
		}
		if (str_eq(argv[i], ""--coverage"") // = -fprofile-arcs -ftest-coverage
		    || str_eq(argv[i], ""-coverage"")) { // Undocumented but still works.
			profile_arcs = true;
			generating_coverage = true;
			args_add(stripped_args, argv[i]);
			continue;
		}
		if (str_startswith(argv[i], ""-fprofile-dir="")) {
			profile_dir = x_strdup(argv[i] + 14);
			args_add(stripped_args, argv[i]);
			continue;
		}
		if (str_startswith(argv[i], ""-fsanitize-blacklist="")) {
			sanitize_blacklists = x_realloc(
				sanitize_blacklists,
				(sanitize_blacklists_len + 1) * sizeof(char *));
			sanitize_blacklists[sanitize_blacklists_len++] = x_strdup(argv[i] + 21);
			args_add(stripped_args, argv[i]);
			continue;
		}
		if (str_startswith(argv[i], ""--sysroot="")) {
			char *relpath = make_relative_path(x_strdup(argv[i] + 10));
			char *option = format(""--sysroot=%s"", relpath);
			args_add(stripped_args, option);
			free(relpath);
			free(option);
			continue;
		}
		// Alternate form of specifying sysroot without =
		if (str_eq(argv[i], ""--sysroot"")) {
			if (i == argc-1) {
				cc_log(""Missing argument to %s"", argv[i]);
				stats_update(STATS_ARGS);
				result = false;
				goto out;
			}
			args_add(stripped_args, argv[i]);
			char *relpath = make_relative_path(x_strdup(argv[i+1]));
			args_add(stripped_args, relpath);
			i++;
			free(relpath);
			continue;
		}
		// Alternate form of specifying target without =
		if (str_eq(argv[i], ""-target"")) {
			if (i == argc-1) {
				cc_log(""Missing argument to %s"", argv[i]);
				stats_update(STATS_ARGS);
				result = false;
				goto out;
			}
			args_add(stripped_args, argv[i]);
			args_add(stripped_args, argv[i+1]);
			i++;
			continue;
		}
		if (str_startswith(argv[i], ""-Wp,"")) {
			if (str_eq(argv[i], ""-Wp,-P"")
			    || strstr(argv[i], "",-P,"")
			    || str_endswith(argv[i], "",-P"")) {
				// -P removes preprocessor information in such a way that the object
				// file from compiling the preprocessed file will not be equal to the
				// object file produced when compiling without ccache.
				cc_log(""Too hard option -Wp,-P detected"");
				stats_update(STATS_UNSUPPORTED_OPTION);
				failed();
			} else if (str_startswith(argv[i], ""-Wp,-MD,"")
			           && !strchr(argv[i] + 8, ',')) {
				generating_dependencies = true;
				dependency_filename_specified = true;
				free(output_dep);
				output_dep = make_relative_path(x_strdup(argv[i] + 8));
				args_add(dep_args, argv[i]);
				continue;
			} else if (str_startswith(argv[i], ""-Wp,-MMD,"")
			           && !strchr(argv[i] + 9, ',')) {
				generating_dependencies = true;
				dependency_filename_specified = true;
				free(output_dep);
				output_dep = make_relative_path(x_strdup(argv[i] + 9));
				args_add(dep_args, argv[i]);
				continue;
			} else if (str_startswith(argv[i], ""-Wp,-D"")
			           && !strchr(argv[i] + 6, ',')) {
				// Treat it like -D.
				args_add(cpp_args, argv[i] + 4);
				continue;
			} else if (str_eq(argv[i], ""-Wp,-MP"")
			           || (strlen(argv[i]) > 8
			               && str_startswith(argv[i], ""-Wp,-M"")
			               && argv[i][7] == ','
			               && (argv[i][6] == 'F'
			                   || argv[i][6] == 'Q'
			                   || argv[i][6] == 'T')
			               && !strchr(argv[i] + 8, ','))) {
				// TODO: Make argument to MF/MQ/MT relative.
				args_add(dep_args, argv[i]);
				continue;
			} else if (conf->direct_mode) {
				// -Wp, can be used to pass too hard options to the preprocessor.
				// Hence, disable direct mode.
				cc_log(""Unsupported compiler option for direct mode: %s"", argv[i]);
				conf->direct_mode = false;
			}

			// Any other -Wp,* arguments are only relevant for the preprocessor.
			args_add(cpp_args, argv[i]);
			continue;
		}
		if (str_eq(argv[i], ""-MP"")) {
			args_add(dep_args, argv[i]);
			continue;
		}

		// Input charset needs to be handled specially.
		if (str_startswith(argv[i], ""-finput-charset="")) {
			input_charset = argv[i];
			continue;
		}

		if (str_eq(argv[i], ""--serialize-diagnostics"")) {
			if (i == argc - 1) {
				cc_log(""Missing argument to %s"", argv[i]);
				stats_update(STATS_ARGS);
				result = false;
				goto out;
			}
			generating_diagnostics = true;
			output_dia = make_relative_path(x_strdup(argv[i+1]));
			i++;
			continue;
		}

		if (str_startswith(argv[i], ""-fprofile-"")) {
			char *arg = x_strdup(argv[i]);
			const char *arg_profile_dir = strchr(argv[i], '=');
			if (arg_profile_dir) {
				// Convert to absolute path.
				char *dir = x_realpath(arg_profile_dir + 1);
				if (!dir) {
					// Directory doesn't exist.
					dir = x_strdup(arg_profile_dir + 1);
				}

				// We can get a better hit rate by using the real path here.
				free(arg);
				char *option = x_strndup(argv[i], arg_profile_dir - argv[i]);
				arg = format(""%s=%s"", option, dir);
				cc_log(""Rewriting %s to %s"", argv[i], arg);
				free(option);
				free(dir);
			}

			bool supported_profile_option = false;
			if (str_startswith(argv[i], ""-fprofile-generate"")
			    || str_eq(argv[i], ""-fprofile-arcs"")) {
				profile_generate = true;
				supported_profile_option = true;
			} else if (str_startswith(argv[i], ""-fprofile-use"")
			           || str_eq(argv[i], ""-fbranch-probabilities"")) {
				profile_use = true;
				supported_profile_option = true;
			} else if (str_eq(argv[i], ""-fprofile-dir"")) {
				supported_profile_option = true;
			}

			if (supported_profile_option) {
				args_add(stripped_args, arg);
				free(arg);

				// If the profile directory has already been set, give up... Hard to
				// know what the user means, and what the compiler will do.
				if (arg_profile_dir && profile_dir) {
					cc_log(""Profile directory already set; giving up"");
					result = false;
					goto out;
				} else if (arg_profile_dir) {
					cc_log(""Setting profile directory to %s"", profile_dir);
					profile_dir = x_strdup(arg_profile_dir);
				}
				continue;
			}
			cc_log(""Unknown profile option: %s"", argv[i]);
			free(arg);
		}

		if (str_eq(argv[i], ""-fcolor-diagnostics"")
		    || str_eq(argv[i], ""-fno-color-diagnostics"")
		    || str_eq(argv[i], ""-fdiagnostics-color"")
		    || str_eq(argv[i], ""-fdiagnostics-color=always"")
		    || str_eq(argv[i], ""-fno-diagnostics-color"")
		    || str_eq(argv[i], ""-fdiagnostics-color=never"")) {
			args_add(stripped_args, argv[i]);
			found_color_diagnostics = true;
			continue;
		}
		if (str_eq(argv[i], ""-fdiagnostics-color=auto"")) {
			if (color_output_possible()) {
				// Output is redirected, so color output must be forced.
				args_add(stripped_args, ""-fdiagnostics-color=always"");
				cc_log(""Automatically forcing colors"");
			} else {
				args_add(stripped_args, argv[i]);
			}
			found_color_diagnostics = true;
			continue;
		}

		// GCC
		if (str_eq(argv[i], ""-fdirectives-only"")) {
			found_directives_only = true;
			continue;
		}
		// Clang
		if (str_eq(argv[i], ""-frewrite-includes"")) {
			found_rewrite_includes = true;
			continue;
		}

		if (conf->sloppiness & SLOPPY_CLANG_INDEX_STORE
		    && str_eq(argv[i], ""-index-store-path"")) {
			// Xcode 9 or later calls Clang with this option. The given path includes
			// a UUID that might lead to cache misses, especially when cache is
			// shared among multiple users.
			i++;
			if (i <= argc - 1) {
				cc_log(""Skipping argument -index-store-path %s"", argv[i]);
			}
			continue;
		}

		// Options taking an argument that we may want to rewrite to relative paths
		// to get better hit rate. A secondary effect is that paths in the standard
		// error output produced by the compiler will be normalized.
		if (compopt_takes_path(argv[i])) {
			if (i == argc - 1) {
				cc_log(""Missing argument to %s"", argv[i]);
				stats_update(STATS_ARGS);
				result = false;
				goto out;
			}

			if (!detect_pch(argv[i], argv[i+1], &found_pch)) {
				result = false;
				goto out;
			}

			char *relpath = make_relative_path(x_strdup(argv[i+1]));
			if (compopt_affects_cpp(argv[i])) {
				args_add(cpp_args, argv[i]);
				args_add(cpp_args, relpath);
			} else {
				args_add(stripped_args, argv[i]);
				args_add(stripped_args, relpath);
			}
			free(relpath);

			i++;
			continue;
		}

		// Same as above but options with concatenated argument beginning with a
		// slash.
		if (argv[i][0] == '-') {
			char *slash_pos = strchr(argv[i], '/');
			if (slash_pos) {
				char *option = x_strndup(argv[i], slash_pos - argv[i]);
				if (compopt_takes_concat_arg(option) && compopt_takes_path(option)) {
					char *relpath = make_relative_path(x_strdup(slash_pos));
					char *new_option = format(""%s%s"", option, relpath);
					if (compopt_affects_cpp(option)) {
						args_add(cpp_args, new_option);
					} else {
						args_add(stripped_args, new_option);
					}
					free(new_option);
					free(relpath);
					free(option);
					continue;
				} else {
					free(option);
				}
			}
		}

		// Options that take an argument.
		if (compopt_takes_arg(argv[i])) {
			if (i == argc - 1) {
				cc_log(""Missing argument to %s"", argv[i]);
				stats_update(STATS_ARGS);
				result = false;
				goto out;
			}

			if (compopt_affects_cpp(argv[i])) {
				args_add(cpp_args, argv[i]);
				args_add(cpp_args, argv[i+1]);
			} else {
				args_add(stripped_args, argv[i]);
				args_add(stripped_args, argv[i+1]);
			}

			i++;
			continue;
		}

		// Other options.
		if (argv[i][0] == '-') {
			if (compopt_affects_cpp(argv[i])
			    || compopt_prefix_affects_cpp(argv[i])) {
				args_add(cpp_args, argv[i]);
			} else {
				args_add(stripped_args, argv[i]);
			}
			continue;
		}

		// If an argument isn't a plain file then assume its an option, not an
		// input file. This allows us to cope better with unusual compiler options.
		//
		// Note that ""/dev/null"" is an exception that is sometimes used as an input
		// file when code is testing compiler flags.
		struct stat st;
		if (!str_eq(argv[i], ""/dev/null"")
		    && (stat(argv[i], &st) != 0 || !S_ISREG(st.st_mode))) {
			cc_log(""%s is not a regular file, not considering as input file"",
			       argv[i]);
			args_add(stripped_args, argv[i]);
			continue;
		}

		if (input_file) {
			if (language_for_file(argv[i])) {
				cc_log(""Multiple input files: %s and %s"", input_file, argv[i]);
				stats_update(STATS_MULTIPLE);
			} else if (!found_c_opt) {
				cc_log(""Called for link with %s"", argv[i]);
				if (strstr(argv[i], ""conftest."")) {
					stats_update(STATS_CONFTEST);
				} else {
					stats_update(STATS_LINK);
				}
			} else {
				cc_log(""Unsupported source extension: %s"", argv[i]);
				stats_update(STATS_SOURCELANG);
			}
			result = false;
			goto out;
		}

		// The source code file path gets put into the notes.
		if (generating_coverage) {
			input_file = x_strdup(argv[i]);
			continue;
		}

		if (is_symlink(argv[i])) {
			// Don't rewrite source file path if it's a symlink since
			// make_relative_path resolves symlinks using realpath(3) and this leads
			// to potentially choosing incorrect relative header files. See the
			// ""symlink to source file"" test.
			input_file = x_strdup(argv[i]);
		} else {
			// Rewrite to relative to increase hit rate.
			input_file = make_relative_path(x_strdup(argv[i]));
		}
	} // for

	// See <http://gcc.gnu.org/onlinedocs/cpp/Environment-Variables.html>.
	// Contrary to what the documentation seems to imply the compiler still
	// creates object files with these defined (confirmed with GCC 8.2.1), i.e.
	// they work as -MMD/-MD, not -MM/-M. These environment variables do nothing
	// on Clang.
	char *dependencies_env = getenv(""DEPENDENCIES_OUTPUT"");
	bool using_sunpro_dependencies = false;
	if (!dependencies_env) {
		dependencies_env = getenv(""SUNPRO_DEPENDENCIES"");
		using_sunpro_dependencies = true;
	}
	if (dependencies_env) {
		generating_dependencies = true;
		dependency_filename_specified = true;
		char *saveptr = NULL;
		char *abspath_file = strtok_r(dependencies_env, "" "", &saveptr);

		free(output_dep);
		output_dep = make_relative_path(x_strdup(abspath_file));

		// Specifying target object is optional.
		char *abspath_obj = strtok_r(NULL, "" "", &saveptr);
		if (abspath_obj) {
			// It's the ""file target"" form.

			dependency_target_specified = true;
			char *relpath_obj = make_relative_path(x_strdup(abspath_obj));
			// Ensure compiler gets relative path.
			char *relpath_both = format(""%s %s"", output_dep, relpath_obj);
			if (using_sunpro_dependencies) {
				x_setenv(""SUNPRO_DEPENDENCIES"", relpath_both);
			} else {
				x_setenv(""DEPENDENCIES_OUTPUT"", relpath_both);
			}
			free(relpath_obj);
			free(relpath_both);
		} else {
			// It's the ""file"" form.

			dependency_implicit_target_specified = true;
			// Ensure compiler gets relative path.
			if (using_sunpro_dependencies) {
				x_setenv(""SUNPRO_DEPENDENCIES"", output_dep);
			} else {
				x_setenv(""DEPENDENCIES_OUTPUT"", output_dep);
			}
		}
	}

	if (found_S_opt) {
		// Even if -gsplit-dwarf is given, the .dwo file is not generated when -S
		// is also given.
		using_split_dwarf = false;
		cc_log(""Disabling caching of dwarf files since -S is used"");
	}

	if (!input_file) {
		cc_log(""No input file found"");
		stats_update(STATS_NOINPUT);
		result = false;
		goto out;
	}

	if (found_pch || found_fpch_preprocess) {
		using_precompiled_header = true;
		if (!(conf->sloppiness & SLOPPY_TIME_MACROS)) {
			cc_log(""You have to specify \""time_macros\"" sloppiness when using""
			       "" precompiled headers to get direct hits"");
			cc_log(""Disabling direct mode"");
			stats_update(STATS_CANTUSEPCH);
			result = false;
			goto out;
		}
	}

	if (explicit_language && str_eq(explicit_language, ""none"")) {
		explicit_language = NULL;
	}
	file_language = language_for_file(input_file);
	if (explicit_language) {
		if (!language_is_supported(explicit_language)) {
			cc_log(""Unsupported language: %s"", explicit_language);
			stats_update(STATS_SOURCELANG);
			result = false;
			goto out;
		}
		actual_language = x_strdup(explicit_language);
	} else {
		actual_language = file_language;
	}

	output_is_precompiled_header =
		actual_language && strstr(actual_language, ""-header"");

	if (output_is_precompiled_header
	    && !(conf->sloppiness & SLOPPY_PCH_DEFINES)) {
		cc_log(""You have to specify \""pch_defines,time_macros\"" sloppiness when""
		       "" creating precompiled headers"");
		stats_update(STATS_CANTUSEPCH);
		result = false;
		goto out;
	}

	if (!found_c_opt && !found_S_opt) {
		if (output_is_precompiled_header) {
			args_add(stripped_args, ""-c"");
		} else {
			cc_log(""No -c option found"");
			// I find that having a separate statistic for autoconf tests is useful,
			// as they are the dominant form of ""called for link"" in many cases.
			if (strstr(input_file, ""conftest."")) {
				stats_update(STATS_CONFTEST);
			} else {
				stats_update(STATS_LINK);
			}
			result = false;
			goto out;
		}
	}

	if (!actual_language) {
		cc_log(""Unsupported source extension: %s"", input_file);
		stats_update(STATS_SOURCELANG);
		result = false;
		goto out;
	}

	if (!conf->run_second_cpp && str_eq(actual_language, ""cuda"")) {
		cc_log(""Using CUDA compiler; not compiling preprocessed code"");
		conf->run_second_cpp = true;
	}

	direct_i_file = language_is_preprocessed(actual_language);

	if (output_is_precompiled_header && !conf->run_second_cpp) {
		// It doesn't work to create the .gch from preprocessed source.
		cc_log(""Creating precompiled header; not compiling preprocessed code"");
		conf->run_second_cpp = true;
	}

	if (str_eq(conf->cpp_extension, """")) {
		const char *p_language = p_language_for_language(actual_language);
		free(conf->cpp_extension);
		conf->cpp_extension = x_strdup(extension_for_language(p_language) + 1);
	}

	// Don't try to second guess the compilers heuristics for stdout handling.
	if (output_obj && str_eq(output_obj, ""-"")) {
		stats_update(STATS_OUTSTDOUT);
		cc_log(""Output file is -"");
		result = false;
		goto out;
	}

	if (!output_obj) {
		if (output_is_precompiled_header) {
			output_obj = format(""%s.gch"", input_file);
		} else {
			char extension = found_S_opt ? 's' : 'o';
			output_obj = basename(input_file);
			char *p = strrchr(output_obj, '.');
			if (!p) {
				reformat(&output_obj, ""%s.%c"", output_obj, extension);
			} else if (!p[1]) {
				reformat(&output_obj, ""%s%c"", output_obj, extension);
			} else {
				p[1] = extension;
				p[2] = 0;
			}
		}
	}

	if (using_split_dwarf) {
		char *p = strrchr(output_obj, '.');
		if (!p || !p[1]) {
			cc_log(""Badly formed object filename"");
			stats_update(STATS_ARGS);
			result = false;
			goto out;
		}

		char *base_name = remove_extension(output_obj);
		output_dwo = format(""%s.dwo"", base_name);
		free(base_name);
	}

	// Cope with -o /dev/null.
	struct stat st;
	if (!str_eq(output_obj, ""/dev/null"")
	    && stat(output_obj, &st) == 0
	    && !S_ISREG(st.st_mode)) {
		cc_log(""Not a regular file: %s"", output_obj);
		stats_update(STATS_BADOUTPUTFILE);
		result = false;
		goto out;
	}

	char *output_dir = dirname(output_obj);
	if (stat(output_dir, &st) != 0 || !S_ISDIR(st.st_mode)) {
		cc_log(""Directory does not exist: %s"", output_dir);
		stats_update(STATS_BADOUTPUTFILE);
		result = false;
		free(output_dir);
		goto out;
	}
	free(output_dir);

	// Some options shouldn't be passed to the real compiler when it compiles
	// preprocessed code:
	//
	// -finput-charset=XXX (otherwise conversion happens twice)
	// -x XXX (otherwise the wrong language is selected)
	if (input_charset) {
		args_add(cpp_args, input_charset);
	}
	if (found_pch) {
		args_add(cpp_args, ""-fpch-preprocess"");
	}
	if (explicit_language) {
		args_add(cpp_args, ""-x"");
		args_add(cpp_args, explicit_language);
	}

	// Since output is redirected, compilers will not color their output by
	// default, so force it explicitly if it would be otherwise done.
	if (!found_color_diagnostics && color_output_possible()) {
		if (guessed_compiler == GUESSED_CLANG) {
			if (!str_eq(actual_language, ""assembler"")) {
				args_add(stripped_args, ""-fcolor-diagnostics"");
				cc_log(""Automatically enabling colors"");
			}
		} else if (guessed_compiler == GUESSED_GCC) {
			// GCC has it since 4.9, but that'd require detecting what GCC version is
			// used for the actual compile. However it requires also GCC_COLORS to be
			// set (and not empty), so use that for detecting if GCC would use
			// colors.
			if (getenv(""GCC_COLORS"") && getenv(""GCC_COLORS"")[0] != '\0') {
				args_add(stripped_args, ""-fdiagnostics-color"");
				cc_log(""Automatically enabling colors"");
			}
		}
	}

	// Add flags for dependency generation only to the preprocessor command line.
	if (generating_dependencies) {
		if (!dependency_filename_specified) {
			char *base_name = remove_extension(output_obj);
			char *default_depfile_name = format(""%s.d"", base_name);
			free(base_name);
			args_add(dep_args, ""-MF"");
			args_add(dep_args, default_depfile_name);
			output_dep = make_relative_path(x_strdup(default_depfile_name));
		}

		if (!dependency_target_specified
		    && !dependency_implicit_target_specified
		    && !str_eq(get_extension(output_dep), "".o"")) {
			args_add(dep_args, ""-MQ"");
			args_add(dep_args, output_obj);
		}
	}
	if (generating_coverage) {
		char *base_name = remove_extension(output_obj);
		char *default_covfile_name = format(""%s.gcno"", base_name);
		free(base_name);
		output_cov = make_relative_path(default_covfile_name);
	}
	if (generating_stackusage) {
		char *base_name = remove_extension(output_obj);
		char *default_sufile_name = format(""%s.su"", base_name);
		free(base_name);
		output_su = make_relative_path(default_sufile_name);
	}

	*compiler_args = args_copy(stripped_args);
	if (conf->run_second_cpp) {
		args_extend(*compiler_args, cpp_args);
	} else if (found_directives_only || found_rewrite_includes) {
		// Need to pass the macros and any other preprocessor directives again.
		args_extend(*compiler_args, cpp_args);
		if (found_directives_only) {
			args_add(cpp_args, ""-fdirectives-only"");
			// The preprocessed source code still needs some more preprocessing.
			args_add(*compiler_args, ""-fpreprocessed"");
			args_add(*compiler_args, ""-fdirectives-only"");
		}
		if (found_rewrite_includes) {
			args_add(cpp_args, ""-frewrite-includes"");
			// The preprocessed source code still needs some more preprocessing.
			args_add(*compiler_args, ""-x"");
			args_add(*compiler_args, actual_language);
		}
	} else if (explicit_language) {
		// Workaround for a bug in Apple's patched distcc -- it doesn't properly
		// reset the language specified with -x, so if -x is given, we have to
		// specify the preprocessed language explicitly.
		args_add(*compiler_args, ""-x"");
		args_add(*compiler_args, p_language_for_language(explicit_language));
	}

	if (found_c_opt) {
		args_add(*compiler_args, ""-c"");
	}

	for (size_t i = 0; i < arch_args_size; ++i) {
		args_add(*compiler_args, ""-arch"");
		args_add(*compiler_args, arch_args[i]);
	}

	// Only pass dependency arguments to the preprocessor since Intel's C++
	// compiler doesn't produce a correct .d file when compiling preprocessed
	// source.
	args_extend(cpp_args, dep_args);

	*preprocessor_args = args_copy(stripped_args);
	args_extend(*preprocessor_args, cpp_args);

out:
	args_free(expanded_args);
	args_free(stripped_args);
	args_free(dep_args);
	args_free(cpp_args);
	return result;
}

static void
create_initial_config_file(const char *path)
{
	if (create_parent_dirs(path) != 0) {
		return;
	}

	unsigned max_files;
	uint64_t max_size;
	char *stats_dir = format(""%s/0"", conf->cache_dir);
	struct stat st;
	if (stat(stats_dir, &st) == 0) {
		stats_get_obsolete_limits(stats_dir, &max_files, &max_size);
		// STATS_MAXFILES and STATS_MAXSIZE was stored for each top directory.
		max_files *= 16;
		max_size *= 16;
	} else {
		max_files = 0;
		max_size = conf->max_size;
	}
	free(stats_dir);

	FILE *f = fopen(path, ""w"");
	if (!f) {
		return;
	}
	if (max_files != 0) {
		fprintf(f, ""max_files = %u\n"", max_files);
		conf->max_files = max_files;
	}
	if (max_size != 0) {
		char *size = format_parsable_size_with_suffix(max_size);
		fprintf(f, ""max_size = %s\n"", size);
		free(size);
		conf->max_size = max_size;
	}
	fclose(f);
}

// Read config file(s), populate variables, create configuration file in cache
// directory if missing, etc.
static void
initialize(void)
{
	conf_free(conf);
	conf = conf_create();

	char *errmsg;
	char *p = getenv(""CCACHE_CONFIGPATH"");
	if (p) {
		primary_config_path = x_strdup(p);
	} else {
		secondary_config_path = format(""%s/ccache.conf"", TO_STRING(SYSCONFDIR));
		if (!conf_read(conf, secondary_config_path, &errmsg)) {
			if (errno == 0) {
				// We could read the file but it contained errors.
				fatal(""%s"", errmsg);
			}
			// A missing config file in SYSCONFDIR is OK.
			free(errmsg);
		}

		if (str_eq(conf->cache_dir, """")) {
			fatal(""configuration setting \""cache_dir\"" must not be the empty string"");
		}
		if ((p = getenv(""CCACHE_DIR""))) {
			free(conf->cache_dir);
			conf->cache_dir = strdup(p);
		}
		if (str_eq(conf->cache_dir, """")) {
			fatal(""CCACHE_DIR must not be the empty string"");
		}

		primary_config_path = format(""%s/ccache.conf"", conf->cache_dir);
	}

	bool should_create_initial_config = false;
	if (!conf_read(conf, primary_config_path, &errmsg)) {
		if (errno == 0) {
			// We could read the file but it contained errors.
			fatal(""%s"", errmsg);
		}
		if (!conf->disable) {
			should_create_initial_config = true;
		}
	}

	if (!conf_update_from_environment(conf, &errmsg)) {
		fatal(""%s"", errmsg);
	}

	if (should_create_initial_config) {
		create_initial_config_file(primary_config_path);
	}

	exitfn_init();
	exitfn_add_nullary(stats_flush);
	exitfn_add_nullary(clean_up_pending_tmp_files);

	cc_log(""=== CCACHE %s STARTED ========================================="",
	       CCACHE_VERSION);

	if (conf->umask != UINT_MAX) {
		umask(conf->umask);
	}
}

// Reset the global state. Used by the test suite.
void
cc_reset(void)
{
	conf_free(conf); conf = NULL;
	free(primary_config_path); primary_config_path = NULL;
	free(secondary_config_path); secondary_config_path = NULL;
	free(current_working_dir); current_working_dir = NULL;
	for (size_t i = 0; i < debug_prefix_maps_len; i++) {
		free(debug_prefix_maps[i]);
		debug_prefix_maps[i] = NULL;
	}
	free(debug_prefix_maps); debug_prefix_maps = NULL;
	debug_prefix_maps_len = 0;
	free(profile_dir); profile_dir = NULL;
	for (size_t i = 0; i < sanitize_blacklists_len; i++) {
		free(sanitize_blacklists[i]);
		sanitize_blacklists[i] = NULL;
	}
	free(sanitize_blacklists); sanitize_blacklists = NULL;
	sanitize_blacklists_len = 0;
	free(included_pch_file); included_pch_file = NULL;
	args_free(orig_args); orig_args = NULL;
	free(input_file); input_file = NULL;
	free(output_obj); output_obj = NULL;
	free(output_dep); output_dep = NULL;
	free(output_cov); output_cov = NULL;
	free(output_su); output_su = NULL;
	free(output_dia); output_dia = NULL;
	free(output_dwo); output_dwo = NULL;
	free(cached_obj_hash); cached_obj_hash = NULL;
	free(cached_stderr); cached_stderr = NULL;
	free(cached_obj); cached_obj = NULL;
	free(cached_dep); cached_dep = NULL;
	free(cached_cov); cached_cov = NULL;
	free(cached_su); cached_su = NULL;
	free(cached_dia); cached_dia = NULL;
	free(cached_dwo); cached_dwo = NULL;
	free(manifest_path); manifest_path = NULL;
	time_of_compilation = 0;
	for (size_t i = 0; i < ignore_headers_len; i++) {
		free(ignore_headers[i]);
		ignore_headers[i] = NULL;
	}
	free(ignore_headers); ignore_headers = NULL;
	ignore_headers_len = 0;
	if (included_files) {
		hashtable_destroy(included_files, 1); included_files = NULL;
	}
	has_absolute_include_headers = false;
	generating_debuginfo = false;
	generating_dependencies = false;
	generating_coverage = false;
	generating_stackusage = false;
	profile_arcs = false;
	free(profile_dir); profile_dir = NULL;
	i_tmpfile = NULL;
	direct_i_file = false;
	free(cpp_stderr); cpp_stderr = NULL;
	free(stats_file); stats_file = NULL;
	output_is_precompiled_header = false;

	conf = conf_create();
	using_split_dwarf = false;
}

// Make a copy of stderr that will not be cached, so things like distcc can
// send networking errors to it.
static void
set_up_uncached_err(void)
{
	int uncached_fd = dup(2); // The file descriptor is intentionally leaked.
	if (uncached_fd == -1) {
		cc_log(""dup(2) failed: %s"", strerror(errno));
		failed();
	}

	// Leak a pointer to the environment.
	char *buf = format(""UNCACHED_ERR_FD=%d"", uncached_fd);
	if (putenv(buf) == -1) {
		cc_log(""putenv failed: %s"", strerror(errno));
		failed();
	}
}

static void
configuration_logger(const char *descr, const char *origin, void *context)
{
	(void)context;
	cc_bulklog(""Config: (%s) %s"", origin, descr);
}

static void ccache(int argc, char *argv[]) ATTR_NORETURN;

// The main ccache driver function.
static void
ccache(int argc, char *argv[])
{
#ifndef _WIN32
	set_up_signal_handlers();
#endif

	orig_args = args_init(argc, argv);

	initialize();
	find_compiler(argv);

	if (str_eq(conf->temporary_dir, """")) {
		clean_up_internal_tempdir();
	}

	if (!str_eq(conf->log_file, """") || conf->debug) {
		conf_print_items(conf, configuration_logger, NULL);
	}

	if (conf->disable) {
		cc_log(""ccache is disabled"");
		failed();
	}

	set_up_uncached_err();

	cc_log_argv(""Command line: "", argv);
	cc_log(""Hostname: %s"", get_hostname());
	cc_log(""Working directory: %s"", get_current_working_dir());

	conf->limit_multiple = MIN(MAX(conf->limit_multiple, 0.0), 1.0);

	guessed_compiler = guess_compiler(orig_args->argv[0]);

	// Arguments (except -E) to send to the preprocessor.
	struct args *preprocessor_args;
	// Arguments to send to the real compiler.
	struct args *compiler_args;
	if (!cc_process_args(orig_args, &preprocessor_args, &compiler_args)) {
		failed();
	}

	if (conf->depend_mode
	    && (!generating_dependencies || !conf->run_second_cpp || conf->unify)) {
		cc_log(""Disabling depend mode"");
		conf->depend_mode = false;
	}

	cc_log(""Source file: %s"", input_file);
	if (generating_dependencies) {
		cc_log(""Dependency file: %s"", output_dep);
	}
	if (generating_coverage) {
		cc_log(""Coverage file: %s"", output_cov);
	}
	if (generating_stackusage) {
		cc_log(""Stack usage file: %s"", output_su);
	}
	if (generating_diagnostics) {
		cc_log(""Diagnostics file: %s"", output_dia);
	}
	if (output_dwo) {
		cc_log(""Split dwarf file: %s"", output_dwo);
	}

	cc_log(""Object file: %s"", output_obj);

	// Need to dump log buffer as the last exit function to not lose any logs.
	exitfn_add_last(dump_debug_log_buffer_exitfn, output_obj);

	FILE *debug_text_file = NULL;
	if (conf->debug) {
		char *path = format(""%s.ccache-input-text"", output_obj);
		debug_text_file = fopen(path, ""w"");
		if (debug_text_file) {
			exitfn_add(fclose_exitfn, debug_text_file);
		}
		else {
			cc_log(""Failed to open %s: %s"", path, strerror(errno));
		}
		free(path);
	}

	struct hash *common_hash = hash_init();
	init_hash_debug(common_hash, output_obj, 'c', ""COMMON"", debug_text_file);

	calculate_common_hash(preprocessor_args, common_hash);

	// Try to find the hash using the manifest.
	struct hash *direct_hash = hash_copy(common_hash);
	init_hash_debug(
		direct_hash, output_obj, 'd', ""DIRECT MODE"", debug_text_file);

	bool put_object_in_manifest = false;
	struct file_hash *object_hash = NULL;
	struct file_hash *object_hash_from_manifest = NULL;
	if (conf->direct_mode) {
		cc_log(""Trying direct lookup"");
		object_hash = calculate_object_hash(preprocessor_args, direct_hash, 1);
		if (object_hash) {
			update_cached_result_globals(object_hash);

			// If we can return from cache at this point then do so.
			from_cache(FROMCACHE_DIRECT_MODE, 0);

			// Wasn't able to return from cache at this point. However, the object
			// was already found in manifest, so don't readd it later.
			put_object_in_manifest = false;

			object_hash_from_manifest = object_hash;
		} else {
			// Add object to manifest later.
			put_object_in_manifest = true;
		}
	}

	if (conf->read_only_direct) {
		cc_log(""Read-only direct mode; running real compiler"");
		failed();
	}

	if (!conf->depend_mode) {
		// Find the hash using the preprocessed output. Also updates
		// included_files.
		struct hash *cpp_hash = hash_copy(common_hash);
		init_hash_debug(
			cpp_hash, output_obj, 'p', ""PREPROCESSOR MODE"", debug_text_file);

		object_hash = calculate_object_hash(preprocessor_args, cpp_hash, 0);
		if (!object_hash) {
			fatal(""internal error: object hash from cpp returned NULL"");
		}
		update_cached_result_globals(object_hash);

		if (object_hash_from_manifest
		    && !file_hashes_equal(object_hash_from_manifest, object_hash)) {
			// The hash from manifest differs from the hash of the preprocessor
			// output. This could be because:
			//
			// - The preprocessor produces different output for the same input (not
			//   likely).
			// - There's a bug in ccache (maybe incorrect handling of compiler
			//   arguments).
			// - The user has used a different CCACHE_BASEDIR (most likely).
			//
			// The best thing here would probably be to remove the hash entry from
			// the manifest. For now, we use a simpler method: just remove the
			// manifest file.
			cc_log(""Hash from manifest doesn't match preprocessor output"");
			cc_log(""Likely reason: different CCACHE_BASEDIRs used"");
			cc_log(""Removing manifest as a safety measure"");
			x_unlink(manifest_path);

			put_object_in_manifest = true;
		}

		// If we can return from cache at this point then do.
		from_cache(FROMCACHE_CPP_MODE, put_object_in_manifest);
	}

	if (conf->read_only) {
		cc_log(""Read-only mode; running real compiler"");
		failed();
	}

	add_prefix(compiler_args, conf->prefix_command);

	// In depend_mode, extend the direct hash.
	struct hash *depend_mode_hash = conf->depend_mode ? direct_hash : NULL;

	// Run real compiler, sending output to cache.
	to_cache(compiler_args, depend_mode_hash);

	x_exit(0);
}

static void
configuration_printer(const char *descr, const char *origin, void *context)
{
	assert(context);
	fprintf(context, ""(%s) %s\n"", origin, descr);
}

// The main program when not doing a compile.
static int
ccache_main_options(int argc, char *argv[])
{
	enum longopts {
		DUMP_MANIFEST,
		HASH_FILE,
		PRINT_STATS,
	};
	static const struct option options[] = {
		{""cleanup"",       no_argument,       0, 'c'},
		{""clear"",         no_argument,       0, 'C'},
		{""dump-manifest"", required_argument, 0, DUMP_MANIFEST},
		{""get-config"",    required_argument, 0, 'k'},
		{""hash-file"",     required_argument, 0, HASH_FILE},
		{""help"",          no_argument,       0, 'h'},
		{""max-files"",     required_argument, 0, 'F'},
		{""max-size"",      required_argument, 0, 'M'},
		{""print-stats"",   no_argument,       0, PRINT_STATS},
		{""set-config"",    required_argument, 0, 'o'},
		{""show-config"",   no_argument,       0, 'p'},
		{""show-stats"",    no_argument,       0, 's'},
		{""version"",       no_argument,       0, 'V'},
		{""zero-stats"",    no_argument,       0, 'z'},
		{0, 0, 0, 0}
	};

	int c;
	while ((c = getopt_long(argc, argv, ""cCk:hF:M:po:sVz"", options, NULL))
	       != -1) {
		switch (c) {
		case DUMP_MANIFEST:
			manifest_dump(optarg, stdout);
			break;

		case HASH_FILE:
		{
			initialize();
			struct hash *hash = hash_init();
			if (str_eq(optarg, ""-"")) {
				hash_fd(hash, STDIN_FILENO);
			} else {
				hash_file(hash, optarg);
			}
			char *result = hash_result(hash);
			puts(result);
			free(result);
			hash_free(hash);
			break;
		}

		case PRINT_STATS:
			initialize();
			stats_print();
			break;

		case 'c': // --cleanup
			initialize();
			clean_up_all(conf);
			printf(""Cleaned cache\n"");
			break;

		case 'C': // --clear
			initialize();
			wipe_all(conf);
			printf(""Cleared cache\n"");
			break;

		case 'h': // --help
			fputs(USAGE_TEXT, stdout);
			x_exit(0);

		case 'k': // --get-config
		{
			initialize();
			char *errmsg;
			if (!conf_print_value(conf, optarg, stdout, &errmsg)) {
				fatal(""%s"", errmsg);
			}
		}
		break;

		case 'F': // --max-files
		{
			initialize();
			char *errmsg;
			if (conf_set_value_in_file(primary_config_path, ""max_files"", optarg,
			                           &errmsg)) {
				unsigned files = atoi(optarg);
				if (files == 0) {
					printf(""Unset cache file limit\n"");
				} else {
					printf(""Set cache file limit to %u\n"", files);
				}
			} else {
				fatal(""could not set cache file limit: %s"", errmsg);
			}
		}
		break;

		case 'M': // --max-size
		{
			initialize();
			uint64_t size;
			if (!parse_size_with_suffix(optarg, &size)) {
				fatal(""invalid size: %s"", optarg);
			}
			char *errmsg;
			if (conf_set_value_in_file(primary_config_path, ""max_size"", optarg,
			                           &errmsg)) {
				if (size == 0) {
					printf(""Unset cache size limit\n"");
				} else {
					char *s = format_human_readable_size(size);
					printf(""Set cache size limit to %s\n"", s);
					free(s);
				}
			} else {
				fatal(""could not set cache size limit: %s"", errmsg);
			}
		}
		break;

		case 'o': // --set-config
		{
			initialize();
			char *p = strchr(optarg, '=');
			if (!p) {
				fatal(""missing equal sign in \""%s\"""", optarg);
			}
			char *key = x_strndup(optarg, p - optarg);
			char *value = p + 1;
			char *errmsg;
			if (!conf_set_value_in_file(primary_config_path, key, value, &errmsg)) {
				fatal(""%s"", errmsg);
			}
			free(key);
		}
		break;

		case 'p': // --show-config
			initialize();
			conf_print_items(conf, configuration_printer, stdout);
			break;

		case 's': // --show-stats
			initialize();
			stats_summary();
			break;

		case 'V': // --version
			fprintf(stdout, VERSION_TEXT, CCACHE_VERSION);
			x_exit(0);

		case 'z': // --zero-stats
			initialize();
			stats_zero();
			printf(""Statistics zeroed\n"");
			break;

		default:
			fputs(USAGE_TEXT, stderr);
			x_exit(1);
		}
	}

	return 0;
}

int ccache_main(int argc, char *argv[]);

int
ccache_main(int argc, char *argv[])
{
	// Check if we are being invoked as ""ccache"".
	char *program_name = basename(argv[0]);
	if (same_executable_name(program_name, MYNAME)) {
		if (argc < 2) {
			fputs(USAGE_TEXT, stderr);
			x_exit(1);
		}
		// If the first argument isn't an option, then assume we are being passed a
		// compiler name and options.
		if (argv[1][0] == '-') {
			return ccache_main_options(argc, argv);
		}
	}
	free(program_name);

	ccache(argc, argv);
}
""","""// ccache -- a fast C/C++ compiler cache
//
// Copyright (C) 2002-2007 Andrew Tridgell
// Copyright (C) 2009-2019 Joel Rosdahl
//
// This program is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by the Free
// Software Foundation; either version 3 of the License, or (at your option)
// any later version.
//
// This program is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
// more details.
//
// You should have received a copy of the GNU General Public License along with
// this program; if not, write to the Free Software Foundation, Inc., 51
// Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA

#include ""ccache.h""
#include ""compopt.h""
#ifdef HAVE_GETOPT_LONG
#include <getopt.h>
#else
#include ""getopt_long.h""
#endif
#include ""hash.h""
#include ""hashtable.h""
#include ""hashtable_itr.h""
#include ""hashutil.h""
#include ""language.h""
#include ""manifest.h""
#include ""unify.h""

#define STRINGIFY(x) #x
#define TO_STRING(x) STRINGIFY(x)

// Global variables used by other compilation units.
extern struct conf *conf;
extern char *primary_config_path;
extern char *secondary_config_path;
extern char *current_working_dir;
extern char *stats_file;
extern unsigned lock_staleness_limit;

static const char VERSION_TEXT[] =
	MYNAME "" version %s\n""
	""\n""
	""Copyright (C) 2002-2007 Andrew Tridgell\n""
	""Copyright (C) 2009-2019 Joel Rosdahl\n""
	""\n""
	""This program is free software; you can redistribute it and/or modify it under\n""
	""the terms of the GNU General Public License as published by the Free Software\n""
	""Foundation; either version 3 of the License, or (at your option) any later\n""
	""version.\n"";

static const char USAGE_TEXT[] =
	""Usage:\n""
	""    "" MYNAME "" [options]\n""
	""    "" MYNAME "" compiler [compiler options]\n""
	""    compiler [compiler options]          (via symbolic link)\n""
	""\n""
	""Common options:\n""
	""    -c, --cleanup             delete old files and recalculate size counters\n""
	""                              (normally not needed as this is done\n""
	""                              automatically)\n""
	""    -C, --clear               clear the cache completely (except configuration)\n""
	""    -F, --max-files=N         set maximum number of files in cache to N (use 0\n""
	""                              for no limit)\n""
	""    -M, --max-size=SIZE       set maximum size of cache to SIZE (use 0 for no\n""
	""                              limit); available suffixes: k, M, G, T (decimal)\n""
	""                              and Ki, Mi, Gi, Ti (binary); default suffix: G\n""
	""    -p, --show-config         show current configuration options in\n""
	""                              human-readable format\n""
	""    -s, --show-stats          show summary of configuration and statistics\n""
	""                              counters in human-readable format\n""
	""    -z, --zero-stats          zero statistics counters\n""
	""\n""
	""    -h, --help                print this help text\n""
	""    -V, --version             print version and copyright information\n""
	""\n""
	""Options for scripting or debugging:\n""
	""        --dump-manifest=PATH  dump manifest file at PATH in text format\n""
	""    -k, --get-config=K        print the value of configuration key K\n""
	""        --hash-file=PATH      print the hash (<MD4>-<size>) of the file at PATH\n""
	""        --print-stats         print statistics counter IDs and corresponding\n""
	""                              values in machine-parsable format\n""
	""    -o, --set-config=K=V      set configuration item K to value V\n""
	""\n""
	""See also <https://ccache.samba.org>.\n"";

// Global configuration data.
struct conf *conf = NULL;

// Where to write configuration changes.
char *primary_config_path = NULL;

// Secondary, read-only configuration file (if any).
char *secondary_config_path = NULL;

// Current working directory taken from $PWD, or getcwd() if $PWD is bad.
char *current_working_dir = NULL;

// The original argument list.
static struct args *orig_args;

// The source file.
static char *input_file;

// The output file being compiled to.
static char *output_obj;

// The path to the dependency file (implicit or specified with -MF).
static char *output_dep;

// The path to the coverage file (implicit when using -ftest-coverage).
static char *output_cov;

// The path to the stack usage (implicit when using -fstack-usage).
static char *output_su;

// Diagnostic generation information (clang). Contains pathname if not NULL.
static char *output_dia;

// Split dwarf information (GCC 4.8 and up). Contains pathname if not NULL.
static char *output_dwo;

// Language to use for the compilation target (see language.c).
static const char *actual_language;

// Array for storing -arch options.
#define MAX_ARCH_ARGS 10
static size_t arch_args_size = 0;
static char *arch_args[MAX_ARCH_ARGS] = {NULL};

// Name (represented as a struct file_hash) of the file containing the cached
// object code.
static struct file_hash *cached_obj_hash;

// Full path to the file containing the cached object code
// (cachedir/a/b/cdef[...]-size.o).
static char *cached_obj;

// Full path to the file containing the standard error output
// (cachedir/a/b/cdef[...]-size.stderr).
static char *cached_stderr;

// Full path to the file containing the dependency information
// (cachedir/a/b/cdef[...]-size.d).
static char *cached_dep;

// Full path to the file containing the coverage information
// (cachedir/a/b/cdef[...]-size.gcno).
static char *cached_cov;

// Full path to the file containing the stack usage
// (cachedir/a/b/cdef[...]-size.su).
static char *cached_su;

// Full path to the file containing the diagnostic information (for clang)
// (cachedir/a/b/cdef[...]-size.dia).
static char *cached_dia;

// Full path to the file containing the split dwarf (for GCC 4.8 and above)
// (cachedir/a/b/cdef[...]-size.dwo).
//
// Contains NULL if -gsplit-dwarf is not given.
static char *cached_dwo;

// Full path to the file containing the manifest
// (cachedir/a/b/cdef[...]-size.manifest).
static char *manifest_path;

// Time of compilation. Used to see if include files have changed after
// compilation.
time_t time_of_compilation;

// Files included by the preprocessor and their hashes/sizes. Key: file path.
// Value: struct file_hash.
static struct hashtable *included_files = NULL;

// Uses absolute path for some include files.
static bool has_absolute_include_headers = false;

// List of headers to ignore.
static char **ignore_headers;

// Size of headers to ignore list.
static size_t ignore_headers_len;

// Is the compiler being asked to output debug info?
static bool generating_debuginfo;

// Is the compiler being asked to output dependencies?
static bool generating_dependencies;

// Is the compiler being asked to output coverage?
static bool generating_coverage;

// Is the compiler being asked to output stack usage?
static bool generating_stackusage;

// Us the compiler being asked to generate diagnostics
// (--serialize-diagnostics)?
static bool generating_diagnostics;

// Is the compiler being asked to separate dwarf debug info into a separate
// file (-gsplit-dwarf)""?
static bool using_split_dwarf;

// Relocating debuginfo in the format old=new.
static char **debug_prefix_maps = NULL;

// Size of debug_prefix_maps list.
static size_t debug_prefix_maps_len = 0;

// Is the compiler being asked to output coverage data (.gcda) at runtime?
static bool profile_arcs;

// Name of the custom profile directory (default: object dirname).
static char *profile_dir;

// The name of the temporary preprocessed file.
static char *i_tmpfile;

// Are we compiling a .i or .ii file directly?
static bool direct_i_file;

// The name of the cpp stderr file.
static char *cpp_stderr;

// Full path to the statistics file in the subdirectory where the cached result
// belongs (<cache_dir>/<x>/stats).
char *stats_file = NULL;

// Whether the output is a precompiled header.
bool output_is_precompiled_header = false;

// Compiler guessing is currently only based on the compiler name, so nothing
// should hard-depend on it if possible.
enum guessed_compiler guessed_compiler = GUESSED_UNKNOWN;

// Profile generation / usage information.
static char *profile_dir = NULL;
static bool profile_use = false;
static bool profile_generate = false;

// Sanitize blacklist
static char **sanitize_blacklists = NULL;

// Size of sanitize_blacklists
static size_t sanitize_blacklists_len = 0;

// Whether we are using a precompiled header (either via -include, #include or
// clang's -include-pch or -include-pth).
static bool using_precompiled_header = false;

// The .gch/.pch/.pth file used for compilation.
static char *included_pch_file = NULL;

// How long (in microseconds) to wait before breaking a stale lock.
unsigned lock_staleness_limit = 2000000;

enum fromcache_call_mode {
	FROMCACHE_DIRECT_MODE,
	FROMCACHE_CPP_MODE
};

struct pending_tmp_file {
	char *path;
	struct pending_tmp_file *next;
};

// Temporary files to remove at program exit.
static struct pending_tmp_file *pending_tmp_files = NULL;

#ifndef _WIN32
static sigset_t fatal_signal_set;

// PID of currently executing compiler that we have started, if any. 0 means no
// ongoing compilation.
static pid_t compiler_pid = 0;
#endif

// This is a string that identifies the current ""version"" of the hash sum
// computed by ccache. If, for any reason, we want to force the hash sum to be
// different for the same input in a new ccache version, we can just change
// this string. A typical example would be if the format of one of the files
// stored in the cache changes in a backwards-incompatible way.
static const char HASH_PREFIX[] = ""3"";

static void
add_prefix(struct args *args, char *prefix_command)
{
	if (str_eq(prefix_command, """")) {
		return;
	}

	struct args *prefix = args_init(0, NULL);
	char *e = x_strdup(prefix_command);
	char *saveptr = NULL;
	for (char *tok = strtok_r(e, "" "", &saveptr);
	     tok;
	     tok = strtok_r(NULL, "" "", &saveptr)) {
		char *p;

		p = find_executable(tok, MYNAME);
		if (!p) {
			fatal(""%s: %s"", tok, strerror(errno));
		}

		args_add(prefix, p);
		free(p);
	}
	free(e);

	cc_log(""Using command-line prefix %s"", prefix_command);
	for (int i = prefix->argc; i != 0; i--) {
		args_add_prefix(args, prefix->argv[i-1]);
	}
	args_free(prefix);
}


static void failed(void) ATTR_NORETURN;

// Something went badly wrong - just execute the real compiler.
static void
failed(void)
{
	assert(orig_args);

	args_strip(orig_args, ""--ccache-"");
	add_prefix(orig_args, conf->prefix_command);

	cc_log(""Failed; falling back to running the real compiler"");
	cc_log_argv(""Executing "", orig_args->argv);
	exitfn_call();
	execv(orig_args->argv[0], orig_args->argv);
	fatal(""execv of %s failed: %s"", orig_args->argv[0], strerror(errno));
}

static const char *
temp_dir()
{
	static char *path = NULL;
	if (path) {
		return path; // Memoize
	}
	path = conf->temporary_dir;
	if (str_eq(path, """")) {
		path = format(""%s/tmp"", conf->cache_dir);
	}
	return path;
}

void
block_signals(void)
{
#ifndef _WIN32
	sigprocmask(SIG_BLOCK, &fatal_signal_set, NULL);
#endif
}

void
unblock_signals(void)
{
#ifndef _WIN32
	sigset_t empty;
	sigemptyset(&empty);
	sigprocmask(SIG_SETMASK, &empty, NULL);
#endif
}

static void
add_pending_tmp_file(const char *path)
{
	block_signals();
	struct pending_tmp_file *e = x_malloc(sizeof(*e));
	e->path = x_strdup(path);
	e->next = pending_tmp_files;
	pending_tmp_files = e;
	unblock_signals();
}

static void
do_clean_up_pending_tmp_files(void)
{
	struct pending_tmp_file *p = pending_tmp_files;
	while (p) {
		// Can't call tmp_unlink here since its cc_log calls aren't signal safe.
		unlink(p->path);
		p = p->next;
		// Leak p->path and p here because clean_up_pending_tmp_files needs to be
		// signal safe.
	}
}

static void
clean_up_pending_tmp_files(void)
{
	block_signals();
	do_clean_up_pending_tmp_files();
	unblock_signals();
}

#ifndef _WIN32
static void
signal_handler(int signum)
{
	// Unregister handler for this signal so that we can send the signal to
	// ourselves at the end of the handler.
	signal(signum, SIG_DFL);

	// If ccache was killed explicitly, then bring the compiler subprocess (if
	// any) with us as well.
	if (signum == SIGTERM
	    && compiler_pid != 0
	    && waitpid(compiler_pid, NULL, WNOHANG) == 0) {
		kill(compiler_pid, signum);
	}

	do_clean_up_pending_tmp_files();

	if (compiler_pid != 0) {
		// Wait for compiler subprocess to exit before we snuff it.
		waitpid(compiler_pid, NULL, 0);
	}

	// Resend signal to ourselves to exit properly after returning from the
	// handler.
	kill(getpid(), signum);
}

static void
register_signal_handler(int signum)
{
	struct sigaction act;
	memset(&act, 0, sizeof(act));
	act.sa_handler = signal_handler;
	act.sa_mask = fatal_signal_set;
#ifdef SA_RESTART
	act.sa_flags = SA_RESTART;
#endif
	sigaction(signum, &act, NULL);
}

static void
set_up_signal_handlers(void)
{
	sigemptyset(&fatal_signal_set);
	sigaddset(&fatal_signal_set, SIGINT);
	sigaddset(&fatal_signal_set, SIGTERM);
#ifdef SIGHUP
	sigaddset(&fatal_signal_set, SIGHUP);
#endif
#ifdef SIGQUIT
	sigaddset(&fatal_signal_set, SIGQUIT);
#endif

	register_signal_handler(SIGINT);
	register_signal_handler(SIGTERM);
#ifdef SIGHUP
	register_signal_handler(SIGHUP);
#endif
#ifdef SIGQUIT
	register_signal_handler(SIGQUIT);
#endif
}
#endif // _WIN32

static void
clean_up_internal_tempdir(void)
{
	time_t now = time(NULL);
	struct stat st;
	if (x_stat(conf->cache_dir, &st) != 0 || st.st_mtime + 3600 >= now) {
		// No cleanup needed.
		return;
	}

	update_mtime(conf->cache_dir);

	DIR *dir = opendir(temp_dir());
	if (!dir) {
		return;
	}

	struct dirent *entry;
	while ((entry = readdir(dir))) {
		if (str_eq(entry->d_name, ""."") || str_eq(entry->d_name, "".."")) {
			continue;
		}

		char *path = format(""%s/%s"", temp_dir(), entry->d_name);
		if (x_lstat(path, &st) == 0 && st.st_mtime + 3600 < now) {
			tmp_unlink(path);
		}
		free(path);
	}

	closedir(dir);
}

static void
fclose_exitfn(void *context)
{
	fclose((FILE *)context);
}

static void
dump_debug_log_buffer_exitfn(void *context)
{
	if (!conf->debug) {
		return;
	}

	char *path = format(""%s.ccache-log"", (const char *)context);
	cc_dump_debug_log_buffer(path);
	free(path);
}

static void
init_hash_debug(struct hash *hash, const char *obj_path, char type,
                const char *section_name, FILE *debug_text_file)
{
	if (!conf->debug) {
		return;
	}

	char *path = format(""%s.ccache-input-%c"", obj_path, type);
	FILE *debug_binary_file = fopen(path, ""wb"");
	if (debug_binary_file) {
		hash_enable_debug(hash, section_name, debug_binary_file, debug_text_file);
		exitfn_add(fclose_exitfn, debug_binary_file);
	} else {
		cc_log(""Failed to open %s: %s"", path, strerror(errno));
	}
	free(path);
}

static enum guessed_compiler
guess_compiler(const char *path)
{
	char *name = basename(path);
	enum guessed_compiler result = GUESSED_UNKNOWN;
	if (strstr(name, ""clang"")) {
		result = GUESSED_CLANG;
	} else if (strstr(name, ""gcc"") || strstr(name, ""g++"")) {
		result = GUESSED_GCC;
	} else if (strstr(name, ""nvcc"")) {
		result = GUESSED_NVCC;
	} else if (str_eq(name, ""pump"") || str_eq(name, ""distcc-pump"")) {
		result = GUESSED_PUMP;
	}
	free(name);
	return result;
}

static char *
get_current_working_dir(void)
{
	if (!current_working_dir) {
		char *cwd = get_cwd();
		if (cwd) {
			current_working_dir = x_realpath(cwd);
			free(cwd);
		}
		if (!current_working_dir) {
			cc_log(""Unable to determine current working directory: %s"",
			       strerror(errno));
			failed();
		}
	}
	return current_working_dir;
}

// Transform a name to a full path into the cache directory, creating needed
// sublevels if needed. Caller frees.
static char *
get_path_in_cache(const char *name, const char *suffix)
{
	char *path = x_strdup(conf->cache_dir);
	for (unsigned i = 0; i < conf->cache_dir_levels; ++i) {
		char *p = format(""%s/%c"", path, name[i]);
		free(path);
		path = p;
	}

	char *result =
		format(""%s/%s%s"", path, name + conf->cache_dir_levels, suffix);
	free(path);
	return result;
}

// This function hashes an include file and stores the path and hash in the
// global included_files variable. If the include file is a PCH, cpp_hash is
// also updated. Takes over ownership of path.
static void
remember_include_file(char *path, struct hash *cpp_hash, bool system,
                      struct hash *depend_mode_hash)
{
	struct hash *fhash = NULL;

	size_t path_len = strlen(path);
	if (path_len >= 2 && (path[0] == '<' && path[path_len - 1] == '>')) {
		// Typically <built-in> or <command-line>.
		goto out;
	}

	if (str_eq(path, input_file)) {
		// Don't remember the input file.
		goto out;
	}

	if (system && (conf->sloppiness & SLOPPY_SYSTEM_HEADERS)) {
		// Don't remember this system header.
		goto out;
	}

	if (hashtable_search(included_files, path)) {
		// Already known include file.
		goto out;
	}

#ifdef _WIN32
	// stat fails on directories on win32.
	DWORD attributes = GetFileAttributes(path);
	if (attributes != INVALID_FILE_ATTRIBUTES &&
	    attributes & FILE_ATTRIBUTE_DIRECTORY) {
		goto out;
	}
#endif

	struct stat st;
	if (x_stat(path, &st) != 0) {
		goto failure;
	}
	if (S_ISDIR(st.st_mode)) {
		// Ignore directory, typically $PWD.
		goto out;
	}
	if (!S_ISREG(st.st_mode)) {
		// Device, pipe, socket or other strange creature.
		cc_log(""Non-regular include file %s"", path);
		goto failure;
	}

	// Canonicalize path for comparison; clang uses ./header.h.
	char *canonical = path;
	size_t canonical_len = path_len;
	if (canonical[0] == '.' && canonical[1] == '/') {
		canonical += 2;
		canonical_len -= 2;
	}

	for (size_t i = 0; i < ignore_headers_len; i++) {
		char *ignore = ignore_headers[i];
		size_t ignore_len = strlen(ignore);
		if (ignore_len > canonical_len) {
			continue;
		}
		if (strncmp(canonical, ignore, ignore_len) == 0
		    && (ignore[ignore_len-1] == DIR_DELIM_CH
		        || canonical[ignore_len] == DIR_DELIM_CH
		        || canonical[ignore_len] == '\0')) {
			goto out;
		}
	}

	// The comparison using >= is intentional, due to a possible race between
	// starting compilation and writing the include file. See also the notes
	// under ""Performance"" in doc/MANUAL.adoc.
	if (!(conf->sloppiness & SLOPPY_INCLUDE_FILE_MTIME)
	    && st.st_mtime >= time_of_compilation) {
		cc_log(""Include file %s too new"", path);
		goto failure;
	}

	// The same >= logic as above applies to the change time of the file.
	if (!(conf->sloppiness & SLOPPY_INCLUDE_FILE_CTIME)
	    && st.st_ctime >= time_of_compilation) {
		cc_log(""Include file %s ctime too new"", path);
		goto failure;
	}

	// Let's hash the include file content.
	fhash = hash_init();

	bool is_pch = is_precompiled_header(path);
	if (is_pch) {
		bool using_pch_sum = false;
		if (conf->pch_external_checksum) {
			// hash pch.sum instead of pch when it exists
			// to prevent hashing a very large .pch file every time
			char *pch_sum_path = format(""%s.sum"", path);
			if (x_stat(pch_sum_path, &st) == 0) {
				char *old_path = path;
				path = pch_sum_path;
				pch_sum_path = old_path;
				using_pch_sum = true;
				cc_log(""Using pch.sum file %s"", path);
			}
			free(pch_sum_path);
		}

		if (!hash_file(fhash, path)) {
			goto failure;
		}
		hash_delimiter(cpp_hash, using_pch_sum ? ""pch_sum_hash"" : ""pch_hash"");
		char *pch_hash_result = hash_result(fhash);
		hash_string(cpp_hash, pch_hash_result);
		free(pch_hash_result);
	}

	if (conf->direct_mode) {
		if (!is_pch) { // else: the file has already been hashed.
			char *source = NULL;
			size_t size;
			if (st.st_size > 0) {
				if (!read_file(path, st.st_size, &source, &size)) {
					goto failure;
				}
			} else {
				source = x_strdup("""");
				size = 0;
			}

			int result = hash_source_code_string(conf, fhash, source, size, path);
			free(source);
			if (result & HASH_SOURCE_CODE_ERROR
			    || result & HASH_SOURCE_CODE_FOUND_TIME) {
				goto failure;
			}
		}

		struct file_hash *h = x_malloc(sizeof(*h));
		hash_result_as_bytes(fhash, h->hash);
		h->size = hash_input_size(fhash);
		hashtable_insert(included_files, path, h);
		path = NULL; // Ownership transferred to included_files.

		if (depend_mode_hash) {
			hash_delimiter(depend_mode_hash, ""include"");
			hash_buffer(depend_mode_hash, h->hash, sizeof(h->hash));
		}
	}

	goto out;

failure:
	if (conf->direct_mode) {
		cc_log(""Disabling direct mode"");
		conf->direct_mode = false;
	}
	// Fall through.
out:
	hash_free(fhash);
	free(path);
}

static void
print_included_files(FILE *fp)
{
	struct hashtable_itr *iter = hashtable_iterator(included_files);
	do {
		char *path = hashtable_iterator_key(iter);
		fprintf(fp, ""%s\n"", path);
	} while (hashtable_iterator_advance(iter));
}

// Make a relative path from current working directory to path if path is under
// the base directory. Takes over ownership of path. Caller frees.
static char *
make_relative_path(char *path)
{
	if (str_eq(conf->base_dir, """") || !str_startswith(path, conf->base_dir)) {
		return path;
	}

#ifdef _WIN32
	if (path[0] == '/') {
		path++;  // Skip leading slash.
	}
#endif

	// x_realpath only works for existing paths, so if path doesn't exist, try
	// dirname(path) and assemble the path afterwards. We only bother to try
	// canonicalizing one of these two paths since a compiler path argument
	// typically only makes sense if path or dirname(path) exists.
	char *path_suffix = NULL;
	struct stat st;
	if (stat(path, &st) != 0) {
		// path doesn't exist.
		char *dir = dirname(path);
		// find the nearest existing directory in path
		while (stat(dir, &st) != 0) {
			char *parent_dir = dirname(dir);
			free(dir);
			dir = parent_dir;
		}

		// suffix is the remaining of the path, skip the first delimiter
		size_t dir_len = strlen(dir);
		if (path[dir_len] == '/' || path[dir_len] == '\\') {
			dir_len++;
		}
		path_suffix = x_strdup(&path[dir_len]);
		char *p = path;
		path = dir;
		free(p);
	}

	char *canon_path = x_realpath(path);
	if (canon_path) {
		free(path);
		char *relpath = get_relative_path(get_current_working_dir(), canon_path);
		free(canon_path);
		if (path_suffix) {
			path = format(""%s/%s"", relpath, path_suffix);
			free(relpath);
			free(path_suffix);
			return path;
		} else {
			return relpath;
		}
	} else {
		// path doesn't exist, so leave it as it is.
		free(path_suffix);
		return path;
	}
}

static void
init_included_files_table(void)
{
	// (This function may be called multiple times if several -arch options are
	// used.)
	if (!included_files) {
		included_files = create_hashtable(1000, hash_from_string, strings_equal);
	}
}

// This function reads and hashes a file. While doing this, it also does these
// things:
//
// - Makes include file paths for which the base directory is a prefix relative
//   when computing the hash sum.
// - Stores the paths and hashes of included files in the global variable
//   included_files.
static bool
process_preprocessed_file(struct hash *hash, const char *path, bool pump)
{
	char *data;
	size_t size;
	if (!read_file(path, 0, &data, &size)) {
		return false;
	}

	ignore_headers = NULL;
	ignore_headers_len = 0;
	if (!str_eq(conf->ignore_headers_in_manifest, """")) {
		char *header, *p, *q, *saveptr = NULL;
		p = x_strdup(conf->ignore_headers_in_manifest);
		q = p;
		while ((header = strtok_r(q, PATH_DELIM, &saveptr))) {
			ignore_headers = x_realloc(ignore_headers,
			                           (ignore_headers_len+1) * sizeof(char *));
			ignore_headers[ignore_headers_len++] = x_strdup(header);
			q = NULL;
		}
		free(p);
	}

	init_included_files_table();

	char *cwd = gnu_getcwd();

	// Bytes between p and q are pending to be hashed.
	char *p = data;
	char *q = data;
	char *end = data + size;

	// There must be at least 7 characters (# 1 ""x"") left to potentially find an
	// include file path.
	while (q < end - 7) {
		// Check if we look at a line containing the file name of an included file.
		// At least the following formats exist (where N is a positive integer):
		//
		// GCC:
		//
		//   # N ""file""
		//   # N ""file"" N
		//   #pragma GCC pch_preprocess ""file""
		//
		// HP's compiler:
		//
		//   #line N ""file""
		//
		// AIX's compiler:
		//
		//   #line N ""file""
		//   #line N
		//
		// Note that there may be other lines starting with '#' left after
		// preprocessing as well, for instance ""#    pragma"".
		if (q[0] == '#'
		    // GCC:
		    && ((q[1] == ' ' && q[2] >= '0' && q[2] <= '9')
		        // GCC precompiled header:
		        || (q[1] == 'p'
		            && str_startswith(&q[2], ""ragma GCC pch_preprocess ""))
		        // HP/AIX:
		        || (q[1] == 'l' && q[2] == 'i' && q[3] == 'n' && q[4] == 'e'
		            && q[5] == ' '))
		    && (q == data || q[-1] == '\n')) {
			// Workarounds for preprocessor linemarker bugs in GCC version 6.
			if (q[2] == '3') {
				if (str_startswith(q, ""# 31 \""<command-line>\""\n"")) {
					// Bogus extra line with #31, after the regular #1: Ignore the whole
					// line, and continue parsing.
					hash_string_buffer(hash, p, q - p);
					while (q < end && *q != '\n') {
						q++;
					}
					q++;
					p = q;
					continue;
				} else if (str_startswith(q, ""# 32 \""<command-line>\"" 2\n"")) {
					// Bogus wrong line with #32, instead of regular #1: Replace the line
					// number with the usual one.
					hash_string_buffer(hash, p, q - p);
					q += 1;
					q[0] = '#';
					q[1] = ' ';
					q[2] = '1';
					p = q;
				}
			}

			while (q < end && *q != '""' && *q != '\n') {
				q++;
			}
			if (q < end && *q == '\n') {
				// A newline before the quotation mark -> no match.
				continue;
			}
			q++;
			if (q >= end) {
				cc_log(""Failed to parse included file path"");
				free(data);
				free(cwd);
				return false;
			}
			// q points to the beginning of an include file path
			hash_string_buffer(hash, p, q - p);
			p = q;
			while (q < end && *q != '""') {
				q++;
			}
			// Look for preprocessor flags, after the ""filename"".
			bool system = false;
			char *r = q + 1;
			while (r < end && *r != '\n') {
				if (*r == '3') { // System header.
					system = true;
				}
				r++;
			}
			// p and q span the include file path.
			char *inc_path = x_strndup(p, q - p);
			if (!has_absolute_include_headers) {
				has_absolute_include_headers = is_absolute_path(inc_path);
			}
			inc_path = make_relative_path(inc_path);

			bool should_hash_inc_path = true;
			if (!conf->hash_dir) {
				if (str_startswith(inc_path, cwd) && str_endswith(inc_path, ""//"")) {
					// When compiling with -g or similar, GCC adds the absolute path to
					// CWD like this:
					//
					//   # 1 ""CWD//""
					//
					// If the user has opted out of including the CWD in the hash, don't
					// hash it. See also how debug_prefix_map is handled.
					should_hash_inc_path = false;
				}
			}
			if (should_hash_inc_path) {
				hash_string_buffer(hash, inc_path, strlen(inc_path));
			}

			remember_include_file(inc_path, hash, system, NULL);
			p = q; // Everything of interest between p and q has been hashed now.
		} else if (q[0] == '.' && q[1] == 'i' && q[2] == 'n' && q[3] == 'c'
		           && q[4] == 'b' && q[5] == 'i' && q[6] == 'n') {
			// An assembler .inc bin (without the space) statement, which could be
			// part of inline assembly, refers to an external file. If the file
			// changes, the hash should change as well, but finding out what file to
			// hash is too hard for ccache, so just bail out.
			cc_log(""Found unsupported .inc"" ""bin directive in source code"");
			stats_update(STATS_UNSUPPORTED_DIRECTIVE);
			failed();
		} else if (pump && strncmp(q, ""_________"", 9) == 0) {
			// Unfortunately the distcc-pump wrapper outputs standard output lines:
			// __________Using distcc-pump from /usr/bin
			// __________Using # distcc servers in pump mode
			// __________Shutting down distcc-pump include server
			while (q < end && *q != '\n') {
				q++;
			}
			if (*q == '\n') {
				q++;
			}
			p = q;
			continue;
		} else {
			q++;
		}
	}

	hash_string_buffer(hash, p, (end - p));
	free(data);
	free(cwd);

	// Explicitly check the .gch/.pch/.pth file, Clang does not include any
	// mention of it in the preprocessed output.
	if (included_pch_file) {
		char *pch_path = x_strdup(included_pch_file);
		pch_path = make_relative_path(pch_path);
		hash_string(hash, pch_path);
		remember_include_file(pch_path, hash, false, NULL);
	}

	bool debug_included = getenv(""CCACHE_DEBUG_INCLUDED"");
	if (debug_included) {
		print_included_files(stdout);
	}

	return true;
}

// Replace absolute paths with relative paths in the provided dependency file.
static void
use_relative_paths_in_depfile(const char *depfile)
{
	if (str_eq(conf->base_dir, """")) {
		cc_log(""Base dir not set, skip using relative paths"");
		return; // nothing to do
	}
	if (!has_absolute_include_headers) {
		cc_log(""No absolute path for included files found, skip using relative""
		       "" paths"");
		return; // nothing to do
	}

	FILE *f;
	f = fopen(depfile, ""r"");
	if (!f) {
		cc_log(""Cannot open dependency file: %s (%s)"", depfile, strerror(errno));
		return;
	}

	char *tmp_file = format(""%s.tmp"", depfile);
	FILE *tmpf = create_tmp_file(&tmp_file, ""w"");

	bool result = false;
	char buf[10000];
	while (fgets(buf, sizeof(buf), f) && !ferror(tmpf)) {
		char *saveptr;
		char *token = strtok_r(buf, "" \t"", &saveptr);
		while (token) {
			char *relpath;
			if (is_absolute_path(token) && str_startswith(token, conf->base_dir)) {
				relpath = make_relative_path(x_strdup(token));
				result = true;
			} else {
				relpath = token;
			}
			if (token != buf) { // This is a dependency file.
				fputc(' ', tmpf);
			}
			fputs(relpath, tmpf);
			if (relpath != token) {
				free(relpath);
			}
			token = strtok_r(NULL, "" \t"", &saveptr);
		}
	}

	if (ferror(f)) {
		cc_log(""Error reading dependency file: %s, skip relative path usage"",
		       depfile);
		result = false;
		goto out;
	}
	if (ferror(tmpf)) {
		cc_log(""Error writing temporary dependency file: %s, skip relative path""
		       "" usage"", tmp_file);
		result = false;
		goto out;
	}

out:
	fclose(tmpf);
	fclose(f);
	if (result) {
		if (x_rename(tmp_file, depfile) != 0) {
			cc_log(""Error renaming dependency file: %s -> %s (%s), skip relative""
			       "" path usage"", tmp_file, depfile, strerror(errno));
			result = false;
		} else {
			cc_log(""Renamed dependency file: %s -> %s"", tmp_file, depfile);
		}
	}
	if (!result) {
		cc_log(""Removing temporary dependency file: %s"", tmp_file);
		x_unlink(tmp_file);
	}
	free(tmp_file);
}

// Extract the used includes from the dependency file. Note that we cannot
// distinguish system headers from other includes here.
static struct file_hash *
object_hash_from_depfile(const char *depfile, struct hash *hash)
{
	FILE *f = fopen(depfile, ""r"");
	if (!f) {
		cc_log(""Cannot open dependency file %s: %s"", depfile, strerror(errno));
		return NULL;
	}

	init_included_files_table();

	char buf[10000];
	while (fgets(buf, sizeof(buf), f) && !ferror(f)) {
		char *saveptr;
		char *token;
		for (token = strtok_r(buf, "" \t\n"", &saveptr);
		     token;
		     token = strtok_r(NULL, "" \t\n"", &saveptr)) {
			if (str_endswith(token, "":"") || str_eq(token, ""\\"")) {
				continue;
			}
			if (!has_absolute_include_headers) {
				has_absolute_include_headers = is_absolute_path(token);
			}
			char *path = make_relative_path(x_strdup(token));
			remember_include_file(path, hash, false, hash);
		}
	}

	fclose(f);

	bool debug_included = getenv(""CCACHE_DEBUG_INCLUDED"");
	if (debug_included) {
		print_included_files(stdout);
	}

	struct file_hash *result = x_malloc(sizeof(*result));
	hash_result_as_bytes(hash, result->hash);
	result->size = hash_input_size(hash);
	return result;
}

// Helper method for copy_file_to_cache and move_file_to_cache_same_fs.
static void
do_copy_or_move_file_to_cache(const char *source, const char *dest, bool copy)
{
	assert(!conf->read_only);
	assert(!conf->read_only_direct);

	struct stat orig_dest_st;
	bool orig_dest_existed = stat(dest, &orig_dest_st) == 0;
	int compression_level = conf->compression ? conf->compression_level : 0;
	bool do_move = !copy && !conf->compression;
	bool do_link = copy && conf->hard_link && !conf->compression;

	if (do_move) {
		move_uncompressed_file(source, dest, compression_level);
	} else {
		if (do_link) {
			x_unlink(dest);
			int ret = link(source, dest);
			if (ret != 0) {
				cc_log(""Failed to link %s to %s: %s"", source, dest, strerror(errno));
				cc_log(""Falling back to copying"");
				do_link = false;
			}
		}
		if (!do_link) {
			int ret = copy_file(source, dest, compression_level);
			if (ret != 0) {
				cc_log(""Failed to copy %s to %s: %s"", source, dest, strerror(errno));
				stats_update(STATS_ERROR);
				failed();
			}
		}
	}

	if (!copy && conf->compression) {
		// We fell back to copying since dest should be compressed, so clean up.
		x_unlink(source);
	}

	cc_log(""Stored in cache: %s -> %s (%s)"",
	       source,
	       dest,
	       do_move ? ""moved"" : (do_link ? ""linked"" : ""copied""));

	struct stat st;
	if (x_stat(dest, &st) != 0) {
		stats_update(STATS_ERROR);
		failed();
	}
	stats_update_size(
		file_size(&st) - (orig_dest_existed ? file_size(&orig_dest_st) : 0),
		orig_dest_existed ? 0 : 1);
}

// Copy a file into the cache.
//
// dest must be a path in the cache (see get_path_in_cache). source does not
// have to be on the same file system as dest.
//
// An attempt will be made to hard link source to dest if conf->hard_link is
// true and conf->compression is false, otherwise copy. dest will be compressed
// if conf->compression is true.
static void
copy_file_to_cache(const char *source, const char *dest)
{
	do_copy_or_move_file_to_cache(source, dest, true);
}

// Move a file into the cache.
//
// dest must be a path in the cache (see get_path_in_cache). source must be on
// the same file system as dest. dest will be compressed if conf->compression
// is true.
static void
move_file_to_cache_same_fs(const char *source, const char *dest)
{
	do_copy_or_move_file_to_cache(source, dest, false);
}

// Copy or link a file from the cache.
static void
get_file_from_cache(const char *source, const char *dest)
{
	int ret;
	bool do_link = conf->hard_link && !file_is_compressed(source);
	if (do_link) {
		x_unlink(dest);
		ret = link(source, dest);
	} else {
		ret = copy_file(source, dest, 0);
	}

	if (ret == -1) {
		if (errno == ENOENT || errno == ESTALE) {
			cc_log(""File missing in cache: %s"", source);
			stats_update(STATS_MISSING);
		} else {
			cc_log(""Failed to %s %s to %s: %s"",
			       do_link ? ""link"" : ""copy"",
			       source,
			       dest,
			       strerror(errno));
			stats_update(STATS_ERROR);
		}

		// If there was trouble getting a file from the cached result, wipe the
		// whole cached result for consistency.
		x_unlink(cached_stderr);
		x_unlink(cached_obj);
		x_unlink(cached_dep);
		x_unlink(cached_cov);
		x_unlink(cached_su);
		x_unlink(cached_dia);
		x_unlink(cached_dwo);

		failed();
	}

	cc_log(""Created from cache: %s -> %s"", source, dest);
}

// Send cached stderr, if any, to stderr.
static void
send_cached_stderr(void)
{
	int fd_stderr = open(cached_stderr, O_RDONLY | O_BINARY);
	if (fd_stderr != -1) {
		copy_fd(fd_stderr, 2);
		close(fd_stderr);
	}
}

// Create or update the manifest file.
static void
update_manifest_file(void)
{
	if (!conf->direct_mode
	    || !included_files
	    || conf->read_only
	    || conf->read_only_direct) {
		return;
	}

	struct stat st;
	size_t old_size = 0; // in bytes
	if (stat(manifest_path, &st) == 0) {
		old_size = file_size(&st);
	}
	if (manifest_put(manifest_path, cached_obj_hash, included_files)) {
		cc_log(""Added object file hash to %s"", manifest_path);
		if (x_stat(manifest_path, &st) == 0) {
			stats_update_size(file_size(&st) - old_size, old_size == 0 ? 1 : 0);
		}
	} else {
		cc_log(""Failed to add object file hash to %s"", manifest_path);
	}
}

static void
update_cached_result_globals(struct file_hash *hash)
{
	char *object_name = format_hash_as_string(hash->hash, hash->size);
	cached_obj_hash = hash;
	cached_obj = get_path_in_cache(object_name, "".o"");
	cached_stderr = get_path_in_cache(object_name, "".stderr"");
	cached_dep = get_path_in_cache(object_name, "".d"");
	cached_cov = get_path_in_cache(object_name, "".gcno"");
	cached_su = get_path_in_cache(object_name, "".su"");
	cached_dia = get_path_in_cache(object_name, "".dia"");
	cached_dwo = get_path_in_cache(object_name, "".dwo"");

	stats_file = format(""%s/%c/stats"", conf->cache_dir, object_name[0]);
	free(object_name);
}

// Run the real compiler and put the result in cache.
static void
to_cache(struct args *args, struct hash *depend_mode_hash)
{
	args_add(args, ""-o"");
	args_add(args, output_obj);

	if (conf->hard_link) {
		x_unlink(output_obj);
	}

	if (generating_diagnostics) {
		args_add(args, ""--serialize-diagnostics"");
		args_add(args, output_dia);
	}

	// Turn off DEPENDENCIES_OUTPUT when running cc1, because otherwise it will
	// emit a line like this:
	//
	//   tmp.stdout.vexed.732.o: /home/mbp/.ccache/tmp.stdout.vexed.732.i
	x_unsetenv(""DEPENDENCIES_OUTPUT"");
	x_unsetenv(""SUNPRO_DEPENDENCIES"");

	if (conf->run_second_cpp) {
		args_add(args, input_file);
	} else {
		args_add(args, i_tmpfile);
	}

	cc_log(""Running real compiler"");
	char *tmp_stdout;
	int tmp_stdout_fd;
	char *tmp_stderr;
	int tmp_stderr_fd;
	int status;
	if (!conf->depend_mode) {
		tmp_stdout = format(""%s.tmp.stdout"", cached_obj);
		tmp_stdout_fd = create_tmp_fd(&tmp_stdout);
		tmp_stderr = format(""%s.tmp.stderr"", cached_obj);
		tmp_stderr_fd = create_tmp_fd(&tmp_stderr);

		status = execute(args->argv, tmp_stdout_fd, tmp_stderr_fd, &compiler_pid);
		args_pop(args, 3);
	} else {
		// The cached object path is not known yet, use temporary files.
		tmp_stdout = format(""%s/tmp.stdout"", temp_dir());
		tmp_stdout_fd = create_tmp_fd(&tmp_stdout);
		tmp_stderr = format(""%s/tmp.stderr"", temp_dir());
		tmp_stderr_fd = create_tmp_fd(&tmp_stderr);

		// Use the original arguments (including dependency options) in depend
		// mode.
		assert(orig_args);
		struct args *depend_mode_args = args_copy(orig_args);
		args_strip(depend_mode_args, ""--ccache-"");
		add_prefix(depend_mode_args, conf->prefix_command);

		time_of_compilation = time(NULL);
		status = execute(
			depend_mode_args->argv, tmp_stdout_fd, tmp_stderr_fd, &compiler_pid);
		args_free(depend_mode_args);
	}

	struct stat st;
	if (x_stat(tmp_stdout, &st) != 0) {
		// The stdout file was removed - cleanup in progress? Better bail out.
		stats_update(STATS_MISSING);
		tmp_unlink(tmp_stdout);
		tmp_unlink(tmp_stderr);
		failed();
	}

	// distcc-pump outputs lines like this:
	// __________Using # distcc servers in pump mode
	if (st.st_size != 0 && guessed_compiler != GUESSED_PUMP) {
		cc_log(""Compiler produced stdout"");
		stats_update(STATS_STDOUT);
		tmp_unlink(tmp_stdout);
		tmp_unlink(tmp_stderr);
		failed();
	}
	tmp_unlink(tmp_stdout);

	// Merge stderr from the preprocessor (if any) and stderr from the real
	// compiler into tmp_stderr.
	if (cpp_stderr) {
		char *tmp_stderr2 = format(""%s.2"", tmp_stderr);
		if (x_rename(tmp_stderr, tmp_stderr2)) {
			cc_log(""Failed to rename %s to %s: %s"", tmp_stderr, tmp_stderr2,
			       strerror(errno));
			failed();
		}

		int fd_cpp_stderr = open(cpp_stderr, O_RDONLY | O_BINARY);
		if (fd_cpp_stderr == -1) {
			cc_log(""Failed opening %s: %s"", cpp_stderr, strerror(errno));
			failed();
		}

		int fd_real_stderr = open(tmp_stderr2, O_RDONLY | O_BINARY);
		if (fd_real_stderr == -1) {
			cc_log(""Failed opening %s: %s"", tmp_stderr2, strerror(errno));
			failed();
		}

		int fd_result =
			open(tmp_stderr, O_WRONLY | O_CREAT | O_TRUNC | O_BINARY, 0666);
		if (fd_result == -1) {
			cc_log(""Failed opening %s: %s"", tmp_stderr, strerror(errno));
			failed();
		}

		copy_fd(fd_cpp_stderr, fd_result);
		copy_fd(fd_real_stderr, fd_result);
		close(fd_cpp_stderr);
		close(fd_real_stderr);
		close(fd_result);
		tmp_unlink(tmp_stderr2);
		free(tmp_stderr2);
	}

	if (status != 0) {
		cc_log(""Compiler gave exit status %d"", status);
		stats_update(STATS_STATUS);

		int fd = open(tmp_stderr, O_RDONLY | O_BINARY);
		if (fd != -1) {
			// We can output stderr immediately instead of rerunning the compiler.
			copy_fd(fd, 2);
			close(fd);
			tmp_unlink(tmp_stderr);

			x_exit(status);
		}

		tmp_unlink(tmp_stderr);
		failed();
	}

	if (conf->depend_mode) {
		struct file_hash *object_hash =
			object_hash_from_depfile(output_dep, depend_mode_hash);
		if (!object_hash) {
			failed();
		}
		update_cached_result_globals(object_hash);
	}

	if (generating_dependencies) {
		use_relative_paths_in_depfile(output_dep);
	}

	if (stat(output_obj, &st) != 0) {
		cc_log(""Compiler didn't produce an object file"");
		stats_update(STATS_NOOUTPUT);
		failed();
	}
	if (st.st_size == 0) {
		cc_log(""Compiler produced an empty object file"");
		stats_update(STATS_EMPTYOUTPUT);
		failed();
	}

	if (x_stat(tmp_stderr, &st) != 0) {
		stats_update(STATS_ERROR);
		failed();
	}
	if (st.st_size > 0) {
		if (!conf->depend_mode) {
			move_file_to_cache_same_fs(tmp_stderr, cached_stderr);
		} else {
			copy_file_to_cache(tmp_stderr, cached_stderr);
		}
	} else if (conf->recache) {
		// If recaching, we need to remove any previous .stderr.
		x_unlink(cached_stderr);
	}
	if (st.st_size == 0 || conf->depend_mode) {
		tmp_unlink(tmp_stderr);
	}

	copy_file_to_cache(output_obj, cached_obj);
	if (generating_dependencies) {
		copy_file_to_cache(output_dep, cached_dep);
	}
	if (generating_coverage) {
		copy_file_to_cache(output_cov, cached_cov);
	}
	if (generating_stackusage) {
		copy_file_to_cache(output_su, cached_su);
	}
	if (generating_diagnostics) {
		copy_file_to_cache(output_dia, cached_dia);
	}
	if (using_split_dwarf) {
		copy_file_to_cache(output_dwo, cached_dwo);
	}

	stats_update(STATS_TOCACHE);

	// Make sure we have a CACHEDIR.TAG in the cache part of cache_dir. This can
	// be done almost anywhere, but we might as well do it near the end as we
	// save the stat call if we exit early.
	{
		char *first_level_dir = dirname(stats_file);
		if (create_cachedirtag(first_level_dir) != 0) {
			cc_log(""Failed to create %s/CACHEDIR.TAG (%s)\n"",
			       first_level_dir, strerror(errno));
			stats_update(STATS_ERROR);
			failed();
		}
		free(first_level_dir);

		// Remove any CACHEDIR.TAG on the cache_dir level where it was located in
		// previous ccache versions.
		if (getpid() % 1000 == 0) {
			char *path = format(""%s/CACHEDIR.TAG"", conf->cache_dir);
			x_unlink(path);
			free(path);
		}
	}

	// Everything OK.
	send_cached_stderr();
	update_manifest_file();

	free(tmp_stderr);
	free(tmp_stdout);
}

// Find the object file name by running the compiler in preprocessor mode.
// Returns the hash as a heap-allocated hex string.
static struct file_hash *
get_object_name_from_cpp(struct args *args, struct hash *hash)
{
	time_of_compilation = time(NULL);

	char *path_stderr = NULL;
	char *path_stdout;
	int status;
	if (direct_i_file) {
		// We are compiling a .i or .ii file - that means we can skip the cpp stage
		// and directly form the correct i_tmpfile.
		path_stdout = input_file;
		status = 0;
	} else {
		// Run cpp on the input file to obtain the .i.

		// Limit the basename to 10 characters in order to cope with filesystem with
		// small maximum filename length limits.
		char *input_base = basename(input_file);
		char *tmp = strchr(input_base, '.');
		if (tmp) {
			*tmp = 0;
		}
		if (strlen(input_base) > 10) {
			input_base[10] = 0;
		}

		path_stdout = format(""%s/%s.stdout"", temp_dir(), input_base);
		free(input_base);
		int path_stdout_fd = create_tmp_fd(&path_stdout);
		add_pending_tmp_file(path_stdout);

		path_stderr = format(""%s/tmp.cpp_stderr"", temp_dir());
		int path_stderr_fd = create_tmp_fd(&path_stderr);
		add_pending_tmp_file(path_stderr);

		int args_added = 2;
		args_add(args, ""-E"");
		if (conf->keep_comments_cpp) {
			args_add(args, ""-C"");
			args_added = 3;
		}
		args_add(args, input_file);
		add_prefix(args, conf->prefix_command_cpp);
		cc_log(""Running preprocessor"");
		status = execute(args->argv, path_stdout_fd, path_stderr_fd, &compiler_pid);
		args_pop(args, args_added);
	}

	if (status != 0) {
		cc_log(""Preprocessor gave exit status %d"", status);
		stats_update(STATS_PREPROCESSOR);
		failed();
	}

	if (conf->unify) {
		// When we are doing the unifying tricks we need to include the input file
		// name in the hash to get the warnings right.
		hash_delimiter(hash, ""unifyfilename"");
		hash_string(hash, input_file);

		hash_delimiter(hash, ""unifycpp"");

		bool debug_unify = getenv(""CCACHE_DEBUG_UNIFY"");
		if (unify_hash(hash, path_stdout, debug_unify) != 0) {
			stats_update(STATS_ERROR);
			cc_log(""Failed to unify %s"", path_stdout);
			failed();
		}
	} else {
		hash_delimiter(hash, ""cpp"");
		if (!process_preprocessed_file(hash, path_stdout,
		                               guessed_compiler == GUESSED_PUMP)) {
			stats_update(STATS_ERROR);
			failed();
		}
	}

	hash_delimiter(hash, ""cppstderr"");
	if (!direct_i_file && !hash_file(hash, path_stderr)) {
		fatal(""Failed to open %s: %s"", path_stderr, strerror(errno));
	}

	if (direct_i_file) {
		i_tmpfile = input_file;
	} else {
		// i_tmpfile needs the proper cpp_extension for the compiler to do its
		// thing correctly
		i_tmpfile = format(""%s.%s"", path_stdout, conf->cpp_extension);
		x_rename(path_stdout, i_tmpfile);
		add_pending_tmp_file(i_tmpfile);
	}

	if (conf->run_second_cpp) {
		free(path_stderr);
	} else {
		// If we are using the CPP trick, we need to remember this stderr data and
		// output it just before the main stderr from the compiler pass.
		cpp_stderr = path_stderr;
		hash_delimiter(hash, ""runsecondcpp"");
		hash_string(hash, ""false"");
	}

	struct file_hash *result = x_malloc(sizeof(*result));
	hash_result_as_bytes(hash, result->hash);
	result->size = hash_input_size(hash);
	return result;
}

// Hash mtime or content of a file, or the output of a command, according to
// the CCACHE_COMPILERCHECK setting.
static void
hash_compiler(struct hash *hash, struct stat *st, const char *path,
              bool allow_command)
{
	if (str_eq(conf->compiler_check, ""none"")) {
		// Do nothing.
	} else if (str_eq(conf->compiler_check, ""mtime"")) {
		hash_delimiter(hash, ""cc_mtime"");
		hash_int(hash, st->st_size);
		hash_int(hash, st->st_mtime);
	} else if (str_startswith(conf->compiler_check, ""string:"")) {
		hash_delimiter(hash, ""cc_hash"");
		hash_string(hash, conf->compiler_check + strlen(""string:""));
	} else if (str_eq(conf->compiler_check, ""content"") || !allow_command) {
		hash_delimiter(hash, ""cc_content"");
		hash_file(hash, path);
	} else { // command string
		bool ok = hash_multicommand_output(
			hash, conf->compiler_check, orig_args->argv[0]);
		if (!ok) {
			fatal(""Failure running compiler check command: %s"", conf->compiler_check);
		}
	}
}

// Hash the host compiler(s) invoked by nvcc.
//
// If ccbin_st and ccbin are set, they refer to a directory or compiler set
// with -ccbin/--compiler-bindir. If they are NULL, the compilers are looked up
// in PATH instead.
static void
hash_nvcc_host_compiler(struct hash *hash, struct stat *ccbin_st,
                        const char *ccbin)
{
	// From <http://docs.nvidia.com/cuda/cuda-compiler-driver-nvcc/index.html>:
	//
	//   ""[...] Specify the directory in which the compiler executable resides.
	//   The host compiler executable name can be also specified to ensure that
	//   the correct host compiler is selected.""
	//
	// and
	//
	//   ""On all platforms, the default host compiler executable (gcc and g++ on
	//   Linux, clang and clang++ on Mac OS X, and cl.exe on Windows) found in
	//   the current execution search path will be used"".

	if (!ccbin || S_ISDIR(ccbin_st->st_mode)) {
#if defined(__APPLE__)
		const char *compilers[] = {""clang"", ""clang++""};
#elif defined(_WIN32)
		const char *compilers[] = {""cl.exe""};
#else
		const char *compilers[] = {""gcc"", ""g++""};
#endif
		for (size_t i = 0; i < ARRAY_SIZE(compilers); i++) {
			if (ccbin) {
				char *path = format(""%s/%s"", ccbin, compilers[i]);
				struct stat st;
				if (stat(path, &st) == 0) {
					hash_compiler(hash, &st, path, false);
				}
				free(path);
			} else {
				char *path = find_executable(compilers[i], MYNAME);
				if (path) {
					struct stat st;
					x_stat(path, &st);
					hash_compiler(hash, &st, ccbin, false);
					free(path);
				}
			}
		}
	} else {
		hash_compiler(hash, ccbin_st, ccbin, false);
	}
}

// Update a hash sum with information common for the direct and preprocessor
// modes.
static void
calculate_common_hash(struct args *args, struct hash *hash)
{
	hash_string(hash, HASH_PREFIX);

	// We have to hash the extension, as a .i file isn't treated the same by the
	// compiler as a .ii file.
	hash_delimiter(hash, ""ext"");
	hash_string(hash, conf->cpp_extension);

#ifdef _WIN32
	const char *ext = strrchr(args->argv[0], '.');
	char full_path_win_ext[MAX_PATH + 1] = {0};
	add_exe_ext_if_no_to_fullpath(full_path_win_ext, MAX_PATH, ext,
	                              args->argv[0]);
	const char *full_path = full_path_win_ext;
#else
	const char *full_path = args->argv[0];
#endif

	struct stat st;
	if (x_stat(full_path, &st) != 0) {
		stats_update(STATS_COMPILER);
		failed();
	}

	// Hash information about the compiler.
	hash_compiler(hash, &st, args->argv[0], true);

	// Also hash the compiler name as some compilers use hard links and behave
	// differently depending on the real name.
	hash_delimiter(hash, ""cc_name"");
	char *base = basename(args->argv[0]);
	hash_string(hash, base);
	free(base);

	if (!(conf->sloppiness & SLOPPY_LOCALE)) {
		// Hash environment variables that may affect localization of compiler
		// warning messages.
		const char *envvars[] = {
			""LANG"",
			""LC_ALL"",
			""LC_CTYPE"",
			""LC_MESSAGES"",
			NULL
		};
		for (const char **p = envvars; *p; ++p) {
			char *v = getenv(*p);
			if (v) {
				hash_delimiter(hash, *p);
				hash_string(hash, v);
			}
		}
	}

	// Possibly hash the current working directory.
	if (generating_debuginfo && conf->hash_dir) {
		char *cwd = gnu_getcwd();
		for (size_t i = 0; i < debug_prefix_maps_len; i++) {
			char *map = debug_prefix_maps[i];
			char *sep = strchr(map, '=');
			if (sep) {
				char *old = x_strndup(map, sep - map);
				char *new = x_strdup(sep + 1);
				cc_log(""Relocating debuginfo CWD %s from %s to %s"", cwd, old, new);
				if (str_startswith(cwd, old)) {
					char *dir = format(""%s%s"", new, cwd + strlen(old));
					free(cwd);
					cwd = dir;
				}
				free(old);
				free(new);
			}
		}
		if (cwd) {
			cc_log(""Hashing CWD %s"", cwd);
			hash_delimiter(hash, ""cwd"");
			hash_string(hash, cwd);
			free(cwd);
		}
	}

	if (using_split_dwarf) {
		// When using -gsplit-dwarf, object files include a link to the
		// corresponding .dwo file based on the target object filename, so we need
		// to include the target filename in the hash to avoid handing out an
		// object file with an incorrect .dwo link.
		hash_delimiter(hash, ""filename"");
		hash_string(hash, basename(output_obj));
	}

	// Possibly hash the coverage data file path.
	if (generating_coverage && profile_arcs) {
		char *dir = dirname(output_obj);
		if (profile_dir) {
			dir = x_strdup(profile_dir);
		} else {
			char *real_dir = x_realpath(dir);
			free(dir);
			dir = real_dir;
		}
		if (dir) {
			char *base_name = basename(output_obj);
			char *p = remove_extension(base_name);
			free(base_name);
			char *gcda_path = format(""%s/%s.gcda"", dir, p);
			cc_log(""Hashing coverage path %s"", gcda_path);
			free(p);
			hash_delimiter(hash, ""gcda"");
			hash_string(hash, gcda_path);
			free(dir);
		}
	}

	// Possibly hash the sanitize blacklist file path.
	for (size_t i = 0; i < sanitize_blacklists_len; i++) {
		char *sanitize_blacklist = sanitize_blacklists[i];
		cc_log(""Hashing sanitize blacklist %s"", sanitize_blacklist);
		hash_delimiter(hash, ""sanitizeblacklist"");
		if (!hash_file(hash, sanitize_blacklist)) {
			stats_update(STATS_BADEXTRAFILE);
			failed();
		}
	}

	if (!str_eq(conf->extra_files_to_hash, """")) {
		char *p = x_strdup(conf->extra_files_to_hash);
		char *q = p;
		char *path;
		char *saveptr = NULL;
		while ((path = strtok_r(q, PATH_DELIM, &saveptr))) {
			cc_log(""Hashing extra file %s"", path);
			hash_delimiter(hash, ""extrafile"");
			if (!hash_file(hash, path)) {
				stats_update(STATS_BADEXTRAFILE);
				failed();
			}
			q = NULL;
		}
		free(p);
	}

	// Possibly hash GCC_COLORS (for color diagnostics).
	if (guessed_compiler == GUESSED_GCC) {
		const char *gcc_colors = getenv(""GCC_COLORS"");
		if (gcc_colors) {
			hash_delimiter(hash, ""gcccolors"");
			hash_string(hash, gcc_colors);
		}
	}
}

// Update a hash sum with information specific to the direct and preprocessor
// modes and calculate the object hash. Returns the object hash on success,
// otherwise NULL. Caller frees.
static struct file_hash *
calculate_object_hash(struct args *args, struct hash *hash, int direct_mode)
{
	bool found_ccbin = false;

	if (direct_mode) {
		hash_delimiter(hash, ""manifest version"");
		hash_int(hash, MANIFEST_VERSION);
	}

	// clang will emit warnings for unused linker flags, so we shouldn't skip
	// those arguments.
	int is_clang =
		guessed_compiler == GUESSED_CLANG || guessed_compiler == GUESSED_UNKNOWN;

	// First the arguments.
	for (int i = 1; i < args->argc; i++) {
		// -L doesn't affect compilation (except for clang).
		if (i < args->argc-1 && str_eq(args->argv[i], ""-L"") && !is_clang) {
			i++;
			continue;
		}
		if (str_startswith(args->argv[i], ""-L"") && !is_clang) {
			continue;
		}

		// -Wl,... doesn't affect compilation (except for clang).
		if (str_startswith(args->argv[i], ""-Wl,"") && !is_clang) {
			continue;
		}

		// The -fdebug-prefix-map option may be used in combination with
		// CCACHE_BASEDIR to reuse results across different directories. Skip using
		// the value of the option from hashing but still hash the existence of the
		// option.
		if (str_startswith(args->argv[i], ""-fdebug-prefix-map="")) {
			hash_delimiter(hash, ""arg"");
			hash_string(hash, ""-fdebug-prefix-map="");
			continue;
		}
		if (str_startswith(args->argv[i], ""-ffile-prefix-map="")) {
			hash_delimiter(hash, ""arg"");
			hash_string(hash, ""-ffile-prefix-map="");
			continue;
		}
		if (str_startswith(args->argv[i], ""-fmacro-prefix-map="")) {
			hash_delimiter(hash, ""arg"");
			hash_string(hash, ""-fmacro-prefix-map="");
			continue;
		}

		// When using the preprocessor, some arguments don't contribute to the
		// hash. The theory is that these arguments will change the output of -E if
		// they are going to have any effect at all. For precompiled headers this
		// might not be the case.
		if (!direct_mode && !output_is_precompiled_header
		    && !using_precompiled_header) {
			if (compopt_affects_cpp(args->argv[i])) {
				if (compopt_takes_arg(args->argv[i])) {
					i++;
				}
				continue;
			}
			if (compopt_short(compopt_affects_cpp, args->argv[i])) {
				continue;
			}
		}

		// If we're generating dependencies, we make sure to skip the filename of
		// the dependency file, since it doesn't impact the output.
		if (generating_dependencies) {
			if (str_startswith(args->argv[i], ""-Wp,"")) {
				if (str_startswith(args->argv[i], ""-Wp,-MD,"")
				    && !strchr(args->argv[i] + 8, ',')) {
					hash_string_buffer(hash, args->argv[i], 8);
					continue;
				} else if (str_startswith(args->argv[i], ""-Wp,-MMD,"")
				           && !strchr(args->argv[i] + 9, ',')) {
					hash_string_buffer(hash, args->argv[i], 9);
					continue;
				}
			} else if (str_startswith(args->argv[i], ""-MF"")) {
				// In either case, hash the ""-MF"" part.
				hash_delimiter(hash, ""arg"");
				hash_string_buffer(hash, args->argv[i], 3);

				bool separate_argument = (strlen(args->argv[i]) == 3);
				if (separate_argument) {
					// Next argument is dependency name, so skip it.
					i++;
				}
				continue;
			}
		}

		char *p = NULL;
		if (str_startswith(args->argv[i], ""-specs="")) {
			p = args->argv[i] + 7;
		} else if (str_startswith(args->argv[i], ""--specs="")) {
			p = args->argv[i] + 8;
		}

		struct stat st;
		if (p && x_stat(p, &st) == 0) {
			// If given an explicit specs file, then hash that file, but don't
			// include the path to it in the hash.
			hash_delimiter(hash, ""specs"");
			hash_compiler(hash, &st, p, false);
			continue;
		}

		if (str_startswith(args->argv[i], ""-fplugin="")
		    && x_stat(args->argv[i] + 9, &st) == 0) {
			hash_delimiter(hash, ""plugin"");
			hash_compiler(hash, &st, args->argv[i] + 9, false);
			continue;
		}

		if (str_eq(args->argv[i], ""-Xclang"")
		    && i + 3 < args->argc
		    && str_eq(args->argv[i+1], ""-load"")
		    && str_eq(args->argv[i+2], ""-Xclang"")
		    && x_stat(args->argv[i+3], &st) == 0) {
			hash_delimiter(hash, ""plugin"");
			hash_compiler(hash, &st, args->argv[i+3], false);
			i += 3;
			continue;
		}

		if ((str_eq(args->argv[i], ""-ccbin"")
		     || str_eq(args->argv[i], ""--compiler-bindir""))
		    && i + 1 < args->argc
		    && x_stat(args->argv[i+1], &st) == 0) {
			found_ccbin = true;
			hash_delimiter(hash, ""ccbin"");
			hash_nvcc_host_compiler(hash, &st, args->argv[i+1]);
			i++;
			continue;
		}

		// All other arguments are included in the hash.
		hash_delimiter(hash, ""arg"");
		hash_string(hash, args->argv[i]);
		if (i + 1 < args->argc && compopt_takes_arg(args->argv[i])) {
			i++;
			hash_delimiter(hash, ""arg"");
			hash_string(hash, args->argv[i]);
		}
	}

	if (!found_ccbin && str_eq(actual_language, ""cuda"")) {
		hash_nvcc_host_compiler(hash, NULL, NULL);
	}

	// For profile generation (-fprofile-arcs, -fprofile-generate):
	// - hash profile directory
	//
	// For profile usage (-fprofile-use):
	// - hash profile data
	//
	// -fbranch-probabilities and -fvpt usage is covered by
	// -fprofile-generate/-fprofile-use.
	//
	// The profile directory can be specified as an argument to
	// -fprofile-generate=, -fprofile-use= or -fprofile-dir=.
	if (profile_generate) {
		if (!profile_dir) {
			profile_dir = get_cwd();
		}
		cc_log(""Adding profile directory %s to our hash"", profile_dir);
		hash_delimiter(hash, ""-fprofile-dir"");
		hash_string(hash, profile_dir);
	}

	if (profile_use) {
		// Calculate gcda name.
		if (!profile_dir) {
			profile_dir = get_cwd();
		}
		char *base_name = remove_extension(output_obj);
		char *gcda_name = format(""%s/%s.gcda"", profile_dir, base_name);
		cc_log(""Adding profile data %s to our hash"", gcda_name);
		// Add the gcda to our hash.
		hash_delimiter(hash, ""-fprofile-use"");
		hash_file(hash, gcda_name);
		free(base_name);
		free(gcda_name);
	}

	// Adding -arch to hash since cpp output is affected.
	for (size_t i = 0; i < arch_args_size; ++i) {
		hash_delimiter(hash, ""-arch"");
		hash_string(hash, arch_args[i]);
	}

	struct file_hash *object_hash = NULL;
	if (direct_mode) {
		// Hash environment variables that affect the preprocessor output.
		const char *envvars[] = {
			""CPATH"",
			""C_INCLUDE_PATH"",
			""CPLUS_INCLUDE_PATH"",
			""OBJC_INCLUDE_PATH"",
			""OBJCPLUS_INCLUDE_PATH"", // clang
			NULL
		};
		for (const char **p = envvars; *p; ++p) {
			char *v = getenv(*p);
			if (v) {
				hash_delimiter(hash, *p);
				hash_string(hash, v);
			}
		}

		if (!(conf->sloppiness & SLOPPY_FILE_MACRO)) {
			// The source code file or an include file may contain __FILE__, so make
			// sure that the hash is unique for the file name.
			hash_delimiter(hash, ""inputfile"");
			hash_string(hash, input_file);
		}

		hash_delimiter(hash, ""sourcecode"");
		int result = hash_source_code_file(conf, hash, input_file);
		if (result & HASH_SOURCE_CODE_ERROR) {
			failed();
		}
		if (result & HASH_SOURCE_CODE_FOUND_TIME) {
			cc_log(""Disabling direct mode"");
			conf->direct_mode = false;
			return NULL;
		}
		char *manifest_name = hash_result(hash);
		manifest_path = get_path_in_cache(manifest_name, "".manifest"");
		free(manifest_name);
		cc_log(""Looking for object file hash in %s"", manifest_path);
		object_hash = manifest_get(conf, manifest_path);
		if (object_hash) {
			cc_log(""Got object file hash from manifest"");
			update_mtime(manifest_path);
		} else {
			cc_log(""Did not find object file hash in manifest"");
		}
	} else {
		if (arch_args_size == 0) {
			object_hash = get_object_name_from_cpp(args, hash);
			cc_log(""Got object file hash from preprocessor"");
		} else {
			args_add(args, ""-arch"");
			for (size_t i = 0; i < arch_args_size; ++i) {
				args_add(args, arch_args[i]);
				object_hash = get_object_name_from_cpp(args, hash);
				cc_log(""Got object file hash from preprocessor with -arch %s"",
				       arch_args[i]);
				if (i != arch_args_size - 1) {
					free(object_hash);
					object_hash = NULL;
				}
				args_pop(args, 1);
			}
			args_pop(args, 1);
		}
		if (generating_dependencies) {
			cc_log(""Preprocessor created %s"", output_dep);
		}
	}

	return object_hash;
}

// Try to return the compile result from cache. If we can return from cache
// then this function exits with the correct status code, otherwise it returns.
static void
from_cache(enum fromcache_call_mode mode, bool put_object_in_manifest)
{
	// The user might be disabling cache hits.
	if (conf->recache) {
		return;
	}

	// If we're using Clang, we can't trust a precompiled header object based on
	// running the preprocessor since clang will produce a fatal error when the
	// precompiled header is used and one of the included files has an updated
	// timestamp:
	//
	//     file 'foo.h' has been modified since the precompiled header 'foo.pch'
	//     was built
	if ((guessed_compiler == GUESSED_CLANG || guessed_compiler == GUESSED_UNKNOWN)
	    && output_is_precompiled_header
	    && mode == FROMCACHE_CPP_MODE) {
		cc_log(""Not considering cached precompiled header in preprocessor mode"");
		return;
	}

	// Occasionally, e.g. on hard reset, our cache ends up as just filesystem
	// meta-data with no content. Catch an easy case of this.
	struct stat st;
	if (stat(cached_obj, &st) != 0) {
		cc_log(""Object file %s not in cache"", cached_obj);
		return;
	}
	if (st.st_size == 0) {
		cc_log(""Invalid (empty) object file %s in cache"", cached_obj);
		x_unlink(cached_obj);
		return;
	}

	// (If mode != FROMCACHE_DIRECT_MODE, the dependency file is created by gcc.)
	bool produce_dep_file =
		generating_dependencies && mode == FROMCACHE_DIRECT_MODE;

	// Get result from cache.
	if (!str_eq(output_obj, ""/dev/null"")) {
		get_file_from_cache(cached_obj, output_obj);
		if (using_split_dwarf) {
			get_file_from_cache(cached_dwo, output_dwo);
		}
	}
	if (produce_dep_file) {
		get_file_from_cache(cached_dep, output_dep);
	}
	if (generating_coverage) {
		get_file_from_cache(cached_cov, output_cov);
	}
	if (generating_stackusage) {
		get_file_from_cache(cached_su, output_su);
	}
	if (generating_diagnostics) {
		get_file_from_cache(cached_dia, output_dia);
	}

	// Update modification timestamps to save files from LRU cleanup. Also gives
	// files a sensible mtime when hard-linking.
	update_mtime(cached_obj);
	update_mtime(cached_stderr);
	if (produce_dep_file) {
		update_mtime(cached_dep);
	}
	if (generating_coverage) {
		update_mtime(cached_cov);
	}
	if (generating_stackusage) {
		update_mtime(cached_su);
	}
	if (generating_diagnostics) {
		update_mtime(cached_dia);
	}
	if (cached_dwo) {
		update_mtime(cached_dwo);
	}

	send_cached_stderr();

	if (put_object_in_manifest) {
		update_manifest_file();
	}

	// Log the cache hit.
	switch (mode) {
	case FROMCACHE_DIRECT_MODE:
		cc_log(""Succeeded getting cached result"");
		stats_update(STATS_CACHEHIT_DIR);
		break;

	case FROMCACHE_CPP_MODE:
		cc_log(""Succeeded getting cached result"");
		stats_update(STATS_CACHEHIT_CPP);
		break;
	}

	// And exit with the right status code.
	x_exit(0);
}

// Find the real compiler. We just search the PATH to find an executable of the
// same name that isn't a link to ourselves.
static void
find_compiler(char **argv)
{
	// We might be being invoked like ""ccache gcc -c foo.c"".
	char *base = basename(argv[0]);
	if (same_executable_name(base, MYNAME)) {
		args_remove_first(orig_args);
		free(base);
		if (is_full_path(orig_args->argv[0])) {
			// A full path was given.
			return;
		}
		base = basename(orig_args->argv[0]);
	}

	// Support user override of the compiler.
	if (!str_eq(conf->compiler, """")) {
		base = conf->compiler;
	}

	char *compiler = find_executable(base, MYNAME);
	if (!compiler) {
		stats_update(STATS_COMPILER);
		fatal(""Could not find compiler \""%s\"" in PATH"", base);
	}
	if (str_eq(compiler, argv[0])) {
		fatal(""Recursive invocation (the name of the ccache binary must be \""%s\"")"",
		      MYNAME);
	}
	orig_args->argv[0] = compiler;
}

bool
is_precompiled_header(const char *path)
{
	const char *ext = get_extension(path);
	char *dir = dirname(path);
	const char *dir_ext = get_extension(dir);
	bool result =
		str_eq(ext, "".gch"")
		|| str_eq(ext, "".pch"")
		|| str_eq(ext, "".pth"")
		|| str_eq(dir_ext, "".gch""); // See ""Precompiled Headers"" in GCC docs.
	free(dir);
	return result;
}

static bool
color_output_possible(void)
{
	const char *term_env = getenv(""TERM"");
	return isatty(STDERR_FILENO) && term_env && strcasecmp(term_env, ""DUMB"") != 0;
}

static bool
detect_pch(const char *option, const char *arg, bool *found_pch)
{
	struct stat st;

	// Try to be smart about detecting precompiled headers.
	char *pch_file = NULL;
	if (str_eq(option, ""-include-pch"") || str_eq(option, ""-include-pth"")) {
		if (stat(arg, &st) == 0) {
			cc_log(""Detected use of precompiled header: %s"", arg);
			pch_file = x_strdup(arg);
		}
	} else {
		char *gchpath = format(""%s.gch"", arg);
		if (stat(gchpath, &st) == 0) {
			cc_log(""Detected use of precompiled header: %s"", gchpath);
			pch_file = x_strdup(gchpath);
		} else {
			char *pchpath = format(""%s.pch"", arg);
			if (stat(pchpath, &st) == 0) {
				cc_log(""Detected use of precompiled header: %s"", pchpath);
				pch_file = x_strdup(pchpath);
			} else {
				// clang may use pretokenized headers.
				char *pthpath = format(""%s.pth"", arg);
				if (stat(pthpath, &st) == 0) {
					cc_log(""Detected use of pretokenized header: %s"", pthpath);
					pch_file = x_strdup(pthpath);
				}
				free(pthpath);
			}
			free(pchpath);
		}
		free(gchpath);
	}

	if (pch_file) {
		if (included_pch_file) {
			cc_log(""Multiple precompiled headers used: %s and %s\n"",
			       included_pch_file, pch_file);
			stats_update(STATS_ARGS);
			return false;
		}
		included_pch_file = pch_file;
		*found_pch = true;
	}
	return true;
}

// Process the compiler options into options suitable for passing to the
// preprocessor and the real compiler. The preprocessor options don't include
// -E; this is added later. Returns true on success, otherwise false.
bool
cc_process_args(struct args *args, struct args **preprocessor_args,
                struct args **compiler_args)
{
	bool found_c_opt = false;
	bool found_S_opt = false;
	bool found_pch = false;
	bool found_fpch_preprocess = false;
	const char *explicit_language = NULL; // As specified with -x.
	const char *file_language;            // As deduced from file extension.
	const char *input_charset = NULL;
	// Is the dependency makefile name overridden with -MF?
	bool dependency_filename_specified = false;
	// Is the dependency makefile target name specified with -MT or -MQ?
	bool dependency_target_specified = false;
	// Is the dependency target name implicitly specified using
	// DEPENDENCIES_OUTPUT or SUNPRO_DEPENDENCIES?
	bool dependency_implicit_target_specified = false;
	// expanded_args is a copy of the original arguments given to the compiler
	// but with arguments from @file and similar constructs expanded. It's only
	// used as a temporary data structure to loop over.
	struct args *expanded_args = args_copy(args);
	// stripped_args essentially contains all original arguments except those
	// that only should be passed to the preprocessor (if run_second_cpp is
	// false) and except dependency options (like -MD and friends).
	struct args *stripped_args = args_init(0, NULL);
	// cpp_args contains arguments that were not added to stripped_args, i.e.
	// those that should only be passed to the preprocessor if run_second_cpp is
	// false. If run_second_cpp is true, they will be passed to the compiler as
	// well.
	struct args *cpp_args = args_init(0, NULL);
	// dep_args contains dependency options like -MD. They only passed to the
	// preprocessor, never to the compiler.
	struct args *dep_args = args_init(0, NULL);

	bool found_color_diagnostics = false;

	bool found_directives_only = false;
	bool found_rewrite_includes = false;

	int argc = expanded_args->argc;
	char **argv = expanded_args->argv;
	args_add(stripped_args, argv[0]);

	bool result = true;
	for (int i = 1; i < argc; i++) {
		// The user knows best: just swallow the next arg.
		if (str_eq(argv[i], ""--ccache-skip"")) {
			i++;
			if (i == argc) {
				cc_log(""--ccache-skip lacks an argument"");
				result = false;
				goto out;
			}
			args_add(stripped_args, argv[i]);
			continue;
		}

		// Special case for -E.
		if (str_eq(argv[i], ""-E"")) {
			stats_update(STATS_PREPROCESSING);
			result = false;
			goto out;
		}

		// Handle ""@file"" argument.
		if (str_startswith(argv[i], ""@"") || str_startswith(argv[i], ""-@"")) {
			char *argpath = argv[i] + 1;

			if (argpath[-1] == '-') {
				++argpath;
			}
			struct args *file_args = args_init_from_gcc_atfile(argpath);
			if (!file_args) {
				cc_log(""Couldn't read arg file %s"", argpath);
				stats_update(STATS_ARGS);
				result = false;
				goto out;
			}

			args_insert(expanded_args, i, file_args, true);
			argc = expanded_args->argc;
			argv = expanded_args->argv;
			i--;
			continue;
		}

		// Handle cuda ""-optf"" and ""--options-file"" argument.
		if (guessed_compiler == GUESSED_NVCC
		    && (str_eq(argv[i], ""-optf"") || str_eq(argv[i], ""--options-file""))) {
			if (i == argc - 1) {
				cc_log(""Expected argument after %s"", argv[i]);
				stats_update(STATS_ARGS);
				result = false;
				goto out;
			}
			++i;

			// Argument is a comma-separated list of files.
			char *str_start = argv[i];
			char *str_end = strchr(str_start, ',');
			int index = i + 1;

			if (!str_end) {
				str_end = str_start + strlen(str_start);
			}

			while (str_end) {
				*str_end = '\0';
				struct args *file_args = args_init_from_gcc_atfile(str_start);
				if (!file_args) {
					cc_log(""Couldn't read cuda options file %s"", str_start);
					stats_update(STATS_ARGS);
					result = false;
					goto out;
				}

				int new_index = file_args->argc + index;
				args_insert(expanded_args, index, file_args, false);
				index = new_index;
				str_start = str_end;
				str_end = strchr(str_start, ',');
			}

			argc = expanded_args->argc;
			argv = expanded_args->argv;
			continue;
		}

		// These are always too hard.
		if (compopt_too_hard(argv[i]) || str_startswith(argv[i], ""-fdump-"")) {
			cc_log(""Compiler option %s is unsupported"", argv[i]);
			stats_update(STATS_UNSUPPORTED_OPTION);
			result = false;
			goto out;
		}

		// These are too hard in direct mode.
		if (conf->direct_mode && compopt_too_hard_for_direct_mode(argv[i])) {
			cc_log(""Unsupported compiler option for direct mode: %s"", argv[i]);
			conf->direct_mode = false;
		}

		// -Xarch_* options are too hard.
		if (str_startswith(argv[i], ""-Xarch_"")) {
			cc_log(""Unsupported compiler option :%s"", argv[i]);
			stats_update(STATS_UNSUPPORTED_OPTION);
			result = false;
			goto out;
		}

		// Handle -arch options.
		if (str_eq(argv[i], ""-arch"")) {
			if (arch_args_size == MAX_ARCH_ARGS - 1) {
				cc_log(""Too many -arch compiler options; ccache supports at most %d"",
				       MAX_ARCH_ARGS);
				stats_update(STATS_UNSUPPORTED_OPTION);
				result = false;
				goto out;
			}

			++i;
			arch_args[arch_args_size] = x_strdup(argv[i]); // It will leak.
			++arch_args_size;
			if (arch_args_size == 2) {
				conf->run_second_cpp = true;
			}
			continue;
		}

		if (str_eq(argv[i], ""-fpch-preprocess"")
		    || str_eq(argv[i], ""-emit-pch"")
		    || str_eq(argv[i], ""-emit-pth"")) {
			found_fpch_preprocess = true;
		}

		// We must have -c.
		if (str_eq(argv[i], ""-c"")) {
			found_c_opt = true;
			continue;
		}

		// -S changes the default extension.
		if (str_eq(argv[i], ""-S"")) {
			args_add(stripped_args, argv[i]);
			found_S_opt = true;
			continue;
		}

		// Special handling for -x: remember the last specified language before the
		// input file and strip all -x options from the arguments.
		if (str_eq(argv[i], ""-x"")) {
			if (i == argc - 1) {
				cc_log(""Missing argument to %s"", argv[i]);
				stats_update(STATS_ARGS);
				result = false;
				goto out;
			}
			if (!input_file) {
				explicit_language = argv[i+1];
			}
			i++;
			continue;
		}
		if (str_startswith(argv[i], ""-x"")) {
			if (!input_file) {
				explicit_language = &argv[i][2];
			}
			continue;
		}

		// We need to work out where the output was meant to go.
		if (str_eq(argv[i], ""-o"")) {
			if (i == argc - 1) {
				cc_log(""Missing argument to %s"", argv[i]);
				stats_update(STATS_ARGS);
				result = false;
				goto out;
			}
			output_obj = make_relative_path(x_strdup(argv[i+1]));
			i++;
			continue;
		}

		// Alternate form of -o with no space. Nvcc does not support this.
		if (str_startswith(argv[i], ""-o"") && guessed_compiler != GUESSED_NVCC) {
			output_obj = make_relative_path(x_strdup(&argv[i][2]));
			continue;
		}

		if (str_startswith(argv[i], ""-fdebug-prefix-map="")
		    || str_startswith(argv[i], ""-ffile-prefix-map="")) {
			debug_prefix_maps = x_realloc(
				debug_prefix_maps,
				(debug_prefix_maps_len + 1) * sizeof(char *));
			debug_prefix_maps[debug_prefix_maps_len++] =
				x_strdup(&argv[i][argv[i][2] == 'f' ? 18 : 19]);
			args_add(stripped_args, argv[i]);
			continue;
		}

		// Debugging is handled specially, so that we know if we can strip line
		// number info.
		if (str_startswith(argv[i], ""-g"")) {
			generating_debuginfo = true;
			args_add(stripped_args, argv[i]);
			if (str_eq(argv[i], ""-gsplit-dwarf"")) {
				using_split_dwarf = true;
			}
			if (conf->unify && !str_eq(argv[i], ""-g0"")) {
				cc_log(""%s used; disabling unify mode"", argv[i]);
				conf->unify = false;
			}
			if (str_eq(argv[i], ""-g3"")) {
				cc_log(""%s used; not compiling preprocessed code"", argv[i]);
				conf->run_second_cpp = true;
			}
			continue;
		}

		// These options require special handling, because they behave differently
		// with gcc -E, when the output file is not specified.
		if (str_eq(argv[i], ""-MD"") || str_eq(argv[i], ""-MMD"")) {
			generating_dependencies = true;
			args_add(dep_args, argv[i]);
			continue;
		}
		if (str_startswith(argv[i], ""-MF"")) {
			dependency_filename_specified = true;
			free(output_dep);

			char *arg;
			bool separate_argument = (strlen(argv[i]) == 3);
			if (separate_argument) {
				// -MF arg
				if (i == argc - 1) {
					cc_log(""Missing argument to %s"", argv[i]);
					stats_update(STATS_ARGS);
					result = false;
					goto out;
				}
				arg = argv[i + 1];
				i++;
			} else {
				// -MFarg
				arg = &argv[i][3];
			}
			output_dep = make_relative_path(x_strdup(arg));
			// Keep the format of the args the same.
			if (separate_argument) {
				args_add(dep_args, ""-MF"");
				args_add(dep_args, output_dep);
			} else {
				char *option = format(""-MF%s"", output_dep);
				args_add(dep_args, option);
				free(option);
			}
			continue;
		}
		if (str_startswith(argv[i], ""-MQ"") || str_startswith(argv[i], ""-MT"")) {
			dependency_target_specified = true;

			char *relpath;
			if (strlen(argv[i]) == 3) {
				// -MQ arg or -MT arg
				if (i == argc - 1) {
					cc_log(""Missing argument to %s"", argv[i]);
					stats_update(STATS_ARGS);
					result = false;
					goto out;
				}
				args_add(dep_args, argv[i]);
				relpath = make_relative_path(x_strdup(argv[i + 1]));
				args_add(dep_args, relpath);
				free(relpath);
				i++;
			} else {
				char *arg_opt = x_strndup(argv[i], 3);
				relpath = make_relative_path(x_strdup(argv[i] + 3));
				char *option = format(""%s%s"", arg_opt, relpath);
				args_add(dep_args, option);
				free(arg_opt);
				free(relpath);
				free(option);
			}
			continue;
		}
		if (str_eq(argv[i], ""-fprofile-arcs"")) {
			profile_arcs = true;
			args_add(stripped_args, argv[i]);
			continue;
		}
		if (str_eq(argv[i], ""-ftest-coverage"")) {
			generating_coverage = true;
			args_add(stripped_args, argv[i]);
			continue;
		}
		if (str_eq(argv[i], ""-fstack-usage"")) {
			generating_stackusage = true;
			args_add(stripped_args, argv[i]);
			continue;
		}
		if (str_eq(argv[i], ""--coverage"") // = -fprofile-arcs -ftest-coverage
		    || str_eq(argv[i], ""-coverage"")) { // Undocumented but still works.
			profile_arcs = true;
			generating_coverage = true;
			args_add(stripped_args, argv[i]);
			continue;
		}
		if (str_startswith(argv[i], ""-fprofile-dir="")) {
			profile_dir = x_strdup(argv[i] + 14);
			args_add(stripped_args, argv[i]);
			continue;
		}
		if (str_startswith(argv[i], ""-fsanitize-blacklist="")) {
			sanitize_blacklists = x_realloc(
				sanitize_blacklists,
				(sanitize_blacklists_len + 1) * sizeof(char *));
			sanitize_blacklists[sanitize_blacklists_len++] = x_strdup(argv[i] + 21);
			args_add(stripped_args, argv[i]);
			continue;
		}
		if (str_startswith(argv[i], ""--sysroot="")) {
			char *relpath = make_relative_path(x_strdup(argv[i] + 10));
			char *option = format(""--sysroot=%s"", relpath);
			args_add(stripped_args, option);
			free(relpath);
			free(option);
			continue;
		}
		// Alternate form of specifying sysroot without =
		if (str_eq(argv[i], ""--sysroot"")) {
			if (i == argc-1) {
				cc_log(""Missing argument to %s"", argv[i]);
				stats_update(STATS_ARGS);
				result = false;
				goto out;
			}
			args_add(stripped_args, argv[i]);
			char *relpath = make_relative_path(x_strdup(argv[i+1]));
			args_add(stripped_args, relpath);
			i++;
			free(relpath);
			continue;
		}
		// Alternate form of specifying target without =
		if (str_eq(argv[i], ""-target"")) {
			if (i == argc-1) {
				cc_log(""Missing argument to %s"", argv[i]);
				stats_update(STATS_ARGS);
				result = false;
				goto out;
			}
			args_add(stripped_args, argv[i]);
			args_add(stripped_args, argv[i+1]);
			i++;
			continue;
		}
		if (str_startswith(argv[i], ""-Wp,"")) {
			if (str_eq(argv[i], ""-Wp,-P"")
			    || strstr(argv[i], "",-P,"")
			    || str_endswith(argv[i], "",-P"")) {
				// -P removes preprocessor information in such a way that the object
				// file from compiling the preprocessed file will not be equal to the
				// object file produced when compiling without ccache.
				cc_log(""Too hard option -Wp,-P detected"");
				stats_update(STATS_UNSUPPORTED_OPTION);
				failed();
			} else if (str_startswith(argv[i], ""-Wp,-MD,"")
			           && !strchr(argv[i] + 8, ',')) {
				generating_dependencies = true;
				dependency_filename_specified = true;
				free(output_dep);
				output_dep = make_relative_path(x_strdup(argv[i] + 8));
				args_add(dep_args, argv[i]);
				continue;
			} else if (str_startswith(argv[i], ""-Wp,-MMD,"")
			           && !strchr(argv[i] + 9, ',')) {
				generating_dependencies = true;
				dependency_filename_specified = true;
				free(output_dep);
				output_dep = make_relative_path(x_strdup(argv[i] + 9));
				args_add(dep_args, argv[i]);
				continue;
			} else if (str_startswith(argv[i], ""-Wp,-D"")
			           && !strchr(argv[i] + 6, ',')) {
				// Treat it like -D.
				args_add(cpp_args, argv[i] + 4);
				continue;
			} else if (str_eq(argv[i], ""-Wp,-MP"")
			           || (strlen(argv[i]) > 8
			               && str_startswith(argv[i], ""-Wp,-M"")
			               && argv[i][7] == ','
			               && (argv[i][6] == 'F'
			                   || argv[i][6] == 'Q'
			                   || argv[i][6] == 'T')
			               && !strchr(argv[i] + 8, ','))) {
				// TODO: Make argument to MF/MQ/MT relative.
				args_add(dep_args, argv[i]);
				continue;
			} else if (conf->direct_mode) {
				// -Wp, can be used to pass too hard options to the preprocessor.
				// Hence, disable direct mode.
				cc_log(""Unsupported compiler option for direct mode: %s"", argv[i]);
				conf->direct_mode = false;
			}

			// Any other -Wp,* arguments are only relevant for the preprocessor.
			args_add(cpp_args, argv[i]);
			continue;
		}
		if (str_eq(argv[i], ""-MP"")) {
			args_add(dep_args, argv[i]);
			continue;
		}

		// Input charset needs to be handled specially.
		if (str_startswith(argv[i], ""-finput-charset="")) {
			input_charset = argv[i];
			continue;
		}

		if (str_eq(argv[i], ""--serialize-diagnostics"")) {
			if (i == argc - 1) {
				cc_log(""Missing argument to %s"", argv[i]);
				stats_update(STATS_ARGS);
				result = false;
				goto out;
			}
			generating_diagnostics = true;
			output_dia = make_relative_path(x_strdup(argv[i+1]));
			i++;
			continue;
		}

		if (str_startswith(argv[i], ""-fprofile-"")) {
			char *arg = x_strdup(argv[i]);
			const char *arg_profile_dir = strchr(argv[i], '=');
			if (arg_profile_dir) {
				// Convert to absolute path.
				char *dir = x_realpath(arg_profile_dir + 1);
				if (!dir) {
					// Directory doesn't exist.
					dir = x_strdup(arg_profile_dir + 1);
				}

				// We can get a better hit rate by using the real path here.
				free(arg);
				char *option = x_strndup(argv[i], arg_profile_dir - argv[i]);
				arg = format(""%s=%s"", option, dir);
				cc_log(""Rewriting %s to %s"", argv[i], arg);
				free(option);
				free(dir);
			}

			bool supported_profile_option = false;
			if (str_startswith(argv[i], ""-fprofile-generate"")
			    || str_eq(argv[i], ""-fprofile-arcs"")) {
				profile_generate = true;
				supported_profile_option = true;
			} else if (str_startswith(argv[i], ""-fprofile-use"")
			           || str_eq(argv[i], ""-fbranch-probabilities"")) {
				profile_use = true;
				supported_profile_option = true;
			} else if (str_eq(argv[i], ""-fprofile-dir"")) {
				supported_profile_option = true;
			}

			if (supported_profile_option) {
				args_add(stripped_args, arg);
				free(arg);

				// If the profile directory has already been set, give up... Hard to
				// know what the user means, and what the compiler will do.
				if (arg_profile_dir && profile_dir) {
					cc_log(""Profile directory already set; giving up"");
					result = false;
					goto out;
				} else if (arg_profile_dir) {
					cc_log(""Setting profile directory to %s"", profile_dir);
					profile_dir = x_strdup(arg_profile_dir);
				}
				continue;
			}
			cc_log(""Unknown profile option: %s"", argv[i]);
			free(arg);
		}

		if (str_eq(argv[i], ""-fcolor-diagnostics"")
		    || str_eq(argv[i], ""-fno-color-diagnostics"")
		    || str_eq(argv[i], ""-fdiagnostics-color"")
		    || str_eq(argv[i], ""-fdiagnostics-color=always"")
		    || str_eq(argv[i], ""-fno-diagnostics-color"")
		    || str_eq(argv[i], ""-fdiagnostics-color=never"")) {
			args_add(stripped_args, argv[i]);
			found_color_diagnostics = true;
			continue;
		}
		if (str_eq(argv[i], ""-fdiagnostics-color=auto"")) {
			if (color_output_possible()) {
				// Output is redirected, so color output must be forced.
				args_add(stripped_args, ""-fdiagnostics-color=always"");
				cc_log(""Automatically forcing colors"");
			} else {
				args_add(stripped_args, argv[i]);
			}
			found_color_diagnostics = true;
			continue;
		}

		// GCC
		if (str_eq(argv[i], ""-fdirectives-only"")) {
			found_directives_only = true;
			continue;
		}
		// Clang
		if (str_eq(argv[i], ""-frewrite-includes"")) {
			found_rewrite_includes = true;
			continue;
		}

		if (conf->sloppiness & SLOPPY_CLANG_INDEX_STORE
		    && str_eq(argv[i], ""-index-store-path"")) {
			// Xcode 9 or later calls Clang with this option. The given path includes
			// a UUID that might lead to cache misses, especially when cache is
			// shared among multiple users.
			i++;
			if (i <= argc - 1) {
				cc_log(""Skipping argument -index-store-path %s"", argv[i]);
			}
			continue;
		}

		// Options taking an argument that we may want to rewrite to relative paths
		// to get better hit rate. A secondary effect is that paths in the standard
		// error output produced by the compiler will be normalized.
		if (compopt_takes_path(argv[i])) {
			if (i == argc - 1) {
				cc_log(""Missing argument to %s"", argv[i]);
				stats_update(STATS_ARGS);
				result = false;
				goto out;
			}

			if (!detect_pch(argv[i], argv[i+1], &found_pch)) {
				result = false;
				goto out;
			}

			char *relpath = make_relative_path(x_strdup(argv[i+1]));
			if (compopt_affects_cpp(argv[i])) {
				args_add(cpp_args, argv[i]);
				args_add(cpp_args, relpath);
			} else {
				args_add(stripped_args, argv[i]);
				args_add(stripped_args, relpath);
			}
			free(relpath);

			i++;
			continue;
		}

		// Same as above but options with concatenated argument beginning with a
		// slash.
		if (argv[i][0] == '-') {
			char *slash_pos = strchr(argv[i], '/');
			if (slash_pos) {
				char *option = x_strndup(argv[i], slash_pos - argv[i]);
				if (compopt_takes_concat_arg(option) && compopt_takes_path(option)) {
					char *relpath = make_relative_path(x_strdup(slash_pos));
					char *new_option = format(""%s%s"", option, relpath);
					if (compopt_affects_cpp(option)) {
						args_add(cpp_args, new_option);
					} else {
						args_add(stripped_args, new_option);
					}
					free(new_option);
					free(relpath);
					free(option);
					continue;
				} else {
					free(option);
				}
			}
		}

		// Options that take an argument.
		if (compopt_takes_arg(argv[i])) {
			if (i == argc - 1) {
				cc_log(""Missing argument to %s"", argv[i]);
				stats_update(STATS_ARGS);
				result = false;
				goto out;
			}

			if (compopt_affects_cpp(argv[i])) {
				args_add(cpp_args, argv[i]);
				args_add(cpp_args, argv[i+1]);
			} else {
				args_add(stripped_args, argv[i]);
				args_add(stripped_args, argv[i+1]);
			}

			i++;
			continue;
		}

		// Other options.
		if (argv[i][0] == '-') {
			if (compopt_affects_cpp(argv[i])
			    || compopt_prefix_affects_cpp(argv[i])) {
				args_add(cpp_args, argv[i]);
			} else {
				args_add(stripped_args, argv[i]);
			}
			continue;
		}

		// If an argument isn't a plain file then assume its an option, not an
		// input file. This allows us to cope better with unusual compiler options.
		//
		// Note that ""/dev/null"" is an exception that is sometimes used as an input
		// file when code is testing compiler flags.
		struct stat st;
		if (!str_eq(argv[i], ""/dev/null"")
		    && (stat(argv[i], &st) != 0 || !S_ISREG(st.st_mode))) {
			cc_log(""%s is not a regular file, not considering as input file"",
			       argv[i]);
			args_add(stripped_args, argv[i]);
			continue;
		}

		if (input_file) {
			if (language_for_file(argv[i])) {
				cc_log(""Multiple input files: %s and %s"", input_file, argv[i]);
				stats_update(STATS_MULTIPLE);
			} else if (!found_c_opt) {
				cc_log(""Called for link with %s"", argv[i]);
				if (strstr(argv[i], ""conftest."")) {
					stats_update(STATS_CONFTEST);
				} else {
					stats_update(STATS_LINK);
				}
			} else {
				cc_log(""Unsupported source extension: %s"", argv[i]);
				stats_update(STATS_SOURCELANG);
			}
			result = false;
			goto out;
		}

		// The source code file path gets put into the notes.
		if (generating_coverage) {
			input_file = x_strdup(argv[i]);
			continue;
		}

		if (is_symlink(argv[i])) {
			// Don't rewrite source file path if it's a symlink since
			// make_relative_path resolves symlinks using realpath(3) and this leads
			// to potentially choosing incorrect relative header files. See the
			// ""symlink to source file"" test.
			input_file = x_strdup(argv[i]);
		} else {
			// Rewrite to relative to increase hit rate.
			input_file = make_relative_path(x_strdup(argv[i]));
		}
	} // for

	// See <http://gcc.gnu.org/onlinedocs/cpp/Environment-Variables.html>.
	// Contrary to what the documentation seems to imply the compiler still
	// creates object files with these defined (confirmed with GCC 8.2.1), i.e.
	// they work as -MMD/-MD, not -MM/-M. These environment variables do nothing
	// on Clang.
	char *dependencies_env = getenv(""DEPENDENCIES_OUTPUT"");
	bool using_sunpro_dependencies = false;
	if (!dependencies_env) {
		dependencies_env = getenv(""SUNPRO_DEPENDENCIES"");
		using_sunpro_dependencies = true;
	}
	if (dependencies_env) {
		generating_dependencies = true;
		dependency_filename_specified = true;
		char *saveptr = NULL;
		char *abspath_file = strtok_r(dependencies_env, "" "", &saveptr);

		free(output_dep);
		output_dep = make_relative_path(x_strdup(abspath_file));

		// Specifying target object is optional.
		char *abspath_obj = strtok_r(NULL, "" "", &saveptr);
		if (abspath_obj) {
			// It's the ""file target"" form.

			dependency_target_specified = true;
			char *relpath_obj = make_relative_path(x_strdup(abspath_obj));
			// Ensure compiler gets relative path.
			char *relpath_both = format(""%s %s"", output_dep, relpath_obj);
			if (using_sunpro_dependencies) {
				x_setenv(""SUNPRO_DEPENDENCIES"", relpath_both);
			} else {
				x_setenv(""DEPENDENCIES_OUTPUT"", relpath_both);
			}
			free(relpath_obj);
			free(relpath_both);
		} else {
			// It's the ""file"" form.

			dependency_implicit_target_specified = true;
			// Ensure compiler gets relative path.
			if (using_sunpro_dependencies) {
				x_setenv(""SUNPRO_DEPENDENCIES"", output_dep);
			} else {
				x_setenv(""DEPENDENCIES_OUTPUT"", output_dep);
			}
		}
	}

	if (found_S_opt) {
		// Even if -gsplit-dwarf is given, the .dwo file is not generated when -S
		// is also given.
		using_split_dwarf = false;
		cc_log(""Disabling caching of dwarf files since -S is used"");
	}

	if (!input_file) {
		cc_log(""No input file found"");
		stats_update(STATS_NOINPUT);
		result = false;
		goto out;
	}

	if (found_pch || found_fpch_preprocess) {
		using_precompiled_header = true;
		if (!(conf->sloppiness & SLOPPY_TIME_MACROS)) {
			cc_log(""You have to specify \""time_macros\"" sloppiness when using""
			       "" precompiled headers to get direct hits"");
			cc_log(""Disabling direct mode"");
			stats_update(STATS_CANTUSEPCH);
			result = false;
			goto out;
		}
	}

	if (explicit_language && str_eq(explicit_language, ""none"")) {
		explicit_language = NULL;
	}
	file_language = language_for_file(input_file);
	if (explicit_language) {
		if (!language_is_supported(explicit_language)) {
			cc_log(""Unsupported language: %s"", explicit_language);
			stats_update(STATS_SOURCELANG);
			result = false;
			goto out;
		}
		actual_language = x_strdup(explicit_language);
	} else {
		actual_language = file_language;
	}

	output_is_precompiled_header =
		actual_language && strstr(actual_language, ""-header"");

	if (output_is_precompiled_header
	    && !(conf->sloppiness & SLOPPY_PCH_DEFINES)) {
		cc_log(""You have to specify \""pch_defines,time_macros\"" sloppiness when""
		       "" creating precompiled headers"");
		stats_update(STATS_CANTUSEPCH);
		result = false;
		goto out;
	}

	if (!found_c_opt && !found_S_opt) {
		if (output_is_precompiled_header) {
			args_add(stripped_args, ""-c"");
		} else {
			cc_log(""No -c option found"");
			// I find that having a separate statistic for autoconf tests is useful,
			// as they are the dominant form of ""called for link"" in many cases.
			if (strstr(input_file, ""conftest."")) {
				stats_update(STATS_CONFTEST);
			} else {
				stats_update(STATS_LINK);
			}
			result = false;
			goto out;
		}
	}

	if (!actual_language) {
		cc_log(""Unsupported source extension: %s"", input_file);
		stats_update(STATS_SOURCELANG);
		result = false;
		goto out;
	}

	if (!conf->run_second_cpp && str_eq(actual_language, ""cuda"")) {
		cc_log(""Using CUDA compiler; not compiling preprocessed code"");
		conf->run_second_cpp = true;
	}

	direct_i_file = language_is_preprocessed(actual_language);

	if (output_is_precompiled_header && !conf->run_second_cpp) {
		// It doesn't work to create the .gch from preprocessed source.
		cc_log(""Creating precompiled header; not compiling preprocessed code"");
		conf->run_second_cpp = true;
	}

	if (str_eq(conf->cpp_extension, """")) {
		const char *p_language = p_language_for_language(actual_language);
		free(conf->cpp_extension);
		conf->cpp_extension = x_strdup(extension_for_language(p_language) + 1);
	}

	// Don't try to second guess the compilers heuristics for stdout handling.
	if (output_obj && str_eq(output_obj, ""-"")) {
		stats_update(STATS_OUTSTDOUT);
		cc_log(""Output file is -"");
		result = false;
		goto out;
	}

	if (!output_obj) {
		if (output_is_precompiled_header) {
			output_obj = format(""%s.gch"", input_file);
		} else {
			char extension = found_S_opt ? 's' : 'o';
			output_obj = basename(input_file);
			char *p = strrchr(output_obj, '.');
			if (!p) {
				reformat(&output_obj, ""%s.%c"", output_obj, extension);
			} else if (!p[1]) {
				reformat(&output_obj, ""%s%c"", output_obj, extension);
			} else {
				p[1] = extension;
				p[2] = 0;
			}
		}
	}

	if (using_split_dwarf) {
		char *p = strrchr(output_obj, '.');
		if (!p || !p[1]) {
			cc_log(""Badly formed object filename"");
			stats_update(STATS_ARGS);
			result = false;
			goto out;
		}

		char *base_name = remove_extension(output_obj);
		output_dwo = format(""%s.dwo"", base_name);
		free(base_name);
	}

	// Cope with -o /dev/null.
	struct stat st;
	if (!str_eq(output_obj, ""/dev/null"")
	    && stat(output_obj, &st) == 0
	    && !S_ISREG(st.st_mode)) {
		cc_log(""Not a regular file: %s"", output_obj);
		stats_update(STATS_BADOUTPUTFILE);
		result = false;
		goto out;
	}

	char *output_dir = dirname(output_obj);
	if (stat(output_dir, &st) != 0 || !S_ISDIR(st.st_mode)) {
		cc_log(""Directory does not exist: %s"", output_dir);
		stats_update(STATS_BADOUTPUTFILE);
		result = false;
		free(output_dir);
		goto out;
	}
	free(output_dir);

	// Some options shouldn't be passed to the real compiler when it compiles
	// preprocessed code:
	//
	// -finput-charset=XXX (otherwise conversion happens twice)
	// -x XXX (otherwise the wrong language is selected)
	if (input_charset) {
		args_add(cpp_args, input_charset);
	}
	if (found_pch) {
		args_add(cpp_args, ""-fpch-preprocess"");
	}
	if (explicit_language) {
		args_add(cpp_args, ""-x"");
		args_add(cpp_args, explicit_language);
	}

	// Since output is redirected, compilers will not color their output by
	// default, so force it explicitly if it would be otherwise done.
	if (!found_color_diagnostics && color_output_possible()) {
		if (guessed_compiler == GUESSED_CLANG) {
			if (!str_eq(actual_language, ""assembler"")) {
				args_add(stripped_args, ""-fcolor-diagnostics"");
				cc_log(""Automatically enabling colors"");
			}
		} else if (guessed_compiler == GUESSED_GCC) {
			// GCC has it since 4.9, but that'd require detecting what GCC version is
			// used for the actual compile. However it requires also GCC_COLORS to be
			// set (and not empty), so use that for detecting if GCC would use
			// colors.
			if (getenv(""GCC_COLORS"") && getenv(""GCC_COLORS"")[0] != '\0') {
				args_add(stripped_args, ""-fdiagnostics-color"");
				cc_log(""Automatically enabling colors"");
			}
		}
	}

	// Add flags for dependency generation only to the preprocessor command line.
	if (generating_dependencies) {
		if (!dependency_filename_specified) {
			char *base_name = remove_extension(output_obj);
			char *default_depfile_name = format(""%s.d"", base_name);
			free(base_name);
			args_add(dep_args, ""-MF"");
			args_add(dep_args, default_depfile_name);
			output_dep = make_relative_path(x_strdup(default_depfile_name));
		}

		if (!dependency_target_specified
		    && !dependency_implicit_target_specified
		    && !str_eq(get_extension(output_dep), "".o"")) {
			args_add(dep_args, ""-MQ"");
			args_add(dep_args, output_obj);
		}
	}
	if (generating_coverage) {
		char *base_name = remove_extension(output_obj);
		char *default_covfile_name = format(""%s.gcno"", base_name);
		free(base_name);
		output_cov = make_relative_path(default_covfile_name);
	}
	if (generating_stackusage) {
		char *base_name = remove_extension(output_obj);
		char *default_sufile_name = format(""%s.su"", base_name);
		free(base_name);
		output_su = make_relative_path(default_sufile_name);
	}

	*compiler_args = args_copy(stripped_args);
	if (conf->run_second_cpp) {
		args_extend(*compiler_args, cpp_args);
	} else if (found_directives_only || found_rewrite_includes) {
		// Need to pass the macros and any other preprocessor directives again.
		args_extend(*compiler_args, cpp_args);
		if (found_directives_only) {
			args_add(cpp_args, ""-fdirectives-only"");
			// The preprocessed source code still needs some more preprocessing.
			args_add(*compiler_args, ""-fpreprocessed"");
			args_add(*compiler_args, ""-fdirectives-only"");
		}
		if (found_rewrite_includes) {
			args_add(cpp_args, ""-frewrite-includes"");
			// The preprocessed source code still needs some more preprocessing.
			args_add(*compiler_args, ""-x"");
			args_add(*compiler_args, actual_language);
		}
	} else if (explicit_language) {
		// Workaround for a bug in Apple's patched distcc -- it doesn't properly
		// reset the language specified with -x, so if -x is given, we have to
		// specify the preprocessed language explicitly.
		args_add(*compiler_args, ""-x"");
		args_add(*compiler_args, p_language_for_language(explicit_language));
	}

	if (found_c_opt) {
		args_add(*compiler_args, ""-c"");
	}

	for (size_t i = 0; i < arch_args_size; ++i) {
		args_add(*compiler_args, ""-arch"");
		args_add(*compiler_args, arch_args[i]);
	}

	// Only pass dependency arguments to the preprocessor since Intel's C++
	// compiler doesn't produce a correct .d file when compiling preprocessed
	// source.
	args_extend(cpp_args, dep_args);

	*preprocessor_args = args_copy(stripped_args);
	args_extend(*preprocessor_args, cpp_args);

out:
	args_free(expanded_args);
	args_free(stripped_args);
	args_free(dep_args);
	args_free(cpp_args);
	return result;
}

static void
create_initial_config_file(const char *path)
{
	if (create_parent_dirs(path) != 0) {
		return;
	}

	unsigned max_files;
	uint64_t max_size;
	char *stats_dir = format(""%s/0"", conf->cache_dir);
	struct stat st;
	if (stat(stats_dir, &st) == 0) {
		stats_get_obsolete_limits(stats_dir, &max_files, &max_size);
		// STATS_MAXFILES and STATS_MAXSIZE was stored for each top directory.
		max_files *= 16;
		max_size *= 16;
	} else {
		max_files = 0;
		max_size = conf->max_size;
	}
	free(stats_dir);

	FILE *f = fopen(path, ""w"");
	if (!f) {
		return;
	}
	if (max_files != 0) {
		fprintf(f, ""max_files = %u\n"", max_files);
		conf->max_files = max_files;
	}
	if (max_size != 0) {
		char *size = format_parsable_size_with_suffix(max_size);
		fprintf(f, ""max_size = %s\n"", size);
		free(size);
		conf->max_size = max_size;
	}
	fclose(f);
}

// Read config file(s), populate variables, create configuration file in cache
// directory if missing, etc.
static void
initialize(void)
{
	conf_free(conf);
	conf = conf_create();

	char *errmsg;
	char *p = getenv(""CCACHE_CONFIGPATH"");
	if (p) {
		primary_config_path = x_strdup(p);
	} else {
		secondary_config_path = format(""%s/ccache.conf"", TO_STRING(SYSCONFDIR));
		if (!conf_read(conf, secondary_config_path, &errmsg)) {
			if (errno == 0) {
				// We could read the file but it contained errors.
				fatal(""%s"", errmsg);
			}
			// A missing config file in SYSCONFDIR is OK.
			free(errmsg);
		}

		if (str_eq(conf->cache_dir, """")) {
			fatal(""configuration setting \""cache_dir\"" must not be the empty string"");
		}
		if ((p = getenv(""CCACHE_DIR""))) {
			free(conf->cache_dir);
			conf->cache_dir = strdup(p);
		}
		if (str_eq(conf->cache_dir, """")) {
			fatal(""CCACHE_DIR must not be the empty string"");
		}

		primary_config_path = format(""%s/ccache.conf"", conf->cache_dir);
	}

	bool should_create_initial_config = false;
	if (!conf_read(conf, primary_config_path, &errmsg)) {
		if (errno == 0) {
			// We could read the file but it contained errors.
			fatal(""%s"", errmsg);
		}
		if (!conf->disable) {
			should_create_initial_config = true;
		}
	}

	if (!conf_update_from_environment(conf, &errmsg)) {
		fatal(""%s"", errmsg);
	}

	if (should_create_initial_config) {
		create_initial_config_file(primary_config_path);
	}

	exitfn_init();
	exitfn_add_nullary(stats_flush);
	exitfn_add_nullary(clean_up_pending_tmp_files);

	cc_log(""=== CCACHE %s STARTED ========================================="",
	       CCACHE_VERSION);

	if (conf->umask != UINT_MAX) {
		umask(conf->umask);
	}
}

// Reset the global state. Used by the test suite.
void
cc_reset(void)
{
	conf_free(conf); conf = NULL;
	free(primary_config_path); primary_config_path = NULL;
	free(secondary_config_path); secondary_config_path = NULL;
	free(current_working_dir); current_working_dir = NULL;
	for (size_t i = 0; i < debug_prefix_maps_len; i++) {
		free(debug_prefix_maps[i]);
		debug_prefix_maps[i] = NULL;
	}
	free(debug_prefix_maps); debug_prefix_maps = NULL;
	debug_prefix_maps_len = 0;
	free(profile_dir); profile_dir = NULL;
	for (size_t i = 0; i < sanitize_blacklists_len; i++) {
		free(sanitize_blacklists[i]);
		sanitize_blacklists[i] = NULL;
	}
	free(sanitize_blacklists); sanitize_blacklists = NULL;
	sanitize_blacklists_len = 0;
	free(included_pch_file); included_pch_file = NULL;
	args_free(orig_args); orig_args = NULL;
	free(input_file); input_file = NULL;
	free(output_obj); output_obj = NULL;
	free(output_dep); output_dep = NULL;
	free(output_cov); output_cov = NULL;
	free(output_su); output_su = NULL;
	free(output_dia); output_dia = NULL;
	free(output_dwo); output_dwo = NULL;
	free(cached_obj_hash); cached_obj_hash = NULL;
	free(cached_stderr); cached_stderr = NULL;
	free(cached_obj); cached_obj = NULL;
	free(cached_dep); cached_dep = NULL;
	free(cached_cov); cached_cov = NULL;
	free(cached_su); cached_su = NULL;
	free(cached_dia); cached_dia = NULL;
	free(cached_dwo); cached_dwo = NULL;
	free(manifest_path); manifest_path = NULL;
	time_of_compilation = 0;
	for (size_t i = 0; i < ignore_headers_len; i++) {
		free(ignore_headers[i]);
		ignore_headers[i] = NULL;
	}
	free(ignore_headers); ignore_headers = NULL;
	ignore_headers_len = 0;
	if (included_files) {
		hashtable_destroy(included_files, 1); included_files = NULL;
	}
	has_absolute_include_headers = false;
	generating_debuginfo = false;
	generating_dependencies = false;
	generating_coverage = false;
	generating_stackusage = false;
	profile_arcs = false;
	free(profile_dir); profile_dir = NULL;
	i_tmpfile = NULL;
	direct_i_file = false;
	free(cpp_stderr); cpp_stderr = NULL;
	free(stats_file); stats_file = NULL;
	output_is_precompiled_header = false;

	conf = conf_create();
	using_split_dwarf = false;
}

// Make a copy of stderr that will not be cached, so things like distcc can
// send networking errors to it.
static void
set_up_uncached_err(void)
{
	int uncached_fd = dup(2); // The file descriptor is intentionally leaked.
	if (uncached_fd == -1) {
		cc_log(""dup(2) failed: %s"", strerror(errno));
		failed();
	}

	// Leak a pointer to the environment.
	char *buf = format(""UNCACHED_ERR_FD=%d"", uncached_fd);
	if (putenv(buf) == -1) {
		cc_log(""putenv failed: %s"", strerror(errno));
		failed();
	}
}

static void
configuration_logger(const char *descr, const char *origin, void *context)
{
	(void)context;
	cc_bulklog(""Config: (%s) %s"", origin, descr);
}

static void ccache(int argc, char *argv[]) ATTR_NORETURN;

// The main ccache driver function.
static void
ccache(int argc, char *argv[])
{
#ifndef _WIN32
	set_up_signal_handlers();
#endif

	orig_args = args_init(argc, argv);

	initialize();
	find_compiler(argv);

	if (str_eq(conf->temporary_dir, """")) {
		clean_up_internal_tempdir();
	}

	if (!str_eq(conf->log_file, """") || conf->debug) {
		conf_print_items(conf, configuration_logger, NULL);
	}

	if (conf->disable) {
		cc_log(""ccache is disabled"");
		failed();
	}

	set_up_uncached_err();

	cc_log_argv(""Command line: "", argv);
	cc_log(""Hostname: %s"", get_hostname());
	cc_log(""Working directory: %s"", get_current_working_dir());

	conf->limit_multiple = MIN(MAX(conf->limit_multiple, 0.0), 1.0);

	guessed_compiler = guess_compiler(orig_args->argv[0]);

	// Arguments (except -E) to send to the preprocessor.
	struct args *preprocessor_args;
	// Arguments to send to the real compiler.
	struct args *compiler_args;
	if (!cc_process_args(orig_args, &preprocessor_args, &compiler_args)) {
		failed();
	}

	if (conf->depend_mode
	    && (!generating_dependencies || !conf->run_second_cpp || conf->unify)) {
		cc_log(""Disabling depend mode"");
		conf->depend_mode = false;
	}

	cc_log(""Source file: %s"", input_file);
	if (generating_dependencies) {
		cc_log(""Dependency file: %s"", output_dep);
	}
	if (generating_coverage) {
		cc_log(""Coverage file: %s"", output_cov);
	}
	if (generating_stackusage) {
		cc_log(""Stack usage file: %s"", output_su);
	}
	if (generating_diagnostics) {
		cc_log(""Diagnostics file: %s"", output_dia);
	}
	if (output_dwo) {
		cc_log(""Split dwarf file: %s"", output_dwo);
	}

	cc_log(""Object file: %s"", output_obj);

	// Need to dump log buffer as the last exit function to not lose any logs.
	exitfn_add_last(dump_debug_log_buffer_exitfn, output_obj);

	FILE *debug_text_file = NULL;
	if (conf->debug) {
		char *path = format(""%s.ccache-input-text"", output_obj);
		debug_text_file = fopen(path, ""w"");
		if (debug_text_file) {
			exitfn_add(fclose_exitfn, debug_text_file);
		}
		else {
			cc_log(""Failed to open %s: %s"", path, strerror(errno));
		}
		free(path);
	}

	struct hash *common_hash = hash_init();
	init_hash_debug(common_hash, output_obj, 'c', ""COMMON"", debug_text_file);

	calculate_common_hash(preprocessor_args, common_hash);

	// Try to find the hash using the manifest.
	struct hash *direct_hash = hash_copy(common_hash);
	init_hash_debug(
		direct_hash, output_obj, 'd', ""DIRECT MODE"", debug_text_file);

	bool put_object_in_manifest = false;
	struct file_hash *object_hash = NULL;
	struct file_hash *object_hash_from_manifest = NULL;
	if (conf->direct_mode) {
		cc_log(""Trying direct lookup"");
		object_hash = calculate_object_hash(preprocessor_args, direct_hash, 1);
		if (object_hash) {
			update_cached_result_globals(object_hash);

			// If we can return from cache at this point then do so.
			from_cache(FROMCACHE_DIRECT_MODE, 0);

			// Wasn't able to return from cache at this point. However, the object
			// was already found in manifest, so don't readd it later.
			put_object_in_manifest = false;

			object_hash_from_manifest = object_hash;
		} else {
			// Add object to manifest later.
			put_object_in_manifest = true;
		}
	}

	if (conf->read_only_direct) {
		cc_log(""Read-only direct mode; running real compiler"");
		failed();
	}

	if (!conf->depend_mode) {
		// Find the hash using the preprocessed output. Also updates
		// included_files.
		struct hash *cpp_hash = hash_copy(common_hash);
		init_hash_debug(
			cpp_hash, output_obj, 'p', ""PREPROCESSOR MODE"", debug_text_file);

		object_hash = calculate_object_hash(preprocessor_args, cpp_hash, 0);
		if (!object_hash) {
			fatal(""internal error: object hash from cpp returned NULL"");
		}
		update_cached_result_globals(object_hash);

		if (object_hash_from_manifest
		    && !file_hashes_equal(object_hash_from_manifest, object_hash)) {
			// The hash from manifest differs from the hash of the preprocessor
			// output. This could be because:
			//
			// - The preprocessor produces different output for the same input (not
			//   likely).
			// - There's a bug in ccache (maybe incorrect handling of compiler
			//   arguments).
			// - The user has used a different CCACHE_BASEDIR (most likely).
			//
			// The best thing here would probably be to remove the hash entry from
			// the manifest. For now, we use a simpler method: just remove the
			// manifest file.
			cc_log(""Hash from manifest doesn't match preprocessor output"");
			cc_log(""Likely reason: different CCACHE_BASEDIRs used"");
			cc_log(""Removing manifest as a safety measure"");
			x_unlink(manifest_path);

			put_object_in_manifest = true;
		}

		// If we can return from cache at this point then do.
		from_cache(FROMCACHE_CPP_MODE, put_object_in_manifest);
	}

	if (conf->read_only) {
		cc_log(""Read-only mode; running real compiler"");
		failed();
	}

	add_prefix(compiler_args, conf->prefix_command);

	// In depend_mode, extend the direct hash.
	struct hash *depend_mode_hash = conf->depend_mode ? direct_hash : NULL;

	// Run real compiler, sending output to cache.
	to_cache(compiler_args, depend_mode_hash);

	x_exit(0);
}

static void
configuration_printer(const char *descr, const char *origin, void *context)
{
	assert(context);
	fprintf(context, ""(%s) %s\n"", origin, descr);
}

// The main program when not doing a compile.
static int
ccache_main_options(int argc, char *argv[])
{
	enum longopts {
		DUMP_MANIFEST,
		HASH_FILE,
		PRINT_STATS,
	};
	static const struct option options[] = {
		{""cleanup"",       no_argument,       0, 'c'},
		{""clear"",         no_argument,       0, 'C'},
		{""dump-manifest"", required_argument, 0, DUMP_MANIFEST},
		{""get-config"",    required_argument, 0, 'k'},
		{""hash-file"",     required_argument, 0, HASH_FILE},
		{""help"",          no_argument,       0, 'h'},
		{""max-files"",     required_argument, 0, 'F'},
		{""max-size"",      required_argument, 0, 'M'},
		{""print-stats"",   no_argument,       0, PRINT_STATS},
		{""set-config"",    required_argument, 0, 'o'},
		{""show-config"",   no_argument,       0, 'p'},
		{""show-stats"",    no_argument,       0, 's'},
		{""version"",       no_argument,       0, 'V'},
		{""zero-stats"",    no_argument,       0, 'z'},
		{0, 0, 0, 0}
	};

	int c;
	while ((c = getopt_long(argc, argv, ""cCk:hF:M:po:sVz"", options, NULL))
	       != -1) {
		switch (c) {
		case DUMP_MANIFEST:
			manifest_dump(optarg, stdout);
			break;

		case HASH_FILE:
		{
			initialize();
			struct hash *hash = hash_init();
			if (str_eq(optarg, ""-"")) {
				hash_fd(hash, STDIN_FILENO);
			} else {
				hash_file(hash, optarg);
			}
			char *result = hash_result(hash);
			puts(result);
			free(result);
			hash_free(hash);
			break;
		}

		case PRINT_STATS:
			initialize();
			stats_print();
			break;

		case 'c': // --cleanup
			initialize();
			clean_up_all(conf);
			printf(""Cleaned cache\n"");
			break;

		case 'C': // --clear
			initialize();
			wipe_all(conf);
			printf(""Cleared cache\n"");
			break;

		case 'h': // --help
			fputs(USAGE_TEXT, stdout);
			x_exit(0);

		case 'k': // --get-config
		{
			initialize();
			char *errmsg;
			if (!conf_print_value(conf, optarg, stdout, &errmsg)) {
				fatal(""%s"", errmsg);
			}
		}
		break;

		case 'F': // --max-files
		{
			initialize();
			char *errmsg;
			if (conf_set_value_in_file(primary_config_path, ""max_files"", optarg,
			                           &errmsg)) {
				unsigned files = atoi(optarg);
				if (files == 0) {
					printf(""Unset cache file limit\n"");
				} else {
					printf(""Set cache file limit to %u\n"", files);
				}
			} else {
				fatal(""could not set cache file limit: %s"", errmsg);
			}
		}
		break;

		case 'M': // --max-size
		{
			initialize();
			uint64_t size;
			if (!parse_size_with_suffix(optarg, &size)) {
				fatal(""invalid size: %s"", optarg);
			}
			char *errmsg;
			if (conf_set_value_in_file(primary_config_path, ""max_size"", optarg,
			                           &errmsg)) {
				if (size == 0) {
					printf(""Unset cache size limit\n"");
				} else {
					char *s = format_human_readable_size(size);
					printf(""Set cache size limit to %s\n"", s);
					free(s);
				}
			} else {
				fatal(""could not set cache size limit: %s"", errmsg);
			}
		}
		break;

		case 'o': // --set-config
		{
			initialize();
			char *p = strchr(optarg, '=');
			if (!p) {
				fatal(""missing equal sign in \""%s\"""", optarg);
			}
			char *key = x_strndup(optarg, p - optarg);
			char *value = p + 1;
			char *errmsg;
			if (!conf_set_value_in_file(primary_config_path, key, value, &errmsg)) {
				fatal(""%s"", errmsg);
			}
			free(key);
		}
		break;

		case 'p': // --show-config
			initialize();
			conf_print_items(conf, configuration_printer, stdout);
			break;

		case 's': // --show-stats
			initialize();
			stats_summary();
			break;

		case 'V': // --version
			fprintf(stdout, VERSION_TEXT, CCACHE_VERSION);
			x_exit(0);

		case 'z': // --zero-stats
			initialize();
			stats_zero();
			printf(""Statistics zeroed\n"");
			break;

		default:
			fputs(USAGE_TEXT, stderr);
			x_exit(1);
		}
	}

	return 0;
}

int ccache_main(int argc, char *argv[]);

int
ccache_main(int argc, char *argv[])
{
	// Check if we are being invoked as ""ccache"".
	char *program_name = basename(argv[0]);
	if (same_executable_name(program_name, MYNAME)) {
		if (argc < 2) {
			fputs(USAGE_TEXT, stderr);
			x_exit(1);
		}
		// If the first argument isn't an option, then assume we are being passed a
		// compiler name and options.
		if (argv[1][0] == '-') {
			return ccache_main_options(argc, argv);
		}
	}
	free(program_name);

	ccache(argc, argv);
}
""",calculate_object_hash,[1922:2188]
ccache,https://github.com/ccache/ccache/commit/59cf218c727b4003c32ae68c4e9e560fa483689b,"""Improve Args::from_gcc_atfile

Scanning for the null character from the string is more efficient.""","""// Copyright (C) 2020 Joel Rosdahl and other contributors
//
// See doc/AUTHORS.adoc for a complete list of contributors.
//
// This program is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by the Free
// Software Foundation; either version 3 of the License, or (at your option)
// any later version.
//
// This program is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
// more details.
//
// You should have received a copy of the GNU General Public License along with
// this program; if not, write to the Free Software Foundation, Inc., 51
// Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA

#include ""Args.hpp""

#include ""Util.hpp""

Args::Args() : argv(m_args)
{
}

Args::Args(const Args& other) : m_args(other.m_args), argv(m_args)
{
}

Args::Args(Args&& other) noexcept
  : m_args(std::move(other.m_args)), argv(m_args)
{
}

Args
Args::from_argv(int argc, const char* const* argv)
{
  Args args;
  args.m_args.assign(argv, argv + argc);
  return args;
}

Args
Args::from_string(const std::string& command)
{
  Args args;
  for (const std::string& word : Util::split_into_strings(command, "" \t\r\n"")) {
    args.push_back(word);
  }
  return args;
}

nonstd::optional<Args>
Args::from_gcc_atfile(const std::string& filename)
{
  std::string argtext;
  try {
    argtext = Util::read_file(filename);
  } catch (Error&) {
    return nonstd::nullopt;
  }

  Args args;
  auto pos = argtext.cbegin();
  std::string argbuf;
  argbuf.resize(argtext.length() + 1);
  auto argpos = argbuf.begin();

  // Used to track quoting state; if \0 we are not inside quotes. Otherwise
  // stores the quoting character that started it for matching the end quote.
  char quoting = '\0';

  while (true) {
    switch (*pos) {
    case '\\':
      pos++;
      if (*pos == '\0') {
        continue;
      }
      break;

    case '""':
    case '\'':
      if (quoting != '\0') {
        if (quoting == *pos) {
          quoting = '\0';
          pos++;
          continue;
        } else {
          break;
        }
      } else {
        quoting = *pos;
        pos++;
        continue;
      }

    case '\n':
    case '\r':
    case '\t':
    case ' ':
      if (quoting) {
        break;
      }
      // Fall through.

    case '\0':
      // End of token
      *argpos = '\0';
      if (argbuf[0] != '\0') {
        args.push_back(argbuf.substr(0, argbuf.find_last_not_of('\0') + 1));
      }
      argpos = argbuf.begin();
      if (*pos == '\0') {
        return args;
      } else {
        pos++;
        continue;
      }
    }

    *argpos = *pos;
    pos++;
    argpos++;
  }
}

Args&
Args::operator=(const Args& other)
{
  if (&other != this) {
    m_args = other.m_args;
    argv.m_args = &m_args;
  }
  return *this;
}

Args&
Args::operator=(Args&& other) noexcept
{
  if (&other != this) {
    m_args = std::move(other.m_args);
    argv.m_args = &m_args;
  }
  return *this;
}

std::vector<const char*>
Args::to_argv() const
{
  std::vector<const char*> result;
  result.reserve(m_args.size() + 1);
  for (const auto& arg : m_args) {
    result.push_back(arg.c_str());
  }
  result.push_back(nullptr);
  return result;
}

std::string
Args::to_string() const
{
  std::string result;
  for (const auto& arg : m_args) {
    if (!result.empty()) {
      result += ' ';
    }
    result += arg;
  }
  return result;
}

void
Args::erase_with_prefix(nonstd::string_view prefix)
{
  m_args.erase(std::remove_if(m_args.begin(),
                              m_args.end(),
                              [&prefix](const std::string& s) {
                                return Util::starts_with(s, prefix);
                              }),
               m_args.end());
}

void
Args::insert(size_t index, const Args& args)
{
  if (args.size() == 0) {
    return;
  }
  m_args.insert(m_args.begin() + index, args.m_args.begin(), args.m_args.end());
}

void
Args::pop_back(size_t count)
{
  m_args.erase(m_args.end() - count, m_args.end());
}

void
Args::pop_front(size_t count)
{
  m_args.erase(m_args.begin(), m_args.begin() + count);
}

void
Args::push_back(const std::string& arg)
{
  m_args.push_back(arg);
}

void
Args::push_back(const Args& args)
{
  m_args.insert(m_args.end(), args.m_args.begin(), args.m_args.end());
}

void
Args::push_front(const std::string& arg)
{
  m_args.push_front(arg);
}

void
Args::replace(size_t index, const Args& args)
{
  if (args.size() == 1) {
    // Trivial case; replace with 1 element.
    m_args[index] = args[0];
  } else {
    m_args.erase(m_args.begin() + index);
    insert(index, args);
  }
}

Args::ArgvAccessWrapper::ArgvAccessWrapper(const std::deque<std::string>& args)
  : m_args(&args)
{
}

// clang-format off
const char*
Args::ArgvAccessWrapper::operator[](size_t i) const
// clang-format on
{
  return i == m_args->size() ? nullptr : m_args->at(i).c_str();
}

// === Wrapper functions for the legacy API: ===

void
args_add(Args& args, const std::string& arg)
{
  args.push_back(arg);
}

void
args_add_prefix(Args& args, const std::string& arg)
{
  args.push_front(arg);
}

Args
args_copy(const Args& args)
{
  return args;
}

void
args_extend(Args& args, const Args& to_append)
{
  args.push_back(to_append);
}

Args
args_init(int argc, const char* const* argv)
{
  return Args::from_argv(argc, argv);
}

nonstd::optional<Args>
args_init_from_gcc_atfile(const std::string& filename)
{
  return Args::from_gcc_atfile(filename);
}

Args
args_init_from_string(const std::string& s)
{
  return Args::from_string(s);
}

void
args_insert(Args& args, size_t index, const Args& to_insert, bool replace)
{
  if (replace) {
    args.replace(index, to_insert);
  } else {
    args.insert(index, to_insert);
  }
}

void
args_pop(Args& args, size_t count)
{
  args.pop_back(count);
}

void
args_remove_first(Args& args)
{
  args.pop_front(1);
}

void
args_set(Args& args, size_t index, const std::string& value)
{
  args[index] = value;
}

void
args_strip(Args& args, nonstd::string_view prefix)
{
  args.erase_with_prefix(prefix);
}
""","""// Copyright (C) 2020 Joel Rosdahl and other contributors
//
// See doc/AUTHORS.adoc for a complete list of contributors.
//
// This program is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by the Free
// Software Foundation; either version 3 of the License, or (at your option)
// any later version.
//
// This program is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
// more details.
//
// You should have received a copy of the GNU General Public License along with
// this program; if not, write to the Free Software Foundation, Inc., 51
// Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA

#include ""Args.hpp""

#include ""Util.hpp""

Args::Args() : argv(m_args)
{
}

Args::Args(const Args& other) : m_args(other.m_args), argv(m_args)
{
}

Args::Args(Args&& other) noexcept
  : m_args(std::move(other.m_args)), argv(m_args)
{
}

Args
Args::from_argv(int argc, const char* const* argv)
{
  Args args;
  args.m_args.assign(argv, argv + argc);
  return args;
}

Args
Args::from_string(const std::string& command)
{
  Args args;
  for (const std::string& word : Util::split_into_strings(command, "" \t\r\n"")) {
    args.push_back(word);
  }
  return args;
}

nonstd::optional<Args>
Args::from_gcc_atfile(const std::string& filename)
{
  std::string argtext;
  try {
    argtext = Util::read_file(filename);
  } catch (Error&) {
    return nonstd::nullopt;
  }

  Args args;
  auto pos = argtext.cbegin();
  std::string argbuf;
  argbuf.resize(argtext.length() + 1);
  auto argpos = argbuf.begin();

  // Used to track quoting state; if \0 we are not inside quotes. Otherwise
  // stores the quoting character that started it for matching the end quote.
  char quoting = '\0';

  while (true) {
    switch (*pos) {
    case '\\':
      pos++;
      if (*pos == '\0') {
        continue;
      }
      break;

    case '""':
    case '\'':
      if (quoting != '\0') {
        if (quoting == *pos) {
          quoting = '\0';
          pos++;
          continue;
        } else {
          break;
        }
      } else {
        quoting = *pos;
        pos++;
        continue;
      }

    case '\n':
    case '\r':
    case '\t':
    case ' ':
      if (quoting) {
        break;
      }
      // Fall through.

    case '\0':
      // End of token
      *argpos = '\0';
      if (argbuf[0] != '\0') {
        args.push_back(argbuf.substr(0, argbuf.find('\0')));
      }
      argpos = argbuf.begin();
      if (*pos == '\0') {
        return args;
      } else {
        pos++;
        continue;
      }
    }

    *argpos = *pos;
    pos++;
    argpos++;
  }
}

Args&
Args::operator=(const Args& other)
{
  if (&other != this) {
    m_args = other.m_args;
    argv.m_args = &m_args;
  }
  return *this;
}

Args&
Args::operator=(Args&& other) noexcept
{
  if (&other != this) {
    m_args = std::move(other.m_args);
    argv.m_args = &m_args;
  }
  return *this;
}

std::vector<const char*>
Args::to_argv() const
{
  std::vector<const char*> result;
  result.reserve(m_args.size() + 1);
  for (const auto& arg : m_args) {
    result.push_back(arg.c_str());
  }
  result.push_back(nullptr);
  return result;
}

std::string
Args::to_string() const
{
  std::string result;
  for (const auto& arg : m_args) {
    if (!result.empty()) {
      result += ' ';
    }
    result += arg;
  }
  return result;
}

void
Args::erase_with_prefix(nonstd::string_view prefix)
{
  m_args.erase(std::remove_if(m_args.begin(),
                              m_args.end(),
                              [&prefix](const std::string& s) {
                                return Util::starts_with(s, prefix);
                              }),
               m_args.end());
}

void
Args::insert(size_t index, const Args& args)
{
  if (args.size() == 0) {
    return;
  }
  m_args.insert(m_args.begin() + index, args.m_args.begin(), args.m_args.end());
}

void
Args::pop_back(size_t count)
{
  m_args.erase(m_args.end() - count, m_args.end());
}

void
Args::pop_front(size_t count)
{
  m_args.erase(m_args.begin(), m_args.begin() + count);
}

void
Args::push_back(const std::string& arg)
{
  m_args.push_back(arg);
}

void
Args::push_back(const Args& args)
{
  m_args.insert(m_args.end(), args.m_args.begin(), args.m_args.end());
}

void
Args::push_front(const std::string& arg)
{
  m_args.push_front(arg);
}

void
Args::replace(size_t index, const Args& args)
{
  if (args.size() == 1) {
    // Trivial case; replace with 1 element.
    m_args[index] = args[0];
  } else {
    m_args.erase(m_args.begin() + index);
    insert(index, args);
  }
}

Args::ArgvAccessWrapper::ArgvAccessWrapper(const std::deque<std::string>& args)
  : m_args(&args)
{
}

// clang-format off
const char*
Args::ArgvAccessWrapper::operator[](size_t i) const
// clang-format on
{
  return i == m_args->size() ? nullptr : m_args->at(i).c_str();
}

// === Wrapper functions for the legacy API: ===

void
args_add(Args& args, const std::string& arg)
{
  args.push_back(arg);
}

void
args_add_prefix(Args& args, const std::string& arg)
{
  args.push_front(arg);
}

Args
args_copy(const Args& args)
{
  return args;
}

void
args_extend(Args& args, const Args& to_append)
{
  args.push_back(to_append);
}

Args
args_init(int argc, const char* const* argv)
{
  return Args::from_argv(argc, argv);
}

nonstd::optional<Args>
args_init_from_gcc_atfile(const std::string& filename)
{
  return Args::from_gcc_atfile(filename);
}

Args
args_init_from_string(const std::string& s)
{
  return Args::from_string(s);
}

void
args_insert(Args& args, size_t index, const Args& to_insert, bool replace)
{
  if (replace) {
    args.replace(index, to_insert);
  } else {
    args.insert(index, to_insert);
  }
}

void
args_pop(Args& args, size_t count)
{
  args.pop_back(count);
}

void
args_remove_first(Args& args)
{
  args.pop_front(1);
}

void
args_set(Args& args, size_t index, const std::string& value)
{
  args[index] = value;
}

void
args_strip(Args& args, nonstd::string_view prefix)
{
  args.erase_with_prefix(prefix);
}
""",Args::from_gcc_atfile,[55:127]
ccache,https://github.com/ccache/ccache/commit/9875edc2e1de486d2db1131595a7a1a4fc858dce,"""Let “ccache --hash-file” perform raw hashing again

Unintended or not, #577 (213d9883) changed the behavior of “ccache
--hash-file” to use hash_binary_file, which essentially performs
hash(hash(path)) if the i-node cache is enabled, otherwise hash(path).
This means that “ccache --hash-file” behaves differently depending on if
i-node cache is enabled and also that it’s no longer usable for
benchmarking purposes.

Fix this by simply using “hash_file” again.""","""// Copyright (C) 2002-2007 Andrew Tridgell
// Copyright (C) 2009-2020 Joel Rosdahl and other contributors
//
// See doc/AUTHORS.adoc for a complete list of contributors.
//
// This program is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by the Free
// Software Foundation; either version 3 of the License, or (at your option)
// any later version.
//
// This program is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
// more details.
//
// You should have received a copy of the GNU General Public License along with
// this program; if not, write to the Free Software Foundation, Inc., 51
// Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA

#include ""ccache.hpp""

#include ""Args.hpp""
#include ""ArgsInfo.hpp""
#include ""Context.hpp""
#include ""Fd.hpp""
#include ""File.hpp""
#include ""Finalizer.hpp""
#include ""FormatNonstdStringView.hpp""
#include ""MiniTrace.hpp""
#include ""ProgressBar.hpp""
#include ""SignalHandler.hpp""
#include ""StdMakeUnique.hpp""
#include ""Util.hpp""
#include ""argprocessing.hpp""
#include ""cleanup.hpp""
#include ""compopt.hpp""
#include ""compress.hpp""
#include ""exceptions.hpp""
#include ""execute.hpp""
#include ""hash.hpp""
#include ""hashutil.hpp""
#include ""language.hpp""
#include ""logging.hpp""
#include ""manifest.hpp""
#include ""result.hpp""
#include ""stats.hpp""

#include ""third_party/fmt/core.h""
#include ""third_party/nonstd/string_view.hpp""

#ifdef HAVE_GETOPT_LONG
#  include <getopt.h>
#else
#  include ""third_party/getopt_long.h""
#endif

#include <limits>

using nonstd::nullopt;
using nonstd::optional;
using nonstd::string_view;

static const char VERSION_TEXT[] =
  R""(%s version %s

Copyright (C) 2002-2007 Andrew Tridgell
Copyright (C) 2009-2020 Joel Rosdahl and other contributors

See <https://ccache.dev/credits.html> for a complete list of contributors.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 3 of the License, or (at your option) any later
version.
)"";

static const char USAGE_TEXT[] =
  R""(Usage:
    %s [options]
    %s compiler [compiler options]
    compiler [compiler options]          (via symbolic link)

Common options:
    -c, --cleanup             delete old files and recalculate size counters
                              (normally not needed as this is done
                              automatically)
    -C, --clear               clear the cache completely (except configuration)
    -F, --max-files NUM       set maximum number of files in cache to NUM (use 0
                              for no limit)
    -M, --max-size SIZE       set maximum size of cache to SIZE (use 0 for no
                              limit); available suffixes: k, M, G, T (decimal)
                              and Ki, Mi, Gi, Ti (binary); default suffix: G
    -X, --recompress LEVEL    recompress the cache to LEVEL (integer level or
                              ""uncompressed"")
    -x, --show-compression    show compression statistics
    -p, --show-config         show current configuration options in
                              human-readable format
    -s, --show-stats          show summary of configuration and statistics
                              counters in human-readable format
    -z, --zero-stats          zero statistics counters

    -h, --help                print this help text
    -V, --version             print version and copyright information

Options for scripting or debugging:
        --dump-manifest PATH  dump manifest file at PATH in text format
    -k, --get-config KEY      print the value of configuration key KEY
        --hash-file PATH      print the hash (160 bit BLAKE3) of the file at
                              PATH
        --print-stats         print statistics counter IDs and corresponding
                              values in machine-parsable format
    -o, --set-config KEY=VAL  set configuration item KEY to value VAL

See also <https://ccache.dev>.
)"";

enum fromcache_call_mode { FROMCACHE_DIRECT_MODE, FROMCACHE_CPP_MODE };

struct pending_tmp_file
{
  char* path;
  struct pending_tmp_file* next;
};

// How often (in seconds) to scan $CCACHE_DIR/tmp for left-over temporary
// files.
static const int k_tempdir_cleanup_interval = 2 * 24 * 60 * 60; // 2 days

// This is a string that identifies the current ""version"" of the hash sum
// computed by ccache. If, for any reason, we want to force the hash sum to be
// different for the same input in a new ccache version, we can just change
// this string. A typical example would be if the format of one of the files
// stored in the cache changes in a backwards-incompatible way.
static const char HASH_PREFIX[] = ""3"";

static void
add_prefix(const Context& ctx, Args& args, const std::string& prefix_command)
{
  if (prefix_command.empty()) {
    return;
  }

  Args prefix;
  for (const auto& word : Util::split_into_strings(prefix_command, "" "")) {
    std::string path = find_executable(ctx, word.c_str(), MYNAME);
    if (path.empty()) {
      fatal(""%s: %s"", word.c_str(), strerror(errno));
    }

    prefix.push_back(path);
  }

  cc_log(""Using command-line prefix %s"", prefix_command.c_str());
  for (size_t i = prefix.size(); i != 0; i--) {
    args.push_front(prefix[i - 1]);
  }
}

// If `exit_code` is set, just exit with that code directly, otherwise execute
// the real compiler and exit with its exit code. Also updates statistics
// counter `stat` if it's not STATS_NONE.
static void failed(enum stats stat = STATS_NONE,
                   optional<int> exit_code = nullopt) ATTR_NORETURN;

static void
failed(enum stats stat, optional<int> exit_code)
{
  throw Failure(stat, exit_code);
}

static void
clean_up_internal_tempdir(const Config& config)
{
  time_t now = time(nullptr);
  auto dir_st = Stat::stat(config.cache_dir(), Stat::OnError::log);
  if (!dir_st || dir_st.mtime() + k_tempdir_cleanup_interval >= now) {
    // No cleanup needed.
    return;
  }

  update_mtime(config.cache_dir().c_str());

  const std::string& temp_dir = config.temporary_dir();
  if (!Stat::lstat(temp_dir)) {
    return;
  }

  Util::traverse(temp_dir, [now](const std::string& path, bool is_dir) {
    if (is_dir) {
      return;
    }
    auto st = Stat::lstat(path, Stat::OnError::log);
    if (st && st.mtime() + k_tempdir_cleanup_interval < now) {
      Util::unlink_tmp(path);
    }
  });
}

static void
init_hash_debug(Context& ctx,
                struct hash* hash,
                const char* obj_path,
                char type,
                const char* section_name,
                FILE* debug_text_file)
{
  if (!ctx.config.debug()) {
    return;
  }

  std::string path = fmt::format(""{}.ccache-input-{}"", obj_path, type);
  File debug_binary_file(path, ""wb"");
  if (debug_binary_file) {
    hash_enable_debug(
      hash, section_name, debug_binary_file.get(), debug_text_file);
    ctx.hash_debug_files.push_back(std::move(debug_binary_file));
  } else {
    cc_log(""Failed to open %s: %s"", path.c_str(), strerror(errno));
  }
}

static GuessedCompiler
guess_compiler(const char* path)
{
  string_view name = Util::base_name(path);
  GuessedCompiler result = GuessedCompiler::unknown;
  if (name.find(""clang"") != std::string::npos) {
    result = GuessedCompiler::clang;
  } else if (name.find(""gcc"") != std::string::npos
             || name.find(""g++"") != std::string::npos) {
    result = GuessedCompiler::gcc;
  } else if (name.find(""nvcc"") != std::string::npos) {
    result = GuessedCompiler::nvcc;
  } else if (name == ""pump"" || name == ""distcc-pump"") {
    result = GuessedCompiler::pump;
  }
  return result;
}

static bool
do_remember_include_file(Context& ctx,
                         std::string path,
                         struct hash* cpp_hash,
                         bool system,
                         struct hash* depend_mode_hash)
{
  bool is_pch = false;

  if (path.length() >= 2 && path[0] == '<' && path[path.length() - 1] == '>') {
    // Typically <built-in> or <command-line>.
    return true;
  }

  if (path == ctx.args_info.input_file) {
    // Don't remember the input file.
    return true;
  }

  if (system && (ctx.config.sloppiness() & SLOPPY_SYSTEM_HEADERS)) {
    // Don't remember this system header.
    return true;
  }

  if (ctx.included_files.find(path) != ctx.included_files.end()) {
    // Already known include file.
    return true;
  }

  // Canonicalize path for comparison; Clang uses ./header.h.
  if (Util::starts_with(path, ""./"")) {
    path.erase(0, 2);
  }

#ifdef _WIN32
  {
    // stat fails on directories on win32.
    DWORD attributes = GetFileAttributes(path.c_str());
    if (attributes != INVALID_FILE_ATTRIBUTES
        && attributes & FILE_ATTRIBUTE_DIRECTORY) {
      return true;
    }
  }
#endif

  auto st = Stat::stat(path, Stat::OnError::log);
  if (!st) {
    return false;
  }
  if (st.is_directory()) {
    // Ignore directory, typically $PWD.
    return true;
  }
  if (!st.is_regular()) {
    // Device, pipe, socket or other strange creature.
    cc_log(""Non-regular include file %s"", path.c_str());
    return false;
  }

  for (const auto& ignore_header_path : ctx.ignore_header_paths) {
    if (Util::matches_dir_prefix_or_file(ignore_header_path, path)) {
      return true;
    }
  }

  // The comparison using >= is intentional, due to a possible race between
  // starting compilation and writing the include file. See also the notes
  // under ""Performance"" in doc/MANUAL.adoc.
  if (!(ctx.config.sloppiness() & SLOPPY_INCLUDE_FILE_MTIME)
      && st.mtime() >= ctx.time_of_compilation) {
    cc_log(""Include file %s too new"", path.c_str());
    return false;
  }

  // The same >= logic as above applies to the change time of the file.
  if (!(ctx.config.sloppiness() & SLOPPY_INCLUDE_FILE_CTIME)
      && st.ctime() >= ctx.time_of_compilation) {
    cc_log(""Include file %s ctime too new"", path.c_str());
    return false;
  }

  // Let's hash the include file content.
  struct hash* fhash = hash_init();
  Finalizer fhash_finalizer([=] { hash_free(fhash); });

  is_pch = is_precompiled_header(path.c_str());
  if (is_pch) {
    if (ctx.included_pch_file.empty()) {
      cc_log(""Detected use of precompiled header: %s"", path.c_str());
    }
    bool using_pch_sum = false;
    if (ctx.config.pch_external_checksum()) {
      // hash pch.sum instead of pch when it exists
      // to prevent hashing a very large .pch file every time
      std::string pch_sum_path = fmt::format(""{}.sum"", path);
      if (Stat::stat(pch_sum_path, Stat::OnError::log)) {
        path = std::move(pch_sum_path);
        using_pch_sum = true;
        cc_log(""Using pch.sum file %s"", path.c_str());
      }
    }

    if (!hash_binary_file(ctx, fhash, path.c_str())) {
      return false;
    }
    hash_delimiter(cpp_hash, using_pch_sum ? ""pch_sum_hash"" : ""pch_hash"");
    hash_string(cpp_hash, hash_result(fhash).to_string());
  }

  if (ctx.config.direct_mode()) {
    if (!is_pch) { // else: the file has already been hashed.
      int result;
#ifdef INODE_CACHE_SUPPORTED
      if (ctx.config.inode_cache()) {
        result = hash_source_code_file(ctx, fhash, path.c_str());
      } else {
#endif
        char* source = nullptr;
        size_t size;
        if (st.size() > 0) {
          if (!read_file(path.c_str(), st.size(), &source, &size)) {
            return false;
          }
        } else {
          source = x_strdup("""");
          size = 0;
        }

        result =
          hash_source_code_string(ctx, fhash, source, size, path.c_str());
        free(source);
#ifdef INODE_CACHE_SUPPORTED
      }
#endif
      if (result & HASH_SOURCE_CODE_ERROR
          || result & HASH_SOURCE_CODE_FOUND_TIME) {
        return false;
      }
    }

    Digest d = hash_result(fhash);
    ctx.included_files.emplace(path, d);

    if (depend_mode_hash) {
      hash_delimiter(depend_mode_hash, ""include"");
      hash_string(depend_mode_hash, d.to_string());
    }
  }

  return true;
}

// This function hashes an include file and stores the path and hash in the
// global g_included_files variable. If the include file is a PCH, cpp_hash is
// also updated.
static void
remember_include_file(Context& ctx,
                      const std::string& path,
                      struct hash* cpp_hash,
                      bool system,
                      struct hash* depend_mode_hash)
{
  if (!do_remember_include_file(ctx, path, cpp_hash, system, depend_mode_hash)
      && ctx.config.direct_mode()) {
    cc_log(""Disabling direct mode"");
    ctx.config.set_direct_mode(false);
  }
}

static void
print_included_files(const Context& ctx, FILE* fp)
{
  for (const auto& item : ctx.included_files) {
    fprintf(fp, ""%s\n"", item.first.c_str());
  }
}

// This function reads and hashes a file. While doing this, it also does these
// things:
//
// - Makes include file paths for which the base directory is a prefix relative
//   when computing the hash sum.
// - Stores the paths and hashes of included files in the global variable
//   g_included_files.
static bool
process_preprocessed_file(Context& ctx,
                          struct hash* hash,
                          const char* path,
                          bool pump)
{
  char* data;
  size_t size;
  if (!read_file(path, 0, &data, &size)) {
    return false;
  }

  // Bytes between p and q are pending to be hashed.
  char* p = data;
  char* q = data;
  char* end = data + size;

  // There must be at least 7 characters (# 1 ""x"") left to potentially find an
  // include file path.
  while (q < end - 7) {
    // Check if we look at a line containing the file name of an included file.
    // At least the following formats exist (where N is a positive integer):
    //
    // GCC:
    //
    //   # N ""file""
    //   # N ""file"" N
    //   #pragma GCC pch_preprocess ""file""
    //
    // HP's compiler:
    //
    //   #line N ""file""
    //
    // AIX's compiler:
    //
    //   #line N ""file""
    //   #line N
    //
    // Note that there may be other lines starting with '#' left after
    // preprocessing as well, for instance ""#    pragma"".
    if (q[0] == '#'
        // GCC:
        && ((q[1] == ' ' && q[2] >= '0' && q[2] <= '9')
            // GCC precompiled header:
            || (q[1] == 'p'
                && str_startswith(&q[2], ""ragma GCC pch_preprocess ""))
            // HP/AIX:
            || (q[1] == 'l' && q[2] == 'i' && q[3] == 'n' && q[4] == 'e'
                && q[5] == ' '))
        && (q == data || q[-1] == '\n')) {
      // Workarounds for preprocessor linemarker bugs in GCC version 6.
      if (q[2] == '3') {
        if (str_startswith(q, ""# 31 \""<command-line>\""\n"")) {
          // Bogus extra line with #31, after the regular #1: Ignore the whole
          // line, and continue parsing.
          hash_string_buffer(hash, p, q - p);
          while (q < end && *q != '\n') {
            q++;
          }
          q++;
          p = q;
          continue;
        } else if (str_startswith(q, ""# 32 \""<command-line>\"" 2\n"")) {
          // Bogus wrong line with #32, instead of regular #1: Replace the line
          // number with the usual one.
          hash_string_buffer(hash, p, q - p);
          q += 1;
          q[0] = '#';
          q[1] = ' ';
          q[2] = '1';
          p = q;
        }
      }

      while (q < end && *q != '""' && *q != '\n') {
        q++;
      }
      if (q < end && *q == '\n') {
        // A newline before the quotation mark -> no match.
        continue;
      }
      q++;
      if (q >= end) {
        cc_log(""Failed to parse included file path"");
        free(data);
        return false;
      }
      // q points to the beginning of an include file path
      hash_string_buffer(hash, p, q - p);
      p = q;
      while (q < end && *q != '""') {
        q++;
      }
      // Look for preprocessor flags, after the ""filename"".
      bool system = false;
      char* r = q + 1;
      while (r < end && *r != '\n') {
        if (*r == '3') { // System header.
          system = true;
        }
        r++;
      }
      // p and q span the include file path.
      char* inc_path = x_strndup(p, q - p);
      if (!ctx.has_absolute_include_headers) {
        ctx.has_absolute_include_headers = Util::is_absolute_path(inc_path);
      }
      char* saved_inc_path = inc_path;
      inc_path = x_strdup(Util::make_relative_path(ctx, inc_path).c_str());
      free(saved_inc_path);

      bool should_hash_inc_path = true;
      if (!ctx.config.hash_dir()) {
        if (Util::starts_with(inc_path, ctx.apparent_cwd)
            && str_endswith(inc_path, ""//"")) {
          // When compiling with -g or similar, GCC adds the absolute path to
          // CWD like this:
          //
          //   # 1 ""CWD//""
          //
          // If the user has opted out of including the CWD in the hash, don't
          // hash it. See also how debug_prefix_map is handled.
          should_hash_inc_path = false;
        }
      }
      if (should_hash_inc_path) {
        hash_string_buffer(hash, inc_path, strlen(inc_path));
      }

      remember_include_file(ctx, inc_path, hash, system, nullptr);
      free(inc_path);
      p = q; // Everything of interest between p and q has been hashed now.
    } else if (q[0] == '.' && q[1] == 'i' && q[2] == 'n' && q[3] == 'c'
               && q[4] == 'b' && q[5] == 'i' && q[6] == 'n') {
      // An assembler .inc bin (without the space) statement, which could be
      // part of inline assembly, refers to an external file. If the file
      // changes, the hash should change as well, but finding out what file to
      // hash is too hard for ccache, so just bail out.
      cc_log(
        ""Found unsupported .inc""
        ""bin directive in source code"");
      failed(STATS_UNSUPPORTED_DIRECTIVE);
    } else if (pump && strncmp(q, ""_________"", 9) == 0) {
      // Unfortunately the distcc-pump wrapper outputs standard output lines:
      // __________Using distcc-pump from /usr/bin
      // __________Using # distcc servers in pump mode
      // __________Shutting down distcc-pump include server
      while (q < end && *q != '\n') {
        q++;
      }
      if (*q == '\n') {
        q++;
      }
      p = q;
      continue;
    } else {
      q++;
    }
  }

  hash_string_buffer(hash, p, (end - p));
  free(data);

  // Explicitly check the .gch/.pch/.pth file as Clang does not include any
  // mention of it in the preprocessed output.
  if (!ctx.included_pch_file.empty()) {
    std::string pch_path =
      Util::make_relative_path(ctx, ctx.included_pch_file.c_str());
    hash_string(hash, pch_path);
    remember_include_file(ctx, pch_path, hash, false, nullptr);
  }

  bool debug_included = getenv(""CCACHE_DEBUG_INCLUDED"");
  if (debug_included) {
    print_included_files(ctx, stdout);
  }

  return true;
}

// Replace absolute paths with relative paths in the provided dependency file.
static void
use_relative_paths_in_depfile(const Context& ctx)
{
  if (ctx.config.base_dir().empty()) {
    cc_log(""Base dir not set, skip using relative paths"");
    return; // nothing to do
  }
  if (!ctx.has_absolute_include_headers) {
    cc_log(
      ""No absolute path for included files found, skip using relative paths"");
    return; // nothing to do
  }

  const std::string& output_dep = ctx.args_info.output_dep;
  std::string file_content;
  try {
    file_content = Util::read_file(output_dep);
  } catch (const Error& e) {
    cc_log(""Cannot open dependency file %s: %s"", output_dep.c_str(), e.what());
    return;
  }

  std::string adjusted_file_content;
  adjusted_file_content.reserve(file_content.size());

  bool rewritten = false;

  for (string_view token : Util::split_into_views(file_content, "" \t\r\n"")) {
    if (Util::is_absolute_path(token)
        && token.starts_with(ctx.config.base_dir())) {
      adjusted_file_content.append(Util::make_relative_path(ctx, token));
      rewritten = true;
    } else {
      adjusted_file_content.append(token.begin(), token.end());
    }
    adjusted_file_content.push_back(' ');
  }

  if (!rewritten) {
    cc_log(
      ""No paths in dependency file %s made relative, skip relative path usage"",
      output_dep.c_str());
    return;
  }

  std::string tmp_file = fmt::format(""{}.tmp{}"", output_dep, tmp_string());

  try {
    Util::write_file(tmp_file, adjusted_file_content);
  } catch (const Error& e) {
    cc_log(
      ""Error writing temporary dependency file %s (%s), skip relative path""
      "" usage"",
      tmp_file.c_str(),
      e.what());
    Util::unlink_safe(tmp_file);
    return;
  }

  if (x_rename(tmp_file.c_str(), output_dep.c_str()) != 0) {
    cc_log(
      ""Error renaming dependency file: %s -> %s (%s), skip relative path usage"",
      tmp_file.c_str(),
      output_dep.c_str(),
      strerror(errno));
    Util::unlink_safe(tmp_file);
  } else {
    cc_log(""Renamed dependency file: %s -> %s"",
           tmp_file.c_str(),
           output_dep.c_str());
  }
}

// Extract the used includes from the dependency file. Note that we cannot
// distinguish system headers from other includes here.
static optional<Digest>
result_name_from_depfile(Context& ctx, struct hash* hash)
{
  std::string file_content;
  try {
    file_content = Util::read_file(ctx.args_info.output_dep);
  } catch (const Error& e) {
    cc_log(""Cannot open dependency file %s: %s"",
           ctx.args_info.output_dep.c_str(),
           e.what());
    return nullopt;
  }

  for (string_view token : Util::split_into_views(file_content, "" \t\r\n"")) {
    if (token == ""\\"" || token.ends_with("":"")) {
      continue;
    }
    if (!ctx.has_absolute_include_headers) {
      ctx.has_absolute_include_headers = Util::is_absolute_path(token);
    }
    std::string path = Util::make_relative_path(ctx, token);
    remember_include_file(ctx, path, hash, false, hash);
  }

  // Explicitly check the .gch/.pch/.pth file as it may not be mentioned in the
  // dependencies output.
  if (!ctx.included_pch_file.empty()) {
    std::string pch_path =
      Util::make_relative_path(ctx, ctx.included_pch_file.c_str());
    hash_string(hash, pch_path);
    remember_include_file(ctx, pch_path, hash, false, nullptr);
  }

  bool debug_included = getenv(""CCACHE_DEBUG_INCLUDED"");
  if (debug_included) {
    print_included_files(ctx, stdout);
  }

  return hash_result(hash);
}

// Execute the compiler/preprocessor, with logic to retry without requesting
// colored diagnostics messages if that fails.
static int
execute(Context& ctx,
        Args& args,
        const std::string& stdout_path,
        int stdout_fd,
        const std::string& stderr_path,
        int stderr_fd)
{
  if (ctx.diagnostics_color_failed
      && ctx.guessed_compiler == GuessedCompiler::gcc) {
    args.erase_with_prefix(""-fdiagnostics-color"");
  }
  int status =
    execute(args.to_argv().data(), stdout_fd, stderr_fd, &ctx.compiler_pid);
  if (status != 0 && !ctx.diagnostics_color_failed
      && ctx.guessed_compiler == GuessedCompiler::gcc) {
    auto errors = Util::read_file(stderr_path);
    if (errors.find(""unrecognized command-line option"") != std::string::npos
        && errors.find(""-fdiagnostics-color"") != std::string::npos) {
      // Old versions of GCC did not support colored diagnostics.
      cc_log(""-fdiagnostics-color is unsupported; trying again without it"");
      if (ftruncate(stdout_fd, 0) < 0 || lseek(stdout_fd, 0, SEEK_SET) < 0) {
        cc_log(
          ""Failed to truncate %s: %s"", stdout_path.c_str(), strerror(errno));
        failed(STATS_ERROR);
      }
      if (ftruncate(stderr_fd, 0) < 0 || lseek(stderr_fd, 0, SEEK_SET) < 0) {
        cc_log(
          ""Failed to truncate %s: %s"", stderr_path.c_str(), strerror(errno));
        failed(STATS_ERROR);
      }
      ctx.diagnostics_color_failed = true;
      return execute(ctx, args, stdout_path, stdout_fd, stderr_path, stderr_fd);
    }
  }
  return status;
}

// Send cached stderr, if any, to stderr.
static void
send_cached_stderr(const std::string& path_stderr, bool strip_colors)
{
  if (strip_colors) {
    try {
      auto stripped = Util::strip_ansi_csi_seqs(Util::read_file(path_stderr));
      write_fd(STDERR_FILENO, stripped.data(), stripped.size());
    } catch (const Error&) {
      // Fall through
    }
  } else {
    Fd fd_stderr(open(path_stderr.c_str(), O_RDONLY | O_BINARY));
    if (fd_stderr) {
      copy_fd(*fd_stderr, STDERR_FILENO);
    }
  }
}

// Create or update the manifest file.
static void
update_manifest_file(Context& ctx)
{
  if (!ctx.config.direct_mode() || ctx.config.read_only()
      || ctx.config.read_only_direct()) {
    return;
  }

  auto old_st = Stat::stat(ctx.manifest_path());

  // See comment in get_file_hash_index for why saving of timestamps is forced
  // for precompiled headers.
  bool save_timestamp = (ctx.config.sloppiness() & SLOPPY_FILE_STAT_MATCHES)
                        || ctx.args_info.output_is_precompiled_header;

  MTR_BEGIN(""manifest"", ""manifest_put"");
  cc_log(""Adding result name to %s"", ctx.manifest_path().c_str());
  if (!manifest_put(ctx.config,
                    ctx.manifest_path(),
                    ctx.result_name(),
                    ctx.included_files,
                    ctx.time_of_compilation,
                    save_timestamp)) {
    cc_log(""Failed to add result name to %s"", ctx.manifest_path().c_str());
  } else {
    auto st = Stat::stat(ctx.manifest_path(), Stat::OnError::log);

    int64_t size_delta = st.size_on_disk() - old_st.size_on_disk();
    int nof_files_delta = !old_st && st ? 1 : 0;

    if (ctx.stats_file() == ctx.manifest_stats_file()) {
      stats_update_size(ctx.counter_updates, size_delta, nof_files_delta);
    } else {
      Counters counters;
      stats_update_size(counters, size_delta, nof_files_delta);
      stats_flush_to_file(ctx.config, ctx.manifest_stats_file(), counters);
    }
  }
  MTR_END(""manifest"", ""manifest_put"");
}

static bool
create_cachedir_tag(nonstd::string_view dir)
{
  constexpr char cachedir_tag[] =
    ""Signature: 8a477f597d28d172789f06886806bc55\n""
    ""# This file is a cache directory tag created by ccache.\n""
    ""# For information about cache directory tags, see:\n""
    ""#\thttp://www.brynosaurus.com/cachedir/\n"";

  std::string filename = fmt::format(""{}/CACHEDIR.TAG"", dir);
  auto st = Stat::stat(filename);

  if (st) {
    if (st.is_regular()) {
      return true;
    }
    errno = EEXIST;
    return false;
  }

  File f(filename, ""w"");

  if (!f) {
    return false;
  }

  return fwrite(cachedir_tag, strlen(cachedir_tag), 1, f.get()) == 1;
}

// Run the real compiler and put the result in cache.
static void
to_cache(Context& ctx,
         Args& args,
         Args& depend_extra_args,
         struct hash* depend_mode_hash)
{
  args.push_back(""-o"");
  args.push_back(ctx.args_info.output_obj);

  if (ctx.config.hard_link() && ctx.args_info.output_obj != ""/dev/null"") {
    // Workaround for Clang bug where it overwrites an existing object file
    // when it's compiling an assembler file, see
    // <https://bugs.llvm.org/show_bug.cgi?id=39782>.
    Util::unlink_safe(ctx.args_info.output_obj);
  }

  if (ctx.args_info.generating_diagnostics) {
    args.push_back(""--serialize-diagnostics"");
    args.push_back(ctx.args_info.output_dia);
  }

  // Turn off DEPENDENCIES_OUTPUT when running cc1, because otherwise it will
  // emit a line like this:
  //
  //   tmp.stdout.vexed.732.o: /home/mbp/.ccache/tmp.stdout.vexed.732.i
  x_unsetenv(""DEPENDENCIES_OUTPUT"");
  x_unsetenv(""SUNPRO_DEPENDENCIES"");

  if (ctx.config.run_second_cpp()) {
    args.push_back(ctx.args_info.input_file);
  } else {
    args.push_back(ctx.i_tmpfile);
  }

  if (ctx.args_info.seen_split_dwarf) {
    // Remove any pre-existing .dwo file since we want to check if the compiler
    // produced one, intentionally not using x_unlink or tmp_unlink since we're
    // not interested in logging successful deletions or failures due to
    // non-existent .dwo files.
    if (unlink(ctx.args_info.output_dwo.c_str()) != 0 && errno != ENOENT
        && errno != ESTALE) {
      cc_log(""Failed to unlink %s: %s"",
             ctx.args_info.output_dwo.c_str(),
             strerror(errno));
      failed(STATS_BADOUTPUTFILE);
    }
  }

  cc_log(""Running real compiler"");
  MTR_BEGIN(""execute"", ""compiler"");

  const auto tmp_stdout_fd_and_path = Util::create_temp_fd(
    fmt::format(""{}/tmp.stdout"", ctx.config.temporary_dir()));
  int tmp_stdout_fd = tmp_stdout_fd_and_path.first;
  const std::string& tmp_stdout = tmp_stdout_fd_and_path.second;
  ctx.register_pending_tmp_file(tmp_stdout);

  const auto tmp_stderr_fd_and_path = Util::create_temp_fd(
    fmt::format(""{}/tmp.stderr"", ctx.config.temporary_dir()));
  int tmp_stderr_fd = tmp_stderr_fd_and_path.first;
  const std::string& tmp_stderr = tmp_stderr_fd_and_path.second;
  ctx.register_pending_tmp_file(tmp_stderr);

  int status;
  if (!ctx.config.depend_mode()) {
    status =
      execute(ctx, args, tmp_stdout, tmp_stdout_fd, tmp_stderr, tmp_stderr_fd);
    args.pop_back(3);
  } else {
    // Use the original arguments (including dependency options) in depend
    // mode.
    Args depend_mode_args = ctx.orig_args;
    depend_mode_args.erase_with_prefix(""--ccache-"");
    depend_mode_args.push_back(depend_extra_args);
    add_prefix(ctx, depend_mode_args, ctx.config.prefix_command());

    ctx.time_of_compilation = time(nullptr);
    status = execute(ctx,
                     depend_mode_args,
                     tmp_stdout,
                     tmp_stdout_fd,
                     tmp_stderr,
                     tmp_stderr_fd);
  }
  MTR_END(""execute"", ""compiler"");

  auto st = Stat::stat(tmp_stdout, Stat::OnError::log);
  if (!st) {
    // The stdout file was removed - cleanup in progress? Better bail out.
    failed(STATS_MISSING);
  }

  // distcc-pump outputs lines like this:
  // __________Using # distcc servers in pump mode
  if (st.size() != 0 && ctx.guessed_compiler != GuessedCompiler::pump) {
    cc_log(""Compiler produced stdout"");
    failed(STATS_STDOUT);
  }

  // Merge stderr from the preprocessor (if any) and stderr from the real
  // compiler into tmp_stderr.
  if (!ctx.cpp_stderr.empty()) {
    std::string combined_stderr =
      Util::read_file(ctx.cpp_stderr) + Util::read_file(tmp_stderr);
    Util::write_file(tmp_stderr, combined_stderr);
  }

  if (status != 0) {
    cc_log(""Compiler gave exit status %d"", status);

    // We can output stderr immediately instead of rerunning the compiler.
    send_cached_stderr(tmp_stderr, ctx.args_info.strip_diagnostics_colors);

    failed(STATS_STATUS, status);
  }

  if (ctx.config.depend_mode()) {
    auto result_name = result_name_from_depfile(ctx, depend_mode_hash);
    if (!result_name) {
      failed(STATS_ERROR);
    }
    ctx.set_result_name(*result_name);
  }

  bool produce_dep_file = ctx.args_info.generating_dependencies
                          && ctx.args_info.output_dep != ""/dev/null"";

  if (produce_dep_file) {
    use_relative_paths_in_depfile(ctx);
  }

  st = Stat::stat(ctx.args_info.output_obj);
  if (!st) {
    cc_log(""Compiler didn't produce an object file"");
    failed(STATS_NOOUTPUT);
  }
  if (st.size() == 0) {
    cc_log(""Compiler produced an empty object file"");
    failed(STATS_EMPTYOUTPUT);
  }

  st = Stat::stat(tmp_stderr, Stat::OnError::log);
  if (!st) {
    failed(STATS_ERROR);
  }
  ResultFileMap result_file_map;
  if (st.size() > 0) {
    result_file_map.emplace(FileType::stderr_output, tmp_stderr);
  }
  result_file_map.emplace(FileType::object, ctx.args_info.output_obj);
  if (ctx.args_info.generating_dependencies) {
    result_file_map.emplace(FileType::dependency, ctx.args_info.output_dep);
  }
  if (ctx.args_info.generating_coverage) {
    result_file_map.emplace(FileType::coverage, ctx.args_info.output_cov);
  }
  if (ctx.args_info.generating_stackusage) {
    result_file_map.emplace(FileType::stackusage, ctx.args_info.output_su);
  }
  if (ctx.args_info.generating_diagnostics) {
    result_file_map.emplace(FileType::diagnostic, ctx.args_info.output_dia);
  }
  if (ctx.args_info.seen_split_dwarf && Stat::stat(ctx.args_info.output_dwo)) {
    // Only copy .dwo file if it was created by the compiler (GCC and Clang
    // behave differently e.g. for ""-gsplit-dwarf -g1"").
    result_file_map.emplace(FileType::dwarf_object, ctx.args_info.output_dwo);
  }

  auto orig_dest_stat = Stat::stat(ctx.result_path());
  result_put(ctx, ctx.result_path(), result_file_map);

  cc_log(""Stored in cache: %s"", ctx.result_path().c_str());

  auto new_dest_stat = Stat::stat(ctx.result_path(), Stat::OnError::log);
  if (!new_dest_stat) {
    failed(STATS_ERROR);
  }
  stats_update_size(ctx.counter_updates,
                    new_dest_stat.size_on_disk()
                      - orig_dest_stat.size_on_disk(),
                    orig_dest_stat ? 0 : 1);

  MTR_END(""file"", ""file_put"");

  // Make sure we have a CACHEDIR.TAG in the cache part of cache_dir. This can
  // be done almost anywhere, but we might as well do it near the end as we
  // save the stat call if we exit early.
  {
    std::string first_level_dir(Util::dir_name(ctx.stats_file()));
    if (!create_cachedir_tag(first_level_dir)) {
      cc_log(""Failed to create %s/CACHEDIR.TAG (%s)"",
             first_level_dir.c_str(),
             strerror(errno));
    }

    // Remove any CACHEDIR.TAG on the cache_dir level where it was located in
    // previous ccache versions.
    if (getpid() % 1000 == 0) {
      char* path = format(""%s/CACHEDIR.TAG"", ctx.config.cache_dir().c_str());
      Util::unlink_safe(path);
      free(path);
    }
  }

  // Everything OK.
  send_cached_stderr(tmp_stderr, ctx.args_info.strip_diagnostics_colors);
}

// Find the result name by running the compiler in preprocessor mode and
// hashing the result.
static Digest
get_result_name_from_cpp(Context& ctx, Args& args, struct hash* hash)
{
  ctx.time_of_compilation = time(nullptr);

  std::string stderr_path;
  std::string stdout_path;
  int status;
  if (ctx.args_info.direct_i_file) {
    // We are compiling a .i or .ii file - that means we can skip the cpp stage
    // and directly form the correct i_tmpfile.
    stdout_path = ctx.args_info.input_file;
    status = 0;
  } else {
    // Run cpp on the input file to obtain the .i.

    // Limit the basename to 10 characters in order to cope with filesystem with
    // small maximum filename length limits.
    string_view input_base =
      Util::get_truncated_base_name(ctx.args_info.input_file, 10);
    auto stdout_fd_and_path = Util::create_temp_fd(
      fmt::format(""{}/{}.stdout"", ctx.config.temporary_dir(), input_base));
    int stdout_fd = stdout_fd_and_path.first;
    stdout_path = stdout_fd_and_path.second;
    ctx.register_pending_tmp_file(stdout_path);

    auto stderr_fd_and_path = Util::create_temp_fd(
      fmt::format(""{}/tmp.cpp_stderr"", ctx.config.temporary_dir()));
    int stderr_fd = stderr_fd_and_path.first;
    stderr_path = stderr_fd_and_path.second;
    ctx.register_pending_tmp_file(stderr_path);

    size_t args_added = 2;
    args.push_back(""-E"");
    if (ctx.config.keep_comments_cpp()) {
      args.push_back(""-C"");
      args_added = 3;
    }
    args.push_back(ctx.args_info.input_file);
    add_prefix(ctx, args, ctx.config.prefix_command_cpp());
    cc_log(""Running preprocessor"");
    MTR_BEGIN(""execute"", ""preprocessor"");
    status = execute(ctx, args, stdout_path, stdout_fd, stderr_path, stderr_fd);
    MTR_END(""execute"", ""preprocessor"");
    args.pop_back(args_added);
  }

  if (status != 0) {
    cc_log(""Preprocessor gave exit status %d"", status);
    failed(STATS_PREPROCESSOR);
  }

  hash_delimiter(hash, ""cpp"");
  bool is_pump = ctx.guessed_compiler == GuessedCompiler::pump;
  if (!process_preprocessed_file(ctx, hash, stdout_path.c_str(), is_pump)) {
    failed(STATS_ERROR);
  }

  hash_delimiter(hash, ""cppstderr"");
  if (!ctx.args_info.direct_i_file
      && !hash_binary_file(ctx, hash, stderr_path.c_str())) {
    // Somebody removed the temporary file?
    cc_log(""Failed to open %s: %s"", stderr_path.c_str(), strerror(errno));
    failed(STATS_ERROR);
  }

  if (ctx.args_info.direct_i_file) {
    ctx.i_tmpfile = ctx.args_info.input_file;
  } else {
    // i_tmpfile needs the proper cpp_extension for the compiler to do its
    // thing correctly
    ctx.i_tmpfile =
      fmt::format(""{}.{}"", stdout_path, ctx.config.cpp_extension());
    x_rename(stdout_path.c_str(), ctx.i_tmpfile.c_str());
    ctx.register_pending_tmp_file(ctx.i_tmpfile);
  }

  if (!ctx.config.run_second_cpp()) {
    // If we are using the CPP trick, we need to remember this stderr data and
    // output it just before the main stderr from the compiler pass.
    ctx.cpp_stderr = stderr_path;
    hash_delimiter(hash, ""runsecondcpp"");
    hash_string(hash, ""false"");
  }

  return hash_result(hash);
}

// Hash mtime or content of a file, or the output of a command, according to
// the CCACHE_COMPILERCHECK setting.
static void
hash_compiler(const Context& ctx,
              struct hash* hash,
              const Stat& st,
              const char* path,
              bool allow_command)
{
  if (ctx.config.compiler_check() == ""none"") {
    // Do nothing.
  } else if (ctx.config.compiler_check() == ""mtime"") {
    hash_delimiter(hash, ""cc_mtime"");
    hash_int(hash, st.size());
    hash_int(hash, st.mtime());
  } else if (Util::starts_with(ctx.config.compiler_check(), ""string:"")) {
    hash_delimiter(hash, ""cc_hash"");
    hash_string(hash, ctx.config.compiler_check().c_str() + strlen(""string:""));
  } else if (ctx.config.compiler_check() == ""content"" || !allow_command) {
    hash_delimiter(hash, ""cc_content"");
    hash_binary_file(ctx, hash, path);
  } else { // command string
    if (!hash_multicommand_output(hash,
                                  ctx.config.compiler_check().c_str(),
                                  ctx.orig_args[0].c_str())) {
      cc_log(""Failure running compiler check command: %s"",
             ctx.config.compiler_check().c_str());
      failed(STATS_COMPCHECK);
    }
  }
}

// Hash the host compiler(s) invoked by nvcc.
//
// If ccbin_st and ccbin are set, they refer to a directory or compiler set
// with -ccbin/--compiler-bindir. If they are NULL, the compilers are looked up
// in PATH instead.
static void
hash_nvcc_host_compiler(const Context& ctx,
                        struct hash* hash,
                        const Stat* ccbin_st,
                        const char* ccbin)
{
  // From <http://docs.nvidia.com/cuda/cuda-compiler-driver-nvcc/index.html>:
  //
  //   ""[...] Specify the directory in which the compiler executable resides.
  //   The host compiler executable name can be also specified to ensure that
  //   the correct host compiler is selected.""
  //
  // and
  //
  //   ""On all platforms, the default host compiler executable (gcc and g++ on
  //   Linux, clang and clang++ on Mac OS X, and cl.exe on Windows) found in
  //   the current execution search path will be used"".

  if (!ccbin || ccbin_st->is_directory()) {
#if defined(__APPLE__)
    const char* compilers[] = {""clang"", ""clang++""};
#elif defined(_WIN32)
    const char* compilers[] = {""cl.exe""};
#else
    const char* compilers[] = {""gcc"", ""g++""};
#endif
    for (const char* compiler : compilers) {
      if (ccbin) {
        char* path = format(""%s/%s"", ccbin, compiler);
        auto st = Stat::stat(path);
        if (st) {
          hash_compiler(ctx, hash, st, path, false);
        }
        free(path);
      } else {
        std::string path = find_executable(ctx, compiler, MYNAME);
        if (!path.empty()) {
          auto st = Stat::stat(path, Stat::OnError::log);
          hash_compiler(ctx, hash, st, ccbin, false);
        }
      }
    }
  } else {
    hash_compiler(ctx, hash, *ccbin_st, ccbin, false);
  }
}

// Update a hash with information common for the direct and preprocessor modes.
static void
hash_common_info(const Context& ctx,
                 const Args& args,
                 struct hash* hash,
                 const ArgsInfo& args_info)
{
  hash_string(hash, HASH_PREFIX);

  // We have to hash the extension, as a .i file isn't treated the same by the
  // compiler as a .ii file.
  hash_delimiter(hash, ""ext"");
  hash_string(hash, ctx.config.cpp_extension().c_str());

#ifdef _WIN32
  const char* ext = strrchr(args[0].c_str(), '.');
  char full_path_win_ext[MAX_PATH + 1] = {0};
  add_exe_ext_if_no_to_fullpath(
    full_path_win_ext, MAX_PATH, ext, args[0].c_str());
  const char* full_path = full_path_win_ext;
#else
  const char* full_path = args[0].c_str();
#endif

  auto st = Stat::stat(full_path, Stat::OnError::log);
  if (!st) {
    failed(STATS_COMPILER);
  }

  // Hash information about the compiler.
  hash_compiler(ctx, hash, st, args[0].c_str(), true);

  // Also hash the compiler name as some compilers use hard links and behave
  // differently depending on the real name.
  hash_delimiter(hash, ""cc_name"");
  string_view base = Util::base_name(args[0]);
  hash_string_view(hash, base);

  if (!(ctx.config.sloppiness() & SLOPPY_LOCALE)) {
    // Hash environment variables that may affect localization of compiler
    // warning messages.
    const char* envvars[] = {
      ""LANG"", ""LC_ALL"", ""LC_CTYPE"", ""LC_MESSAGES"", nullptr};
    for (const char** p = envvars; *p; ++p) {
      char* v = getenv(*p);
      if (v) {
        hash_delimiter(hash, *p);
        hash_string(hash, v);
      }
    }
  }

  // Possibly hash the current working directory.
  if (args_info.generating_debuginfo && ctx.config.hash_dir()) {
    std::string dir_to_hash = ctx.apparent_cwd;
    for (const auto& map : args_info.debug_prefix_maps) {
      size_t sep_pos = map.find('=');
      if (sep_pos != std::string::npos) {
        std::string old_path = map.substr(0, sep_pos);
        std::string new_path = map.substr(sep_pos + 1);
        cc_log(""Relocating debuginfo from %s to %s (CWD: %s)"",
               old_path.c_str(),
               new_path.c_str(),
               ctx.apparent_cwd.c_str());
        if (Util::starts_with(ctx.apparent_cwd, old_path)) {
          dir_to_hash = new_path + ctx.apparent_cwd.substr(old_path.size());
        }
      }
    }
    cc_log(""Hashing CWD %s"", dir_to_hash.c_str());
    hash_delimiter(hash, ""cwd"");
    hash_string(hash, dir_to_hash);
  }

  if (ctx.args_info.generating_dependencies || ctx.args_info.seen_split_dwarf) {
    // The output object file name is part of the .d file, so include the path
    // in the hash if generating dependencies.
    //
    // Object files include a link to the corresponding .dwo file based on the
    // target object filename when using -gsplit-dwarf, so hashing the object
    // file path will do it, although just hashing the object file base name
    // would be enough.
    hash_delimiter(hash, ""object file"");
    hash_string_view(hash, ctx.args_info.output_obj);
  }

  // Possibly hash the coverage data file path.
  if (ctx.args_info.generating_coverage && ctx.args_info.profile_arcs) {
    std::string dir;
    if (!ctx.args_info.profile_path.empty()) {
      dir = ctx.args_info.profile_path;
    } else {
      dir =
        Util::real_path(std::string(Util::dir_name(ctx.args_info.output_obj)));
    }
    string_view stem =
      Util::remove_extension(Util::base_name(ctx.args_info.output_obj));
    std::string gcda_path = fmt::format(""{}/{}.gcda"", dir, stem);
    cc_log(""Hashing coverage path %s"", gcda_path.c_str());
    hash_delimiter(hash, ""gcda"");
    hash_string(hash, gcda_path);
  }

  // Possibly hash the sanitize blacklist file path.
  for (const auto& sanitize_blacklist : args_info.sanitize_blacklists) {
    cc_log(""Hashing sanitize blacklist %s"", sanitize_blacklist.c_str());
    hash_delimiter(hash, ""sanitizeblacklist"");
    if (!hash_binary_file(ctx, hash, sanitize_blacklist.c_str())) {
      failed(STATS_BADEXTRAFILE);
    }
  }

  if (!ctx.config.extra_files_to_hash().empty()) {
    for (const std::string& path : Util::split_into_strings(
           ctx.config.extra_files_to_hash(), PATH_DELIM)) {
      cc_log(""Hashing extra file %s"", path.c_str());
      hash_delimiter(hash, ""extrafile"");
      if (!hash_binary_file(ctx, hash, path.c_str())) {
        failed(STATS_BADEXTRAFILE);
      }
    }
  }

  // Possibly hash GCC_COLORS (for color diagnostics).
  if (ctx.guessed_compiler == GuessedCompiler::gcc) {
    const char* gcc_colors = getenv(""GCC_COLORS"");
    if (gcc_colors) {
      hash_delimiter(hash, ""gcccolors"");
      hash_string(hash, gcc_colors);
    }
  }
}

static bool
hash_profile_data_file(const Context& ctx, struct hash* hash)
{
  const std::string& profile_path = ctx.args_info.profile_path;
  string_view base_name = Util::remove_extension(ctx.args_info.output_obj);
  std::string hashified_cwd = ctx.apparent_cwd;
  std::replace(hashified_cwd.begin(), hashified_cwd.end(), '/', '#');

  std::vector<std::string> paths_to_try{
    // -fprofile-use[=dir]/-fbranch-probabilities (GCC <9)
    fmt::format(""{}/{}.gcda"", profile_path, base_name),
    // -fprofile-use[=dir]/-fbranch-probabilities (GCC >=9)
    fmt::format(""{}/{}#{}.gcda"", profile_path, hashified_cwd, base_name),
    // -fprofile(-instr|-sample)-use=file (Clang), -fauto-profile=file (GCC >=5)
    profile_path,
    // -fprofile(-instr|-sample)-use=dir (Clang)
    fmt::format(""{}/default.profdata"", profile_path),
    // -fauto-profile (GCC >=5)
    ""fbdata.afdo"", // -fprofile-dir is not used
  };

  bool found = false;
  for (const std::string& p : paths_to_try) {
    cc_log(""Checking for profile data file %s"", p.c_str());
    auto st = Stat::stat(p);
    if (st && !st.is_directory()) {
      cc_log(""Adding profile data %s to the hash"", p.c_str());
      hash_delimiter(hash, ""-fprofile-use"");
      if (hash_binary_file(ctx, hash, p.c_str())) {
        found = true;
      }
    }
  }

  return found;
}

// Update a hash sum with information specific to the direct and preprocessor
// modes and calculate the result name. Returns the result name on success,
// otherwise NULL. Caller frees.
static optional<Digest>
calculate_result_name(Context& ctx,
                      const Args& args,
                      Args& preprocessor_args,
                      struct hash* hash,
                      bool direct_mode)
{
  bool found_ccbin = false;

  hash_delimiter(hash, ""result version"");
  hash_int(hash, k_result_version);

  if (direct_mode) {
    hash_delimiter(hash, ""manifest version"");
    hash_int(hash, k_manifest_version);
  }

  // clang will emit warnings for unused linker flags, so we shouldn't skip
  // those arguments.
  int is_clang = ctx.guessed_compiler == GuessedCompiler::clang
                 || ctx.guessed_compiler == GuessedCompiler::unknown;

  // First the arguments.
  for (size_t i = 1; i < args.size(); i++) {
    // -L doesn't affect compilation (except for clang).
    if (i < args.size() - 1 && args[i] == ""-L"" && !is_clang) {
      i++;
      continue;
    }
    if (Util::starts_with(args[i], ""-L"") && !is_clang) {
      continue;
    }

    // -Wl,... doesn't affect compilation (except for clang).
    if (Util::starts_with(args[i], ""-Wl,"") && !is_clang) {
      continue;
    }

    // The -fdebug-prefix-map option may be used in combination with
    // CCACHE_BASEDIR to reuse results across different directories. Skip using
    // the value of the option from hashing but still hash the existence of the
    // option.
    if (Util::starts_with(args[i], ""-fdebug-prefix-map="")) {
      hash_delimiter(hash, ""arg"");
      hash_string(hash, ""-fdebug-prefix-map="");
      continue;
    }
    if (Util::starts_with(args[i], ""-ffile-prefix-map="")) {
      hash_delimiter(hash, ""arg"");
      hash_string(hash, ""-ffile-prefix-map="");
      continue;
    }
    if (Util::starts_with(args[i], ""-fmacro-prefix-map="")) {
      hash_delimiter(hash, ""arg"");
      hash_string(hash, ""-fmacro-prefix-map="");
      continue;
    }

    // When using the preprocessor, some arguments don't contribute to the
    // hash. The theory is that these arguments will change the output of -E if
    // they are going to have any effect at all. For precompiled headers this
    // might not be the case.
    if (!direct_mode && !ctx.args_info.output_is_precompiled_header
        && !ctx.args_info.using_precompiled_header) {
      if (compopt_affects_cpp(args[i])) {
        if (compopt_takes_arg(args[i])) {
          i++;
        }
        continue;
      }
      if (compopt_short(compopt_affects_cpp, args[i])) {
        continue;
      }
    }

    // If we're generating dependencies, we make sure to skip the filename of
    // the dependency file, since it doesn't impact the output.
    if (ctx.args_info.generating_dependencies) {
      if (Util::starts_with(args[i], ""-Wp,"")) {
        if (Util::starts_with(args[i], ""-Wp,-MD,"")
            && !strchr(args[i].c_str() + 8, ',')) {
          hash_string_buffer(hash, args[i].c_str(), 8);
          continue;
        } else if (Util::starts_with(args[i], ""-Wp,-MMD,"")
                   && !strchr(args[i].c_str() + 9, ',')) {
          hash_string_buffer(hash, args[i].c_str(), 9);
          continue;
        }
      } else if (Util::starts_with(args[i], ""-MF"")) {
        // In either case, hash the ""-MF"" part.
        hash_delimiter(hash, ""arg"");
        hash_string_buffer(hash, args[i].c_str(), 3);

        if (ctx.args_info.output_dep != ""/dev/null"") {
          bool separate_argument = (args[i].size() == 3);
          if (separate_argument) {
            // Next argument is dependency name, so skip it.
            i++;
          }
        }
        continue;
      }
    }

    const char* p = nullptr;
    if (Util::starts_with(args[i], ""-specs="")) {
      p = args[i].c_str() + 7;
    } else if (Util::starts_with(args[i], ""--specs="")) {
      p = args[i].c_str() + 8;
    }

    if (p) {
      auto st = Stat::stat(p, Stat::OnError::log);
      if (st) {
        // If given an explicit specs file, then hash that file, but don't
        // include the path to it in the hash.
        hash_delimiter(hash, ""specs"");
        hash_compiler(ctx, hash, st, p, false);
        continue;
      }
    }

    if (Util::starts_with(args[i], ""-fplugin="")) {
      auto st = Stat::stat(args[i].c_str() + 9, Stat::OnError::log);
      if (st) {
        hash_delimiter(hash, ""plugin"");
        hash_compiler(ctx, hash, st, args[i].c_str() + 9, false);
        continue;
      }
    }

    if (args[i] == ""-Xclang"" && i + 3 < args.size() && args[i + 1] == ""-load""
        && args[i + 2] == ""-Xclang"") {
      auto st = Stat::stat(args[i + 3], Stat::OnError::log);
      if (st) {
        hash_delimiter(hash, ""plugin"");
        hash_compiler(ctx, hash, st, args[i + 3].c_str(), false);
        i += 3;
        continue;
      }
    }

    if ((args[i] == ""-ccbin"" || args[i] == ""--compiler-bindir"")
        && i + 1 < args.size()) {
      auto st = Stat::stat(args[i + 1], Stat::OnError::log);
      if (st) {
        found_ccbin = true;
        hash_delimiter(hash, ""ccbin"");
        hash_nvcc_host_compiler(ctx, hash, &st, args[i + 1].c_str());
        i++;
        continue;
      }
    }

    // All other arguments are included in the hash.
    hash_delimiter(hash, ""arg"");
    hash_string(hash, args[i]);
    if (i + 1 < args.size() && compopt_takes_arg(args[i])) {
      i++;
      hash_delimiter(hash, ""arg"");
      hash_string(hash, args[i]);
    }
  }

  // Make results with dependency file /dev/null different from those without
  // it.
  if (ctx.args_info.generating_dependencies
      && ctx.args_info.output_dep == ""/dev/null"") {
    hash_delimiter(hash, ""/dev/null dependency file"");
  }

  if (!found_ccbin && ctx.args_info.actual_language == ""cu"") {
    hash_nvcc_host_compiler(ctx, hash, nullptr, nullptr);
  }

  // For profile generation (-fprofile(-instr)-generate[=path])
  // - hash profile path
  //
  // For profile usage (-fprofile(-instr|-sample)-use, -fbranch-probabilities):
  // - hash profile data
  //
  // -fbranch-probabilities and -fvpt usage is covered by
  // -fprofile-generate/-fprofile-use.
  //
  // The profile directory can be specified as an argument to
  // -fprofile(-instr)-generate=, -fprofile(-instr|-sample)-use= or
  // -fprofile-dir=.

  if (ctx.args_info.profile_generate) {
    assert(!ctx.args_info.profile_path.empty());
    cc_log(""Adding profile directory %s to our hash"",
           ctx.args_info.profile_path.c_str());
    hash_delimiter(hash, ""-fprofile-dir"");
    hash_string(hash, ctx.args_info.profile_path);
  }

  if (ctx.args_info.profile_use && !hash_profile_data_file(ctx, hash)) {
    cc_log(""No profile data file found"");
    failed(STATS_NOINPUT);
  }

  // Adding -arch to hash since cpp output is affected.
  for (const auto& arch : ctx.args_info.arch_args) {
    hash_delimiter(hash, ""-arch"");
    hash_string(hash, arch);
  }

  optional<Digest> result_name;
  if (direct_mode) {
    // Hash environment variables that affect the preprocessor output.
    const char* envvars[] = {""CPATH"",
                             ""C_INCLUDE_PATH"",
                             ""CPLUS_INCLUDE_PATH"",
                             ""OBJC_INCLUDE_PATH"",
                             ""OBJCPLUS_INCLUDE_PATH"", // clang
                             nullptr};
    for (const char** p = envvars; *p; ++p) {
      char* v = getenv(*p);
      if (v) {
        hash_delimiter(hash, *p);
        hash_string(hash, v);
      }
    }

    // Make sure that the direct mode hash is unique for the input file path.
    // If this would not be the case:
    //
    // * An false cache hit may be produced. Scenario:
    //   - a/r.h exists.
    //   - a/x.c has #include ""r.h"".
    //   - b/x.c is identical to a/x.c.
    //   - Compiling a/x.c records a/r.h in the manifest.
    //   - Compiling b/x.c results in a false cache hit since a/x.c and b/x.c
    //     share manifests and a/r.h exists.
    // * The expansion of __FILE__ may be incorrect.
    hash_delimiter(hash, ""inputfile"");
    hash_string(hash, ctx.args_info.input_file);

    hash_delimiter(hash, ""sourcecode"");
    int result =
      hash_source_code_file(ctx, hash, ctx.args_info.input_file.c_str());
    if (result & HASH_SOURCE_CODE_ERROR) {
      failed(STATS_ERROR);
    }
    if (result & HASH_SOURCE_CODE_FOUND_TIME) {
      cc_log(""Disabling direct mode"");
      ctx.config.set_direct_mode(false);
      return nullopt;
    }

    ctx.set_manifest_name(hash_result(hash));

    cc_log(""Looking for result name in %s"", ctx.manifest_path().c_str());
    MTR_BEGIN(""manifest"", ""manifest_get"");
    result_name = manifest_get(ctx, ctx.manifest_path());
    MTR_END(""manifest"", ""manifest_get"");
    if (result_name) {
      cc_log(""Got result name from manifest"");
    } else {
      cc_log(""Did not find result name in manifest"");
    }
  } else {
    if (ctx.args_info.arch_args.empty()) {
      result_name = get_result_name_from_cpp(ctx, preprocessor_args, hash);
      cc_log(""Got result name from preprocessor"");
    } else {
      preprocessor_args.push_back(""-arch"");
      for (size_t i = 0; i < ctx.args_info.arch_args.size(); ++i) {
        preprocessor_args.push_back(ctx.args_info.arch_args[i]);
        result_name = get_result_name_from_cpp(ctx, preprocessor_args, hash);
        cc_log(""Got result name from preprocessor with -arch %s"",
               ctx.args_info.arch_args[i].c_str());
        if (i != ctx.args_info.arch_args.size() - 1) {
          result_name = nullopt;
        }
        preprocessor_args.pop_back();
      }
      preprocessor_args.pop_back();
    }
  }

  return result_name;
}

// Try to return the compile result from cache.
static optional<enum stats>
from_cache(Context& ctx, enum fromcache_call_mode mode)
{
  // The user might be disabling cache hits.
  if (ctx.config.recache()) {
    return nullopt;
  }

  // If we're using Clang, we can't trust a precompiled header object based on
  // running the preprocessor since clang will produce a fatal error when the
  // precompiled header is used and one of the included files has an updated
  // timestamp:
  //
  //     file 'foo.h' has been modified since the precompiled header 'foo.pch'
  //     was built
  if ((ctx.guessed_compiler == GuessedCompiler::clang
       || ctx.guessed_compiler == GuessedCompiler::unknown)
      && ctx.args_info.output_is_precompiled_header
      && mode == FROMCACHE_CPP_MODE) {
    cc_log(""Not considering cached precompiled header in preprocessor mode"");
    return nullopt;
  }

  MTR_BEGIN(""cache"", ""from_cache"");

  bool produce_dep_file = ctx.args_info.generating_dependencies
                          && ctx.args_info.output_dep != ""/dev/null"";

  MTR_BEGIN(""file"", ""file_get"");

  // Get result from cache.
  const auto tmp_stderr_fd_and_path = Util::create_temp_fd(
    fmt::format(""{}/tmp.stderr"", ctx.config.temporary_dir()));
  close(tmp_stderr_fd_and_path.first);
  const std::string& tmp_stderr = tmp_stderr_fd_and_path.second;
  ctx.register_pending_tmp_file(tmp_stderr);

  ResultFileMap result_file_map;
  if (ctx.args_info.output_obj != ""/dev/null"") {
    result_file_map.emplace(FileType::object, ctx.args_info.output_obj);
    if (ctx.args_info.seen_split_dwarf) {
      result_file_map.emplace(FileType::dwarf_object, ctx.args_info.output_dwo);
    }
  }
  result_file_map.emplace(FileType::stderr_output, tmp_stderr);
  if (produce_dep_file) {
    result_file_map.emplace(FileType::dependency, ctx.args_info.output_dep);
  }
  if (ctx.args_info.generating_coverage) {
    result_file_map.emplace(FileType::coverage, ctx.args_info.output_cov);
  }
  if (ctx.args_info.generating_stackusage) {
    result_file_map.emplace(FileType::stackusage, ctx.args_info.output_su);
  }
  if (ctx.args_info.generating_diagnostics) {
    result_file_map.emplace(FileType::diagnostic, ctx.args_info.output_dia);
  }
  bool ok = result_get(ctx, ctx.result_path(), result_file_map);
  if (!ok) {
    cc_log(""Failed to get result from cache"");
    return nullopt;
  }

  MTR_END(""file"", ""file_get"");

  send_cached_stderr(tmp_stderr, ctx.args_info.strip_diagnostics_colors);

  cc_log(""Succeeded getting cached result"");

  MTR_END(""cache"", ""from_cache"");

  return mode == FROMCACHE_DIRECT_MODE ? STATS_CACHEHIT_DIR
                                       : STATS_CACHEHIT_CPP;
}

// Find the real compiler. We just search the PATH to find an executable of the
// same name that isn't a link to ourselves.
static void
find_compiler(Context& ctx, const char* const* argv)
{
  // We might be being invoked like ""ccache gcc -c foo.c"".
  std::string base(Util::base_name(argv[0]));
  if (same_executable_name(base.c_str(), MYNAME)) {
    ctx.orig_args.pop_front();
    if (is_full_path(ctx.orig_args[0].c_str())) {
      // A full path was given.
      return;
    }
    base = std::string(Util::base_name(ctx.orig_args[0]));
  }

  // Support user override of the compiler.
  if (!ctx.config.compiler().empty()) {
    base = ctx.config.compiler();
  }

  std::string compiler = find_executable(ctx, base.c_str(), MYNAME);
  if (compiler.empty()) {
    fatal(""Could not find compiler \""%s\"" in PATH"", base.c_str());
  }
  if (compiler == argv[0]) {
    fatal(""Recursive invocation (the name of the ccache binary must be \""%s\"")"",
          MYNAME);
  }
  ctx.orig_args[0] = compiler;
}

bool
is_precompiled_header(const char* path)
{
  const char* ext = get_extension(path);
  char* dir = x_dirname(path);
  const char* dir_ext = get_extension(dir);
  bool result =
    str_eq(ext, "".gch"") || str_eq(ext, "".pch"") || str_eq(ext, "".pth"")
    || str_eq(dir_ext, "".gch""); // See ""Precompiled Headers"" in GCC docs.
  free(dir);
  return result;
}

static void
create_initial_config_file(Config& config)
{
  if (!Util::create_dir(Util::dir_name(config.primary_config_path()))) {
    return;
  }

  unsigned max_files;
  uint64_t max_size;
  char* stats_dir = format(""%s/0"", config.cache_dir().c_str());
  if (Stat::stat(stats_dir)) {
    stats_get_obsolete_limits(stats_dir, &max_files, &max_size);
    // STATS_MAXFILES and STATS_MAXSIZE was stored for each top directory.
    max_files *= 16;
    max_size *= 16;
  } else {
    max_files = 0;
    max_size = config.max_size();
  }
  free(stats_dir);

  FILE* f = fopen(config.primary_config_path().c_str(), ""w"");
  if (!f) {
    return;
  }
  if (max_files != 0) {
    fprintf(f, ""max_files = %u\n"", max_files);
    config.set_max_files(max_files);
  }
  if (max_size != 0) {
    char* size = format_parsable_size_with_suffix(max_size);
    fprintf(f, ""max_size = %s\n"", size);
    free(size);
    config.set_max_size(max_size);
  }
  fclose(f);
}

// Read config file(s), populate variables, create configuration file in cache
// directory if missing, etc.
static void
set_up_config(Config& config)
{
  char* p = getenv(""CCACHE_CONFIGPATH"");
  if (p) {
    config.set_primary_config_path(p);
  } else {
    config.set_secondary_config_path(fmt::format(""{}/ccache.conf"", SYSCONFDIR));
    MTR_BEGIN(""config"", ""conf_read_secondary"");
    // A missing config file in SYSCONFDIR is OK so don't check return value.
    config.update_from_file(config.secondary_config_path());
    MTR_END(""config"", ""conf_read_secondary"");

    if (config.cache_dir().empty()) {
      fatal(""configuration setting \""cache_dir\"" must not be the empty string"");
    }
    if ((p = getenv(""CCACHE_DIR""))) {
      config.set_cache_dir(p);
    }
    if (config.cache_dir().empty()) {
      fatal(""CCACHE_DIR must not be the empty string"");
    }

    config.set_primary_config_path(
      fmt::format(""{}/ccache.conf"", config.cache_dir()));
  }

  bool should_create_initial_config = false;
  MTR_BEGIN(""config"", ""conf_read_primary"");
  if (!config.update_from_file(config.primary_config_path())
      && !config.disable()) {
    should_create_initial_config = true;
  }
  MTR_END(""config"", ""conf_read_primary"");

  MTR_BEGIN(""config"", ""conf_update_from_environment"");
  config.update_from_environment();
  MTR_END(""config"", ""conf_update_from_environment"");

  if (should_create_initial_config) {
    create_initial_config_file(config);
  }

  if (config.umask() != std::numeric_limits<uint32_t>::max()) {
    umask(config.umask());
  }
}

static void
set_up_context(Context& ctx, int argc, const char* const* argv)
{
  ctx.orig_args = Args::from_argv(argc, argv);
  ctx.ignore_header_paths = Util::split_into_strings(
    ctx.config.ignore_headers_in_manifest(), PATH_DELIM);
}

// Initialize ccache, must be called once before anything else is run.
static void
initialize(Context& ctx, int argc, const char* const* argv)
{
  set_up_config(ctx.config);
  set_up_context(ctx, argc, argv);
  init_log(ctx.config);

  cc_log(""=== CCACHE %s STARTED ========================================="",
         CCACHE_VERSION);

  if (getenv(""CCACHE_INTERNAL_TRACE"")) {
#ifdef MTR_ENABLED
    ctx.mini_trace = std::make_unique<MiniTrace>(ctx->args_info);
#else
    cc_log(""Error: tracing is not enabled!"");
#endif
  }
}

// Make a copy of stderr that will not be cached, so things like distcc can
// send networking errors to it.
static void
set_up_uncached_err()
{
  int uncached_fd =
    dup(STDERR_FILENO); // The file descriptor is intentionally leaked.
  if (uncached_fd == -1) {
    cc_log(""dup(2) failed: %s"", strerror(errno));
    failed(STATS_ERROR);
  }

  x_setenv(""UNCACHED_ERR_FD"", fmt::format(""{}"", uncached_fd).c_str());
}

static void
configuration_logger(const std::string& key,
                     const std::string& value,
                     const std::string& origin)
{
  cc_bulklog(
    ""Config: (%s) %s = %s"", origin.c_str(), key.c_str(), value.c_str());
}

static void
configuration_printer(const std::string& key,
                      const std::string& value,
                      const std::string& origin)
{
  fmt::print(""({}) {} = {}\n"", origin, key, value);
}

static int cache_compilation(int argc, const char* const* argv);
static enum stats do_cache_compilation(Context& ctx, const char* const* argv);

// The entry point when invoked to cache a compilation.
static int
cache_compilation(int argc, const char* const* argv)
{
  // Needed for portability when using localtime_r.
  tzset();

  auto ctx = std::make_unique<Context>();
  SignalHandler signal_handler(*ctx);

  initialize(*ctx, argc, argv);

  MTR_BEGIN(""main"", ""find_compiler"");
  find_compiler(*ctx, argv);
  MTR_END(""main"", ""find_compiler"");

  try {
    enum stats stat = do_cache_compilation(*ctx, argv);
    stats_update(*ctx, stat);
    return EXIT_SUCCESS;
  } catch (const Failure& e) {
    if (e.stat() != STATS_NONE) {
      stats_update(*ctx, e.stat());
    }

    if (e.exit_code()) {
      return *e.exit_code();
    }
    // Else: Fall back to running the real compiler.

    assert(!ctx->orig_args.empty());

    ctx->orig_args.erase_with_prefix(""--ccache-"");
    add_prefix(*ctx, ctx->orig_args, ctx->config.prefix_command());

    cc_log(""Failed; falling back to running the real compiler"");

    Args saved_orig_args(std::move(ctx->orig_args));
    auto execv_argv = saved_orig_args.to_argv();

    cc_log_argv(""Executing "", execv_argv.data());
    ctx.reset(); // Dump debug logs last thing before executing.
    execv(execv_argv[0], const_cast<char* const*>(execv_argv.data()));
    fatal(""execv of %s failed: %s"", execv_argv[0], strerror(errno));
  }
}

static enum stats
do_cache_compilation(Context& ctx, const char* const* argv)
{
  if (ctx.actual_cwd.empty()) {
    cc_log(""Unable to determine current working directory: %s"",
           strerror(errno));
    failed(STATS_ERROR);
  }

  MTR_BEGIN(""main"", ""clean_up_internal_tempdir"");
  if (ctx.config.temporary_dir() == ctx.config.cache_dir() + ""/tmp"") {
    clean_up_internal_tempdir(ctx.config);
  }
  MTR_END(""main"", ""clean_up_internal_tempdir"");

  if (!ctx.config.log_file().empty() || ctx.config.debug()) {
    ctx.config.visit_items(configuration_logger);
  }

  if (ctx.config.disable()) {
    cc_log(""ccache is disabled"");
    // STATS_CACHEMISS is a dummy to trigger stats_flush.
    failed(STATS_CACHEMISS);
  }

  MTR_BEGIN(""main"", ""set_up_uncached_err"");
  set_up_uncached_err();
  MTR_END(""main"", ""set_up_uncached_err"");

  cc_log_argv(""Command line: "", argv);
  cc_log(""Hostname: %s"", get_hostname());
  cc_log(""Working directory: %s"", ctx.actual_cwd.c_str());
  if (ctx.apparent_cwd != ctx.actual_cwd) {
    cc_log(""Apparent working directory: %s"", ctx.apparent_cwd.c_str());
  }

  ctx.config.set_limit_multiple(
    std::min(std::max(ctx.config.limit_multiple(), 0.0), 1.0));

  MTR_BEGIN(""main"", ""guess_compiler"");
  ctx.guessed_compiler = guess_compiler(ctx.orig_args[0].c_str());
  MTR_END(""main"", ""guess_compiler"");

  // Arguments (except -E) to send to the preprocessor.
  Args preprocessor_args;
  // Arguments not sent to the preprocessor but that should be part of the
  // hash.
  Args extra_args_to_hash;
  // Arguments to send to the real compiler.
  Args compiler_args;
  MTR_BEGIN(""main"", ""process_args"");

  auto error =
    process_args(ctx, preprocessor_args, extra_args_to_hash, compiler_args);
  if (error) {
    failed(*error);
  }

  MTR_END(""main"", ""process_args"");

  if (ctx.config.depend_mode()
      && (!ctx.args_info.generating_dependencies
          || ctx.args_info.output_dep == ""/dev/null""
          || !ctx.config.run_second_cpp())) {
    cc_log(""Disabling depend mode"");
    ctx.config.set_depend_mode(false);
  }

  cc_log(""Source file: %s"", ctx.args_info.input_file.c_str());
  if (ctx.args_info.generating_dependencies) {
    cc_log(""Dependency file: %s"", ctx.args_info.output_dep.c_str());
  }
  if (ctx.args_info.generating_coverage) {
    cc_log(""Coverage file: %s"", ctx.args_info.output_cov.c_str());
  }
  if (ctx.args_info.generating_stackusage) {
    cc_log(""Stack usage file: %s"", ctx.args_info.output_su.c_str());
  }
  if (ctx.args_info.generating_diagnostics) {
    cc_log(""Diagnostics file: %s"", ctx.args_info.output_dia.c_str());
  }
  if (!ctx.args_info.output_dwo.empty()) {
    cc_log(""Split dwarf file: %s"", ctx.args_info.output_dwo.c_str());
  }

  cc_log(""Object file: %s"", ctx.args_info.output_obj.c_str());
  MTR_META_THREAD_NAME(ctx.args_info.output_obj.c_str());

  if (ctx.config.debug()) {
    std::string path =
      fmt::format(""{}.ccache-input-text"", ctx.args_info.output_obj);
    File debug_text_file(path, ""w"");
    if (debug_text_file) {
      ctx.hash_debug_files.push_back(std::move(debug_text_file));
    } else {
      cc_log(""Failed to open %s: %s"", path.c_str(), strerror(errno));
    }
  }

  FILE* debug_text_file = !ctx.hash_debug_files.empty()
                            ? ctx.hash_debug_files.front().get()
                            : nullptr;

  struct hash* common_hash = hash_init();
  init_hash_debug(ctx,
                  common_hash,
                  ctx.args_info.output_obj.c_str(),
                  'c',
                  ""COMMON"",
                  debug_text_file);

  MTR_BEGIN(""hash"", ""common_hash"");
  hash_common_info(ctx, preprocessor_args, common_hash, ctx.args_info);
  MTR_END(""hash"", ""common_hash"");

  // Try to find the hash using the manifest.
  struct hash* direct_hash = hash_copy(common_hash);
  init_hash_debug(ctx,
                  direct_hash,
                  ctx.args_info.output_obj.c_str(),
                  'd',
                  ""DIRECT MODE"",
                  debug_text_file);

  Args args_to_hash = preprocessor_args;
  args_to_hash.push_back(extra_args_to_hash);

  bool put_result_in_manifest = false;
  optional<Digest> result_name;
  optional<Digest> result_name_from_manifest;
  if (ctx.config.direct_mode()) {
    cc_log(""Trying direct lookup"");
    MTR_BEGIN(""hash"", ""direct_hash"");
    Args dummy_args;
    result_name =
      calculate_result_name(ctx, args_to_hash, dummy_args, direct_hash, true);
    MTR_END(""hash"", ""direct_hash"");
    if (result_name) {
      ctx.set_result_name(*result_name);

      // If we can return from cache at this point then do so.
      auto result = from_cache(ctx, FROMCACHE_DIRECT_MODE);
      if (result) {
        return *result;
      }

      // Wasn't able to return from cache at this point. However, the result
      // was already found in manifest, so don't re-add it later.
      put_result_in_manifest = false;

      result_name_from_manifest = result_name;
    } else {
      // Add result to manifest later.
      put_result_in_manifest = true;
    }
  }

  if (ctx.config.read_only_direct()) {
    cc_log(""Read-only direct mode; running real compiler"");
    failed(STATS_CACHEMISS);
  }

  if (!ctx.config.depend_mode()) {
    // Find the hash using the preprocessed output. Also updates
    // g_included_files.
    struct hash* cpp_hash = hash_copy(common_hash);
    init_hash_debug(ctx,
                    cpp_hash,
                    ctx.args_info.output_obj.c_str(),
                    'p',
                    ""PREPROCESSOR MODE"",
                    debug_text_file);

    MTR_BEGIN(""hash"", ""cpp_hash"");
    result_name = calculate_result_name(
      ctx, args_to_hash, preprocessor_args, cpp_hash, false);
    MTR_END(""hash"", ""cpp_hash"");
    if (!result_name) {
      fatal(""internal error: calculate_result_name returned NULL for cpp"");
    }
    ctx.set_result_name(*result_name);

    if (result_name_from_manifest && result_name_from_manifest != result_name) {
      // The hash from manifest differs from the hash of the preprocessor
      // output. This could be because:
      //
      // - The preprocessor produces different output for the same input (not
      //   likely).
      // - There's a bug in ccache (maybe incorrect handling of compiler
      //   arguments).
      // - The user has used a different CCACHE_BASEDIR (most likely).
      //
      // The best thing here would probably be to remove the hash entry from
      // the manifest. For now, we use a simpler method: just remove the
      // manifest file.
      cc_log(""Hash from manifest doesn't match preprocessor output"");
      cc_log(""Likely reason: different CCACHE_BASEDIRs used"");
      cc_log(""Removing manifest as a safety measure"");
      Util::unlink_safe(ctx.manifest_path());

      put_result_in_manifest = true;
    }

    // If we can return from cache at this point then do.
    auto result = from_cache(ctx, FROMCACHE_CPP_MODE);
    if (result) {
      if (put_result_in_manifest) {
        update_manifest_file(ctx);
      }
      return *result;
    }
  }

  if (ctx.config.read_only()) {
    cc_log(""Read-only mode; running real compiler"");
    failed(STATS_CACHEMISS);
  }

  add_prefix(ctx, compiler_args, ctx.config.prefix_command());

  // In depend_mode, extend the direct hash.
  struct hash* depend_mode_hash =
    ctx.config.depend_mode() ? direct_hash : nullptr;

  // Run real compiler, sending output to cache.
  MTR_BEGIN(""cache"", ""to_cache"");
  to_cache(
    ctx, compiler_args, ctx.args_info.depend_extra_args, depend_mode_hash);
  update_manifest_file(ctx);
  MTR_END(""cache"", ""to_cache"");

  return STATS_CACHEMISS;
}

// The main program when not doing a compile.
static int
handle_main_options(int argc, const char* const* argv)
{
  enum longopts {
    DUMP_MANIFEST,
    DUMP_RESULT,
    HASH_FILE,
    PRINT_STATS,
  };
  static const struct option options[] = {
    {""cleanup"", no_argument, nullptr, 'c'},
    {""clear"", no_argument, nullptr, 'C'},
    {""dump-manifest"", required_argument, nullptr, DUMP_MANIFEST},
    {""dump-result"", required_argument, nullptr, DUMP_RESULT},
    {""get-config"", required_argument, nullptr, 'k'},
    {""hash-file"", required_argument, nullptr, HASH_FILE},
    {""help"", no_argument, nullptr, 'h'},
    {""max-files"", required_argument, nullptr, 'F'},
    {""max-size"", required_argument, nullptr, 'M'},
    {""print-stats"", no_argument, nullptr, PRINT_STATS},
    {""recompress"", required_argument, nullptr, 'X'},
    {""set-config"", required_argument, nullptr, 'o'},
    {""show-compression"", no_argument, nullptr, 'x'},
    {""show-config"", no_argument, nullptr, 'p'},
    {""show-stats"", no_argument, nullptr, 's'},
    {""version"", no_argument, nullptr, 'V'},
    {""zero-stats"", no_argument, nullptr, 'z'},
    {nullptr, 0, nullptr, 0}};

  Context ctx;
  initialize(ctx, argc, argv);

  int c;
  while ((c = getopt_long(argc,
                          const_cast<char* const*>(argv),
                          ""cCk:hF:M:po:sVxX:z"",
                          options,
                          nullptr))
         != -1) {
    switch (c) {
    case DUMP_MANIFEST:
      return manifest_dump(optarg, stdout) ? 0 : 1;

    case DUMP_RESULT:
      return result_dump(ctx, optarg, stdout) ? 0 : 1;

    case HASH_FILE: {
      struct hash* hash = hash_init();
      if (str_eq(optarg, ""-"")) {
        hash_fd(hash, STDIN_FILENO);
      } else {
        hash_binary_file(ctx, hash, optarg);
      }
      puts(hash_result(hash).to_string().c_str());
      hash_free(hash);
      break;
    }

    case PRINT_STATS:
      stats_print(ctx.config);
      break;

    case 'c': // --cleanup
    {
      ProgressBar progress_bar(""Cleaning..."");
      clean_up_all(ctx.config,
                   [&](double progress) { progress_bar.update(progress); });
      if (isatty(STDOUT_FILENO)) {
        printf(""\n"");
      }
      break;
    }

    case 'C': // --clear
    {
      ProgressBar progress_bar(""Clearing..."");
      wipe_all(ctx, [&](double progress) { progress_bar.update(progress); });
      if (isatty(STDOUT_FILENO)) {
        printf(""\n"");
      }
      break;
    }

    case 'h': // --help
      fprintf(stdout, USAGE_TEXT, MYNAME, MYNAME);
      x_exit(0);

    case 'k': // --get-config
      fmt::print(""{}\n"", ctx.config.get_string_value(optarg));
      break;

    case 'F': { // --max-files
      Config::set_value_in_file(
        ctx.config.primary_config_path(), ""max_files"", optarg);
      unsigned files = atoi(optarg);
      if (files == 0) {
        printf(""Unset cache file limit\n"");
      } else {
        printf(""Set cache file limit to %u\n"", files);
      }
      break;
    }

    case 'M': { // --max-size
      uint64_t size;
      if (!parse_size_with_suffix(optarg, &size)) {
        fatal(""invalid size: %s"", optarg);
      }
      Config::set_value_in_file(
        ctx.config.primary_config_path(), ""max_size"", optarg);
      if (size == 0) {
        printf(""Unset cache size limit\n"");
      } else {
        char* s = format_human_readable_size(size);
        printf(""Set cache size limit to %s\n"", s);
        free(s);
      }
      break;
    }

    case 'o': {                          // --set-config
      char* p = strchr(optarg + 1, '='); // Improve error message for -o=K=V
      if (!p) {
        fatal(""missing equal sign in \""%s\"""", optarg);
      }
      char* key = x_strndup(optarg, p - optarg);
      char* value = p + 1;
      Config::set_value_in_file(ctx.config.primary_config_path(), key, value);
      free(key);
      break;
    }

    case 'p': // --show-config
      ctx.config.visit_items(configuration_printer);
      break;

    case 's': // --show-stats
      stats_summary(ctx);
      break;

    case 'V': // --version
      fprintf(stdout, VERSION_TEXT, MYNAME, CCACHE_VERSION);
      x_exit(0);

    case 'x': // --show-compression
    {
      ProgressBar progress_bar(""Scanning..."");
      compress_stats(ctx.config,
                     [&](double progress) { progress_bar.update(progress); });
      break;
    }

    case 'X': // --recompress
    {
      int level;
      if (std::string(optarg) == ""uncompressed"") {
        level = 0;
      } else {
        level = Util::parse_int(optarg);
        if (level < -128 || level > 127) {
          throw Error(""compression level must be between -128 and 127"");
        }
        if (level == 0) {
          level = ctx.config.compression_level();
        }
      }

      ProgressBar progress_bar(""Recompressing..."");
      compress_recompress(
        ctx, level, [&](double progress) { progress_bar.update(progress); });
      break;
    }

    case 'z': // --zero-stats
      stats_zero(ctx);
      printf(""Statistics zeroed\n"");
      break;

    default:
      fprintf(stderr, USAGE_TEXT, MYNAME, MYNAME);
      x_exit(1);
    }

    // Some of the above switches might have changed config settings, so run the
    // setup again.
    set_up_config(ctx.config);
  }

  return 0;
}

int ccache_main(int argc, const char* const* argv);

int
ccache_main(int argc, const char* const* argv)
{
  try {
    // Check if we are being invoked as ""ccache"".
    std::string program_name(Util::base_name(argv[0]));
    if (same_executable_name(program_name.c_str(), MYNAME)) {
      if (argc < 2) {
        fprintf(stderr, USAGE_TEXT, MYNAME, MYNAME);
        x_exit(1);
      }
      // If the first argument isn't an option, then assume we are being passed
      // a compiler name and options.
      if (argv[1][0] == '-') {
        return handle_main_options(argc, argv);
      }
    }

    return cache_compilation(argc, argv);
  } catch (const ErrorBase& e) {
    fmt::print(stderr, ""ccache: error: {}\n"", e.what());
    return EXIT_FAILURE;
  }
}
""","""// Copyright (C) 2002-2007 Andrew Tridgell
// Copyright (C) 2009-2020 Joel Rosdahl and other contributors
//
// See doc/AUTHORS.adoc for a complete list of contributors.
//
// This program is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by the Free
// Software Foundation; either version 3 of the License, or (at your option)
// any later version.
//
// This program is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
// more details.
//
// You should have received a copy of the GNU General Public License along with
// this program; if not, write to the Free Software Foundation, Inc., 51
// Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA

#include ""ccache.hpp""

#include ""Args.hpp""
#include ""ArgsInfo.hpp""
#include ""Context.hpp""
#include ""Fd.hpp""
#include ""File.hpp""
#include ""Finalizer.hpp""
#include ""FormatNonstdStringView.hpp""
#include ""MiniTrace.hpp""
#include ""ProgressBar.hpp""
#include ""SignalHandler.hpp""
#include ""StdMakeUnique.hpp""
#include ""Util.hpp""
#include ""argprocessing.hpp""
#include ""cleanup.hpp""
#include ""compopt.hpp""
#include ""compress.hpp""
#include ""exceptions.hpp""
#include ""execute.hpp""
#include ""hash.hpp""
#include ""hashutil.hpp""
#include ""language.hpp""
#include ""logging.hpp""
#include ""manifest.hpp""
#include ""result.hpp""
#include ""stats.hpp""

#include ""third_party/fmt/core.h""
#include ""third_party/nonstd/string_view.hpp""

#ifdef HAVE_GETOPT_LONG
#  include <getopt.h>
#else
#  include ""third_party/getopt_long.h""
#endif

#include <limits>

using nonstd::nullopt;
using nonstd::optional;
using nonstd::string_view;

static const char VERSION_TEXT[] =
  R""(%s version %s

Copyright (C) 2002-2007 Andrew Tridgell
Copyright (C) 2009-2020 Joel Rosdahl and other contributors

See <https://ccache.dev/credits.html> for a complete list of contributors.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 3 of the License, or (at your option) any later
version.
)"";

static const char USAGE_TEXT[] =
  R""(Usage:
    %s [options]
    %s compiler [compiler options]
    compiler [compiler options]          (via symbolic link)

Common options:
    -c, --cleanup             delete old files and recalculate size counters
                              (normally not needed as this is done
                              automatically)
    -C, --clear               clear the cache completely (except configuration)
    -F, --max-files NUM       set maximum number of files in cache to NUM (use 0
                              for no limit)
    -M, --max-size SIZE       set maximum size of cache to SIZE (use 0 for no
                              limit); available suffixes: k, M, G, T (decimal)
                              and Ki, Mi, Gi, Ti (binary); default suffix: G
    -X, --recompress LEVEL    recompress the cache to LEVEL (integer level or
                              ""uncompressed"")
    -x, --show-compression    show compression statistics
    -p, --show-config         show current configuration options in
                              human-readable format
    -s, --show-stats          show summary of configuration and statistics
                              counters in human-readable format
    -z, --zero-stats          zero statistics counters

    -h, --help                print this help text
    -V, --version             print version and copyright information

Options for scripting or debugging:
        --dump-manifest PATH  dump manifest file at PATH in text format
    -k, --get-config KEY      print the value of configuration key KEY
        --hash-file PATH      print the hash (160 bit BLAKE3) of the file at
                              PATH
        --print-stats         print statistics counter IDs and corresponding
                              values in machine-parsable format
    -o, --set-config KEY=VAL  set configuration item KEY to value VAL

See also <https://ccache.dev>.
)"";

enum fromcache_call_mode { FROMCACHE_DIRECT_MODE, FROMCACHE_CPP_MODE };

struct pending_tmp_file
{
  char* path;
  struct pending_tmp_file* next;
};

// How often (in seconds) to scan $CCACHE_DIR/tmp for left-over temporary
// files.
static const int k_tempdir_cleanup_interval = 2 * 24 * 60 * 60; // 2 days

// This is a string that identifies the current ""version"" of the hash sum
// computed by ccache. If, for any reason, we want to force the hash sum to be
// different for the same input in a new ccache version, we can just change
// this string. A typical example would be if the format of one of the files
// stored in the cache changes in a backwards-incompatible way.
static const char HASH_PREFIX[] = ""3"";

static void
add_prefix(const Context& ctx, Args& args, const std::string& prefix_command)
{
  if (prefix_command.empty()) {
    return;
  }

  Args prefix;
  for (const auto& word : Util::split_into_strings(prefix_command, "" "")) {
    std::string path = find_executable(ctx, word.c_str(), MYNAME);
    if (path.empty()) {
      fatal(""%s: %s"", word.c_str(), strerror(errno));
    }

    prefix.push_back(path);
  }

  cc_log(""Using command-line prefix %s"", prefix_command.c_str());
  for (size_t i = prefix.size(); i != 0; i--) {
    args.push_front(prefix[i - 1]);
  }
}

// If `exit_code` is set, just exit with that code directly, otherwise execute
// the real compiler and exit with its exit code. Also updates statistics
// counter `stat` if it's not STATS_NONE.
static void failed(enum stats stat = STATS_NONE,
                   optional<int> exit_code = nullopt) ATTR_NORETURN;

static void
failed(enum stats stat, optional<int> exit_code)
{
  throw Failure(stat, exit_code);
}

static void
clean_up_internal_tempdir(const Config& config)
{
  time_t now = time(nullptr);
  auto dir_st = Stat::stat(config.cache_dir(), Stat::OnError::log);
  if (!dir_st || dir_st.mtime() + k_tempdir_cleanup_interval >= now) {
    // No cleanup needed.
    return;
  }

  update_mtime(config.cache_dir().c_str());

  const std::string& temp_dir = config.temporary_dir();
  if (!Stat::lstat(temp_dir)) {
    return;
  }

  Util::traverse(temp_dir, [now](const std::string& path, bool is_dir) {
    if (is_dir) {
      return;
    }
    auto st = Stat::lstat(path, Stat::OnError::log);
    if (st && st.mtime() + k_tempdir_cleanup_interval < now) {
      Util::unlink_tmp(path);
    }
  });
}

static void
init_hash_debug(Context& ctx,
                struct hash* hash,
                const char* obj_path,
                char type,
                const char* section_name,
                FILE* debug_text_file)
{
  if (!ctx.config.debug()) {
    return;
  }

  std::string path = fmt::format(""{}.ccache-input-{}"", obj_path, type);
  File debug_binary_file(path, ""wb"");
  if (debug_binary_file) {
    hash_enable_debug(
      hash, section_name, debug_binary_file.get(), debug_text_file);
    ctx.hash_debug_files.push_back(std::move(debug_binary_file));
  } else {
    cc_log(""Failed to open %s: %s"", path.c_str(), strerror(errno));
  }
}

static GuessedCompiler
guess_compiler(const char* path)
{
  string_view name = Util::base_name(path);
  GuessedCompiler result = GuessedCompiler::unknown;
  if (name.find(""clang"") != std::string::npos) {
    result = GuessedCompiler::clang;
  } else if (name.find(""gcc"") != std::string::npos
             || name.find(""g++"") != std::string::npos) {
    result = GuessedCompiler::gcc;
  } else if (name.find(""nvcc"") != std::string::npos) {
    result = GuessedCompiler::nvcc;
  } else if (name == ""pump"" || name == ""distcc-pump"") {
    result = GuessedCompiler::pump;
  }
  return result;
}

static bool
do_remember_include_file(Context& ctx,
                         std::string path,
                         struct hash* cpp_hash,
                         bool system,
                         struct hash* depend_mode_hash)
{
  bool is_pch = false;

  if (path.length() >= 2 && path[0] == '<' && path[path.length() - 1] == '>') {
    // Typically <built-in> or <command-line>.
    return true;
  }

  if (path == ctx.args_info.input_file) {
    // Don't remember the input file.
    return true;
  }

  if (system && (ctx.config.sloppiness() & SLOPPY_SYSTEM_HEADERS)) {
    // Don't remember this system header.
    return true;
  }

  if (ctx.included_files.find(path) != ctx.included_files.end()) {
    // Already known include file.
    return true;
  }

  // Canonicalize path for comparison; Clang uses ./header.h.
  if (Util::starts_with(path, ""./"")) {
    path.erase(0, 2);
  }

#ifdef _WIN32
  {
    // stat fails on directories on win32.
    DWORD attributes = GetFileAttributes(path.c_str());
    if (attributes != INVALID_FILE_ATTRIBUTES
        && attributes & FILE_ATTRIBUTE_DIRECTORY) {
      return true;
    }
  }
#endif

  auto st = Stat::stat(path, Stat::OnError::log);
  if (!st) {
    return false;
  }
  if (st.is_directory()) {
    // Ignore directory, typically $PWD.
    return true;
  }
  if (!st.is_regular()) {
    // Device, pipe, socket or other strange creature.
    cc_log(""Non-regular include file %s"", path.c_str());
    return false;
  }

  for (const auto& ignore_header_path : ctx.ignore_header_paths) {
    if (Util::matches_dir_prefix_or_file(ignore_header_path, path)) {
      return true;
    }
  }

  // The comparison using >= is intentional, due to a possible race between
  // starting compilation and writing the include file. See also the notes
  // under ""Performance"" in doc/MANUAL.adoc.
  if (!(ctx.config.sloppiness() & SLOPPY_INCLUDE_FILE_MTIME)
      && st.mtime() >= ctx.time_of_compilation) {
    cc_log(""Include file %s too new"", path.c_str());
    return false;
  }

  // The same >= logic as above applies to the change time of the file.
  if (!(ctx.config.sloppiness() & SLOPPY_INCLUDE_FILE_CTIME)
      && st.ctime() >= ctx.time_of_compilation) {
    cc_log(""Include file %s ctime too new"", path.c_str());
    return false;
  }

  // Let's hash the include file content.
  struct hash* fhash = hash_init();
  Finalizer fhash_finalizer([=] { hash_free(fhash); });

  is_pch = is_precompiled_header(path.c_str());
  if (is_pch) {
    if (ctx.included_pch_file.empty()) {
      cc_log(""Detected use of precompiled header: %s"", path.c_str());
    }
    bool using_pch_sum = false;
    if (ctx.config.pch_external_checksum()) {
      // hash pch.sum instead of pch when it exists
      // to prevent hashing a very large .pch file every time
      std::string pch_sum_path = fmt::format(""{}.sum"", path);
      if (Stat::stat(pch_sum_path, Stat::OnError::log)) {
        path = std::move(pch_sum_path);
        using_pch_sum = true;
        cc_log(""Using pch.sum file %s"", path.c_str());
      }
    }

    if (!hash_binary_file(ctx, fhash, path.c_str())) {
      return false;
    }
    hash_delimiter(cpp_hash, using_pch_sum ? ""pch_sum_hash"" : ""pch_hash"");
    hash_string(cpp_hash, hash_result(fhash).to_string());
  }

  if (ctx.config.direct_mode()) {
    if (!is_pch) { // else: the file has already been hashed.
      int result;
#ifdef INODE_CACHE_SUPPORTED
      if (ctx.config.inode_cache()) {
        result = hash_source_code_file(ctx, fhash, path.c_str());
      } else {
#endif
        char* source = nullptr;
        size_t size;
        if (st.size() > 0) {
          if (!read_file(path.c_str(), st.size(), &source, &size)) {
            return false;
          }
        } else {
          source = x_strdup("""");
          size = 0;
        }

        result =
          hash_source_code_string(ctx, fhash, source, size, path.c_str());
        free(source);
#ifdef INODE_CACHE_SUPPORTED
      }
#endif
      if (result & HASH_SOURCE_CODE_ERROR
          || result & HASH_SOURCE_CODE_FOUND_TIME) {
        return false;
      }
    }

    Digest d = hash_result(fhash);
    ctx.included_files.emplace(path, d);

    if (depend_mode_hash) {
      hash_delimiter(depend_mode_hash, ""include"");
      hash_string(depend_mode_hash, d.to_string());
    }
  }

  return true;
}

// This function hashes an include file and stores the path and hash in the
// global g_included_files variable. If the include file is a PCH, cpp_hash is
// also updated.
static void
remember_include_file(Context& ctx,
                      const std::string& path,
                      struct hash* cpp_hash,
                      bool system,
                      struct hash* depend_mode_hash)
{
  if (!do_remember_include_file(ctx, path, cpp_hash, system, depend_mode_hash)
      && ctx.config.direct_mode()) {
    cc_log(""Disabling direct mode"");
    ctx.config.set_direct_mode(false);
  }
}

static void
print_included_files(const Context& ctx, FILE* fp)
{
  for (const auto& item : ctx.included_files) {
    fprintf(fp, ""%s\n"", item.first.c_str());
  }
}

// This function reads and hashes a file. While doing this, it also does these
// things:
//
// - Makes include file paths for which the base directory is a prefix relative
//   when computing the hash sum.
// - Stores the paths and hashes of included files in the global variable
//   g_included_files.
static bool
process_preprocessed_file(Context& ctx,
                          struct hash* hash,
                          const char* path,
                          bool pump)
{
  char* data;
  size_t size;
  if (!read_file(path, 0, &data, &size)) {
    return false;
  }

  // Bytes between p and q are pending to be hashed.
  char* p = data;
  char* q = data;
  char* end = data + size;

  // There must be at least 7 characters (# 1 ""x"") left to potentially find an
  // include file path.
  while (q < end - 7) {
    // Check if we look at a line containing the file name of an included file.
    // At least the following formats exist (where N is a positive integer):
    //
    // GCC:
    //
    //   # N ""file""
    //   # N ""file"" N
    //   #pragma GCC pch_preprocess ""file""
    //
    // HP's compiler:
    //
    //   #line N ""file""
    //
    // AIX's compiler:
    //
    //   #line N ""file""
    //   #line N
    //
    // Note that there may be other lines starting with '#' left after
    // preprocessing as well, for instance ""#    pragma"".
    if (q[0] == '#'
        // GCC:
        && ((q[1] == ' ' && q[2] >= '0' && q[2] <= '9')
            // GCC precompiled header:
            || (q[1] == 'p'
                && str_startswith(&q[2], ""ragma GCC pch_preprocess ""))
            // HP/AIX:
            || (q[1] == 'l' && q[2] == 'i' && q[3] == 'n' && q[4] == 'e'
                && q[5] == ' '))
        && (q == data || q[-1] == '\n')) {
      // Workarounds for preprocessor linemarker bugs in GCC version 6.
      if (q[2] == '3') {
        if (str_startswith(q, ""# 31 \""<command-line>\""\n"")) {
          // Bogus extra line with #31, after the regular #1: Ignore the whole
          // line, and continue parsing.
          hash_string_buffer(hash, p, q - p);
          while (q < end && *q != '\n') {
            q++;
          }
          q++;
          p = q;
          continue;
        } else if (str_startswith(q, ""# 32 \""<command-line>\"" 2\n"")) {
          // Bogus wrong line with #32, instead of regular #1: Replace the line
          // number with the usual one.
          hash_string_buffer(hash, p, q - p);
          q += 1;
          q[0] = '#';
          q[1] = ' ';
          q[2] = '1';
          p = q;
        }
      }

      while (q < end && *q != '""' && *q != '\n') {
        q++;
      }
      if (q < end && *q == '\n') {
        // A newline before the quotation mark -> no match.
        continue;
      }
      q++;
      if (q >= end) {
        cc_log(""Failed to parse included file path"");
        free(data);
        return false;
      }
      // q points to the beginning of an include file path
      hash_string_buffer(hash, p, q - p);
      p = q;
      while (q < end && *q != '""') {
        q++;
      }
      // Look for preprocessor flags, after the ""filename"".
      bool system = false;
      char* r = q + 1;
      while (r < end && *r != '\n') {
        if (*r == '3') { // System header.
          system = true;
        }
        r++;
      }
      // p and q span the include file path.
      char* inc_path = x_strndup(p, q - p);
      if (!ctx.has_absolute_include_headers) {
        ctx.has_absolute_include_headers = Util::is_absolute_path(inc_path);
      }
      char* saved_inc_path = inc_path;
      inc_path = x_strdup(Util::make_relative_path(ctx, inc_path).c_str());
      free(saved_inc_path);

      bool should_hash_inc_path = true;
      if (!ctx.config.hash_dir()) {
        if (Util::starts_with(inc_path, ctx.apparent_cwd)
            && str_endswith(inc_path, ""//"")) {
          // When compiling with -g or similar, GCC adds the absolute path to
          // CWD like this:
          //
          //   # 1 ""CWD//""
          //
          // If the user has opted out of including the CWD in the hash, don't
          // hash it. See also how debug_prefix_map is handled.
          should_hash_inc_path = false;
        }
      }
      if (should_hash_inc_path) {
        hash_string_buffer(hash, inc_path, strlen(inc_path));
      }

      remember_include_file(ctx, inc_path, hash, system, nullptr);
      free(inc_path);
      p = q; // Everything of interest between p and q has been hashed now.
    } else if (q[0] == '.' && q[1] == 'i' && q[2] == 'n' && q[3] == 'c'
               && q[4] == 'b' && q[5] == 'i' && q[6] == 'n') {
      // An assembler .inc bin (without the space) statement, which could be
      // part of inline assembly, refers to an external file. If the file
      // changes, the hash should change as well, but finding out what file to
      // hash is too hard for ccache, so just bail out.
      cc_log(
        ""Found unsupported .inc""
        ""bin directive in source code"");
      failed(STATS_UNSUPPORTED_DIRECTIVE);
    } else if (pump && strncmp(q, ""_________"", 9) == 0) {
      // Unfortunately the distcc-pump wrapper outputs standard output lines:
      // __________Using distcc-pump from /usr/bin
      // __________Using # distcc servers in pump mode
      // __________Shutting down distcc-pump include server
      while (q < end && *q != '\n') {
        q++;
      }
      if (*q == '\n') {
        q++;
      }
      p = q;
      continue;
    } else {
      q++;
    }
  }

  hash_string_buffer(hash, p, (end - p));
  free(data);

  // Explicitly check the .gch/.pch/.pth file as Clang does not include any
  // mention of it in the preprocessed output.
  if (!ctx.included_pch_file.empty()) {
    std::string pch_path =
      Util::make_relative_path(ctx, ctx.included_pch_file.c_str());
    hash_string(hash, pch_path);
    remember_include_file(ctx, pch_path, hash, false, nullptr);
  }

  bool debug_included = getenv(""CCACHE_DEBUG_INCLUDED"");
  if (debug_included) {
    print_included_files(ctx, stdout);
  }

  return true;
}

// Replace absolute paths with relative paths in the provided dependency file.
static void
use_relative_paths_in_depfile(const Context& ctx)
{
  if (ctx.config.base_dir().empty()) {
    cc_log(""Base dir not set, skip using relative paths"");
    return; // nothing to do
  }
  if (!ctx.has_absolute_include_headers) {
    cc_log(
      ""No absolute path for included files found, skip using relative paths"");
    return; // nothing to do
  }

  const std::string& output_dep = ctx.args_info.output_dep;
  std::string file_content;
  try {
    file_content = Util::read_file(output_dep);
  } catch (const Error& e) {
    cc_log(""Cannot open dependency file %s: %s"", output_dep.c_str(), e.what());
    return;
  }

  std::string adjusted_file_content;
  adjusted_file_content.reserve(file_content.size());

  bool rewritten = false;

  for (string_view token : Util::split_into_views(file_content, "" \t\r\n"")) {
    if (Util::is_absolute_path(token)
        && token.starts_with(ctx.config.base_dir())) {
      adjusted_file_content.append(Util::make_relative_path(ctx, token));
      rewritten = true;
    } else {
      adjusted_file_content.append(token.begin(), token.end());
    }
    adjusted_file_content.push_back(' ');
  }

  if (!rewritten) {
    cc_log(
      ""No paths in dependency file %s made relative, skip relative path usage"",
      output_dep.c_str());
    return;
  }

  std::string tmp_file = fmt::format(""{}.tmp{}"", output_dep, tmp_string());

  try {
    Util::write_file(tmp_file, adjusted_file_content);
  } catch (const Error& e) {
    cc_log(
      ""Error writing temporary dependency file %s (%s), skip relative path""
      "" usage"",
      tmp_file.c_str(),
      e.what());
    Util::unlink_safe(tmp_file);
    return;
  }

  if (x_rename(tmp_file.c_str(), output_dep.c_str()) != 0) {
    cc_log(
      ""Error renaming dependency file: %s -> %s (%s), skip relative path usage"",
      tmp_file.c_str(),
      output_dep.c_str(),
      strerror(errno));
    Util::unlink_safe(tmp_file);
  } else {
    cc_log(""Renamed dependency file: %s -> %s"",
           tmp_file.c_str(),
           output_dep.c_str());
  }
}

// Extract the used includes from the dependency file. Note that we cannot
// distinguish system headers from other includes here.
static optional<Digest>
result_name_from_depfile(Context& ctx, struct hash* hash)
{
  std::string file_content;
  try {
    file_content = Util::read_file(ctx.args_info.output_dep);
  } catch (const Error& e) {
    cc_log(""Cannot open dependency file %s: %s"",
           ctx.args_info.output_dep.c_str(),
           e.what());
    return nullopt;
  }

  for (string_view token : Util::split_into_views(file_content, "" \t\r\n"")) {
    if (token == ""\\"" || token.ends_with("":"")) {
      continue;
    }
    if (!ctx.has_absolute_include_headers) {
      ctx.has_absolute_include_headers = Util::is_absolute_path(token);
    }
    std::string path = Util::make_relative_path(ctx, token);
    remember_include_file(ctx, path, hash, false, hash);
  }

  // Explicitly check the .gch/.pch/.pth file as it may not be mentioned in the
  // dependencies output.
  if (!ctx.included_pch_file.empty()) {
    std::string pch_path =
      Util::make_relative_path(ctx, ctx.included_pch_file.c_str());
    hash_string(hash, pch_path);
    remember_include_file(ctx, pch_path, hash, false, nullptr);
  }

  bool debug_included = getenv(""CCACHE_DEBUG_INCLUDED"");
  if (debug_included) {
    print_included_files(ctx, stdout);
  }

  return hash_result(hash);
}

// Execute the compiler/preprocessor, with logic to retry without requesting
// colored diagnostics messages if that fails.
static int
execute(Context& ctx,
        Args& args,
        const std::string& stdout_path,
        int stdout_fd,
        const std::string& stderr_path,
        int stderr_fd)
{
  if (ctx.diagnostics_color_failed
      && ctx.guessed_compiler == GuessedCompiler::gcc) {
    args.erase_with_prefix(""-fdiagnostics-color"");
  }
  int status =
    execute(args.to_argv().data(), stdout_fd, stderr_fd, &ctx.compiler_pid);
  if (status != 0 && !ctx.diagnostics_color_failed
      && ctx.guessed_compiler == GuessedCompiler::gcc) {
    auto errors = Util::read_file(stderr_path);
    if (errors.find(""unrecognized command-line option"") != std::string::npos
        && errors.find(""-fdiagnostics-color"") != std::string::npos) {
      // Old versions of GCC did not support colored diagnostics.
      cc_log(""-fdiagnostics-color is unsupported; trying again without it"");
      if (ftruncate(stdout_fd, 0) < 0 || lseek(stdout_fd, 0, SEEK_SET) < 0) {
        cc_log(
          ""Failed to truncate %s: %s"", stdout_path.c_str(), strerror(errno));
        failed(STATS_ERROR);
      }
      if (ftruncate(stderr_fd, 0) < 0 || lseek(stderr_fd, 0, SEEK_SET) < 0) {
        cc_log(
          ""Failed to truncate %s: %s"", stderr_path.c_str(), strerror(errno));
        failed(STATS_ERROR);
      }
      ctx.diagnostics_color_failed = true;
      return execute(ctx, args, stdout_path, stdout_fd, stderr_path, stderr_fd);
    }
  }
  return status;
}

// Send cached stderr, if any, to stderr.
static void
send_cached_stderr(const std::string& path_stderr, bool strip_colors)
{
  if (strip_colors) {
    try {
      auto stripped = Util::strip_ansi_csi_seqs(Util::read_file(path_stderr));
      write_fd(STDERR_FILENO, stripped.data(), stripped.size());
    } catch (const Error&) {
      // Fall through
    }
  } else {
    Fd fd_stderr(open(path_stderr.c_str(), O_RDONLY | O_BINARY));
    if (fd_stderr) {
      copy_fd(*fd_stderr, STDERR_FILENO);
    }
  }
}

// Create or update the manifest file.
static void
update_manifest_file(Context& ctx)
{
  if (!ctx.config.direct_mode() || ctx.config.read_only()
      || ctx.config.read_only_direct()) {
    return;
  }

  auto old_st = Stat::stat(ctx.manifest_path());

  // See comment in get_file_hash_index for why saving of timestamps is forced
  // for precompiled headers.
  bool save_timestamp = (ctx.config.sloppiness() & SLOPPY_FILE_STAT_MATCHES)
                        || ctx.args_info.output_is_precompiled_header;

  MTR_BEGIN(""manifest"", ""manifest_put"");
  cc_log(""Adding result name to %s"", ctx.manifest_path().c_str());
  if (!manifest_put(ctx.config,
                    ctx.manifest_path(),
                    ctx.result_name(),
                    ctx.included_files,
                    ctx.time_of_compilation,
                    save_timestamp)) {
    cc_log(""Failed to add result name to %s"", ctx.manifest_path().c_str());
  } else {
    auto st = Stat::stat(ctx.manifest_path(), Stat::OnError::log);

    int64_t size_delta = st.size_on_disk() - old_st.size_on_disk();
    int nof_files_delta = !old_st && st ? 1 : 0;

    if (ctx.stats_file() == ctx.manifest_stats_file()) {
      stats_update_size(ctx.counter_updates, size_delta, nof_files_delta);
    } else {
      Counters counters;
      stats_update_size(counters, size_delta, nof_files_delta);
      stats_flush_to_file(ctx.config, ctx.manifest_stats_file(), counters);
    }
  }
  MTR_END(""manifest"", ""manifest_put"");
}

static bool
create_cachedir_tag(nonstd::string_view dir)
{
  constexpr char cachedir_tag[] =
    ""Signature: 8a477f597d28d172789f06886806bc55\n""
    ""# This file is a cache directory tag created by ccache.\n""
    ""# For information about cache directory tags, see:\n""
    ""#\thttp://www.brynosaurus.com/cachedir/\n"";

  std::string filename = fmt::format(""{}/CACHEDIR.TAG"", dir);
  auto st = Stat::stat(filename);

  if (st) {
    if (st.is_regular()) {
      return true;
    }
    errno = EEXIST;
    return false;
  }

  File f(filename, ""w"");

  if (!f) {
    return false;
  }

  return fwrite(cachedir_tag, strlen(cachedir_tag), 1, f.get()) == 1;
}

// Run the real compiler and put the result in cache.
static void
to_cache(Context& ctx,
         Args& args,
         Args& depend_extra_args,
         struct hash* depend_mode_hash)
{
  args.push_back(""-o"");
  args.push_back(ctx.args_info.output_obj);

  if (ctx.config.hard_link() && ctx.args_info.output_obj != ""/dev/null"") {
    // Workaround for Clang bug where it overwrites an existing object file
    // when it's compiling an assembler file, see
    // <https://bugs.llvm.org/show_bug.cgi?id=39782>.
    Util::unlink_safe(ctx.args_info.output_obj);
  }

  if (ctx.args_info.generating_diagnostics) {
    args.push_back(""--serialize-diagnostics"");
    args.push_back(ctx.args_info.output_dia);
  }

  // Turn off DEPENDENCIES_OUTPUT when running cc1, because otherwise it will
  // emit a line like this:
  //
  //   tmp.stdout.vexed.732.o: /home/mbp/.ccache/tmp.stdout.vexed.732.i
  x_unsetenv(""DEPENDENCIES_OUTPUT"");
  x_unsetenv(""SUNPRO_DEPENDENCIES"");

  if (ctx.config.run_second_cpp()) {
    args.push_back(ctx.args_info.input_file);
  } else {
    args.push_back(ctx.i_tmpfile);
  }

  if (ctx.args_info.seen_split_dwarf) {
    // Remove any pre-existing .dwo file since we want to check if the compiler
    // produced one, intentionally not using x_unlink or tmp_unlink since we're
    // not interested in logging successful deletions or failures due to
    // non-existent .dwo files.
    if (unlink(ctx.args_info.output_dwo.c_str()) != 0 && errno != ENOENT
        && errno != ESTALE) {
      cc_log(""Failed to unlink %s: %s"",
             ctx.args_info.output_dwo.c_str(),
             strerror(errno));
      failed(STATS_BADOUTPUTFILE);
    }
  }

  cc_log(""Running real compiler"");
  MTR_BEGIN(""execute"", ""compiler"");

  const auto tmp_stdout_fd_and_path = Util::create_temp_fd(
    fmt::format(""{}/tmp.stdout"", ctx.config.temporary_dir()));
  int tmp_stdout_fd = tmp_stdout_fd_and_path.first;
  const std::string& tmp_stdout = tmp_stdout_fd_and_path.second;
  ctx.register_pending_tmp_file(tmp_stdout);

  const auto tmp_stderr_fd_and_path = Util::create_temp_fd(
    fmt::format(""{}/tmp.stderr"", ctx.config.temporary_dir()));
  int tmp_stderr_fd = tmp_stderr_fd_and_path.first;
  const std::string& tmp_stderr = tmp_stderr_fd_and_path.second;
  ctx.register_pending_tmp_file(tmp_stderr);

  int status;
  if (!ctx.config.depend_mode()) {
    status =
      execute(ctx, args, tmp_stdout, tmp_stdout_fd, tmp_stderr, tmp_stderr_fd);
    args.pop_back(3);
  } else {
    // Use the original arguments (including dependency options) in depend
    // mode.
    Args depend_mode_args = ctx.orig_args;
    depend_mode_args.erase_with_prefix(""--ccache-"");
    depend_mode_args.push_back(depend_extra_args);
    add_prefix(ctx, depend_mode_args, ctx.config.prefix_command());

    ctx.time_of_compilation = time(nullptr);
    status = execute(ctx,
                     depend_mode_args,
                     tmp_stdout,
                     tmp_stdout_fd,
                     tmp_stderr,
                     tmp_stderr_fd);
  }
  MTR_END(""execute"", ""compiler"");

  auto st = Stat::stat(tmp_stdout, Stat::OnError::log);
  if (!st) {
    // The stdout file was removed - cleanup in progress? Better bail out.
    failed(STATS_MISSING);
  }

  // distcc-pump outputs lines like this:
  // __________Using # distcc servers in pump mode
  if (st.size() != 0 && ctx.guessed_compiler != GuessedCompiler::pump) {
    cc_log(""Compiler produced stdout"");
    failed(STATS_STDOUT);
  }

  // Merge stderr from the preprocessor (if any) and stderr from the real
  // compiler into tmp_stderr.
  if (!ctx.cpp_stderr.empty()) {
    std::string combined_stderr =
      Util::read_file(ctx.cpp_stderr) + Util::read_file(tmp_stderr);
    Util::write_file(tmp_stderr, combined_stderr);
  }

  if (status != 0) {
    cc_log(""Compiler gave exit status %d"", status);

    // We can output stderr immediately instead of rerunning the compiler.
    send_cached_stderr(tmp_stderr, ctx.args_info.strip_diagnostics_colors);

    failed(STATS_STATUS, status);
  }

  if (ctx.config.depend_mode()) {
    auto result_name = result_name_from_depfile(ctx, depend_mode_hash);
    if (!result_name) {
      failed(STATS_ERROR);
    }
    ctx.set_result_name(*result_name);
  }

  bool produce_dep_file = ctx.args_info.generating_dependencies
                          && ctx.args_info.output_dep != ""/dev/null"";

  if (produce_dep_file) {
    use_relative_paths_in_depfile(ctx);
  }

  st = Stat::stat(ctx.args_info.output_obj);
  if (!st) {
    cc_log(""Compiler didn't produce an object file"");
    failed(STATS_NOOUTPUT);
  }
  if (st.size() == 0) {
    cc_log(""Compiler produced an empty object file"");
    failed(STATS_EMPTYOUTPUT);
  }

  st = Stat::stat(tmp_stderr, Stat::OnError::log);
  if (!st) {
    failed(STATS_ERROR);
  }
  ResultFileMap result_file_map;
  if (st.size() > 0) {
    result_file_map.emplace(FileType::stderr_output, tmp_stderr);
  }
  result_file_map.emplace(FileType::object, ctx.args_info.output_obj);
  if (ctx.args_info.generating_dependencies) {
    result_file_map.emplace(FileType::dependency, ctx.args_info.output_dep);
  }
  if (ctx.args_info.generating_coverage) {
    result_file_map.emplace(FileType::coverage, ctx.args_info.output_cov);
  }
  if (ctx.args_info.generating_stackusage) {
    result_file_map.emplace(FileType::stackusage, ctx.args_info.output_su);
  }
  if (ctx.args_info.generating_diagnostics) {
    result_file_map.emplace(FileType::diagnostic, ctx.args_info.output_dia);
  }
  if (ctx.args_info.seen_split_dwarf && Stat::stat(ctx.args_info.output_dwo)) {
    // Only copy .dwo file if it was created by the compiler (GCC and Clang
    // behave differently e.g. for ""-gsplit-dwarf -g1"").
    result_file_map.emplace(FileType::dwarf_object, ctx.args_info.output_dwo);
  }

  auto orig_dest_stat = Stat::stat(ctx.result_path());
  result_put(ctx, ctx.result_path(), result_file_map);

  cc_log(""Stored in cache: %s"", ctx.result_path().c_str());

  auto new_dest_stat = Stat::stat(ctx.result_path(), Stat::OnError::log);
  if (!new_dest_stat) {
    failed(STATS_ERROR);
  }
  stats_update_size(ctx.counter_updates,
                    new_dest_stat.size_on_disk()
                      - orig_dest_stat.size_on_disk(),
                    orig_dest_stat ? 0 : 1);

  MTR_END(""file"", ""file_put"");

  // Make sure we have a CACHEDIR.TAG in the cache part of cache_dir. This can
  // be done almost anywhere, but we might as well do it near the end as we
  // save the stat call if we exit early.
  {
    std::string first_level_dir(Util::dir_name(ctx.stats_file()));
    if (!create_cachedir_tag(first_level_dir)) {
      cc_log(""Failed to create %s/CACHEDIR.TAG (%s)"",
             first_level_dir.c_str(),
             strerror(errno));
    }

    // Remove any CACHEDIR.TAG on the cache_dir level where it was located in
    // previous ccache versions.
    if (getpid() % 1000 == 0) {
      char* path = format(""%s/CACHEDIR.TAG"", ctx.config.cache_dir().c_str());
      Util::unlink_safe(path);
      free(path);
    }
  }

  // Everything OK.
  send_cached_stderr(tmp_stderr, ctx.args_info.strip_diagnostics_colors);
}

// Find the result name by running the compiler in preprocessor mode and
// hashing the result.
static Digest
get_result_name_from_cpp(Context& ctx, Args& args, struct hash* hash)
{
  ctx.time_of_compilation = time(nullptr);

  std::string stderr_path;
  std::string stdout_path;
  int status;
  if (ctx.args_info.direct_i_file) {
    // We are compiling a .i or .ii file - that means we can skip the cpp stage
    // and directly form the correct i_tmpfile.
    stdout_path = ctx.args_info.input_file;
    status = 0;
  } else {
    // Run cpp on the input file to obtain the .i.

    // Limit the basename to 10 characters in order to cope with filesystem with
    // small maximum filename length limits.
    string_view input_base =
      Util::get_truncated_base_name(ctx.args_info.input_file, 10);
    auto stdout_fd_and_path = Util::create_temp_fd(
      fmt::format(""{}/{}.stdout"", ctx.config.temporary_dir(), input_base));
    int stdout_fd = stdout_fd_and_path.first;
    stdout_path = stdout_fd_and_path.second;
    ctx.register_pending_tmp_file(stdout_path);

    auto stderr_fd_and_path = Util::create_temp_fd(
      fmt::format(""{}/tmp.cpp_stderr"", ctx.config.temporary_dir()));
    int stderr_fd = stderr_fd_and_path.first;
    stderr_path = stderr_fd_and_path.second;
    ctx.register_pending_tmp_file(stderr_path);

    size_t args_added = 2;
    args.push_back(""-E"");
    if (ctx.config.keep_comments_cpp()) {
      args.push_back(""-C"");
      args_added = 3;
    }
    args.push_back(ctx.args_info.input_file);
    add_prefix(ctx, args, ctx.config.prefix_command_cpp());
    cc_log(""Running preprocessor"");
    MTR_BEGIN(""execute"", ""preprocessor"");
    status = execute(ctx, args, stdout_path, stdout_fd, stderr_path, stderr_fd);
    MTR_END(""execute"", ""preprocessor"");
    args.pop_back(args_added);
  }

  if (status != 0) {
    cc_log(""Preprocessor gave exit status %d"", status);
    failed(STATS_PREPROCESSOR);
  }

  hash_delimiter(hash, ""cpp"");
  bool is_pump = ctx.guessed_compiler == GuessedCompiler::pump;
  if (!process_preprocessed_file(ctx, hash, stdout_path.c_str(), is_pump)) {
    failed(STATS_ERROR);
  }

  hash_delimiter(hash, ""cppstderr"");
  if (!ctx.args_info.direct_i_file
      && !hash_binary_file(ctx, hash, stderr_path.c_str())) {
    // Somebody removed the temporary file?
    cc_log(""Failed to open %s: %s"", stderr_path.c_str(), strerror(errno));
    failed(STATS_ERROR);
  }

  if (ctx.args_info.direct_i_file) {
    ctx.i_tmpfile = ctx.args_info.input_file;
  } else {
    // i_tmpfile needs the proper cpp_extension for the compiler to do its
    // thing correctly
    ctx.i_tmpfile =
      fmt::format(""{}.{}"", stdout_path, ctx.config.cpp_extension());
    x_rename(stdout_path.c_str(), ctx.i_tmpfile.c_str());
    ctx.register_pending_tmp_file(ctx.i_tmpfile);
  }

  if (!ctx.config.run_second_cpp()) {
    // If we are using the CPP trick, we need to remember this stderr data and
    // output it just before the main stderr from the compiler pass.
    ctx.cpp_stderr = stderr_path;
    hash_delimiter(hash, ""runsecondcpp"");
    hash_string(hash, ""false"");
  }

  return hash_result(hash);
}

// Hash mtime or content of a file, or the output of a command, according to
// the CCACHE_COMPILERCHECK setting.
static void
hash_compiler(const Context& ctx,
              struct hash* hash,
              const Stat& st,
              const char* path,
              bool allow_command)
{
  if (ctx.config.compiler_check() == ""none"") {
    // Do nothing.
  } else if (ctx.config.compiler_check() == ""mtime"") {
    hash_delimiter(hash, ""cc_mtime"");
    hash_int(hash, st.size());
    hash_int(hash, st.mtime());
  } else if (Util::starts_with(ctx.config.compiler_check(), ""string:"")) {
    hash_delimiter(hash, ""cc_hash"");
    hash_string(hash, ctx.config.compiler_check().c_str() + strlen(""string:""));
  } else if (ctx.config.compiler_check() == ""content"" || !allow_command) {
    hash_delimiter(hash, ""cc_content"");
    hash_binary_file(ctx, hash, path);
  } else { // command string
    if (!hash_multicommand_output(hash,
                                  ctx.config.compiler_check().c_str(),
                                  ctx.orig_args[0].c_str())) {
      cc_log(""Failure running compiler check command: %s"",
             ctx.config.compiler_check().c_str());
      failed(STATS_COMPCHECK);
    }
  }
}

// Hash the host compiler(s) invoked by nvcc.
//
// If ccbin_st and ccbin are set, they refer to a directory or compiler set
// with -ccbin/--compiler-bindir. If they are NULL, the compilers are looked up
// in PATH instead.
static void
hash_nvcc_host_compiler(const Context& ctx,
                        struct hash* hash,
                        const Stat* ccbin_st,
                        const char* ccbin)
{
  // From <http://docs.nvidia.com/cuda/cuda-compiler-driver-nvcc/index.html>:
  //
  //   ""[...] Specify the directory in which the compiler executable resides.
  //   The host compiler executable name can be also specified to ensure that
  //   the correct host compiler is selected.""
  //
  // and
  //
  //   ""On all platforms, the default host compiler executable (gcc and g++ on
  //   Linux, clang and clang++ on Mac OS X, and cl.exe on Windows) found in
  //   the current execution search path will be used"".

  if (!ccbin || ccbin_st->is_directory()) {
#if defined(__APPLE__)
    const char* compilers[] = {""clang"", ""clang++""};
#elif defined(_WIN32)
    const char* compilers[] = {""cl.exe""};
#else
    const char* compilers[] = {""gcc"", ""g++""};
#endif
    for (const char* compiler : compilers) {
      if (ccbin) {
        char* path = format(""%s/%s"", ccbin, compiler);
        auto st = Stat::stat(path);
        if (st) {
          hash_compiler(ctx, hash, st, path, false);
        }
        free(path);
      } else {
        std::string path = find_executable(ctx, compiler, MYNAME);
        if (!path.empty()) {
          auto st = Stat::stat(path, Stat::OnError::log);
          hash_compiler(ctx, hash, st, ccbin, false);
        }
      }
    }
  } else {
    hash_compiler(ctx, hash, *ccbin_st, ccbin, false);
  }
}

// Update a hash with information common for the direct and preprocessor modes.
static void
hash_common_info(const Context& ctx,
                 const Args& args,
                 struct hash* hash,
                 const ArgsInfo& args_info)
{
  hash_string(hash, HASH_PREFIX);

  // We have to hash the extension, as a .i file isn't treated the same by the
  // compiler as a .ii file.
  hash_delimiter(hash, ""ext"");
  hash_string(hash, ctx.config.cpp_extension().c_str());

#ifdef _WIN32
  const char* ext = strrchr(args[0].c_str(), '.');
  char full_path_win_ext[MAX_PATH + 1] = {0};
  add_exe_ext_if_no_to_fullpath(
    full_path_win_ext, MAX_PATH, ext, args[0].c_str());
  const char* full_path = full_path_win_ext;
#else
  const char* full_path = args[0].c_str();
#endif

  auto st = Stat::stat(full_path, Stat::OnError::log);
  if (!st) {
    failed(STATS_COMPILER);
  }

  // Hash information about the compiler.
  hash_compiler(ctx, hash, st, args[0].c_str(), true);

  // Also hash the compiler name as some compilers use hard links and behave
  // differently depending on the real name.
  hash_delimiter(hash, ""cc_name"");
  string_view base = Util::base_name(args[0]);
  hash_string_view(hash, base);

  if (!(ctx.config.sloppiness() & SLOPPY_LOCALE)) {
    // Hash environment variables that may affect localization of compiler
    // warning messages.
    const char* envvars[] = {
      ""LANG"", ""LC_ALL"", ""LC_CTYPE"", ""LC_MESSAGES"", nullptr};
    for (const char** p = envvars; *p; ++p) {
      char* v = getenv(*p);
      if (v) {
        hash_delimiter(hash, *p);
        hash_string(hash, v);
      }
    }
  }

  // Possibly hash the current working directory.
  if (args_info.generating_debuginfo && ctx.config.hash_dir()) {
    std::string dir_to_hash = ctx.apparent_cwd;
    for (const auto& map : args_info.debug_prefix_maps) {
      size_t sep_pos = map.find('=');
      if (sep_pos != std::string::npos) {
        std::string old_path = map.substr(0, sep_pos);
        std::string new_path = map.substr(sep_pos + 1);
        cc_log(""Relocating debuginfo from %s to %s (CWD: %s)"",
               old_path.c_str(),
               new_path.c_str(),
               ctx.apparent_cwd.c_str());
        if (Util::starts_with(ctx.apparent_cwd, old_path)) {
          dir_to_hash = new_path + ctx.apparent_cwd.substr(old_path.size());
        }
      }
    }
    cc_log(""Hashing CWD %s"", dir_to_hash.c_str());
    hash_delimiter(hash, ""cwd"");
    hash_string(hash, dir_to_hash);
  }

  if (ctx.args_info.generating_dependencies || ctx.args_info.seen_split_dwarf) {
    // The output object file name is part of the .d file, so include the path
    // in the hash if generating dependencies.
    //
    // Object files include a link to the corresponding .dwo file based on the
    // target object filename when using -gsplit-dwarf, so hashing the object
    // file path will do it, although just hashing the object file base name
    // would be enough.
    hash_delimiter(hash, ""object file"");
    hash_string_view(hash, ctx.args_info.output_obj);
  }

  // Possibly hash the coverage data file path.
  if (ctx.args_info.generating_coverage && ctx.args_info.profile_arcs) {
    std::string dir;
    if (!ctx.args_info.profile_path.empty()) {
      dir = ctx.args_info.profile_path;
    } else {
      dir =
        Util::real_path(std::string(Util::dir_name(ctx.args_info.output_obj)));
    }
    string_view stem =
      Util::remove_extension(Util::base_name(ctx.args_info.output_obj));
    std::string gcda_path = fmt::format(""{}/{}.gcda"", dir, stem);
    cc_log(""Hashing coverage path %s"", gcda_path.c_str());
    hash_delimiter(hash, ""gcda"");
    hash_string(hash, gcda_path);
  }

  // Possibly hash the sanitize blacklist file path.
  for (const auto& sanitize_blacklist : args_info.sanitize_blacklists) {
    cc_log(""Hashing sanitize blacklist %s"", sanitize_blacklist.c_str());
    hash_delimiter(hash, ""sanitizeblacklist"");
    if (!hash_binary_file(ctx, hash, sanitize_blacklist.c_str())) {
      failed(STATS_BADEXTRAFILE);
    }
  }

  if (!ctx.config.extra_files_to_hash().empty()) {
    for (const std::string& path : Util::split_into_strings(
           ctx.config.extra_files_to_hash(), PATH_DELIM)) {
      cc_log(""Hashing extra file %s"", path.c_str());
      hash_delimiter(hash, ""extrafile"");
      if (!hash_binary_file(ctx, hash, path.c_str())) {
        failed(STATS_BADEXTRAFILE);
      }
    }
  }

  // Possibly hash GCC_COLORS (for color diagnostics).
  if (ctx.guessed_compiler == GuessedCompiler::gcc) {
    const char* gcc_colors = getenv(""GCC_COLORS"");
    if (gcc_colors) {
      hash_delimiter(hash, ""gcccolors"");
      hash_string(hash, gcc_colors);
    }
  }
}

static bool
hash_profile_data_file(const Context& ctx, struct hash* hash)
{
  const std::string& profile_path = ctx.args_info.profile_path;
  string_view base_name = Util::remove_extension(ctx.args_info.output_obj);
  std::string hashified_cwd = ctx.apparent_cwd;
  std::replace(hashified_cwd.begin(), hashified_cwd.end(), '/', '#');

  std::vector<std::string> paths_to_try{
    // -fprofile-use[=dir]/-fbranch-probabilities (GCC <9)
    fmt::format(""{}/{}.gcda"", profile_path, base_name),
    // -fprofile-use[=dir]/-fbranch-probabilities (GCC >=9)
    fmt::format(""{}/{}#{}.gcda"", profile_path, hashified_cwd, base_name),
    // -fprofile(-instr|-sample)-use=file (Clang), -fauto-profile=file (GCC >=5)
    profile_path,
    // -fprofile(-instr|-sample)-use=dir (Clang)
    fmt::format(""{}/default.profdata"", profile_path),
    // -fauto-profile (GCC >=5)
    ""fbdata.afdo"", // -fprofile-dir is not used
  };

  bool found = false;
  for (const std::string& p : paths_to_try) {
    cc_log(""Checking for profile data file %s"", p.c_str());
    auto st = Stat::stat(p);
    if (st && !st.is_directory()) {
      cc_log(""Adding profile data %s to the hash"", p.c_str());
      hash_delimiter(hash, ""-fprofile-use"");
      if (hash_binary_file(ctx, hash, p.c_str())) {
        found = true;
      }
    }
  }

  return found;
}

// Update a hash sum with information specific to the direct and preprocessor
// modes and calculate the result name. Returns the result name on success,
// otherwise NULL. Caller frees.
static optional<Digest>
calculate_result_name(Context& ctx,
                      const Args& args,
                      Args& preprocessor_args,
                      struct hash* hash,
                      bool direct_mode)
{
  bool found_ccbin = false;

  hash_delimiter(hash, ""result version"");
  hash_int(hash, k_result_version);

  if (direct_mode) {
    hash_delimiter(hash, ""manifest version"");
    hash_int(hash, k_manifest_version);
  }

  // clang will emit warnings for unused linker flags, so we shouldn't skip
  // those arguments.
  int is_clang = ctx.guessed_compiler == GuessedCompiler::clang
                 || ctx.guessed_compiler == GuessedCompiler::unknown;

  // First the arguments.
  for (size_t i = 1; i < args.size(); i++) {
    // -L doesn't affect compilation (except for clang).
    if (i < args.size() - 1 && args[i] == ""-L"" && !is_clang) {
      i++;
      continue;
    }
    if (Util::starts_with(args[i], ""-L"") && !is_clang) {
      continue;
    }

    // -Wl,... doesn't affect compilation (except for clang).
    if (Util::starts_with(args[i], ""-Wl,"") && !is_clang) {
      continue;
    }

    // The -fdebug-prefix-map option may be used in combination with
    // CCACHE_BASEDIR to reuse results across different directories. Skip using
    // the value of the option from hashing but still hash the existence of the
    // option.
    if (Util::starts_with(args[i], ""-fdebug-prefix-map="")) {
      hash_delimiter(hash, ""arg"");
      hash_string(hash, ""-fdebug-prefix-map="");
      continue;
    }
    if (Util::starts_with(args[i], ""-ffile-prefix-map="")) {
      hash_delimiter(hash, ""arg"");
      hash_string(hash, ""-ffile-prefix-map="");
      continue;
    }
    if (Util::starts_with(args[i], ""-fmacro-prefix-map="")) {
      hash_delimiter(hash, ""arg"");
      hash_string(hash, ""-fmacro-prefix-map="");
      continue;
    }

    // When using the preprocessor, some arguments don't contribute to the
    // hash. The theory is that these arguments will change the output of -E if
    // they are going to have any effect at all. For precompiled headers this
    // might not be the case.
    if (!direct_mode && !ctx.args_info.output_is_precompiled_header
        && !ctx.args_info.using_precompiled_header) {
      if (compopt_affects_cpp(args[i])) {
        if (compopt_takes_arg(args[i])) {
          i++;
        }
        continue;
      }
      if (compopt_short(compopt_affects_cpp, args[i])) {
        continue;
      }
    }

    // If we're generating dependencies, we make sure to skip the filename of
    // the dependency file, since it doesn't impact the output.
    if (ctx.args_info.generating_dependencies) {
      if (Util::starts_with(args[i], ""-Wp,"")) {
        if (Util::starts_with(args[i], ""-Wp,-MD,"")
            && !strchr(args[i].c_str() + 8, ',')) {
          hash_string_buffer(hash, args[i].c_str(), 8);
          continue;
        } else if (Util::starts_with(args[i], ""-Wp,-MMD,"")
                   && !strchr(args[i].c_str() + 9, ',')) {
          hash_string_buffer(hash, args[i].c_str(), 9);
          continue;
        }
      } else if (Util::starts_with(args[i], ""-MF"")) {
        // In either case, hash the ""-MF"" part.
        hash_delimiter(hash, ""arg"");
        hash_string_buffer(hash, args[i].c_str(), 3);

        if (ctx.args_info.output_dep != ""/dev/null"") {
          bool separate_argument = (args[i].size() == 3);
          if (separate_argument) {
            // Next argument is dependency name, so skip it.
            i++;
          }
        }
        continue;
      }
    }

    const char* p = nullptr;
    if (Util::starts_with(args[i], ""-specs="")) {
      p = args[i].c_str() + 7;
    } else if (Util::starts_with(args[i], ""--specs="")) {
      p = args[i].c_str() + 8;
    }

    if (p) {
      auto st = Stat::stat(p, Stat::OnError::log);
      if (st) {
        // If given an explicit specs file, then hash that file, but don't
        // include the path to it in the hash.
        hash_delimiter(hash, ""specs"");
        hash_compiler(ctx, hash, st, p, false);
        continue;
      }
    }

    if (Util::starts_with(args[i], ""-fplugin="")) {
      auto st = Stat::stat(args[i].c_str() + 9, Stat::OnError::log);
      if (st) {
        hash_delimiter(hash, ""plugin"");
        hash_compiler(ctx, hash, st, args[i].c_str() + 9, false);
        continue;
      }
    }

    if (args[i] == ""-Xclang"" && i + 3 < args.size() && args[i + 1] == ""-load""
        && args[i + 2] == ""-Xclang"") {
      auto st = Stat::stat(args[i + 3], Stat::OnError::log);
      if (st) {
        hash_delimiter(hash, ""plugin"");
        hash_compiler(ctx, hash, st, args[i + 3].c_str(), false);
        i += 3;
        continue;
      }
    }

    if ((args[i] == ""-ccbin"" || args[i] == ""--compiler-bindir"")
        && i + 1 < args.size()) {
      auto st = Stat::stat(args[i + 1], Stat::OnError::log);
      if (st) {
        found_ccbin = true;
        hash_delimiter(hash, ""ccbin"");
        hash_nvcc_host_compiler(ctx, hash, &st, args[i + 1].c_str());
        i++;
        continue;
      }
    }

    // All other arguments are included in the hash.
    hash_delimiter(hash, ""arg"");
    hash_string(hash, args[i]);
    if (i + 1 < args.size() && compopt_takes_arg(args[i])) {
      i++;
      hash_delimiter(hash, ""arg"");
      hash_string(hash, args[i]);
    }
  }

  // Make results with dependency file /dev/null different from those without
  // it.
  if (ctx.args_info.generating_dependencies
      && ctx.args_info.output_dep == ""/dev/null"") {
    hash_delimiter(hash, ""/dev/null dependency file"");
  }

  if (!found_ccbin && ctx.args_info.actual_language == ""cu"") {
    hash_nvcc_host_compiler(ctx, hash, nullptr, nullptr);
  }

  // For profile generation (-fprofile(-instr)-generate[=path])
  // - hash profile path
  //
  // For profile usage (-fprofile(-instr|-sample)-use, -fbranch-probabilities):
  // - hash profile data
  //
  // -fbranch-probabilities and -fvpt usage is covered by
  // -fprofile-generate/-fprofile-use.
  //
  // The profile directory can be specified as an argument to
  // -fprofile(-instr)-generate=, -fprofile(-instr|-sample)-use= or
  // -fprofile-dir=.

  if (ctx.args_info.profile_generate) {
    assert(!ctx.args_info.profile_path.empty());
    cc_log(""Adding profile directory %s to our hash"",
           ctx.args_info.profile_path.c_str());
    hash_delimiter(hash, ""-fprofile-dir"");
    hash_string(hash, ctx.args_info.profile_path);
  }

  if (ctx.args_info.profile_use && !hash_profile_data_file(ctx, hash)) {
    cc_log(""No profile data file found"");
    failed(STATS_NOINPUT);
  }

  // Adding -arch to hash since cpp output is affected.
  for (const auto& arch : ctx.args_info.arch_args) {
    hash_delimiter(hash, ""-arch"");
    hash_string(hash, arch);
  }

  optional<Digest> result_name;
  if (direct_mode) {
    // Hash environment variables that affect the preprocessor output.
    const char* envvars[] = {""CPATH"",
                             ""C_INCLUDE_PATH"",
                             ""CPLUS_INCLUDE_PATH"",
                             ""OBJC_INCLUDE_PATH"",
                             ""OBJCPLUS_INCLUDE_PATH"", // clang
                             nullptr};
    for (const char** p = envvars; *p; ++p) {
      char* v = getenv(*p);
      if (v) {
        hash_delimiter(hash, *p);
        hash_string(hash, v);
      }
    }

    // Make sure that the direct mode hash is unique for the input file path.
    // If this would not be the case:
    //
    // * An false cache hit may be produced. Scenario:
    //   - a/r.h exists.
    //   - a/x.c has #include ""r.h"".
    //   - b/x.c is identical to a/x.c.
    //   - Compiling a/x.c records a/r.h in the manifest.
    //   - Compiling b/x.c results in a false cache hit since a/x.c and b/x.c
    //     share manifests and a/r.h exists.
    // * The expansion of __FILE__ may be incorrect.
    hash_delimiter(hash, ""inputfile"");
    hash_string(hash, ctx.args_info.input_file);

    hash_delimiter(hash, ""sourcecode"");
    int result =
      hash_source_code_file(ctx, hash, ctx.args_info.input_file.c_str());
    if (result & HASH_SOURCE_CODE_ERROR) {
      failed(STATS_ERROR);
    }
    if (result & HASH_SOURCE_CODE_FOUND_TIME) {
      cc_log(""Disabling direct mode"");
      ctx.config.set_direct_mode(false);
      return nullopt;
    }

    ctx.set_manifest_name(hash_result(hash));

    cc_log(""Looking for result name in %s"", ctx.manifest_path().c_str());
    MTR_BEGIN(""manifest"", ""manifest_get"");
    result_name = manifest_get(ctx, ctx.manifest_path());
    MTR_END(""manifest"", ""manifest_get"");
    if (result_name) {
      cc_log(""Got result name from manifest"");
    } else {
      cc_log(""Did not find result name in manifest"");
    }
  } else {
    if (ctx.args_info.arch_args.empty()) {
      result_name = get_result_name_from_cpp(ctx, preprocessor_args, hash);
      cc_log(""Got result name from preprocessor"");
    } else {
      preprocessor_args.push_back(""-arch"");
      for (size_t i = 0; i < ctx.args_info.arch_args.size(); ++i) {
        preprocessor_args.push_back(ctx.args_info.arch_args[i]);
        result_name = get_result_name_from_cpp(ctx, preprocessor_args, hash);
        cc_log(""Got result name from preprocessor with -arch %s"",
               ctx.args_info.arch_args[i].c_str());
        if (i != ctx.args_info.arch_args.size() - 1) {
          result_name = nullopt;
        }
        preprocessor_args.pop_back();
      }
      preprocessor_args.pop_back();
    }
  }

  return result_name;
}

// Try to return the compile result from cache.
static optional<enum stats>
from_cache(Context& ctx, enum fromcache_call_mode mode)
{
  // The user might be disabling cache hits.
  if (ctx.config.recache()) {
    return nullopt;
  }

  // If we're using Clang, we can't trust a precompiled header object based on
  // running the preprocessor since clang will produce a fatal error when the
  // precompiled header is used and one of the included files has an updated
  // timestamp:
  //
  //     file 'foo.h' has been modified since the precompiled header 'foo.pch'
  //     was built
  if ((ctx.guessed_compiler == GuessedCompiler::clang
       || ctx.guessed_compiler == GuessedCompiler::unknown)
      && ctx.args_info.output_is_precompiled_header
      && mode == FROMCACHE_CPP_MODE) {
    cc_log(""Not considering cached precompiled header in preprocessor mode"");
    return nullopt;
  }

  MTR_BEGIN(""cache"", ""from_cache"");

  bool produce_dep_file = ctx.args_info.generating_dependencies
                          && ctx.args_info.output_dep != ""/dev/null"";

  MTR_BEGIN(""file"", ""file_get"");

  // Get result from cache.
  const auto tmp_stderr_fd_and_path = Util::create_temp_fd(
    fmt::format(""{}/tmp.stderr"", ctx.config.temporary_dir()));
  close(tmp_stderr_fd_and_path.first);
  const std::string& tmp_stderr = tmp_stderr_fd_and_path.second;
  ctx.register_pending_tmp_file(tmp_stderr);

  ResultFileMap result_file_map;
  if (ctx.args_info.output_obj != ""/dev/null"") {
    result_file_map.emplace(FileType::object, ctx.args_info.output_obj);
    if (ctx.args_info.seen_split_dwarf) {
      result_file_map.emplace(FileType::dwarf_object, ctx.args_info.output_dwo);
    }
  }
  result_file_map.emplace(FileType::stderr_output, tmp_stderr);
  if (produce_dep_file) {
    result_file_map.emplace(FileType::dependency, ctx.args_info.output_dep);
  }
  if (ctx.args_info.generating_coverage) {
    result_file_map.emplace(FileType::coverage, ctx.args_info.output_cov);
  }
  if (ctx.args_info.generating_stackusage) {
    result_file_map.emplace(FileType::stackusage, ctx.args_info.output_su);
  }
  if (ctx.args_info.generating_diagnostics) {
    result_file_map.emplace(FileType::diagnostic, ctx.args_info.output_dia);
  }
  bool ok = result_get(ctx, ctx.result_path(), result_file_map);
  if (!ok) {
    cc_log(""Failed to get result from cache"");
    return nullopt;
  }

  MTR_END(""file"", ""file_get"");

  send_cached_stderr(tmp_stderr, ctx.args_info.strip_diagnostics_colors);

  cc_log(""Succeeded getting cached result"");

  MTR_END(""cache"", ""from_cache"");

  return mode == FROMCACHE_DIRECT_MODE ? STATS_CACHEHIT_DIR
                                       : STATS_CACHEHIT_CPP;
}

// Find the real compiler. We just search the PATH to find an executable of the
// same name that isn't a link to ourselves.
static void
find_compiler(Context& ctx, const char* const* argv)
{
  // We might be being invoked like ""ccache gcc -c foo.c"".
  std::string base(Util::base_name(argv[0]));
  if (same_executable_name(base.c_str(), MYNAME)) {
    ctx.orig_args.pop_front();
    if (is_full_path(ctx.orig_args[0].c_str())) {
      // A full path was given.
      return;
    }
    base = std::string(Util::base_name(ctx.orig_args[0]));
  }

  // Support user override of the compiler.
  if (!ctx.config.compiler().empty()) {
    base = ctx.config.compiler();
  }

  std::string compiler = find_executable(ctx, base.c_str(), MYNAME);
  if (compiler.empty()) {
    fatal(""Could not find compiler \""%s\"" in PATH"", base.c_str());
  }
  if (compiler == argv[0]) {
    fatal(""Recursive invocation (the name of the ccache binary must be \""%s\"")"",
          MYNAME);
  }
  ctx.orig_args[0] = compiler;
}

bool
is_precompiled_header(const char* path)
{
  const char* ext = get_extension(path);
  char* dir = x_dirname(path);
  const char* dir_ext = get_extension(dir);
  bool result =
    str_eq(ext, "".gch"") || str_eq(ext, "".pch"") || str_eq(ext, "".pth"")
    || str_eq(dir_ext, "".gch""); // See ""Precompiled Headers"" in GCC docs.
  free(dir);
  return result;
}

static void
create_initial_config_file(Config& config)
{
  if (!Util::create_dir(Util::dir_name(config.primary_config_path()))) {
    return;
  }

  unsigned max_files;
  uint64_t max_size;
  char* stats_dir = format(""%s/0"", config.cache_dir().c_str());
  if (Stat::stat(stats_dir)) {
    stats_get_obsolete_limits(stats_dir, &max_files, &max_size);
    // STATS_MAXFILES and STATS_MAXSIZE was stored for each top directory.
    max_files *= 16;
    max_size *= 16;
  } else {
    max_files = 0;
    max_size = config.max_size();
  }
  free(stats_dir);

  FILE* f = fopen(config.primary_config_path().c_str(), ""w"");
  if (!f) {
    return;
  }
  if (max_files != 0) {
    fprintf(f, ""max_files = %u\n"", max_files);
    config.set_max_files(max_files);
  }
  if (max_size != 0) {
    char* size = format_parsable_size_with_suffix(max_size);
    fprintf(f, ""max_size = %s\n"", size);
    free(size);
    config.set_max_size(max_size);
  }
  fclose(f);
}

// Read config file(s), populate variables, create configuration file in cache
// directory if missing, etc.
static void
set_up_config(Config& config)
{
  char* p = getenv(""CCACHE_CONFIGPATH"");
  if (p) {
    config.set_primary_config_path(p);
  } else {
    config.set_secondary_config_path(fmt::format(""{}/ccache.conf"", SYSCONFDIR));
    MTR_BEGIN(""config"", ""conf_read_secondary"");
    // A missing config file in SYSCONFDIR is OK so don't check return value.
    config.update_from_file(config.secondary_config_path());
    MTR_END(""config"", ""conf_read_secondary"");

    if (config.cache_dir().empty()) {
      fatal(""configuration setting \""cache_dir\"" must not be the empty string"");
    }
    if ((p = getenv(""CCACHE_DIR""))) {
      config.set_cache_dir(p);
    }
    if (config.cache_dir().empty()) {
      fatal(""CCACHE_DIR must not be the empty string"");
    }

    config.set_primary_config_path(
      fmt::format(""{}/ccache.conf"", config.cache_dir()));
  }

  bool should_create_initial_config = false;
  MTR_BEGIN(""config"", ""conf_read_primary"");
  if (!config.update_from_file(config.primary_config_path())
      && !config.disable()) {
    should_create_initial_config = true;
  }
  MTR_END(""config"", ""conf_read_primary"");

  MTR_BEGIN(""config"", ""conf_update_from_environment"");
  config.update_from_environment();
  MTR_END(""config"", ""conf_update_from_environment"");

  if (should_create_initial_config) {
    create_initial_config_file(config);
  }

  if (config.umask() != std::numeric_limits<uint32_t>::max()) {
    umask(config.umask());
  }
}

static void
set_up_context(Context& ctx, int argc, const char* const* argv)
{
  ctx.orig_args = Args::from_argv(argc, argv);
  ctx.ignore_header_paths = Util::split_into_strings(
    ctx.config.ignore_headers_in_manifest(), PATH_DELIM);
}

// Initialize ccache, must be called once before anything else is run.
static void
initialize(Context& ctx, int argc, const char* const* argv)
{
  set_up_config(ctx.config);
  set_up_context(ctx, argc, argv);
  init_log(ctx.config);

  cc_log(""=== CCACHE %s STARTED ========================================="",
         CCACHE_VERSION);

  if (getenv(""CCACHE_INTERNAL_TRACE"")) {
#ifdef MTR_ENABLED
    ctx.mini_trace = std::make_unique<MiniTrace>(ctx->args_info);
#else
    cc_log(""Error: tracing is not enabled!"");
#endif
  }
}

// Make a copy of stderr that will not be cached, so things like distcc can
// send networking errors to it.
static void
set_up_uncached_err()
{
  int uncached_fd =
    dup(STDERR_FILENO); // The file descriptor is intentionally leaked.
  if (uncached_fd == -1) {
    cc_log(""dup(2) failed: %s"", strerror(errno));
    failed(STATS_ERROR);
  }

  x_setenv(""UNCACHED_ERR_FD"", fmt::format(""{}"", uncached_fd).c_str());
}

static void
configuration_logger(const std::string& key,
                     const std::string& value,
                     const std::string& origin)
{
  cc_bulklog(
    ""Config: (%s) %s = %s"", origin.c_str(), key.c_str(), value.c_str());
}

static void
configuration_printer(const std::string& key,
                      const std::string& value,
                      const std::string& origin)
{
  fmt::print(""({}) {} = {}\n"", origin, key, value);
}

static int cache_compilation(int argc, const char* const* argv);
static enum stats do_cache_compilation(Context& ctx, const char* const* argv);

// The entry point when invoked to cache a compilation.
static int
cache_compilation(int argc, const char* const* argv)
{
  // Needed for portability when using localtime_r.
  tzset();

  auto ctx = std::make_unique<Context>();
  SignalHandler signal_handler(*ctx);

  initialize(*ctx, argc, argv);

  MTR_BEGIN(""main"", ""find_compiler"");
  find_compiler(*ctx, argv);
  MTR_END(""main"", ""find_compiler"");

  try {
    enum stats stat = do_cache_compilation(*ctx, argv);
    stats_update(*ctx, stat);
    return EXIT_SUCCESS;
  } catch (const Failure& e) {
    if (e.stat() != STATS_NONE) {
      stats_update(*ctx, e.stat());
    }

    if (e.exit_code()) {
      return *e.exit_code();
    }
    // Else: Fall back to running the real compiler.

    assert(!ctx->orig_args.empty());

    ctx->orig_args.erase_with_prefix(""--ccache-"");
    add_prefix(*ctx, ctx->orig_args, ctx->config.prefix_command());

    cc_log(""Failed; falling back to running the real compiler"");

    Args saved_orig_args(std::move(ctx->orig_args));
    auto execv_argv = saved_orig_args.to_argv();

    cc_log_argv(""Executing "", execv_argv.data());
    ctx.reset(); // Dump debug logs last thing before executing.
    execv(execv_argv[0], const_cast<char* const*>(execv_argv.data()));
    fatal(""execv of %s failed: %s"", execv_argv[0], strerror(errno));
  }
}

static enum stats
do_cache_compilation(Context& ctx, const char* const* argv)
{
  if (ctx.actual_cwd.empty()) {
    cc_log(""Unable to determine current working directory: %s"",
           strerror(errno));
    failed(STATS_ERROR);
  }

  MTR_BEGIN(""main"", ""clean_up_internal_tempdir"");
  if (ctx.config.temporary_dir() == ctx.config.cache_dir() + ""/tmp"") {
    clean_up_internal_tempdir(ctx.config);
  }
  MTR_END(""main"", ""clean_up_internal_tempdir"");

  if (!ctx.config.log_file().empty() || ctx.config.debug()) {
    ctx.config.visit_items(configuration_logger);
  }

  if (ctx.config.disable()) {
    cc_log(""ccache is disabled"");
    // STATS_CACHEMISS is a dummy to trigger stats_flush.
    failed(STATS_CACHEMISS);
  }

  MTR_BEGIN(""main"", ""set_up_uncached_err"");
  set_up_uncached_err();
  MTR_END(""main"", ""set_up_uncached_err"");

  cc_log_argv(""Command line: "", argv);
  cc_log(""Hostname: %s"", get_hostname());
  cc_log(""Working directory: %s"", ctx.actual_cwd.c_str());
  if (ctx.apparent_cwd != ctx.actual_cwd) {
    cc_log(""Apparent working directory: %s"", ctx.apparent_cwd.c_str());
  }

  ctx.config.set_limit_multiple(
    std::min(std::max(ctx.config.limit_multiple(), 0.0), 1.0));

  MTR_BEGIN(""main"", ""guess_compiler"");
  ctx.guessed_compiler = guess_compiler(ctx.orig_args[0].c_str());
  MTR_END(""main"", ""guess_compiler"");

  // Arguments (except -E) to send to the preprocessor.
  Args preprocessor_args;
  // Arguments not sent to the preprocessor but that should be part of the
  // hash.
  Args extra_args_to_hash;
  // Arguments to send to the real compiler.
  Args compiler_args;
  MTR_BEGIN(""main"", ""process_args"");

  auto error =
    process_args(ctx, preprocessor_args, extra_args_to_hash, compiler_args);
  if (error) {
    failed(*error);
  }

  MTR_END(""main"", ""process_args"");

  if (ctx.config.depend_mode()
      && (!ctx.args_info.generating_dependencies
          || ctx.args_info.output_dep == ""/dev/null""
          || !ctx.config.run_second_cpp())) {
    cc_log(""Disabling depend mode"");
    ctx.config.set_depend_mode(false);
  }

  cc_log(""Source file: %s"", ctx.args_info.input_file.c_str());
  if (ctx.args_info.generating_dependencies) {
    cc_log(""Dependency file: %s"", ctx.args_info.output_dep.c_str());
  }
  if (ctx.args_info.generating_coverage) {
    cc_log(""Coverage file: %s"", ctx.args_info.output_cov.c_str());
  }
  if (ctx.args_info.generating_stackusage) {
    cc_log(""Stack usage file: %s"", ctx.args_info.output_su.c_str());
  }
  if (ctx.args_info.generating_diagnostics) {
    cc_log(""Diagnostics file: %s"", ctx.args_info.output_dia.c_str());
  }
  if (!ctx.args_info.output_dwo.empty()) {
    cc_log(""Split dwarf file: %s"", ctx.args_info.output_dwo.c_str());
  }

  cc_log(""Object file: %s"", ctx.args_info.output_obj.c_str());
  MTR_META_THREAD_NAME(ctx.args_info.output_obj.c_str());

  if (ctx.config.debug()) {
    std::string path =
      fmt::format(""{}.ccache-input-text"", ctx.args_info.output_obj);
    File debug_text_file(path, ""w"");
    if (debug_text_file) {
      ctx.hash_debug_files.push_back(std::move(debug_text_file));
    } else {
      cc_log(""Failed to open %s: %s"", path.c_str(), strerror(errno));
    }
  }

  FILE* debug_text_file = !ctx.hash_debug_files.empty()
                            ? ctx.hash_debug_files.front().get()
                            : nullptr;

  struct hash* common_hash = hash_init();
  init_hash_debug(ctx,
                  common_hash,
                  ctx.args_info.output_obj.c_str(),
                  'c',
                  ""COMMON"",
                  debug_text_file);

  MTR_BEGIN(""hash"", ""common_hash"");
  hash_common_info(ctx, preprocessor_args, common_hash, ctx.args_info);
  MTR_END(""hash"", ""common_hash"");

  // Try to find the hash using the manifest.
  struct hash* direct_hash = hash_copy(common_hash);
  init_hash_debug(ctx,
                  direct_hash,
                  ctx.args_info.output_obj.c_str(),
                  'd',
                  ""DIRECT MODE"",
                  debug_text_file);

  Args args_to_hash = preprocessor_args;
  args_to_hash.push_back(extra_args_to_hash);

  bool put_result_in_manifest = false;
  optional<Digest> result_name;
  optional<Digest> result_name_from_manifest;
  if (ctx.config.direct_mode()) {
    cc_log(""Trying direct lookup"");
    MTR_BEGIN(""hash"", ""direct_hash"");
    Args dummy_args;
    result_name =
      calculate_result_name(ctx, args_to_hash, dummy_args, direct_hash, true);
    MTR_END(""hash"", ""direct_hash"");
    if (result_name) {
      ctx.set_result_name(*result_name);

      // If we can return from cache at this point then do so.
      auto result = from_cache(ctx, FROMCACHE_DIRECT_MODE);
      if (result) {
        return *result;
      }

      // Wasn't able to return from cache at this point. However, the result
      // was already found in manifest, so don't re-add it later.
      put_result_in_manifest = false;

      result_name_from_manifest = result_name;
    } else {
      // Add result to manifest later.
      put_result_in_manifest = true;
    }
  }

  if (ctx.config.read_only_direct()) {
    cc_log(""Read-only direct mode; running real compiler"");
    failed(STATS_CACHEMISS);
  }

  if (!ctx.config.depend_mode()) {
    // Find the hash using the preprocessed output. Also updates
    // g_included_files.
    struct hash* cpp_hash = hash_copy(common_hash);
    init_hash_debug(ctx,
                    cpp_hash,
                    ctx.args_info.output_obj.c_str(),
                    'p',
                    ""PREPROCESSOR MODE"",
                    debug_text_file);

    MTR_BEGIN(""hash"", ""cpp_hash"");
    result_name = calculate_result_name(
      ctx, args_to_hash, preprocessor_args, cpp_hash, false);
    MTR_END(""hash"", ""cpp_hash"");
    if (!result_name) {
      fatal(""internal error: calculate_result_name returned NULL for cpp"");
    }
    ctx.set_result_name(*result_name);

    if (result_name_from_manifest && result_name_from_manifest != result_name) {
      // The hash from manifest differs from the hash of the preprocessor
      // output. This could be because:
      //
      // - The preprocessor produces different output for the same input (not
      //   likely).
      // - There's a bug in ccache (maybe incorrect handling of compiler
      //   arguments).
      // - The user has used a different CCACHE_BASEDIR (most likely).
      //
      // The best thing here would probably be to remove the hash entry from
      // the manifest. For now, we use a simpler method: just remove the
      // manifest file.
      cc_log(""Hash from manifest doesn't match preprocessor output"");
      cc_log(""Likely reason: different CCACHE_BASEDIRs used"");
      cc_log(""Removing manifest as a safety measure"");
      Util::unlink_safe(ctx.manifest_path());

      put_result_in_manifest = true;
    }

    // If we can return from cache at this point then do.
    auto result = from_cache(ctx, FROMCACHE_CPP_MODE);
    if (result) {
      if (put_result_in_manifest) {
        update_manifest_file(ctx);
      }
      return *result;
    }
  }

  if (ctx.config.read_only()) {
    cc_log(""Read-only mode; running real compiler"");
    failed(STATS_CACHEMISS);
  }

  add_prefix(ctx, compiler_args, ctx.config.prefix_command());

  // In depend_mode, extend the direct hash.
  struct hash* depend_mode_hash =
    ctx.config.depend_mode() ? direct_hash : nullptr;

  // Run real compiler, sending output to cache.
  MTR_BEGIN(""cache"", ""to_cache"");
  to_cache(
    ctx, compiler_args, ctx.args_info.depend_extra_args, depend_mode_hash);
  update_manifest_file(ctx);
  MTR_END(""cache"", ""to_cache"");

  return STATS_CACHEMISS;
}

// The main program when not doing a compile.
static int
handle_main_options(int argc, const char* const* argv)
{
  enum longopts {
    DUMP_MANIFEST,
    DUMP_RESULT,
    HASH_FILE,
    PRINT_STATS,
  };
  static const struct option options[] = {
    {""cleanup"", no_argument, nullptr, 'c'},
    {""clear"", no_argument, nullptr, 'C'},
    {""dump-manifest"", required_argument, nullptr, DUMP_MANIFEST},
    {""dump-result"", required_argument, nullptr, DUMP_RESULT},
    {""get-config"", required_argument, nullptr, 'k'},
    {""hash-file"", required_argument, nullptr, HASH_FILE},
    {""help"", no_argument, nullptr, 'h'},
    {""max-files"", required_argument, nullptr, 'F'},
    {""max-size"", required_argument, nullptr, 'M'},
    {""print-stats"", no_argument, nullptr, PRINT_STATS},
    {""recompress"", required_argument, nullptr, 'X'},
    {""set-config"", required_argument, nullptr, 'o'},
    {""show-compression"", no_argument, nullptr, 'x'},
    {""show-config"", no_argument, nullptr, 'p'},
    {""show-stats"", no_argument, nullptr, 's'},
    {""version"", no_argument, nullptr, 'V'},
    {""zero-stats"", no_argument, nullptr, 'z'},
    {nullptr, 0, nullptr, 0}};

  Context ctx;
  initialize(ctx, argc, argv);

  int c;
  while ((c = getopt_long(argc,
                          const_cast<char* const*>(argv),
                          ""cCk:hF:M:po:sVxX:z"",
                          options,
                          nullptr))
         != -1) {
    switch (c) {
    case DUMP_MANIFEST:
      return manifest_dump(optarg, stdout) ? 0 : 1;

    case DUMP_RESULT:
      return result_dump(ctx, optarg, stdout) ? 0 : 1;

    case HASH_FILE: {
      struct hash* hash = hash_init();
      if (str_eq(optarg, ""-"")) {
        hash_fd(hash, STDIN_FILENO);
      } else {
        hash_file(hash, optarg);
      }
      puts(hash_result(hash).to_string().c_str());
      hash_free(hash);
      break;
    }

    case PRINT_STATS:
      stats_print(ctx.config);
      break;

    case 'c': // --cleanup
    {
      ProgressBar progress_bar(""Cleaning..."");
      clean_up_all(ctx.config,
                   [&](double progress) { progress_bar.update(progress); });
      if (isatty(STDOUT_FILENO)) {
        printf(""\n"");
      }
      break;
    }

    case 'C': // --clear
    {
      ProgressBar progress_bar(""Clearing..."");
      wipe_all(ctx, [&](double progress) { progress_bar.update(progress); });
      if (isatty(STDOUT_FILENO)) {
        printf(""\n"");
      }
      break;
    }

    case 'h': // --help
      fprintf(stdout, USAGE_TEXT, MYNAME, MYNAME);
      x_exit(0);

    case 'k': // --get-config
      fmt::print(""{}\n"", ctx.config.get_string_value(optarg));
      break;

    case 'F': { // --max-files
      Config::set_value_in_file(
        ctx.config.primary_config_path(), ""max_files"", optarg);
      unsigned files = atoi(optarg);
      if (files == 0) {
        printf(""Unset cache file limit\n"");
      } else {
        printf(""Set cache file limit to %u\n"", files);
      }
      break;
    }

    case 'M': { // --max-size
      uint64_t size;
      if (!parse_size_with_suffix(optarg, &size)) {
        fatal(""invalid size: %s"", optarg);
      }
      Config::set_value_in_file(
        ctx.config.primary_config_path(), ""max_size"", optarg);
      if (size == 0) {
        printf(""Unset cache size limit\n"");
      } else {
        char* s = format_human_readable_size(size);
        printf(""Set cache size limit to %s\n"", s);
        free(s);
      }
      break;
    }

    case 'o': {                          // --set-config
      char* p = strchr(optarg + 1, '='); // Improve error message for -o=K=V
      if (!p) {
        fatal(""missing equal sign in \""%s\"""", optarg);
      }
      char* key = x_strndup(optarg, p - optarg);
      char* value = p + 1;
      Config::set_value_in_file(ctx.config.primary_config_path(), key, value);
      free(key);
      break;
    }

    case 'p': // --show-config
      ctx.config.visit_items(configuration_printer);
      break;

    case 's': // --show-stats
      stats_summary(ctx);
      break;

    case 'V': // --version
      fprintf(stdout, VERSION_TEXT, MYNAME, CCACHE_VERSION);
      x_exit(0);

    case 'x': // --show-compression
    {
      ProgressBar progress_bar(""Scanning..."");
      compress_stats(ctx.config,
                     [&](double progress) { progress_bar.update(progress); });
      break;
    }

    case 'X': // --recompress
    {
      int level;
      if (std::string(optarg) == ""uncompressed"") {
        level = 0;
      } else {
        level = Util::parse_int(optarg);
        if (level < -128 || level > 127) {
          throw Error(""compression level must be between -128 and 127"");
        }
        if (level == 0) {
          level = ctx.config.compression_level();
        }
      }

      ProgressBar progress_bar(""Recompressing..."");
      compress_recompress(
        ctx, level, [&](double progress) { progress_bar.update(progress); });
      break;
    }

    case 'z': // --zero-stats
      stats_zero(ctx);
      printf(""Statistics zeroed\n"");
      break;

    default:
      fprintf(stderr, USAGE_TEXT, MYNAME, MYNAME);
      x_exit(1);
    }

    // Some of the above switches might have changed config settings, so run the
    // setup again.
    set_up_config(ctx.config);
  }

  return 0;
}

int ccache_main(int argc, const char* const* argv);

int
ccache_main(int argc, const char* const* argv)
{
  try {
    // Check if we are being invoked as ""ccache"".
    std::string program_name(Util::base_name(argv[0]));
    if (same_executable_name(program_name.c_str(), MYNAME)) {
      if (argc < 2) {
        fprintf(stderr, USAGE_TEXT, MYNAME, MYNAME);
        x_exit(1);
      }
      // If the first argument isn't an option, then assume we are being passed
      // a compiler name and options.
      if (argv[1][0] == '-') {
        return handle_main_options(argc, argv);
      }
    }

    return cache_compilation(argc, argv);
  } catch (const ErrorBase& e) {
    fmt::print(stderr, ""ccache: error: {}\n"", e.what());
    return EXIT_FAILURE;
  }
}
""",handle_main_options,[2246:2434]
ccache,https://github.com/ccache/ccache/commit/925a35bb3d730482c3734356a1da3d810b21925f,"""Remove no longer needed cleanup of CACHEDIR.TAG in $CCACHE_DIR

The cleanup functionality was added in 3.2 and it should be safe to
assume that it has performed its task for almost everybody now.""","""// Copyright (C) 2002-2007 Andrew Tridgell
// Copyright (C) 2009-2020 Joel Rosdahl and other contributors
//
// See doc/AUTHORS.adoc for a complete list of contributors.
//
// This program is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by the Free
// Software Foundation; either version 3 of the License, or (at your option)
// any later version.
//
// This program is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
// more details.
//
// You should have received a copy of the GNU General Public License along with
// this program; if not, write to the Free Software Foundation, Inc., 51
// Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA

#include ""ccache.hpp""

#include ""Args.hpp""
#include ""ArgsInfo.hpp""
#include ""Context.hpp""
#include ""Fd.hpp""
#include ""File.hpp""
#include ""FormatNonstdStringView.hpp""
#include ""Hash.hpp""
#include ""MiniTrace.hpp""
#include ""ProgressBar.hpp""
#include ""Result.hpp""
#include ""ResultDumper.hpp""
#include ""ResultExtractor.hpp""
#include ""ResultRetriever.hpp""
#include ""SignalHandler.hpp""
#include ""StdMakeUnique.hpp""
#include ""Util.hpp""
#include ""argprocessing.hpp""
#include ""cleanup.hpp""
#include ""compopt.hpp""
#include ""compress.hpp""
#include ""exceptions.hpp""
#include ""execute.hpp""
#include ""hashutil.hpp""
#include ""language.hpp""
#include ""logging.hpp""
#include ""manifest.hpp""
#include ""stats.hpp""

#include ""third_party/fmt/core.h""
#include ""third_party/nonstd/string_view.hpp""

#ifdef HAVE_GETOPT_LONG
#  include <getopt.h>
#else
#  include ""third_party/getopt_long.h""
#endif

#include <algorithm>
#include <limits>

using nonstd::nullopt;
using nonstd::optional;
using nonstd::string_view;

static const char VERSION_TEXT[] =
  R""(%s version %s

Copyright (C) 2002-2007 Andrew Tridgell
Copyright (C) 2009-2020 Joel Rosdahl and other contributors

See <https://ccache.dev/credits.html> for a complete list of contributors.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 3 of the License, or (at your option) any later
version.
)"";

static const char USAGE_TEXT[] =
  R""(Usage:
    %s [options]
    %s compiler [compiler options]
    compiler [compiler options]          (via symbolic link)

Common options:
    -c, --cleanup             delete old files and recalculate size counters
                              (normally not needed as this is done
                              automatically)
    -C, --clear               clear the cache completely (except configuration)
    -F, --max-files NUM       set maximum number of files in cache to NUM (use 0
                              for no limit)
    -M, --max-size SIZE       set maximum size of cache to SIZE (use 0 for no
                              limit); available suffixes: k, M, G, T (decimal)
                              and Ki, Mi, Gi, Ti (binary); default suffix: G
    -X, --recompress LEVEL    recompress the cache to LEVEL (integer level or
                              ""uncompressed"")
    -o, --set-config KEY=VAL  set configuration item KEY to value VAL
    -x, --show-compression    show compression statistics
    -p, --show-config         show current configuration options in
                              human-readable format
    -s, --show-stats          show summary of configuration and statistics
                              counters in human-readable format
    -z, --zero-stats          zero statistics counters

    -h, --help                print this help text
    -V, --version             print version and copyright information

Options for scripting or debugging:
        --dump-manifest PATH  dump manifest file at PATH in text format
        --dump-result PATH    dump result file at PATH in text format
        --extract-result PATH extract data stored in result file at PATH to the
                              current working directory
    -k, --get-config KEY      print the value of configuration key KEY
        --hash-file PATH      print the hash (160 bit BLAKE3) of the file at
                              PATH
        --print-stats         print statistics counter IDs and corresponding
                              values in machine-parsable format

See also <https://ccache.dev>.
)"";

enum fromcache_call_mode { FROMCACHE_DIRECT_MODE, FROMCACHE_CPP_MODE };

struct pending_tmp_file
{
  char* path;
  struct pending_tmp_file* next;
};

// How often (in seconds) to scan $CCACHE_DIR/tmp for left-over temporary
// files.
static const int k_tempdir_cleanup_interval = 2 * 24 * 60 * 60; // 2 days

// This is a string that identifies the current ""version"" of the hash sum
// computed by ccache. If, for any reason, we want to force the hash sum to be
// different for the same input in a new ccache version, we can just change
// this string. A typical example would be if the format of one of the files
// stored in the cache changes in a backwards-incompatible way.
static const char HASH_PREFIX[] = ""3"";

static void
add_prefix(const Context& ctx, Args& args, const std::string& prefix_command)
{
  if (prefix_command.empty()) {
    return;
  }

  Args prefix;
  for (const auto& word : Util::split_into_strings(prefix_command, "" "")) {
    std::string path = find_executable(ctx, word.c_str(), MYNAME);
    if (path.empty()) {
      fatal(""%s: %s"", word.c_str(), strerror(errno));
    }

    prefix.push_back(path);
  }

  cc_log(""Using command-line prefix %s"", prefix_command.c_str());
  for (size_t i = prefix.size(); i != 0; i--) {
    args.push_front(prefix[i - 1]);
  }
}

// If `exit_code` is set, just exit with that code directly, otherwise execute
// the real compiler and exit with its exit code. Also updates statistics
// counter `stat` if it's not STATS_NONE.
static void failed(enum stats stat = STATS_NONE,
                   optional<int> exit_code = nullopt) ATTR_NORETURN;

static void
failed(enum stats stat, optional<int> exit_code)
{
  throw Failure(stat, exit_code);
}

static void
clean_up_internal_tempdir(const Config& config)
{
  time_t now = time(nullptr);
  auto dir_st = Stat::stat(config.cache_dir(), Stat::OnError::log);
  if (!dir_st || dir_st.mtime() + k_tempdir_cleanup_interval >= now) {
    // No cleanup needed.
    return;
  }

  update_mtime(config.cache_dir().c_str());

  const std::string& temp_dir = config.temporary_dir();
  if (!Stat::lstat(temp_dir)) {
    return;
  }

  Util::traverse(temp_dir, [now](const std::string& path, bool is_dir) {
    if (is_dir) {
      return;
    }
    auto st = Stat::lstat(path, Stat::OnError::log);
    if (st && st.mtime() + k_tempdir_cleanup_interval < now) {
      Util::unlink_tmp(path);
    }
  });
}

static void
init_hash_debug(Context& ctx,
                Hash& hash,
                const char* obj_path,
                char type,
                const char* section_name,
                FILE* debug_text_file)
{
  if (!ctx.config.debug()) {
    return;
  }

  std::string path = fmt::format(""{}.ccache-input-{}"", obj_path, type);
  File debug_binary_file(path, ""wb"");
  if (debug_binary_file) {
    hash.enable_debug(section_name, debug_binary_file.get(), debug_text_file);
    ctx.hash_debug_files.push_back(std::move(debug_binary_file));
  } else {
    cc_log(""Failed to open %s: %s"", path.c_str(), strerror(errno));
  }
}

static GuessedCompiler
guess_compiler(const char* path)
{
  string_view name = Util::base_name(path);
  GuessedCompiler result = GuessedCompiler::unknown;
  if (name.find(""clang"") != std::string::npos) {
    result = GuessedCompiler::clang;
  } else if (name.find(""gcc"") != std::string::npos
             || name.find(""g++"") != std::string::npos) {
    result = GuessedCompiler::gcc;
  } else if (name.find(""nvcc"") != std::string::npos) {
    result = GuessedCompiler::nvcc;
  } else if (name == ""pump"" || name == ""distcc-pump"") {
    result = GuessedCompiler::pump;
  }
  return result;
}

static bool
do_remember_include_file(Context& ctx,
                         std::string path,
                         Hash& cpp_hash,
                         bool system,
                         Hash* depend_mode_hash)
{
  bool is_pch = false;

  if (path.length() >= 2 && path[0] == '<' && path[path.length() - 1] == '>') {
    // Typically <built-in> or <command-line>.
    return true;
  }

  if (path == ctx.args_info.input_file) {
    // Don't remember the input file.
    return true;
  }

  if (system && (ctx.config.sloppiness() & SLOPPY_SYSTEM_HEADERS)) {
    // Don't remember this system header.
    return true;
  }

  if (ctx.included_files.find(path) != ctx.included_files.end()) {
    // Already known include file.
    return true;
  }

  // Canonicalize path for comparison; Clang uses ./header.h.
  if (Util::starts_with(path, ""./"")) {
    path.erase(0, 2);
  }

#ifdef _WIN32
  {
    // stat fails on directories on win32.
    DWORD attributes = GetFileAttributes(path.c_str());
    if (attributes != INVALID_FILE_ATTRIBUTES
        && attributes & FILE_ATTRIBUTE_DIRECTORY) {
      return true;
    }
  }
#endif

  auto st = Stat::stat(path, Stat::OnError::log);
  if (!st) {
    return false;
  }
  if (st.is_directory()) {
    // Ignore directory, typically $PWD.
    return true;
  }
  if (!st.is_regular()) {
    // Device, pipe, socket or other strange creature.
    cc_log(""Non-regular include file %s"", path.c_str());
    return false;
  }

  for (const auto& ignore_header_path : ctx.ignore_header_paths) {
    if (Util::matches_dir_prefix_or_file(ignore_header_path, path)) {
      return true;
    }
  }

  // The comparison using >= is intentional, due to a possible race between
  // starting compilation and writing the include file. See also the notes
  // under ""Performance"" in doc/MANUAL.adoc.
  if (!(ctx.config.sloppiness() & SLOPPY_INCLUDE_FILE_MTIME)
      && st.mtime() >= ctx.time_of_compilation) {
    cc_log(""Include file %s too new"", path.c_str());
    return false;
  }

  // The same >= logic as above applies to the change time of the file.
  if (!(ctx.config.sloppiness() & SLOPPY_INCLUDE_FILE_CTIME)
      && st.ctime() >= ctx.time_of_compilation) {
    cc_log(""Include file %s ctime too new"", path.c_str());
    return false;
  }

  // Let's hash the include file content.
  Hash fhash;

  is_pch = is_precompiled_header(path.c_str());
  if (is_pch) {
    if (ctx.included_pch_file.empty()) {
      cc_log(""Detected use of precompiled header: %s"", path.c_str());
    }
    bool using_pch_sum = false;
    if (ctx.config.pch_external_checksum()) {
      // hash pch.sum instead of pch when it exists
      // to prevent hashing a very large .pch file every time
      std::string pch_sum_path = fmt::format(""{}.sum"", path);
      if (Stat::stat(pch_sum_path, Stat::OnError::log)) {
        path = std::move(pch_sum_path);
        using_pch_sum = true;
        cc_log(""Using pch.sum file %s"", path.c_str());
      }
    }

    if (!hash_binary_file(ctx, fhash, path.c_str())) {
      return false;
    }
    cpp_hash.hash_delimiter(using_pch_sum ? ""pch_sum_hash"" : ""pch_hash"");
    cpp_hash.hash(fhash.digest().to_string());
  }

  if (ctx.config.direct_mode()) {
    if (!is_pch) { // else: the file has already been hashed.
      int result = hash_source_code_file(ctx, fhash, path.c_str());
      if (result & HASH_SOURCE_CODE_ERROR
          || result & HASH_SOURCE_CODE_FOUND_TIME) {
        return false;
      }
    }

    Digest d = fhash.digest();
    ctx.included_files.emplace(path, d);

    if (depend_mode_hash) {
      depend_mode_hash->hash_delimiter(""include"");
      depend_mode_hash->hash(d.to_string());
    }
  }

  return true;
}

// This function hashes an include file and stores the path and hash in the
// global g_included_files variable. If the include file is a PCH, cpp_hash is
// also updated.
static void
remember_include_file(Context& ctx,
                      const std::string& path,
                      Hash& cpp_hash,
                      bool system,
                      Hash* depend_mode_hash)
{
  if (!do_remember_include_file(ctx, path, cpp_hash, system, depend_mode_hash)
      && ctx.config.direct_mode()) {
    cc_log(""Disabling direct mode"");
    ctx.config.set_direct_mode(false);
  }
}

static void
print_included_files(const Context& ctx, FILE* fp)
{
  for (const auto& item : ctx.included_files) {
    fprintf(fp, ""%s\n"", item.first.c_str());
  }
}

// This function reads and hashes a file. While doing this, it also does these
// things:
//
// - Makes include file paths for which the base directory is a prefix relative
//   when computing the hash sum.
// - Stores the paths and hashes of included files in the global variable
//   g_included_files.
static bool
process_preprocessed_file(Context& ctx, Hash& hash, const char* path, bool pump)
{
  std::string data;
  try {
    data = Util::read_file(path);
  } catch (Error&) {
    return false;
  }

  // Bytes between p and q are pending to be hashed.
  const char* p = data.data();
  char* q = const_cast<char*>(data.data()); // cast needed before C++17
  const char* end = data.c_str() + data.length();

  // There must be at least 7 characters (# 1 ""x"") left to potentially find an
  // include file path.
  while (q < end - 7) {
    // Check if we look at a line containing the file name of an included file.
    // At least the following formats exist (where N is a positive integer):
    //
    // GCC:
    //
    //   # N ""file""
    //   # N ""file"" N
    //   #pragma GCC pch_preprocess ""file""
    //
    // HP's compiler:
    //
    //   #line N ""file""
    //
    // AIX's compiler:
    //
    //   #line N ""file""
    //   #line N
    //
    // Note that there may be other lines starting with '#' left after
    // preprocessing as well, for instance ""#    pragma"".
    if (q[0] == '#'
        // GCC:
        && ((q[1] == ' ' && q[2] >= '0' && q[2] <= '9')
            // GCC precompiled header:
            || (q[1] == 'p'
                && str_startswith(&q[2], ""ragma GCC pch_preprocess ""))
            // HP/AIX:
            || (q[1] == 'l' && q[2] == 'i' && q[3] == 'n' && q[4] == 'e'
                && q[5] == ' '))
        && (q == data.data() || q[-1] == '\n')) {
      // Workarounds for preprocessor linemarker bugs in GCC version 6.
      if (q[2] == '3') {
        if (str_startswith(q, ""# 31 \""<command-line>\""\n"")) {
          // Bogus extra line with #31, after the regular #1: Ignore the whole
          // line, and continue parsing.
          hash.hash(p, q - p);
          while (q < end && *q != '\n') {
            q++;
          }
          q++;
          p = q;
          continue;
        } else if (str_startswith(q, ""# 32 \""<command-line>\"" 2\n"")) {
          // Bogus wrong line with #32, instead of regular #1: Replace the line
          // number with the usual one.
          hash.hash(p, q - p);
          q += 1;
          q[0] = '#';
          q[1] = ' ';
          q[2] = '1';
          p = q;
        }
      }

      while (q < end && *q != '""' && *q != '\n') {
        q++;
      }
      if (q < end && *q == '\n') {
        // A newline before the quotation mark -> no match.
        continue;
      }
      q++;
      if (q >= end) {
        cc_log(""Failed to parse included file path"");
        return false;
      }
      // q points to the beginning of an include file path
      hash.hash(p, q - p);
      p = q;
      while (q < end && *q != '""') {
        q++;
      }
      // Look for preprocessor flags, after the ""filename"".
      bool system = false;
      const char* r = q + 1;
      while (r < end && *r != '\n') {
        if (*r == '3') { // System header.
          system = true;
        }
        r++;
      }
      // p and q span the include file path.
      std::string inc_path(p, q - p);
      if (!ctx.has_absolute_include_headers) {
        ctx.has_absolute_include_headers = Util::is_absolute_path(inc_path);
      }
      inc_path = Util::make_relative_path(ctx, inc_path);

      bool should_hash_inc_path = true;
      if (!ctx.config.hash_dir()) {
        if (Util::starts_with(inc_path, ctx.apparent_cwd)
            && Util::ends_with(inc_path, ""//"")) {
          // When compiling with -g or similar, GCC adds the absolute path to
          // CWD like this:
          //
          //   # 1 ""CWD//""
          //
          // If the user has opted out of including the CWD in the hash, don't
          // hash it. See also how debug_prefix_map is handled.
          should_hash_inc_path = false;
        }
      }
      if (should_hash_inc_path) {
        hash.hash(inc_path);
      }

      remember_include_file(ctx, inc_path, hash, system, nullptr);
      p = q; // Everything of interest between p and q has been hashed now.
    } else if (q[0] == '.' && q[1] == 'i' && q[2] == 'n' && q[3] == 'c'
               && q[4] == 'b' && q[5] == 'i' && q[6] == 'n') {
      // An assembler .inc bin (without the space) statement, which could be
      // part of inline assembly, refers to an external file. If the file
      // changes, the hash should change as well, but finding out what file to
      // hash is too hard for ccache, so just bail out.
      cc_log(
        ""Found unsupported .inc""
        ""bin directive in source code"");
      failed(STATS_UNSUPPORTED_DIRECTIVE);
    } else if (pump && strncmp(q, ""_________"", 9) == 0) {
      // Unfortunately the distcc-pump wrapper outputs standard output lines:
      // __________Using distcc-pump from /usr/bin
      // __________Using # distcc servers in pump mode
      // __________Shutting down distcc-pump include server
      while (q < end && *q != '\n') {
        q++;
      }
      if (*q == '\n') {
        q++;
      }
      p = q;
      continue;
    } else {
      q++;
    }
  }

  hash.hash(p, (end - p));

  // Explicitly check the .gch/.pch/.pth file as Clang does not include any
  // mention of it in the preprocessed output.
  if (!ctx.included_pch_file.empty()) {
    std::string pch_path =
      Util::make_relative_path(ctx, ctx.included_pch_file.c_str());
    hash.hash(pch_path);
    remember_include_file(ctx, pch_path, hash, false, nullptr);
  }

  bool debug_included = getenv(""CCACHE_DEBUG_INCLUDED"");
  if (debug_included) {
    print_included_files(ctx, stdout);
  }

  return true;
}

// Replace absolute paths with relative paths in the provided dependency file.
static void
use_relative_paths_in_depfile(const Context& ctx)
{
  if (ctx.config.base_dir().empty()) {
    cc_log(""Base dir not set, skip using relative paths"");
    return; // nothing to do
  }
  if (!ctx.has_absolute_include_headers) {
    cc_log(
      ""No absolute path for included files found, skip using relative paths"");
    return; // nothing to do
  }

  const std::string& output_dep = ctx.args_info.output_dep;
  std::string file_content;
  try {
    file_content = Util::read_file(output_dep);
  } catch (const Error& e) {
    cc_log(""Cannot open dependency file %s: %s"", output_dep.c_str(), e.what());
    return;
  }

  std::string adjusted_file_content;
  adjusted_file_content.reserve(file_content.size());

  bool rewritten = false;

  for (string_view token : Util::split_into_views(file_content, "" \t\r\n"")) {
    if (Util::is_absolute_path(token)
        && token.starts_with(ctx.config.base_dir())) {
      adjusted_file_content.append(Util::make_relative_path(ctx, token));
      rewritten = true;
    } else {
      adjusted_file_content.append(token.begin(), token.end());
    }
    adjusted_file_content.push_back(' ');
  }

  if (!rewritten) {
    cc_log(
      ""No paths in dependency file %s made relative, skip relative path usage"",
      output_dep.c_str());
    return;
  }

  std::string tmp_file = fmt::format(""{}.tmp{}"", output_dep, tmp_string());

  try {
    Util::write_file(tmp_file, adjusted_file_content);
  } catch (const Error& e) {
    cc_log(
      ""Error writing temporary dependency file %s (%s), skip relative path""
      "" usage"",
      tmp_file.c_str(),
      e.what());
    Util::unlink_safe(tmp_file);
    return;
  }

  if (x_rename(tmp_file.c_str(), output_dep.c_str()) != 0) {
    cc_log(
      ""Error renaming dependency file: %s -> %s (%s), skip relative path usage"",
      tmp_file.c_str(),
      output_dep.c_str(),
      strerror(errno));
    Util::unlink_safe(tmp_file);
  } else {
    cc_log(""Renamed dependency file: %s -> %s"",
           tmp_file.c_str(),
           output_dep.c_str());
  }
}

// Extract the used includes from the dependency file. Note that we cannot
// distinguish system headers from other includes here.
static optional<Digest>
result_name_from_depfile(Context& ctx, Hash& hash)
{
  std::string file_content;
  try {
    file_content = Util::read_file(ctx.args_info.output_dep);
  } catch (const Error& e) {
    cc_log(""Cannot open dependency file %s: %s"",
           ctx.args_info.output_dep.c_str(),
           e.what());
    return nullopt;
  }

  for (string_view token : Util::split_into_views(file_content, "" \t\r\n"")) {
    if (token == ""\\"" || token.ends_with("":"")) {
      continue;
    }
    if (!ctx.has_absolute_include_headers) {
      ctx.has_absolute_include_headers = Util::is_absolute_path(token);
    }
    std::string path = Util::make_relative_path(ctx, token);
    remember_include_file(ctx, path, hash, false, &hash);
  }

  // Explicitly check the .gch/.pch/.pth file as it may not be mentioned in the
  // dependencies output.
  if (!ctx.included_pch_file.empty()) {
    std::string pch_path =
      Util::make_relative_path(ctx, ctx.included_pch_file.c_str());
    hash.hash(pch_path);
    remember_include_file(ctx, pch_path, hash, false, nullptr);
  }

  bool debug_included = getenv(""CCACHE_DEBUG_INCLUDED"");
  if (debug_included) {
    print_included_files(ctx, stdout);
  }

  return hash.digest();
}

// Execute the compiler/preprocessor, with logic to retry without requesting
// colored diagnostics messages if that fails.
static int
execute(Context& ctx,
        Args& args,
        const std::string& stdout_path,
        int stdout_fd,
        const std::string& stderr_path,
        int stderr_fd)
{
  if (ctx.diagnostics_color_failed
      && ctx.guessed_compiler == GuessedCompiler::gcc) {
    args.erase_with_prefix(""-fdiagnostics-color"");
  }
  int status =
    execute(args.to_argv().data(), stdout_fd, stderr_fd, &ctx.compiler_pid);
  if (status != 0 && !ctx.diagnostics_color_failed
      && ctx.guessed_compiler == GuessedCompiler::gcc) {
    auto errors = Util::read_file(stderr_path);
    if (errors.find(""unrecognized command-line option"") != std::string::npos
        && errors.find(""-fdiagnostics-color"") != std::string::npos) {
      // Old versions of GCC did not support colored diagnostics.
      cc_log(""-fdiagnostics-color is unsupported; trying again without it"");
      if (ftruncate(stdout_fd, 0) < 0 || lseek(stdout_fd, 0, SEEK_SET) < 0) {
        cc_log(
          ""Failed to truncate %s: %s"", stdout_path.c_str(), strerror(errno));
        failed(STATS_ERROR);
      }
      if (ftruncate(stderr_fd, 0) < 0 || lseek(stderr_fd, 0, SEEK_SET) < 0) {
        cc_log(
          ""Failed to truncate %s: %s"", stderr_path.c_str(), strerror(errno));
        failed(STATS_ERROR);
      }
      ctx.diagnostics_color_failed = true;
      return execute(ctx, args, stdout_path, stdout_fd, stderr_path, stderr_fd);
    }
  }
  return status;
}

// Create or update the manifest file.
static void
update_manifest_file(Context& ctx)
{
  if (!ctx.config.direct_mode() || ctx.config.read_only()
      || ctx.config.read_only_direct()) {
    return;
  }

  auto old_st = Stat::stat(ctx.manifest_path());

  // See comment in get_file_hash_index for why saving of timestamps is forced
  // for precompiled headers.
  bool save_timestamp = (ctx.config.sloppiness() & SLOPPY_FILE_STAT_MATCHES)
                        || ctx.args_info.output_is_precompiled_header;

  MTR_BEGIN(""manifest"", ""manifest_put"");
  cc_log(""Adding result name to %s"", ctx.manifest_path().c_str());
  if (!manifest_put(ctx.config,
                    ctx.manifest_path(),
                    ctx.result_name(),
                    ctx.included_files,
                    ctx.time_of_compilation,
                    save_timestamp)) {
    cc_log(""Failed to add result name to %s"", ctx.manifest_path().c_str());
  } else {
    auto st = Stat::stat(ctx.manifest_path(), Stat::OnError::log);

    int64_t size_delta = st.size_on_disk() - old_st.size_on_disk();
    int nof_files_delta = !old_st && st ? 1 : 0;

    if (ctx.stats_file() == ctx.manifest_stats_file()) {
      stats_update_size(ctx.counter_updates, size_delta, nof_files_delta);
    } else {
      Counters counters;
      stats_update_size(counters, size_delta, nof_files_delta);
      stats_flush_to_file(ctx.config, ctx.manifest_stats_file(), counters);
    }
  }
  MTR_END(""manifest"", ""manifest_put"");
}

static bool
create_cachedir_tag(nonstd::string_view dir)
{
  constexpr char cachedir_tag[] =
    ""Signature: 8a477f597d28d172789f06886806bc55\n""
    ""# This file is a cache directory tag created by ccache.\n""
    ""# For information about cache directory tags, see:\n""
    ""#\thttp://www.brynosaurus.com/cachedir/\n"";

  std::string filename = fmt::format(""{}/CACHEDIR.TAG"", dir);
  auto st = Stat::stat(filename);

  if (st) {
    if (st.is_regular()) {
      return true;
    }
    errno = EEXIST;
    return false;
  }

  File f(filename, ""w"");

  if (!f) {
    return false;
  }

  return fwrite(cachedir_tag, strlen(cachedir_tag), 1, f.get()) == 1;
}

// Run the real compiler and put the result in cache.
static void
to_cache(Context& ctx,
         Args& args,
         Args& depend_extra_args,
         Hash* depend_mode_hash)
{
  args.push_back(""-o"");
  args.push_back(ctx.args_info.output_obj);

  if (ctx.config.hard_link() && ctx.args_info.output_obj != ""/dev/null"") {
    // Workaround for Clang bug where it overwrites an existing object file
    // when it's compiling an assembler file, see
    // <https://bugs.llvm.org/show_bug.cgi?id=39782>.
    Util::unlink_safe(ctx.args_info.output_obj);
  }

  if (ctx.args_info.generating_diagnostics) {
    args.push_back(""--serialize-diagnostics"");
    args.push_back(ctx.args_info.output_dia);
  }

  // Turn off DEPENDENCIES_OUTPUT when running cc1, because otherwise it will
  // emit a line like this:
  //
  //   tmp.stdout.vexed.732.o: /home/mbp/.ccache/tmp.stdout.vexed.732.i
  x_unsetenv(""DEPENDENCIES_OUTPUT"");
  x_unsetenv(""SUNPRO_DEPENDENCIES"");

  if (ctx.config.run_second_cpp()) {
    args.push_back(ctx.args_info.input_file);
  } else {
    args.push_back(ctx.i_tmpfile);
  }

  if (ctx.args_info.seen_split_dwarf) {
    // Remove any pre-existing .dwo file since we want to check if the compiler
    // produced one, intentionally not using x_unlink or tmp_unlink since we're
    // not interested in logging successful deletions or failures due to
    // non-existent .dwo files.
    if (unlink(ctx.args_info.output_dwo.c_str()) != 0 && errno != ENOENT
        && errno != ESTALE) {
      cc_log(""Failed to unlink %s: %s"",
             ctx.args_info.output_dwo.c_str(),
             strerror(errno));
      failed(STATS_BADOUTPUTFILE);
    }
  }

  cc_log(""Running real compiler"");
  MTR_BEGIN(""execute"", ""compiler"");

  const auto tmp_stdout_fd_and_path = Util::create_temp_fd(
    fmt::format(""{}/tmp.stdout"", ctx.config.temporary_dir()));
  int tmp_stdout_fd = tmp_stdout_fd_and_path.first;
  const std::string& tmp_stdout = tmp_stdout_fd_and_path.second;
  ctx.register_pending_tmp_file(tmp_stdout);

  const auto tmp_stderr_fd_and_path = Util::create_temp_fd(
    fmt::format(""{}/tmp.stderr"", ctx.config.temporary_dir()));
  int tmp_stderr_fd = tmp_stderr_fd_and_path.first;
  const std::string& tmp_stderr = tmp_stderr_fd_and_path.second;
  ctx.register_pending_tmp_file(tmp_stderr);

  int status;
  if (!ctx.config.depend_mode()) {
    status =
      execute(ctx, args, tmp_stdout, tmp_stdout_fd, tmp_stderr, tmp_stderr_fd);
    args.pop_back(3);
  } else {
    // Use the original arguments (including dependency options) in depend
    // mode.
    Args depend_mode_args = ctx.orig_args;
    depend_mode_args.erase_with_prefix(""--ccache-"");
    depend_mode_args.push_back(depend_extra_args);
    add_prefix(ctx, depend_mode_args, ctx.config.prefix_command());

    ctx.time_of_compilation = time(nullptr);
    status = execute(ctx,
                     depend_mode_args,
                     tmp_stdout,
                     tmp_stdout_fd,
                     tmp_stderr,
                     tmp_stderr_fd);
  }
  MTR_END(""execute"", ""compiler"");

  auto st = Stat::stat(tmp_stdout, Stat::OnError::log);
  if (!st) {
    // The stdout file was removed - cleanup in progress? Better bail out.
    failed(STATS_MISSING);
  }

  // distcc-pump outputs lines like this:
  // __________Using # distcc servers in pump mode
  if (st.size() != 0 && ctx.guessed_compiler != GuessedCompiler::pump) {
    cc_log(""Compiler produced stdout"");
    failed(STATS_STDOUT);
  }

  // Merge stderr from the preprocessor (if any) and stderr from the real
  // compiler into tmp_stderr.
  if (!ctx.cpp_stderr.empty()) {
    std::string combined_stderr =
      Util::read_file(ctx.cpp_stderr) + Util::read_file(tmp_stderr);
    Util::write_file(tmp_stderr, combined_stderr);
  }

  if (status != 0) {
    cc_log(""Compiler gave exit status %d"", status);

    // We can output stderr immediately instead of rerunning the compiler.
    Util::send_to_stderr(Util::read_file(tmp_stderr),
                         ctx.args_info.strip_diagnostics_colors);

    failed(STATS_STATUS, status);
  }

  if (ctx.config.depend_mode()) {
    assert(depend_mode_hash);
    auto result_name = result_name_from_depfile(ctx, *depend_mode_hash);
    if (!result_name) {
      failed(STATS_ERROR);
    }
    ctx.set_result_name(*result_name);
  }

  bool produce_dep_file = ctx.args_info.generating_dependencies
                          && ctx.args_info.output_dep != ""/dev/null"";

  if (produce_dep_file) {
    use_relative_paths_in_depfile(ctx);
  }

  st = Stat::stat(ctx.args_info.output_obj);
  if (!st) {
    cc_log(""Compiler didn't produce an object file"");
    failed(STATS_NOOUTPUT);
  }
  if (st.size() == 0) {
    cc_log(""Compiler produced an empty object file"");
    failed(STATS_EMPTYOUTPUT);
  }

  st = Stat::stat(tmp_stderr, Stat::OnError::log);
  if (!st) {
    failed(STATS_ERROR);
  }

  auto orig_dest_stat = Stat::stat(ctx.result_path());
  Result::Writer result_writer(ctx, ctx.result_path());

  if (st.size() > 0) {
    result_writer.write(Result::FileType::stderr_output, tmp_stderr);
  }
  result_writer.write(Result::FileType::object, ctx.args_info.output_obj);
  if (ctx.args_info.generating_dependencies) {
    result_writer.write(Result::FileType::dependency, ctx.args_info.output_dep);
  }
  if (ctx.args_info.generating_coverage) {
    result_writer.write(Result::FileType::coverage, ctx.args_info.output_cov);
  }
  if (ctx.args_info.generating_stackusage) {
    result_writer.write(Result::FileType::stackusage, ctx.args_info.output_su);
  }
  if (ctx.args_info.generating_diagnostics) {
    result_writer.write(Result::FileType::diagnostic, ctx.args_info.output_dia);
  }
  if (ctx.args_info.seen_split_dwarf && Stat::stat(ctx.args_info.output_dwo)) {
    // Only store .dwo file if it was created by the compiler (GCC and Clang
    // behave differently e.g. for ""-gsplit-dwarf -g1"").
    result_writer.write(Result::FileType::dwarf_object,
                        ctx.args_info.output_dwo);
  }

  auto error = result_writer.finalize();
  if (error) {
    cc_log(""Error: %s"", error->c_str());
  } else {
    cc_log(""Stored in cache: %s"", ctx.result_path().c_str());
  }

  auto new_dest_stat = Stat::stat(ctx.result_path(), Stat::OnError::log);
  if (!new_dest_stat) {
    failed(STATS_ERROR);
  }
  stats_update_size(ctx.counter_updates,
                    new_dest_stat.size_on_disk()
                      - orig_dest_stat.size_on_disk(),
                    orig_dest_stat ? 0 : 1);

  MTR_END(""file"", ""file_put"");

  // Make sure we have a CACHEDIR.TAG in the cache part of cache_dir. This can
  // be done almost anywhere, but we might as well do it near the end as we
  // save the stat call if we exit early.
  {
    std::string first_level_dir(Util::dir_name(ctx.stats_file()));
    if (!create_cachedir_tag(first_level_dir)) {
      cc_log(""Failed to create %s/CACHEDIR.TAG (%s)"",
             first_level_dir.c_str(),
             strerror(errno));
    }

    // Remove any CACHEDIR.TAG on the cache_dir level where it was located in
    // previous ccache versions.
    if (getpid() % 1000 == 0) {
      char* path = format(""%s/CACHEDIR.TAG"", ctx.config.cache_dir().c_str());
      Util::unlink_safe(path);
      free(path);
    }
  }

  // Everything OK.
  Util::send_to_stderr(Util::read_file(tmp_stderr),
                       ctx.args_info.strip_diagnostics_colors);
}

// Find the result name by running the compiler in preprocessor mode and
// hashing the result.
static Digest
get_result_name_from_cpp(Context& ctx, Args& args, Hash& hash)
{
  ctx.time_of_compilation = time(nullptr);

  std::string stderr_path;
  std::string stdout_path;
  int status;
  if (ctx.args_info.direct_i_file) {
    // We are compiling a .i or .ii file - that means we can skip the cpp stage
    // and directly form the correct i_tmpfile.
    stdout_path = ctx.args_info.input_file;
    status = 0;
  } else {
    // Run cpp on the input file to obtain the .i.

    // Limit the basename to 10 characters in order to cope with filesystem with
    // small maximum filename length limits.
    string_view input_base =
      Util::get_truncated_base_name(ctx.args_info.input_file, 10);
    auto stdout_fd_and_path = Util::create_temp_fd(
      fmt::format(""{}/{}.stdout"", ctx.config.temporary_dir(), input_base));
    int stdout_fd = stdout_fd_and_path.first;
    stdout_path = stdout_fd_and_path.second;
    ctx.register_pending_tmp_file(stdout_path);

    auto stderr_fd_and_path = Util::create_temp_fd(
      fmt::format(""{}/tmp.cpp_stderr"", ctx.config.temporary_dir()));
    int stderr_fd = stderr_fd_and_path.first;
    stderr_path = stderr_fd_and_path.second;
    ctx.register_pending_tmp_file(stderr_path);

    size_t args_added = 2;
    args.push_back(""-E"");
    if (ctx.config.keep_comments_cpp()) {
      args.push_back(""-C"");
      args_added = 3;
    }
    args.push_back(ctx.args_info.input_file);
    add_prefix(ctx, args, ctx.config.prefix_command_cpp());
    cc_log(""Running preprocessor"");
    MTR_BEGIN(""execute"", ""preprocessor"");
    status = execute(ctx, args, stdout_path, stdout_fd, stderr_path, stderr_fd);
    MTR_END(""execute"", ""preprocessor"");
    args.pop_back(args_added);
  }

  if (status != 0) {
    cc_log(""Preprocessor gave exit status %d"", status);
    failed(STATS_PREPROCESSOR);
  }

  hash.hash_delimiter(""cpp"");
  bool is_pump = ctx.guessed_compiler == GuessedCompiler::pump;
  if (!process_preprocessed_file(ctx, hash, stdout_path.c_str(), is_pump)) {
    failed(STATS_ERROR);
  }

  hash.hash_delimiter(""cppstderr"");
  if (!ctx.args_info.direct_i_file
      && !hash_binary_file(ctx, hash, stderr_path.c_str())) {
    // Somebody removed the temporary file?
    cc_log(""Failed to open %s: %s"", stderr_path.c_str(), strerror(errno));
    failed(STATS_ERROR);
  }

  if (ctx.args_info.direct_i_file) {
    ctx.i_tmpfile = ctx.args_info.input_file;
  } else {
    // i_tmpfile needs the proper cpp_extension for the compiler to do its
    // thing correctly
    ctx.i_tmpfile =
      fmt::format(""{}.{}"", stdout_path, ctx.config.cpp_extension());
    x_rename(stdout_path.c_str(), ctx.i_tmpfile.c_str());
    ctx.register_pending_tmp_file(ctx.i_tmpfile);
  }

  if (!ctx.config.run_second_cpp()) {
    // If we are using the CPP trick, we need to remember this stderr data and
    // output it just before the main stderr from the compiler pass.
    ctx.cpp_stderr = stderr_path;
    hash.hash_delimiter(""runsecondcpp"");
    hash.hash(""false"");
  }

  return hash.digest();
}

// Hash mtime or content of a file, or the output of a command, according to
// the CCACHE_COMPILERCHECK setting.
static void
hash_compiler(const Context& ctx,
              Hash& hash,
              const Stat& st,
              const char* path,
              bool allow_command)
{
  if (ctx.config.compiler_check() == ""none"") {
    // Do nothing.
  } else if (ctx.config.compiler_check() == ""mtime"") {
    hash.hash_delimiter(""cc_mtime"");
    hash.hash(st.size());
    hash.hash(st.mtime());
  } else if (Util::starts_with(ctx.config.compiler_check(), ""string:"")) {
    hash.hash_delimiter(""cc_hash"");
    hash.hash(ctx.config.compiler_check().c_str() + strlen(""string:""));
  } else if (ctx.config.compiler_check() == ""content"" || !allow_command) {
    hash.hash_delimiter(""cc_content"");
    hash_binary_file(ctx, hash, path);
  } else { // command string
    if (!hash_multicommand_output(hash,
                                  ctx.config.compiler_check().c_str(),
                                  ctx.orig_args[0].c_str())) {
      cc_log(""Failure running compiler check command: %s"",
             ctx.config.compiler_check().c_str());
      failed(STATS_COMPCHECK);
    }
  }
}

// Hash the host compiler(s) invoked by nvcc.
//
// If ccbin_st and ccbin are set, they refer to a directory or compiler set
// with -ccbin/--compiler-bindir. If they are NULL, the compilers are looked up
// in PATH instead.
static void
hash_nvcc_host_compiler(const Context& ctx,
                        Hash& hash,
                        const Stat* ccbin_st,
                        const char* ccbin)
{
  // From <http://docs.nvidia.com/cuda/cuda-compiler-driver-nvcc/index.html>:
  //
  //   ""[...] Specify the directory in which the compiler executable resides.
  //   The host compiler executable name can be also specified to ensure that
  //   the correct host compiler is selected.""
  //
  // and
  //
  //   ""On all platforms, the default host compiler executable (gcc and g++ on
  //   Linux, clang and clang++ on Mac OS X, and cl.exe on Windows) found in
  //   the current execution search path will be used"".

  if (!ccbin || ccbin_st->is_directory()) {
#if defined(__APPLE__)
    const char* compilers[] = {""clang"", ""clang++""};
#elif defined(_WIN32)
    const char* compilers[] = {""cl.exe""};
#else
    const char* compilers[] = {""gcc"", ""g++""};
#endif
    for (const char* compiler : compilers) {
      if (ccbin) {
        char* path = format(""%s/%s"", ccbin, compiler);
        auto st = Stat::stat(path);
        if (st) {
          hash_compiler(ctx, hash, st, path, false);
        }
        free(path);
      } else {
        std::string path = find_executable(ctx, compiler, MYNAME);
        if (!path.empty()) {
          auto st = Stat::stat(path, Stat::OnError::log);
          hash_compiler(ctx, hash, st, ccbin, false);
        }
      }
    }
  } else {
    hash_compiler(ctx, hash, *ccbin_st, ccbin, false);
  }
}

// Update a hash with information common for the direct and preprocessor modes.
static void
hash_common_info(const Context& ctx,
                 const Args& args,
                 Hash& hash,
                 const ArgsInfo& args_info)
{
  hash.hash(HASH_PREFIX);

  // We have to hash the extension, as a .i file isn't treated the same by the
  // compiler as a .ii file.
  hash.hash_delimiter(""ext"");
  hash.hash(ctx.config.cpp_extension().c_str());

#ifdef _WIN32
  const char* ext = strrchr(args[0].c_str(), '.');
  char full_path_win_ext[MAX_PATH + 1] = {0};
  add_exe_ext_if_no_to_fullpath(
    full_path_win_ext, MAX_PATH, ext, args[0].c_str());
  const char* full_path = full_path_win_ext;
#else
  const char* full_path = args[0].c_str();
#endif

  auto st = Stat::stat(full_path, Stat::OnError::log);
  if (!st) {
    failed(STATS_COMPILER);
  }

  // Hash information about the compiler.
  hash_compiler(ctx, hash, st, args[0].c_str(), true);

  // Also hash the compiler name as some compilers use hard links and behave
  // differently depending on the real name.
  hash.hash_delimiter(""cc_name"");
  hash.hash(Util::base_name(args[0]));

  if (!(ctx.config.sloppiness() & SLOPPY_LOCALE)) {
    // Hash environment variables that may affect localization of compiler
    // warning messages.
    const char* envvars[] = {
      ""LANG"", ""LC_ALL"", ""LC_CTYPE"", ""LC_MESSAGES"", nullptr};
    for (const char** p = envvars; *p; ++p) {
      char* v = getenv(*p);
      if (v) {
        hash.hash_delimiter(*p);
        hash.hash(v);
      }
    }
  }

  // Possibly hash the current working directory.
  if (args_info.generating_debuginfo && ctx.config.hash_dir()) {
    std::string dir_to_hash = ctx.apparent_cwd;
    for (const auto& map : args_info.debug_prefix_maps) {
      size_t sep_pos = map.find('=');
      if (sep_pos != std::string::npos) {
        std::string old_path = map.substr(0, sep_pos);
        std::string new_path = map.substr(sep_pos + 1);
        cc_log(""Relocating debuginfo from %s to %s (CWD: %s)"",
               old_path.c_str(),
               new_path.c_str(),
               ctx.apparent_cwd.c_str());
        if (Util::starts_with(ctx.apparent_cwd, old_path)) {
          dir_to_hash = new_path + ctx.apparent_cwd.substr(old_path.size());
        }
      }
    }
    cc_log(""Hashing CWD %s"", dir_to_hash.c_str());
    hash.hash_delimiter(""cwd"");
    hash.hash(dir_to_hash);
  }

  if (ctx.args_info.generating_dependencies || ctx.args_info.seen_split_dwarf) {
    // The output object file name is part of the .d file, so include the path
    // in the hash if generating dependencies.
    //
    // Object files include a link to the corresponding .dwo file based on the
    // target object filename when using -gsplit-dwarf, so hashing the object
    // file path will do it, although just hashing the object file base name
    // would be enough.
    hash.hash_delimiter(""object file"");
    hash.hash(ctx.args_info.output_obj);
  }

  // Possibly hash the coverage data file path.
  if (ctx.args_info.generating_coverage && ctx.args_info.profile_arcs) {
    std::string dir;
    if (!ctx.args_info.profile_path.empty()) {
      dir = ctx.args_info.profile_path;
    } else {
      dir =
        Util::real_path(std::string(Util::dir_name(ctx.args_info.output_obj)));
    }
    string_view stem =
      Util::remove_extension(Util::base_name(ctx.args_info.output_obj));
    std::string gcda_path = fmt::format(""{}/{}.gcda"", dir, stem);
    cc_log(""Hashing coverage path %s"", gcda_path.c_str());
    hash.hash_delimiter(""gcda"");
    hash.hash(gcda_path);
  }

  // Possibly hash the sanitize blacklist file path.
  for (const auto& sanitize_blacklist : args_info.sanitize_blacklists) {
    cc_log(""Hashing sanitize blacklist %s"", sanitize_blacklist.c_str());
    hash.hash(""sanitizeblacklist"");
    if (!hash_binary_file(ctx, hash, sanitize_blacklist.c_str())) {
      failed(STATS_BADEXTRAFILE);
    }
  }

  if (!ctx.config.extra_files_to_hash().empty()) {
    for (const std::string& path : Util::split_into_strings(
           ctx.config.extra_files_to_hash(), PATH_DELIM)) {
      cc_log(""Hashing extra file %s"", path.c_str());
      hash.hash_delimiter(""extrafile"");
      if (!hash_binary_file(ctx, hash, path.c_str())) {
        failed(STATS_BADEXTRAFILE);
      }
    }
  }

  // Possibly hash GCC_COLORS (for color diagnostics).
  if (ctx.guessed_compiler == GuessedCompiler::gcc) {
    const char* gcc_colors = getenv(""GCC_COLORS"");
    if (gcc_colors) {
      hash.hash_delimiter(""gcccolors"");
      hash.hash(gcc_colors);
    }
  }
}

static bool
hash_profile_data_file(const Context& ctx, Hash& hash)
{
  const std::string& profile_path = ctx.args_info.profile_path;
  string_view base_name = Util::remove_extension(ctx.args_info.output_obj);
  std::string hashified_cwd = ctx.apparent_cwd;
  std::replace(hashified_cwd.begin(), hashified_cwd.end(), '/', '#');

  std::vector<std::string> paths_to_try{
    // -fprofile-use[=dir]/-fbranch-probabilities (GCC <9)
    fmt::format(""{}/{}.gcda"", profile_path, base_name),
    // -fprofile-use[=dir]/-fbranch-probabilities (GCC >=9)
    fmt::format(""{}/{}#{}.gcda"", profile_path, hashified_cwd, base_name),
    // -fprofile(-instr|-sample)-use=file (Clang), -fauto-profile=file (GCC >=5)
    profile_path,
    // -fprofile(-instr|-sample)-use=dir (Clang)
    fmt::format(""{}/default.profdata"", profile_path),
    // -fauto-profile (GCC >=5)
    ""fbdata.afdo"", // -fprofile-dir is not used
  };

  bool found = false;
  for (const std::string& p : paths_to_try) {
    cc_log(""Checking for profile data file %s"", p.c_str());
    auto st = Stat::stat(p);
    if (st && !st.is_directory()) {
      cc_log(""Adding profile data %s to the hash"", p.c_str());
      hash.hash_delimiter(""-fprofile-use"");
      if (hash_binary_file(ctx, hash, p.c_str())) {
        found = true;
      }
    }
  }

  return found;
}

static bool
option_should_be_ignored(const std::string& arg,
                         const std::vector<std::string>& patterns)
{
  return std::any_of(
    patterns.cbegin(), patterns.cend(), [&arg](const std::string& pattern) {
      const auto& prefix = string_view(pattern).substr(0, pattern.length() - 1);
      return (
        pattern == arg
        || (Util::ends_with(pattern, ""*"") && Util::starts_with(arg, prefix)));
    });
}

// Update a hash sum with information specific to the direct and preprocessor
// modes and calculate the result name. Returns the result name on success,
// otherwise NULL. Caller frees.
static optional<Digest>
calculate_result_name(Context& ctx,
                      const Args& args,
                      Args& preprocessor_args,
                      Hash& hash,
                      bool direct_mode)
{
  bool found_ccbin = false;

  hash.hash_delimiter(""result version"");
  hash.hash(Result::k_version);

  if (direct_mode) {
    hash.hash_delimiter(""manifest version"");
    hash.hash(k_manifest_version);
  }

  // clang will emit warnings for unused linker flags, so we shouldn't skip
  // those arguments.
  int is_clang = ctx.guessed_compiler == GuessedCompiler::clang
                 || ctx.guessed_compiler == GuessedCompiler::unknown;

  // First the arguments.
  for (size_t i = 1; i < args.size(); i++) {
    // Trust the user if they've said we should not hash a given option.
    if (option_should_be_ignored(args[i], ctx.ignore_options())) {
      cc_log(""Not hashing ignored option: %s"", args[i].c_str());
      if (i + 1 < args.size() && compopt_takes_arg(args[i])) {
        i++;
        cc_log(""Not hashing argument of ignored option: %s"", args[i].c_str());
      }
      continue;
    }

    // -L doesn't affect compilation (except for clang).
    if (i < args.size() - 1 && args[i] == ""-L"" && !is_clang) {
      i++;
      continue;
    }
    if (Util::starts_with(args[i], ""-L"") && !is_clang) {
      continue;
    }

    // -Wl,... doesn't affect compilation (except for clang).
    if (Util::starts_with(args[i], ""-Wl,"") && !is_clang) {
      continue;
    }

    // The -fdebug-prefix-map option may be used in combination with
    // CCACHE_BASEDIR to reuse results across different directories. Skip using
    // the value of the option from hashing but still hash the existence of the
    // option.
    if (Util::starts_with(args[i], ""-fdebug-prefix-map="")) {
      hash.hash_delimiter(""arg"");
      hash.hash(""-fdebug-prefix-map="");
      continue;
    }
    if (Util::starts_with(args[i], ""-ffile-prefix-map="")) {
      hash.hash_delimiter(""arg"");
      hash.hash(""-ffile-prefix-map="");
      continue;
    }
    if (Util::starts_with(args[i], ""-fmacro-prefix-map="")) {
      hash.hash_delimiter(""arg"");
      hash.hash(""-fmacro-prefix-map="");
      continue;
    }

    // When using the preprocessor, some arguments don't contribute to the
    // hash. The theory is that these arguments will change the output of -E if
    // they are going to have any effect at all. For precompiled headers this
    // might not be the case.
    if (!direct_mode && !ctx.args_info.output_is_precompiled_header
        && !ctx.args_info.using_precompiled_header) {
      if (compopt_affects_cpp(args[i])) {
        if (compopt_takes_arg(args[i])) {
          i++;
        }
        continue;
      }
      if (compopt_short(compopt_affects_cpp, args[i])) {
        continue;
      }
    }

    // If we're generating dependencies, we make sure to skip the filename of
    // the dependency file, since it doesn't impact the output.
    if (ctx.args_info.generating_dependencies) {
      if (Util::starts_with(args[i], ""-Wp,"")) {
        if (Util::starts_with(args[i], ""-Wp,-MD,"")
            && !strchr(args[i].c_str() + 8, ',')) {
          hash.hash(args[i].c_str(), 8);
          continue;
        } else if (Util::starts_with(args[i], ""-Wp,-MMD,"")
                   && !strchr(args[i].c_str() + 9, ',')) {
          hash.hash(args[i].c_str(), 9);
          continue;
        }
      } else if (Util::starts_with(args[i], ""-MF"")) {
        // In either case, hash the ""-MF"" part.
        hash.hash_delimiter(""arg"");
        hash.hash(args[i].c_str(), 3);

        if (ctx.args_info.output_dep != ""/dev/null"") {
          bool separate_argument = (args[i].size() == 3);
          if (separate_argument) {
            // Next argument is dependency name, so skip it.
            i++;
          }
        }
        continue;
      }
    }

    const char* p = nullptr;
    if (Util::starts_with(args[i], ""-specs="")) {
      p = args[i].c_str() + 7;
    } else if (Util::starts_with(args[i], ""--specs="")) {
      p = args[i].c_str() + 8;
    }

    if (p) {
      auto st = Stat::stat(p, Stat::OnError::log);
      if (st) {
        // If given an explicit specs file, then hash that file, but don't
        // include the path to it in the hash.
        hash.hash_delimiter(""specs"");
        hash_compiler(ctx, hash, st, p, false);
        continue;
      }
    }

    if (Util::starts_with(args[i], ""-fplugin="")) {
      auto st = Stat::stat(args[i].c_str() + 9, Stat::OnError::log);
      if (st) {
        hash.hash_delimiter(""plugin"");
        hash_compiler(ctx, hash, st, args[i].c_str() + 9, false);
        continue;
      }
    }

    if (args[i] == ""-Xclang"" && i + 3 < args.size() && args[i + 1] == ""-load""
        && args[i + 2] == ""-Xclang"") {
      auto st = Stat::stat(args[i + 3], Stat::OnError::log);
      if (st) {
        hash.hash_delimiter(""plugin"");
        hash_compiler(ctx, hash, st, args[i + 3].c_str(), false);
        i += 3;
        continue;
      }
    }

    if ((args[i] == ""-ccbin"" || args[i] == ""--compiler-bindir"")
        && i + 1 < args.size()) {
      auto st = Stat::stat(args[i + 1], Stat::OnError::log);
      if (st) {
        found_ccbin = true;
        hash.hash_delimiter(""ccbin"");
        hash_nvcc_host_compiler(ctx, hash, &st, args[i + 1].c_str());
        i++;
        continue;
      }
    }

    // All other arguments are included in the hash.
    hash.hash_delimiter(""arg"");
    hash.hash(args[i]);
    if (i + 1 < args.size() && compopt_takes_arg(args[i])) {
      i++;
      hash.hash_delimiter(""arg"");
      hash.hash(args[i]);
    }
  }

  // Make results with dependency file /dev/null different from those without
  // it.
  if (ctx.args_info.generating_dependencies
      && ctx.args_info.output_dep == ""/dev/null"") {
    hash.hash_delimiter(""/dev/null dependency file"");
  }

  if (!found_ccbin && ctx.args_info.actual_language == ""cu"") {
    hash_nvcc_host_compiler(ctx, hash, nullptr, nullptr);
  }

  // For profile generation (-fprofile(-instr)-generate[=path])
  // - hash profile path
  //
  // For profile usage (-fprofile(-instr|-sample)-use, -fbranch-probabilities):
  // - hash profile data
  //
  // -fbranch-probabilities and -fvpt usage is covered by
  // -fprofile-generate/-fprofile-use.
  //
  // The profile directory can be specified as an argument to
  // -fprofile(-instr)-generate=, -fprofile(-instr|-sample)-use= or
  // -fprofile-dir=.

  if (ctx.args_info.profile_generate) {
    assert(!ctx.args_info.profile_path.empty());
    cc_log(""Adding profile directory %s to our hash"",
           ctx.args_info.profile_path.c_str());
    hash.hash_delimiter(""-fprofile-dir"");
    hash.hash(ctx.args_info.profile_path);
  }

  if (ctx.args_info.profile_use && !hash_profile_data_file(ctx, hash)) {
    cc_log(""No profile data file found"");
    failed(STATS_NOINPUT);
  }

  // Adding -arch to hash since cpp output is affected.
  for (const auto& arch : ctx.args_info.arch_args) {
    hash.hash_delimiter(""-arch"");
    hash.hash(arch);
  }

  optional<Digest> result_name;
  if (direct_mode) {
    // Hash environment variables that affect the preprocessor output.
    const char* envvars[] = {""CPATH"",
                             ""C_INCLUDE_PATH"",
                             ""CPLUS_INCLUDE_PATH"",
                             ""OBJC_INCLUDE_PATH"",
                             ""OBJCPLUS_INCLUDE_PATH"", // clang
                             nullptr};
    for (const char** p = envvars; *p; ++p) {
      char* v = getenv(*p);
      if (v) {
        hash.hash_delimiter(*p);
        hash.hash(v);
      }
    }

    // Make sure that the direct mode hash is unique for the input file path.
    // If this would not be the case:
    //
    // * An false cache hit may be produced. Scenario:
    //   - a/r.h exists.
    //   - a/x.c has #include ""r.h"".
    //   - b/x.c is identical to a/x.c.
    //   - Compiling a/x.c records a/r.h in the manifest.
    //   - Compiling b/x.c results in a false cache hit since a/x.c and b/x.c
    //     share manifests and a/r.h exists.
    // * The expansion of __FILE__ may be incorrect.
    hash.hash_delimiter(""inputfile"");
    hash.hash(ctx.args_info.input_file);

    hash.hash_delimiter(""sourcecode"");
    int result =
      hash_source_code_file(ctx, hash, ctx.args_info.input_file.c_str());
    if (result & HASH_SOURCE_CODE_ERROR) {
      failed(STATS_ERROR);
    }
    if (result & HASH_SOURCE_CODE_FOUND_TIME) {
      cc_log(""Disabling direct mode"");
      ctx.config.set_direct_mode(false);
      return nullopt;
    }

    ctx.set_manifest_name(hash.digest());

    cc_log(""Looking for result name in %s"", ctx.manifest_path().c_str());
    MTR_BEGIN(""manifest"", ""manifest_get"");
    result_name = manifest_get(ctx, ctx.manifest_path());
    MTR_END(""manifest"", ""manifest_get"");
    if (result_name) {
      cc_log(""Got result name from manifest"");
    } else {
      cc_log(""Did not find result name in manifest"");
    }
  } else {
    if (ctx.args_info.arch_args.empty()) {
      result_name = get_result_name_from_cpp(ctx, preprocessor_args, hash);
      cc_log(""Got result name from preprocessor"");
    } else {
      preprocessor_args.push_back(""-arch"");
      for (size_t i = 0; i < ctx.args_info.arch_args.size(); ++i) {
        preprocessor_args.push_back(ctx.args_info.arch_args[i]);
        result_name = get_result_name_from_cpp(ctx, preprocessor_args, hash);
        cc_log(""Got result name from preprocessor with -arch %s"",
               ctx.args_info.arch_args[i].c_str());
        if (i != ctx.args_info.arch_args.size() - 1) {
          result_name = nullopt;
        }
        preprocessor_args.pop_back();
      }
      preprocessor_args.pop_back();
    }
  }

  return result_name;
}

// Try to return the compile result from cache.
static optional<enum stats>
from_cache(Context& ctx, enum fromcache_call_mode mode)
{
  // The user might be disabling cache hits.
  if (ctx.config.recache()) {
    return nullopt;
  }

  // If we're using Clang, we can't trust a precompiled header object based on
  // running the preprocessor since clang will produce a fatal error when the
  // precompiled header is used and one of the included files has an updated
  // timestamp:
  //
  //     file 'foo.h' has been modified since the precompiled header 'foo.pch'
  //     was built
  if ((ctx.guessed_compiler == GuessedCompiler::clang
       || ctx.guessed_compiler == GuessedCompiler::unknown)
      && ctx.args_info.output_is_precompiled_header
      && mode == FROMCACHE_CPP_MODE) {
    cc_log(""Not considering cached precompiled header in preprocessor mode"");
    return nullopt;
  }

  MTR_BEGIN(""cache"", ""from_cache"");

  // Get result from cache.
  Result::Reader result_reader(ctx.result_path());
  ResultRetriever result_retriever(ctx);

  auto error = result_reader.read(result_retriever);
  if (error) {
    cc_log(""Failed to get result from cache: %s"", error->c_str());
    return nullopt;
  } else {
    // Update modification timestamp to save file from LRU cleanup.
    update_mtime(ctx.result_path().c_str());
  }

  cc_log(""Succeeded getting cached result"");

  MTR_END(""cache"", ""from_cache"");

  return mode == FROMCACHE_DIRECT_MODE ? STATS_CACHEHIT_DIR
                                       : STATS_CACHEHIT_CPP;
}

// Find the real compiler. We just search the PATH to find an executable of the
// same name that isn't a link to ourselves.
static void
find_compiler(Context& ctx, const char* const* argv)
{
  // We might be being invoked like ""ccache gcc -c foo.c"".
  std::string base(Util::base_name(argv[0]));
  if (same_executable_name(base.c_str(), MYNAME)) {
    ctx.orig_args.pop_front();
    if (is_full_path(ctx.orig_args[0].c_str())) {
      // A full path was given.
      return;
    }
    base = std::string(Util::base_name(ctx.orig_args[0]));
  }

  // Support user override of the compiler.
  if (!ctx.config.compiler().empty()) {
    base = ctx.config.compiler();
  }

  std::string compiler = find_executable(ctx, base.c_str(), MYNAME);
  if (compiler.empty()) {
    fatal(""Could not find compiler \""%s\"" in PATH"", base.c_str());
  }
  if (compiler == argv[0]) {
    fatal(""Recursive invocation (the name of the ccache binary must be \""%s\"")"",
          MYNAME);
  }
  ctx.orig_args[0] = compiler;
}

bool
is_precompiled_header(const char* path)
{
  // See ""Precompiled Headers"" in GCC docs.
  string_view ext = Util::get_extension(path);
  return ext == "".gch"" || ext == "".pch"" || ext == "".pth""
         || Util::get_extension(Util::dir_name(path)) == "".gch"";
}

static void
create_initial_config_file(Config& config)
{
  if (!Util::create_dir(Util::dir_name(config.primary_config_path()))) {
    return;
  }

  unsigned max_files;
  uint64_t max_size;
  char* stats_dir = format(""%s/0"", config.cache_dir().c_str());
  if (Stat::stat(stats_dir)) {
    stats_get_obsolete_limits(stats_dir, &max_files, &max_size);
    // STATS_MAXFILES and STATS_MAXSIZE was stored for each top directory.
    max_files *= 16;
    max_size *= 16;
  } else {
    max_files = 0;
    max_size = config.max_size();
  }
  free(stats_dir);

  FILE* f = fopen(config.primary_config_path().c_str(), ""w"");
  if (!f) {
    return;
  }
  if (max_files != 0) {
    fprintf(f, ""max_files = %u\n"", max_files);
    config.set_max_files(max_files);
  }
  if (max_size != 0) {
    char* size = format_parsable_size_with_suffix(max_size);
    fprintf(f, ""max_size = %s\n"", size);
    free(size);
    config.set_max_size(max_size);
  }
  fclose(f);
}

// Read config file(s), populate variables, create configuration file in cache
// directory if missing, etc.
static void
set_up_config(Config& config)
{
  char* p = getenv(""CCACHE_CONFIGPATH"");
  if (p) {
    config.set_primary_config_path(p);
  } else {
    config.set_secondary_config_path(fmt::format(""{}/ccache.conf"", SYSCONFDIR));
    MTR_BEGIN(""config"", ""conf_read_secondary"");
    // A missing config file in SYSCONFDIR is OK so don't check return value.
    config.update_from_file(config.secondary_config_path());
    MTR_END(""config"", ""conf_read_secondary"");

    if (config.cache_dir().empty()) {
      fatal(""configuration setting \""cache_dir\"" must not be the empty string"");
    }
    if ((p = getenv(""CCACHE_DIR""))) {
      config.set_cache_dir(p);
    }
    if (config.cache_dir().empty()) {
      fatal(""CCACHE_DIR must not be the empty string"");
    }

    config.set_primary_config_path(
      fmt::format(""{}/ccache.conf"", config.cache_dir()));
  }

  bool should_create_initial_config = false;
  MTR_BEGIN(""config"", ""conf_read_primary"");
  if (!config.update_from_file(config.primary_config_path())
      && !config.disable()) {
    should_create_initial_config = true;
  }
  MTR_END(""config"", ""conf_read_primary"");

  MTR_BEGIN(""config"", ""conf_update_from_environment"");
  config.update_from_environment();
  MTR_END(""config"", ""conf_update_from_environment"");

  if (should_create_initial_config) {
    create_initial_config_file(config);
  }

  if (config.umask() != std::numeric_limits<uint32_t>::max()) {
    umask(config.umask());
  }
}

static void
set_up_context(Context& ctx, int argc, const char* const* argv)
{
  ctx.orig_args = Args::from_argv(argc, argv);
  ctx.ignore_header_paths = Util::split_into_strings(
    ctx.config.ignore_headers_in_manifest(), PATH_DELIM);
  ctx.set_ignore_options(
    Util::split_into_strings(ctx.config.ignore_options(), "" ""));
}

// Initialize ccache, must be called once before anything else is run.
static void
initialize(Context& ctx, int argc, const char* const* argv)
{
  set_up_config(ctx.config);
  set_up_context(ctx, argc, argv);
  init_log(ctx.config);

  cc_log(""=== CCACHE %s STARTED ========================================="",
         CCACHE_VERSION);

  if (getenv(""CCACHE_INTERNAL_TRACE"")) {
#ifdef MTR_ENABLED
    ctx.mini_trace = std::make_unique<MiniTrace>(ctx->args_info);
#else
    cc_log(""Error: tracing is not enabled!"");
#endif
  }
}

// Make a copy of stderr that will not be cached, so things like distcc can
// send networking errors to it.
static void
set_up_uncached_err()
{
  int uncached_fd =
    dup(STDERR_FILENO); // The file descriptor is intentionally leaked.
  if (uncached_fd == -1) {
    cc_log(""dup(2) failed: %s"", strerror(errno));
    failed(STATS_ERROR);
  }

  x_setenv(""UNCACHED_ERR_FD"", fmt::format(""{}"", uncached_fd).c_str());
}

static void
configuration_logger(const std::string& key,
                     const std::string& value,
                     const std::string& origin)
{
  cc_bulklog(
    ""Config: (%s) %s = %s"", origin.c_str(), key.c_str(), value.c_str());
}

static void
configuration_printer(const std::string& key,
                      const std::string& value,
                      const std::string& origin)
{
  fmt::print(""({}) {} = {}\n"", origin, key, value);
}

static int cache_compilation(int argc, const char* const* argv);
static enum stats do_cache_compilation(Context& ctx, const char* const* argv);

// The entry point when invoked to cache a compilation.
static int
cache_compilation(int argc, const char* const* argv)
{
  // Needed for portability when using localtime_r.
  tzset();

  auto ctx = std::make_unique<Context>();
  SignalHandler signal_handler(*ctx);

  initialize(*ctx, argc, argv);

  MTR_BEGIN(""main"", ""find_compiler"");
  find_compiler(*ctx, argv);
  MTR_END(""main"", ""find_compiler"");

  try {
    enum stats stat = do_cache_compilation(*ctx, argv);
    stats_update(*ctx, stat);
    return EXIT_SUCCESS;
  } catch (const Failure& e) {
    if (e.stat() != STATS_NONE) {
      stats_update(*ctx, e.stat());
    }

    if (e.exit_code()) {
      return *e.exit_code();
    }
    // Else: Fall back to running the real compiler.

    assert(!ctx->orig_args.empty());

    ctx->orig_args.erase_with_prefix(""--ccache-"");
    add_prefix(*ctx, ctx->orig_args, ctx->config.prefix_command());

    cc_log(""Failed; falling back to running the real compiler"");

    Args saved_orig_args(std::move(ctx->orig_args));
    auto execv_argv = saved_orig_args.to_argv();

    cc_log_argv(""Executing "", execv_argv.data());
    ctx.reset(); // Dump debug logs last thing before executing.
    execv(execv_argv[0], const_cast<char* const*>(execv_argv.data()));
    fatal(""execv of %s failed: %s"", execv_argv[0], strerror(errno));
  }
}

static enum stats
do_cache_compilation(Context& ctx, const char* const* argv)
{
  if (ctx.actual_cwd.empty()) {
    cc_log(""Unable to determine current working directory: %s"",
           strerror(errno));
    failed(STATS_ERROR);
  }

  MTR_BEGIN(""main"", ""clean_up_internal_tempdir"");
  if (ctx.config.temporary_dir() == ctx.config.cache_dir() + ""/tmp"") {
    clean_up_internal_tempdir(ctx.config);
  }
  MTR_END(""main"", ""clean_up_internal_tempdir"");

  if (!ctx.config.log_file().empty() || ctx.config.debug()) {
    ctx.config.visit_items(configuration_logger);
  }

  if (ctx.config.disable()) {
    cc_log(""ccache is disabled"");
    // STATS_CACHEMISS is a dummy to trigger stats_flush.
    failed(STATS_CACHEMISS);
  }

  MTR_BEGIN(""main"", ""set_up_uncached_err"");
  set_up_uncached_err();
  MTR_END(""main"", ""set_up_uncached_err"");

  cc_log_argv(""Command line: "", argv);
  cc_log(""Hostname: %s"", get_hostname());
  cc_log(""Working directory: %s"", ctx.actual_cwd.c_str());
  if (ctx.apparent_cwd != ctx.actual_cwd) {
    cc_log(""Apparent working directory: %s"", ctx.apparent_cwd.c_str());
  }

  ctx.config.set_limit_multiple(
    std::min(std::max(ctx.config.limit_multiple(), 0.0), 1.0));

  MTR_BEGIN(""main"", ""guess_compiler"");
  ctx.guessed_compiler = guess_compiler(ctx.orig_args[0].c_str());
  MTR_END(""main"", ""guess_compiler"");

  // Arguments (except -E) to send to the preprocessor.
  Args preprocessor_args;
  // Arguments not sent to the preprocessor but that should be part of the
  // hash.
  Args extra_args_to_hash;
  // Arguments to send to the real compiler.
  Args compiler_args;
  MTR_BEGIN(""main"", ""process_args"");

  auto error =
    process_args(ctx, preprocessor_args, extra_args_to_hash, compiler_args);
  if (error) {
    failed(*error);
  }

  MTR_END(""main"", ""process_args"");

  if (ctx.config.depend_mode()
      && (!ctx.args_info.generating_dependencies
          || ctx.args_info.output_dep == ""/dev/null""
          || !ctx.config.run_second_cpp())) {
    cc_log(""Disabling depend mode"");
    ctx.config.set_depend_mode(false);
  }

  cc_log(""Source file: %s"", ctx.args_info.input_file.c_str());
  if (ctx.args_info.generating_dependencies) {
    cc_log(""Dependency file: %s"", ctx.args_info.output_dep.c_str());
  }
  if (ctx.args_info.generating_coverage) {
    cc_log(""Coverage file: %s"", ctx.args_info.output_cov.c_str());
  }
  if (ctx.args_info.generating_stackusage) {
    cc_log(""Stack usage file: %s"", ctx.args_info.output_su.c_str());
  }
  if (ctx.args_info.generating_diagnostics) {
    cc_log(""Diagnostics file: %s"", ctx.args_info.output_dia.c_str());
  }
  if (!ctx.args_info.output_dwo.empty()) {
    cc_log(""Split dwarf file: %s"", ctx.args_info.output_dwo.c_str());
  }

  cc_log(""Object file: %s"", ctx.args_info.output_obj.c_str());
  MTR_META_THREAD_NAME(ctx.args_info.output_obj.c_str());

  if (ctx.config.debug()) {
    std::string path =
      fmt::format(""{}.ccache-input-text"", ctx.args_info.output_obj);
    File debug_text_file(path, ""w"");
    if (debug_text_file) {
      ctx.hash_debug_files.push_back(std::move(debug_text_file));
    } else {
      cc_log(""Failed to open %s: %s"", path.c_str(), strerror(errno));
    }
  }

  FILE* debug_text_file = !ctx.hash_debug_files.empty()
                            ? ctx.hash_debug_files.front().get()
                            : nullptr;

  Hash common_hash;
  init_hash_debug(ctx,
                  common_hash,
                  ctx.args_info.output_obj.c_str(),
                  'c',
                  ""COMMON"",
                  debug_text_file);

  MTR_BEGIN(""hash"", ""common_hash"");
  hash_common_info(ctx, preprocessor_args, common_hash, ctx.args_info);
  MTR_END(""hash"", ""common_hash"");

  // Try to find the hash using the manifest.
  Hash direct_hash = common_hash;
  init_hash_debug(ctx,
                  direct_hash,
                  ctx.args_info.output_obj.c_str(),
                  'd',
                  ""DIRECT MODE"",
                  debug_text_file);

  Args args_to_hash = preprocessor_args;
  args_to_hash.push_back(extra_args_to_hash);

  bool put_result_in_manifest = false;
  optional<Digest> result_name;
  optional<Digest> result_name_from_manifest;
  if (ctx.config.direct_mode()) {
    cc_log(""Trying direct lookup"");
    MTR_BEGIN(""hash"", ""direct_hash"");
    Args dummy_args;
    result_name =
      calculate_result_name(ctx, args_to_hash, dummy_args, direct_hash, true);
    MTR_END(""hash"", ""direct_hash"");
    if (result_name) {
      ctx.set_result_name(*result_name);

      // If we can return from cache at this point then do so.
      auto result = from_cache(ctx, FROMCACHE_DIRECT_MODE);
      if (result) {
        return *result;
      }

      // Wasn't able to return from cache at this point. However, the result
      // was already found in manifest, so don't re-add it later.
      put_result_in_manifest = false;

      result_name_from_manifest = result_name;
    } else {
      // Add result to manifest later.
      put_result_in_manifest = true;
    }
  }

  if (ctx.config.read_only_direct()) {
    cc_log(""Read-only direct mode; running real compiler"");
    failed(STATS_CACHEMISS);
  }

  if (!ctx.config.depend_mode()) {
    // Find the hash using the preprocessed output. Also updates
    // g_included_files.
    Hash cpp_hash = common_hash;
    init_hash_debug(ctx,
                    cpp_hash,
                    ctx.args_info.output_obj.c_str(),
                    'p',
                    ""PREPROCESSOR MODE"",
                    debug_text_file);

    MTR_BEGIN(""hash"", ""cpp_hash"");
    result_name = calculate_result_name(
      ctx, args_to_hash, preprocessor_args, cpp_hash, false);
    MTR_END(""hash"", ""cpp_hash"");
    if (!result_name) {
      fatal(""internal error: calculate_result_name returned NULL for cpp"");
    }
    ctx.set_result_name(*result_name);

    if (result_name_from_manifest && result_name_from_manifest != result_name) {
      // The hash from manifest differs from the hash of the preprocessor
      // output. This could be because:
      //
      // - The preprocessor produces different output for the same input (not
      //   likely).
      // - There's a bug in ccache (maybe incorrect handling of compiler
      //   arguments).
      // - The user has used a different CCACHE_BASEDIR (most likely).
      //
      // The best thing here would probably be to remove the hash entry from
      // the manifest. For now, we use a simpler method: just remove the
      // manifest file.
      cc_log(""Hash from manifest doesn't match preprocessor output"");
      cc_log(""Likely reason: different CCACHE_BASEDIRs used"");
      cc_log(""Removing manifest as a safety measure"");
      Util::unlink_safe(ctx.manifest_path());

      put_result_in_manifest = true;
    }

    // If we can return from cache at this point then do.
    auto result = from_cache(ctx, FROMCACHE_CPP_MODE);
    if (result) {
      if (put_result_in_manifest) {
        update_manifest_file(ctx);
      }
      return *result;
    }
  }

  if (ctx.config.read_only()) {
    cc_log(""Read-only mode; running real compiler"");
    failed(STATS_CACHEMISS);
  }

  add_prefix(ctx, compiler_args, ctx.config.prefix_command());

  // In depend_mode, extend the direct hash.
  Hash* depend_mode_hash = ctx.config.depend_mode() ? &direct_hash : nullptr;

  // Run real compiler, sending output to cache.
  MTR_BEGIN(""cache"", ""to_cache"");
  to_cache(
    ctx, compiler_args, ctx.args_info.depend_extra_args, depend_mode_hash);
  update_manifest_file(ctx);
  MTR_END(""cache"", ""to_cache"");

  return STATS_CACHEMISS;
}

// The main program when not doing a compile.
static int
handle_main_options(int argc, const char* const* argv)
{
  enum longopts {
    DUMP_MANIFEST,
    DUMP_RESULT,
    EXTRACT_RESULT,
    HASH_FILE,
    PRINT_STATS,
  };
  static const struct option options[] = {
    {""cleanup"", no_argument, nullptr, 'c'},
    {""clear"", no_argument, nullptr, 'C'},
    {""dump-manifest"", required_argument, nullptr, DUMP_MANIFEST},
    {""dump-result"", required_argument, nullptr, DUMP_RESULT},
    {""extract-result"", required_argument, nullptr, EXTRACT_RESULT},
    {""get-config"", required_argument, nullptr, 'k'},
    {""hash-file"", required_argument, nullptr, HASH_FILE},
    {""help"", no_argument, nullptr, 'h'},
    {""max-files"", required_argument, nullptr, 'F'},
    {""max-size"", required_argument, nullptr, 'M'},
    {""print-stats"", no_argument, nullptr, PRINT_STATS},
    {""recompress"", required_argument, nullptr, 'X'},
    {""set-config"", required_argument, nullptr, 'o'},
    {""show-compression"", no_argument, nullptr, 'x'},
    {""show-config"", no_argument, nullptr, 'p'},
    {""show-stats"", no_argument, nullptr, 's'},
    {""version"", no_argument, nullptr, 'V'},
    {""zero-stats"", no_argument, nullptr, 'z'},
    {nullptr, 0, nullptr, 0}};

  Context ctx;
  initialize(ctx, argc, argv);

  int c;
  while ((c = getopt_long(argc,
                          const_cast<char* const*>(argv),
                          ""cCk:hF:M:po:sVxX:z"",
                          options,
                          nullptr))
         != -1) {
    switch (c) {
    case DUMP_MANIFEST:
      return manifest_dump(optarg, stdout) ? 0 : 1;

    case DUMP_RESULT: {
      ResultDumper result_dumper(stdout);
      Result::Reader result_reader(optarg);
      auto error = result_reader.read(result_dumper);
      if (error) {
        fmt::print(stderr, ""Error: {}\n"", *error);
      }
      return error ? EXIT_FAILURE : EXIT_SUCCESS;
    }

    case EXTRACT_RESULT: {
      ResultExtractor result_extractor(""."");
      Result::Reader result_reader(optarg);
      auto error = result_reader.read(result_extractor);
      if (error) {
        fmt::print(stderr, ""Error: {}\n"", *error);
      }
      return error ? EXIT_FAILURE : EXIT_SUCCESS;
    }

    case HASH_FILE: {
      Hash hash;
      if (str_eq(optarg, ""-"")) {
        hash.hash_fd(STDIN_FILENO);
      } else {
        hash.hash_file(optarg);
      }
      fmt::print(""{}"", hash.digest().to_string());
      break;
    }

    case PRINT_STATS:
      stats_print(ctx.config);
      break;

    case 'c': // --cleanup
    {
      ProgressBar progress_bar(""Cleaning..."");
      clean_up_all(ctx.config,
                   [&](double progress) { progress_bar.update(progress); });
      if (isatty(STDOUT_FILENO)) {
        printf(""\n"");
      }
      break;
    }

    case 'C': // --clear
    {
      ProgressBar progress_bar(""Clearing..."");
      wipe_all(ctx, [&](double progress) { progress_bar.update(progress); });
      if (isatty(STDOUT_FILENO)) {
        printf(""\n"");
      }
      break;
    }

    case 'h': // --help
      fprintf(stdout, USAGE_TEXT, MYNAME, MYNAME);
      x_exit(0);

    case 'k': // --get-config
      fmt::print(""{}\n"", ctx.config.get_string_value(optarg));
      break;

    case 'F': { // --max-files
      Config::set_value_in_file(
        ctx.config.primary_config_path(), ""max_files"", optarg);
      unsigned files = atoi(optarg);
      if (files == 0) {
        printf(""Unset cache file limit\n"");
      } else {
        printf(""Set cache file limit to %u\n"", files);
      }
      break;
    }

    case 'M': { // --max-size
      uint64_t size;
      if (!parse_size_with_suffix(optarg, &size)) {
        fatal(""invalid size: %s"", optarg);
      }
      Config::set_value_in_file(
        ctx.config.primary_config_path(), ""max_size"", optarg);
      if (size == 0) {
        printf(""Unset cache size limit\n"");
      } else {
        char* s = format_human_readable_size(size);
        printf(""Set cache size limit to %s\n"", s);
        free(s);
      }
      break;
    }

    case 'o': {                          // --set-config
      char* p = strchr(optarg + 1, '='); // Improve error message for -o=K=V
      if (!p) {
        fatal(""missing equal sign in \""%s\"""", optarg);
      }
      char* key = x_strndup(optarg, p - optarg);
      char* value = p + 1;
      Config::set_value_in_file(ctx.config.primary_config_path(), key, value);
      free(key);
      break;
    }

    case 'p': // --show-config
      ctx.config.visit_items(configuration_printer);
      break;

    case 's': // --show-stats
      stats_summary(ctx);
      break;

    case 'V': // --version
      fprintf(stdout, VERSION_TEXT, MYNAME, CCACHE_VERSION);
      x_exit(0);

    case 'x': // --show-compression
    {
      ProgressBar progress_bar(""Scanning..."");
      compress_stats(ctx.config,
                     [&](double progress) { progress_bar.update(progress); });
      break;
    }

    case 'X': // --recompress
    {
      int level;
      if (std::string(optarg) == ""uncompressed"") {
        level = 0;
      } else {
        level = Util::parse_int(optarg);
        if (level < -128 || level > 127) {
          throw Error(""compression level must be between -128 and 127"");
        }
        if (level == 0) {
          level = ctx.config.compression_level();
        }
      }

      ProgressBar progress_bar(""Recompressing..."");
      compress_recompress(
        ctx, level, [&](double progress) { progress_bar.update(progress); });
      break;
    }

    case 'z': // --zero-stats
      stats_zero(ctx);
      printf(""Statistics zeroed\n"");
      break;

    default:
      fprintf(stderr, USAGE_TEXT, MYNAME, MYNAME);
      x_exit(1);
    }

    // Some of the above switches might have changed config settings, so run the
    // setup again.
    set_up_config(ctx.config);
  }

  return 0;
}

int ccache_main(int argc, const char* const* argv);

int
ccache_main(int argc, const char* const* argv)
{
  try {
    // Check if we are being invoked as ""ccache"".
    std::string program_name(Util::base_name(argv[0]));
    if (same_executable_name(program_name.c_str(), MYNAME)) {
      if (argc < 2) {
        fprintf(stderr, USAGE_TEXT, MYNAME, MYNAME);
        x_exit(1);
      }
      // If the first argument isn't an option, then assume we are being passed
      // a compiler name and options.
      if (argv[1][0] == '-') {
        return handle_main_options(argc, argv);
      }
    }

    return cache_compilation(argc, argv);
  } catch (const ErrorBase& e) {
    fmt::print(stderr, ""ccache: error: {}\n"", e.what());
    return EXIT_FAILURE;
  }
}
""","""// Copyright (C) 2002-2007 Andrew Tridgell
// Copyright (C) 2009-2020 Joel Rosdahl and other contributors
//
// See doc/AUTHORS.adoc for a complete list of contributors.
//
// This program is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by the Free
// Software Foundation; either version 3 of the License, or (at your option)
// any later version.
//
// This program is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
// more details.
//
// You should have received a copy of the GNU General Public License along with
// this program; if not, write to the Free Software Foundation, Inc., 51
// Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA

#include ""ccache.hpp""

#include ""Args.hpp""
#include ""ArgsInfo.hpp""
#include ""Context.hpp""
#include ""Fd.hpp""
#include ""File.hpp""
#include ""FormatNonstdStringView.hpp""
#include ""Hash.hpp""
#include ""MiniTrace.hpp""
#include ""ProgressBar.hpp""
#include ""Result.hpp""
#include ""ResultDumper.hpp""
#include ""ResultExtractor.hpp""
#include ""ResultRetriever.hpp""
#include ""SignalHandler.hpp""
#include ""StdMakeUnique.hpp""
#include ""Util.hpp""
#include ""argprocessing.hpp""
#include ""cleanup.hpp""
#include ""compopt.hpp""
#include ""compress.hpp""
#include ""exceptions.hpp""
#include ""execute.hpp""
#include ""hashutil.hpp""
#include ""language.hpp""
#include ""logging.hpp""
#include ""manifest.hpp""
#include ""stats.hpp""

#include ""third_party/fmt/core.h""
#include ""third_party/nonstd/string_view.hpp""

#ifdef HAVE_GETOPT_LONG
#  include <getopt.h>
#else
#  include ""third_party/getopt_long.h""
#endif

#include <algorithm>
#include <limits>

using nonstd::nullopt;
using nonstd::optional;
using nonstd::string_view;

static const char VERSION_TEXT[] =
  R""(%s version %s

Copyright (C) 2002-2007 Andrew Tridgell
Copyright (C) 2009-2020 Joel Rosdahl and other contributors

See <https://ccache.dev/credits.html> for a complete list of contributors.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 3 of the License, or (at your option) any later
version.
)"";

static const char USAGE_TEXT[] =
  R""(Usage:
    %s [options]
    %s compiler [compiler options]
    compiler [compiler options]          (via symbolic link)

Common options:
    -c, --cleanup             delete old files and recalculate size counters
                              (normally not needed as this is done
                              automatically)
    -C, --clear               clear the cache completely (except configuration)
    -F, --max-files NUM       set maximum number of files in cache to NUM (use 0
                              for no limit)
    -M, --max-size SIZE       set maximum size of cache to SIZE (use 0 for no
                              limit); available suffixes: k, M, G, T (decimal)
                              and Ki, Mi, Gi, Ti (binary); default suffix: G
    -X, --recompress LEVEL    recompress the cache to LEVEL (integer level or
                              ""uncompressed"")
    -o, --set-config KEY=VAL  set configuration item KEY to value VAL
    -x, --show-compression    show compression statistics
    -p, --show-config         show current configuration options in
                              human-readable format
    -s, --show-stats          show summary of configuration and statistics
                              counters in human-readable format
    -z, --zero-stats          zero statistics counters

    -h, --help                print this help text
    -V, --version             print version and copyright information

Options for scripting or debugging:
        --dump-manifest PATH  dump manifest file at PATH in text format
        --dump-result PATH    dump result file at PATH in text format
        --extract-result PATH extract data stored in result file at PATH to the
                              current working directory
    -k, --get-config KEY      print the value of configuration key KEY
        --hash-file PATH      print the hash (160 bit BLAKE3) of the file at
                              PATH
        --print-stats         print statistics counter IDs and corresponding
                              values in machine-parsable format

See also <https://ccache.dev>.
)"";

enum fromcache_call_mode { FROMCACHE_DIRECT_MODE, FROMCACHE_CPP_MODE };

struct pending_tmp_file
{
  char* path;
  struct pending_tmp_file* next;
};

// How often (in seconds) to scan $CCACHE_DIR/tmp for left-over temporary
// files.
static const int k_tempdir_cleanup_interval = 2 * 24 * 60 * 60; // 2 days

// This is a string that identifies the current ""version"" of the hash sum
// computed by ccache. If, for any reason, we want to force the hash sum to be
// different for the same input in a new ccache version, we can just change
// this string. A typical example would be if the format of one of the files
// stored in the cache changes in a backwards-incompatible way.
static const char HASH_PREFIX[] = ""3"";

static void
add_prefix(const Context& ctx, Args& args, const std::string& prefix_command)
{
  if (prefix_command.empty()) {
    return;
  }

  Args prefix;
  for (const auto& word : Util::split_into_strings(prefix_command, "" "")) {
    std::string path = find_executable(ctx, word.c_str(), MYNAME);
    if (path.empty()) {
      fatal(""%s: %s"", word.c_str(), strerror(errno));
    }

    prefix.push_back(path);
  }

  cc_log(""Using command-line prefix %s"", prefix_command.c_str());
  for (size_t i = prefix.size(); i != 0; i--) {
    args.push_front(prefix[i - 1]);
  }
}

// If `exit_code` is set, just exit with that code directly, otherwise execute
// the real compiler and exit with its exit code. Also updates statistics
// counter `stat` if it's not STATS_NONE.
static void failed(enum stats stat = STATS_NONE,
                   optional<int> exit_code = nullopt) ATTR_NORETURN;

static void
failed(enum stats stat, optional<int> exit_code)
{
  throw Failure(stat, exit_code);
}

static void
clean_up_internal_tempdir(const Config& config)
{
  time_t now = time(nullptr);
  auto dir_st = Stat::stat(config.cache_dir(), Stat::OnError::log);
  if (!dir_st || dir_st.mtime() + k_tempdir_cleanup_interval >= now) {
    // No cleanup needed.
    return;
  }

  update_mtime(config.cache_dir().c_str());

  const std::string& temp_dir = config.temporary_dir();
  if (!Stat::lstat(temp_dir)) {
    return;
  }

  Util::traverse(temp_dir, [now](const std::string& path, bool is_dir) {
    if (is_dir) {
      return;
    }
    auto st = Stat::lstat(path, Stat::OnError::log);
    if (st && st.mtime() + k_tempdir_cleanup_interval < now) {
      Util::unlink_tmp(path);
    }
  });
}

static void
init_hash_debug(Context& ctx,
                Hash& hash,
                const char* obj_path,
                char type,
                const char* section_name,
                FILE* debug_text_file)
{
  if (!ctx.config.debug()) {
    return;
  }

  std::string path = fmt::format(""{}.ccache-input-{}"", obj_path, type);
  File debug_binary_file(path, ""wb"");
  if (debug_binary_file) {
    hash.enable_debug(section_name, debug_binary_file.get(), debug_text_file);
    ctx.hash_debug_files.push_back(std::move(debug_binary_file));
  } else {
    cc_log(""Failed to open %s: %s"", path.c_str(), strerror(errno));
  }
}

static GuessedCompiler
guess_compiler(const char* path)
{
  string_view name = Util::base_name(path);
  GuessedCompiler result = GuessedCompiler::unknown;
  if (name.find(""clang"") != std::string::npos) {
    result = GuessedCompiler::clang;
  } else if (name.find(""gcc"") != std::string::npos
             || name.find(""g++"") != std::string::npos) {
    result = GuessedCompiler::gcc;
  } else if (name.find(""nvcc"") != std::string::npos) {
    result = GuessedCompiler::nvcc;
  } else if (name == ""pump"" || name == ""distcc-pump"") {
    result = GuessedCompiler::pump;
  }
  return result;
}

static bool
do_remember_include_file(Context& ctx,
                         std::string path,
                         Hash& cpp_hash,
                         bool system,
                         Hash* depend_mode_hash)
{
  bool is_pch = false;

  if (path.length() >= 2 && path[0] == '<' && path[path.length() - 1] == '>') {
    // Typically <built-in> or <command-line>.
    return true;
  }

  if (path == ctx.args_info.input_file) {
    // Don't remember the input file.
    return true;
  }

  if (system && (ctx.config.sloppiness() & SLOPPY_SYSTEM_HEADERS)) {
    // Don't remember this system header.
    return true;
  }

  if (ctx.included_files.find(path) != ctx.included_files.end()) {
    // Already known include file.
    return true;
  }

  // Canonicalize path for comparison; Clang uses ./header.h.
  if (Util::starts_with(path, ""./"")) {
    path.erase(0, 2);
  }

#ifdef _WIN32
  {
    // stat fails on directories on win32.
    DWORD attributes = GetFileAttributes(path.c_str());
    if (attributes != INVALID_FILE_ATTRIBUTES
        && attributes & FILE_ATTRIBUTE_DIRECTORY) {
      return true;
    }
  }
#endif

  auto st = Stat::stat(path, Stat::OnError::log);
  if (!st) {
    return false;
  }
  if (st.is_directory()) {
    // Ignore directory, typically $PWD.
    return true;
  }
  if (!st.is_regular()) {
    // Device, pipe, socket or other strange creature.
    cc_log(""Non-regular include file %s"", path.c_str());
    return false;
  }

  for (const auto& ignore_header_path : ctx.ignore_header_paths) {
    if (Util::matches_dir_prefix_or_file(ignore_header_path, path)) {
      return true;
    }
  }

  // The comparison using >= is intentional, due to a possible race between
  // starting compilation and writing the include file. See also the notes
  // under ""Performance"" in doc/MANUAL.adoc.
  if (!(ctx.config.sloppiness() & SLOPPY_INCLUDE_FILE_MTIME)
      && st.mtime() >= ctx.time_of_compilation) {
    cc_log(""Include file %s too new"", path.c_str());
    return false;
  }

  // The same >= logic as above applies to the change time of the file.
  if (!(ctx.config.sloppiness() & SLOPPY_INCLUDE_FILE_CTIME)
      && st.ctime() >= ctx.time_of_compilation) {
    cc_log(""Include file %s ctime too new"", path.c_str());
    return false;
  }

  // Let's hash the include file content.
  Hash fhash;

  is_pch = is_precompiled_header(path.c_str());
  if (is_pch) {
    if (ctx.included_pch_file.empty()) {
      cc_log(""Detected use of precompiled header: %s"", path.c_str());
    }
    bool using_pch_sum = false;
    if (ctx.config.pch_external_checksum()) {
      // hash pch.sum instead of pch when it exists
      // to prevent hashing a very large .pch file every time
      std::string pch_sum_path = fmt::format(""{}.sum"", path);
      if (Stat::stat(pch_sum_path, Stat::OnError::log)) {
        path = std::move(pch_sum_path);
        using_pch_sum = true;
        cc_log(""Using pch.sum file %s"", path.c_str());
      }
    }

    if (!hash_binary_file(ctx, fhash, path.c_str())) {
      return false;
    }
    cpp_hash.hash_delimiter(using_pch_sum ? ""pch_sum_hash"" : ""pch_hash"");
    cpp_hash.hash(fhash.digest().to_string());
  }

  if (ctx.config.direct_mode()) {
    if (!is_pch) { // else: the file has already been hashed.
      int result = hash_source_code_file(ctx, fhash, path.c_str());
      if (result & HASH_SOURCE_CODE_ERROR
          || result & HASH_SOURCE_CODE_FOUND_TIME) {
        return false;
      }
    }

    Digest d = fhash.digest();
    ctx.included_files.emplace(path, d);

    if (depend_mode_hash) {
      depend_mode_hash->hash_delimiter(""include"");
      depend_mode_hash->hash(d.to_string());
    }
  }

  return true;
}

// This function hashes an include file and stores the path and hash in the
// global g_included_files variable. If the include file is a PCH, cpp_hash is
// also updated.
static void
remember_include_file(Context& ctx,
                      const std::string& path,
                      Hash& cpp_hash,
                      bool system,
                      Hash* depend_mode_hash)
{
  if (!do_remember_include_file(ctx, path, cpp_hash, system, depend_mode_hash)
      && ctx.config.direct_mode()) {
    cc_log(""Disabling direct mode"");
    ctx.config.set_direct_mode(false);
  }
}

static void
print_included_files(const Context& ctx, FILE* fp)
{
  for (const auto& item : ctx.included_files) {
    fprintf(fp, ""%s\n"", item.first.c_str());
  }
}

// This function reads and hashes a file. While doing this, it also does these
// things:
//
// - Makes include file paths for which the base directory is a prefix relative
//   when computing the hash sum.
// - Stores the paths and hashes of included files in the global variable
//   g_included_files.
static bool
process_preprocessed_file(Context& ctx, Hash& hash, const char* path, bool pump)
{
  std::string data;
  try {
    data = Util::read_file(path);
  } catch (Error&) {
    return false;
  }

  // Bytes between p and q are pending to be hashed.
  const char* p = data.data();
  char* q = const_cast<char*>(data.data()); // cast needed before C++17
  const char* end = data.c_str() + data.length();

  // There must be at least 7 characters (# 1 ""x"") left to potentially find an
  // include file path.
  while (q < end - 7) {
    // Check if we look at a line containing the file name of an included file.
    // At least the following formats exist (where N is a positive integer):
    //
    // GCC:
    //
    //   # N ""file""
    //   # N ""file"" N
    //   #pragma GCC pch_preprocess ""file""
    //
    // HP's compiler:
    //
    //   #line N ""file""
    //
    // AIX's compiler:
    //
    //   #line N ""file""
    //   #line N
    //
    // Note that there may be other lines starting with '#' left after
    // preprocessing as well, for instance ""#    pragma"".
    if (q[0] == '#'
        // GCC:
        && ((q[1] == ' ' && q[2] >= '0' && q[2] <= '9')
            // GCC precompiled header:
            || (q[1] == 'p'
                && str_startswith(&q[2], ""ragma GCC pch_preprocess ""))
            // HP/AIX:
            || (q[1] == 'l' && q[2] == 'i' && q[3] == 'n' && q[4] == 'e'
                && q[5] == ' '))
        && (q == data.data() || q[-1] == '\n')) {
      // Workarounds for preprocessor linemarker bugs in GCC version 6.
      if (q[2] == '3') {
        if (str_startswith(q, ""# 31 \""<command-line>\""\n"")) {
          // Bogus extra line with #31, after the regular #1: Ignore the whole
          // line, and continue parsing.
          hash.hash(p, q - p);
          while (q < end && *q != '\n') {
            q++;
          }
          q++;
          p = q;
          continue;
        } else if (str_startswith(q, ""# 32 \""<command-line>\"" 2\n"")) {
          // Bogus wrong line with #32, instead of regular #1: Replace the line
          // number with the usual one.
          hash.hash(p, q - p);
          q += 1;
          q[0] = '#';
          q[1] = ' ';
          q[2] = '1';
          p = q;
        }
      }

      while (q < end && *q != '""' && *q != '\n') {
        q++;
      }
      if (q < end && *q == '\n') {
        // A newline before the quotation mark -> no match.
        continue;
      }
      q++;
      if (q >= end) {
        cc_log(""Failed to parse included file path"");
        return false;
      }
      // q points to the beginning of an include file path
      hash.hash(p, q - p);
      p = q;
      while (q < end && *q != '""') {
        q++;
      }
      // Look for preprocessor flags, after the ""filename"".
      bool system = false;
      const char* r = q + 1;
      while (r < end && *r != '\n') {
        if (*r == '3') { // System header.
          system = true;
        }
        r++;
      }
      // p and q span the include file path.
      std::string inc_path(p, q - p);
      if (!ctx.has_absolute_include_headers) {
        ctx.has_absolute_include_headers = Util::is_absolute_path(inc_path);
      }
      inc_path = Util::make_relative_path(ctx, inc_path);

      bool should_hash_inc_path = true;
      if (!ctx.config.hash_dir()) {
        if (Util::starts_with(inc_path, ctx.apparent_cwd)
            && Util::ends_with(inc_path, ""//"")) {
          // When compiling with -g or similar, GCC adds the absolute path to
          // CWD like this:
          //
          //   # 1 ""CWD//""
          //
          // If the user has opted out of including the CWD in the hash, don't
          // hash it. See also how debug_prefix_map is handled.
          should_hash_inc_path = false;
        }
      }
      if (should_hash_inc_path) {
        hash.hash(inc_path);
      }

      remember_include_file(ctx, inc_path, hash, system, nullptr);
      p = q; // Everything of interest between p and q has been hashed now.
    } else if (q[0] == '.' && q[1] == 'i' && q[2] == 'n' && q[3] == 'c'
               && q[4] == 'b' && q[5] == 'i' && q[6] == 'n') {
      // An assembler .inc bin (without the space) statement, which could be
      // part of inline assembly, refers to an external file. If the file
      // changes, the hash should change as well, but finding out what file to
      // hash is too hard for ccache, so just bail out.
      cc_log(
        ""Found unsupported .inc""
        ""bin directive in source code"");
      failed(STATS_UNSUPPORTED_DIRECTIVE);
    } else if (pump && strncmp(q, ""_________"", 9) == 0) {
      // Unfortunately the distcc-pump wrapper outputs standard output lines:
      // __________Using distcc-pump from /usr/bin
      // __________Using # distcc servers in pump mode
      // __________Shutting down distcc-pump include server
      while (q < end && *q != '\n') {
        q++;
      }
      if (*q == '\n') {
        q++;
      }
      p = q;
      continue;
    } else {
      q++;
    }
  }

  hash.hash(p, (end - p));

  // Explicitly check the .gch/.pch/.pth file as Clang does not include any
  // mention of it in the preprocessed output.
  if (!ctx.included_pch_file.empty()) {
    std::string pch_path =
      Util::make_relative_path(ctx, ctx.included_pch_file.c_str());
    hash.hash(pch_path);
    remember_include_file(ctx, pch_path, hash, false, nullptr);
  }

  bool debug_included = getenv(""CCACHE_DEBUG_INCLUDED"");
  if (debug_included) {
    print_included_files(ctx, stdout);
  }

  return true;
}

// Replace absolute paths with relative paths in the provided dependency file.
static void
use_relative_paths_in_depfile(const Context& ctx)
{
  if (ctx.config.base_dir().empty()) {
    cc_log(""Base dir not set, skip using relative paths"");
    return; // nothing to do
  }
  if (!ctx.has_absolute_include_headers) {
    cc_log(
      ""No absolute path for included files found, skip using relative paths"");
    return; // nothing to do
  }

  const std::string& output_dep = ctx.args_info.output_dep;
  std::string file_content;
  try {
    file_content = Util::read_file(output_dep);
  } catch (const Error& e) {
    cc_log(""Cannot open dependency file %s: %s"", output_dep.c_str(), e.what());
    return;
  }

  std::string adjusted_file_content;
  adjusted_file_content.reserve(file_content.size());

  bool rewritten = false;

  for (string_view token : Util::split_into_views(file_content, "" \t\r\n"")) {
    if (Util::is_absolute_path(token)
        && token.starts_with(ctx.config.base_dir())) {
      adjusted_file_content.append(Util::make_relative_path(ctx, token));
      rewritten = true;
    } else {
      adjusted_file_content.append(token.begin(), token.end());
    }
    adjusted_file_content.push_back(' ');
  }

  if (!rewritten) {
    cc_log(
      ""No paths in dependency file %s made relative, skip relative path usage"",
      output_dep.c_str());
    return;
  }

  std::string tmp_file = fmt::format(""{}.tmp{}"", output_dep, tmp_string());

  try {
    Util::write_file(tmp_file, adjusted_file_content);
  } catch (const Error& e) {
    cc_log(
      ""Error writing temporary dependency file %s (%s), skip relative path""
      "" usage"",
      tmp_file.c_str(),
      e.what());
    Util::unlink_safe(tmp_file);
    return;
  }

  if (x_rename(tmp_file.c_str(), output_dep.c_str()) != 0) {
    cc_log(
      ""Error renaming dependency file: %s -> %s (%s), skip relative path usage"",
      tmp_file.c_str(),
      output_dep.c_str(),
      strerror(errno));
    Util::unlink_safe(tmp_file);
  } else {
    cc_log(""Renamed dependency file: %s -> %s"",
           tmp_file.c_str(),
           output_dep.c_str());
  }
}

// Extract the used includes from the dependency file. Note that we cannot
// distinguish system headers from other includes here.
static optional<Digest>
result_name_from_depfile(Context& ctx, Hash& hash)
{
  std::string file_content;
  try {
    file_content = Util::read_file(ctx.args_info.output_dep);
  } catch (const Error& e) {
    cc_log(""Cannot open dependency file %s: %s"",
           ctx.args_info.output_dep.c_str(),
           e.what());
    return nullopt;
  }

  for (string_view token : Util::split_into_views(file_content, "" \t\r\n"")) {
    if (token == ""\\"" || token.ends_with("":"")) {
      continue;
    }
    if (!ctx.has_absolute_include_headers) {
      ctx.has_absolute_include_headers = Util::is_absolute_path(token);
    }
    std::string path = Util::make_relative_path(ctx, token);
    remember_include_file(ctx, path, hash, false, &hash);
  }

  // Explicitly check the .gch/.pch/.pth file as it may not be mentioned in the
  // dependencies output.
  if (!ctx.included_pch_file.empty()) {
    std::string pch_path =
      Util::make_relative_path(ctx, ctx.included_pch_file.c_str());
    hash.hash(pch_path);
    remember_include_file(ctx, pch_path, hash, false, nullptr);
  }

  bool debug_included = getenv(""CCACHE_DEBUG_INCLUDED"");
  if (debug_included) {
    print_included_files(ctx, stdout);
  }

  return hash.digest();
}

// Execute the compiler/preprocessor, with logic to retry without requesting
// colored diagnostics messages if that fails.
static int
execute(Context& ctx,
        Args& args,
        const std::string& stdout_path,
        int stdout_fd,
        const std::string& stderr_path,
        int stderr_fd)
{
  if (ctx.diagnostics_color_failed
      && ctx.guessed_compiler == GuessedCompiler::gcc) {
    args.erase_with_prefix(""-fdiagnostics-color"");
  }
  int status =
    execute(args.to_argv().data(), stdout_fd, stderr_fd, &ctx.compiler_pid);
  if (status != 0 && !ctx.diagnostics_color_failed
      && ctx.guessed_compiler == GuessedCompiler::gcc) {
    auto errors = Util::read_file(stderr_path);
    if (errors.find(""unrecognized command-line option"") != std::string::npos
        && errors.find(""-fdiagnostics-color"") != std::string::npos) {
      // Old versions of GCC did not support colored diagnostics.
      cc_log(""-fdiagnostics-color is unsupported; trying again without it"");
      if (ftruncate(stdout_fd, 0) < 0 || lseek(stdout_fd, 0, SEEK_SET) < 0) {
        cc_log(
          ""Failed to truncate %s: %s"", stdout_path.c_str(), strerror(errno));
        failed(STATS_ERROR);
      }
      if (ftruncate(stderr_fd, 0) < 0 || lseek(stderr_fd, 0, SEEK_SET) < 0) {
        cc_log(
          ""Failed to truncate %s: %s"", stderr_path.c_str(), strerror(errno));
        failed(STATS_ERROR);
      }
      ctx.diagnostics_color_failed = true;
      return execute(ctx, args, stdout_path, stdout_fd, stderr_path, stderr_fd);
    }
  }
  return status;
}

// Create or update the manifest file.
static void
update_manifest_file(Context& ctx)
{
  if (!ctx.config.direct_mode() || ctx.config.read_only()
      || ctx.config.read_only_direct()) {
    return;
  }

  auto old_st = Stat::stat(ctx.manifest_path());

  // See comment in get_file_hash_index for why saving of timestamps is forced
  // for precompiled headers.
  bool save_timestamp = (ctx.config.sloppiness() & SLOPPY_FILE_STAT_MATCHES)
                        || ctx.args_info.output_is_precompiled_header;

  MTR_BEGIN(""manifest"", ""manifest_put"");
  cc_log(""Adding result name to %s"", ctx.manifest_path().c_str());
  if (!manifest_put(ctx.config,
                    ctx.manifest_path(),
                    ctx.result_name(),
                    ctx.included_files,
                    ctx.time_of_compilation,
                    save_timestamp)) {
    cc_log(""Failed to add result name to %s"", ctx.manifest_path().c_str());
  } else {
    auto st = Stat::stat(ctx.manifest_path(), Stat::OnError::log);

    int64_t size_delta = st.size_on_disk() - old_st.size_on_disk();
    int nof_files_delta = !old_st && st ? 1 : 0;

    if (ctx.stats_file() == ctx.manifest_stats_file()) {
      stats_update_size(ctx.counter_updates, size_delta, nof_files_delta);
    } else {
      Counters counters;
      stats_update_size(counters, size_delta, nof_files_delta);
      stats_flush_to_file(ctx.config, ctx.manifest_stats_file(), counters);
    }
  }
  MTR_END(""manifest"", ""manifest_put"");
}

static bool
create_cachedir_tag(nonstd::string_view dir)
{
  constexpr char cachedir_tag[] =
    ""Signature: 8a477f597d28d172789f06886806bc55\n""
    ""# This file is a cache directory tag created by ccache.\n""
    ""# For information about cache directory tags, see:\n""
    ""#\thttp://www.brynosaurus.com/cachedir/\n"";

  std::string filename = fmt::format(""{}/CACHEDIR.TAG"", dir);
  auto st = Stat::stat(filename);

  if (st) {
    if (st.is_regular()) {
      return true;
    }
    errno = EEXIST;
    return false;
  }

  File f(filename, ""w"");

  if (!f) {
    return false;
  }

  return fwrite(cachedir_tag, strlen(cachedir_tag), 1, f.get()) == 1;
}

// Run the real compiler and put the result in cache.
static void
to_cache(Context& ctx,
         Args& args,
         Args& depend_extra_args,
         Hash* depend_mode_hash)
{
  args.push_back(""-o"");
  args.push_back(ctx.args_info.output_obj);

  if (ctx.config.hard_link() && ctx.args_info.output_obj != ""/dev/null"") {
    // Workaround for Clang bug where it overwrites an existing object file
    // when it's compiling an assembler file, see
    // <https://bugs.llvm.org/show_bug.cgi?id=39782>.
    Util::unlink_safe(ctx.args_info.output_obj);
  }

  if (ctx.args_info.generating_diagnostics) {
    args.push_back(""--serialize-diagnostics"");
    args.push_back(ctx.args_info.output_dia);
  }

  // Turn off DEPENDENCIES_OUTPUT when running cc1, because otherwise it will
  // emit a line like this:
  //
  //   tmp.stdout.vexed.732.o: /home/mbp/.ccache/tmp.stdout.vexed.732.i
  x_unsetenv(""DEPENDENCIES_OUTPUT"");
  x_unsetenv(""SUNPRO_DEPENDENCIES"");

  if (ctx.config.run_second_cpp()) {
    args.push_back(ctx.args_info.input_file);
  } else {
    args.push_back(ctx.i_tmpfile);
  }

  if (ctx.args_info.seen_split_dwarf) {
    // Remove any pre-existing .dwo file since we want to check if the compiler
    // produced one, intentionally not using x_unlink or tmp_unlink since we're
    // not interested in logging successful deletions or failures due to
    // non-existent .dwo files.
    if (unlink(ctx.args_info.output_dwo.c_str()) != 0 && errno != ENOENT
        && errno != ESTALE) {
      cc_log(""Failed to unlink %s: %s"",
             ctx.args_info.output_dwo.c_str(),
             strerror(errno));
      failed(STATS_BADOUTPUTFILE);
    }
  }

  cc_log(""Running real compiler"");
  MTR_BEGIN(""execute"", ""compiler"");

  const auto tmp_stdout_fd_and_path = Util::create_temp_fd(
    fmt::format(""{}/tmp.stdout"", ctx.config.temporary_dir()));
  int tmp_stdout_fd = tmp_stdout_fd_and_path.first;
  const std::string& tmp_stdout = tmp_stdout_fd_and_path.second;
  ctx.register_pending_tmp_file(tmp_stdout);

  const auto tmp_stderr_fd_and_path = Util::create_temp_fd(
    fmt::format(""{}/tmp.stderr"", ctx.config.temporary_dir()));
  int tmp_stderr_fd = tmp_stderr_fd_and_path.first;
  const std::string& tmp_stderr = tmp_stderr_fd_and_path.second;
  ctx.register_pending_tmp_file(tmp_stderr);

  int status;
  if (!ctx.config.depend_mode()) {
    status =
      execute(ctx, args, tmp_stdout, tmp_stdout_fd, tmp_stderr, tmp_stderr_fd);
    args.pop_back(3);
  } else {
    // Use the original arguments (including dependency options) in depend
    // mode.
    Args depend_mode_args = ctx.orig_args;
    depend_mode_args.erase_with_prefix(""--ccache-"");
    depend_mode_args.push_back(depend_extra_args);
    add_prefix(ctx, depend_mode_args, ctx.config.prefix_command());

    ctx.time_of_compilation = time(nullptr);
    status = execute(ctx,
                     depend_mode_args,
                     tmp_stdout,
                     tmp_stdout_fd,
                     tmp_stderr,
                     tmp_stderr_fd);
  }
  MTR_END(""execute"", ""compiler"");

  auto st = Stat::stat(tmp_stdout, Stat::OnError::log);
  if (!st) {
    // The stdout file was removed - cleanup in progress? Better bail out.
    failed(STATS_MISSING);
  }

  // distcc-pump outputs lines like this:
  // __________Using # distcc servers in pump mode
  if (st.size() != 0 && ctx.guessed_compiler != GuessedCompiler::pump) {
    cc_log(""Compiler produced stdout"");
    failed(STATS_STDOUT);
  }

  // Merge stderr from the preprocessor (if any) and stderr from the real
  // compiler into tmp_stderr.
  if (!ctx.cpp_stderr.empty()) {
    std::string combined_stderr =
      Util::read_file(ctx.cpp_stderr) + Util::read_file(tmp_stderr);
    Util::write_file(tmp_stderr, combined_stderr);
  }

  if (status != 0) {
    cc_log(""Compiler gave exit status %d"", status);

    // We can output stderr immediately instead of rerunning the compiler.
    Util::send_to_stderr(Util::read_file(tmp_stderr),
                         ctx.args_info.strip_diagnostics_colors);

    failed(STATS_STATUS, status);
  }

  if (ctx.config.depend_mode()) {
    assert(depend_mode_hash);
    auto result_name = result_name_from_depfile(ctx, *depend_mode_hash);
    if (!result_name) {
      failed(STATS_ERROR);
    }
    ctx.set_result_name(*result_name);
  }

  bool produce_dep_file = ctx.args_info.generating_dependencies
                          && ctx.args_info.output_dep != ""/dev/null"";

  if (produce_dep_file) {
    use_relative_paths_in_depfile(ctx);
  }

  st = Stat::stat(ctx.args_info.output_obj);
  if (!st) {
    cc_log(""Compiler didn't produce an object file"");
    failed(STATS_NOOUTPUT);
  }
  if (st.size() == 0) {
    cc_log(""Compiler produced an empty object file"");
    failed(STATS_EMPTYOUTPUT);
  }

  st = Stat::stat(tmp_stderr, Stat::OnError::log);
  if (!st) {
    failed(STATS_ERROR);
  }

  auto orig_dest_stat = Stat::stat(ctx.result_path());
  Result::Writer result_writer(ctx, ctx.result_path());

  if (st.size() > 0) {
    result_writer.write(Result::FileType::stderr_output, tmp_stderr);
  }
  result_writer.write(Result::FileType::object, ctx.args_info.output_obj);
  if (ctx.args_info.generating_dependencies) {
    result_writer.write(Result::FileType::dependency, ctx.args_info.output_dep);
  }
  if (ctx.args_info.generating_coverage) {
    result_writer.write(Result::FileType::coverage, ctx.args_info.output_cov);
  }
  if (ctx.args_info.generating_stackusage) {
    result_writer.write(Result::FileType::stackusage, ctx.args_info.output_su);
  }
  if (ctx.args_info.generating_diagnostics) {
    result_writer.write(Result::FileType::diagnostic, ctx.args_info.output_dia);
  }
  if (ctx.args_info.seen_split_dwarf && Stat::stat(ctx.args_info.output_dwo)) {
    // Only store .dwo file if it was created by the compiler (GCC and Clang
    // behave differently e.g. for ""-gsplit-dwarf -g1"").
    result_writer.write(Result::FileType::dwarf_object,
                        ctx.args_info.output_dwo);
  }

  auto error = result_writer.finalize();
  if (error) {
    cc_log(""Error: %s"", error->c_str());
  } else {
    cc_log(""Stored in cache: %s"", ctx.result_path().c_str());
  }

  auto new_dest_stat = Stat::stat(ctx.result_path(), Stat::OnError::log);
  if (!new_dest_stat) {
    failed(STATS_ERROR);
  }
  stats_update_size(ctx.counter_updates,
                    new_dest_stat.size_on_disk()
                      - orig_dest_stat.size_on_disk(),
                    orig_dest_stat ? 0 : 1);

  MTR_END(""file"", ""file_put"");

  // Make sure we have a CACHEDIR.TAG in the cache part of cache_dir. This can
  // be done almost anywhere, but we might as well do it near the end as we
  // save the stat call if we exit early.
  std::string first_level_dir(Util::dir_name(ctx.stats_file()));
  if (!create_cachedir_tag(first_level_dir)) {
    cc_log(""Failed to create %s/CACHEDIR.TAG (%s)"",
           first_level_dir.c_str(),
           strerror(errno));
  }

  // Everything OK.
  Util::send_to_stderr(Util::read_file(tmp_stderr),
                       ctx.args_info.strip_diagnostics_colors);
}

// Find the result name by running the compiler in preprocessor mode and
// hashing the result.
static Digest
get_result_name_from_cpp(Context& ctx, Args& args, Hash& hash)
{
  ctx.time_of_compilation = time(nullptr);

  std::string stderr_path;
  std::string stdout_path;
  int status;
  if (ctx.args_info.direct_i_file) {
    // We are compiling a .i or .ii file - that means we can skip the cpp stage
    // and directly form the correct i_tmpfile.
    stdout_path = ctx.args_info.input_file;
    status = 0;
  } else {
    // Run cpp on the input file to obtain the .i.

    // Limit the basename to 10 characters in order to cope with filesystem with
    // small maximum filename length limits.
    string_view input_base =
      Util::get_truncated_base_name(ctx.args_info.input_file, 10);
    auto stdout_fd_and_path = Util::create_temp_fd(
      fmt::format(""{}/{}.stdout"", ctx.config.temporary_dir(), input_base));
    int stdout_fd = stdout_fd_and_path.first;
    stdout_path = stdout_fd_and_path.second;
    ctx.register_pending_tmp_file(stdout_path);

    auto stderr_fd_and_path = Util::create_temp_fd(
      fmt::format(""{}/tmp.cpp_stderr"", ctx.config.temporary_dir()));
    int stderr_fd = stderr_fd_and_path.first;
    stderr_path = stderr_fd_and_path.second;
    ctx.register_pending_tmp_file(stderr_path);

    size_t args_added = 2;
    args.push_back(""-E"");
    if (ctx.config.keep_comments_cpp()) {
      args.push_back(""-C"");
      args_added = 3;
    }
    args.push_back(ctx.args_info.input_file);
    add_prefix(ctx, args, ctx.config.prefix_command_cpp());
    cc_log(""Running preprocessor"");
    MTR_BEGIN(""execute"", ""preprocessor"");
    status = execute(ctx, args, stdout_path, stdout_fd, stderr_path, stderr_fd);
    MTR_END(""execute"", ""preprocessor"");
    args.pop_back(args_added);
  }

  if (status != 0) {
    cc_log(""Preprocessor gave exit status %d"", status);
    failed(STATS_PREPROCESSOR);
  }

  hash.hash_delimiter(""cpp"");
  bool is_pump = ctx.guessed_compiler == GuessedCompiler::pump;
  if (!process_preprocessed_file(ctx, hash, stdout_path.c_str(), is_pump)) {
    failed(STATS_ERROR);
  }

  hash.hash_delimiter(""cppstderr"");
  if (!ctx.args_info.direct_i_file
      && !hash_binary_file(ctx, hash, stderr_path.c_str())) {
    // Somebody removed the temporary file?
    cc_log(""Failed to open %s: %s"", stderr_path.c_str(), strerror(errno));
    failed(STATS_ERROR);
  }

  if (ctx.args_info.direct_i_file) {
    ctx.i_tmpfile = ctx.args_info.input_file;
  } else {
    // i_tmpfile needs the proper cpp_extension for the compiler to do its
    // thing correctly
    ctx.i_tmpfile =
      fmt::format(""{}.{}"", stdout_path, ctx.config.cpp_extension());
    x_rename(stdout_path.c_str(), ctx.i_tmpfile.c_str());
    ctx.register_pending_tmp_file(ctx.i_tmpfile);
  }

  if (!ctx.config.run_second_cpp()) {
    // If we are using the CPP trick, we need to remember this stderr data and
    // output it just before the main stderr from the compiler pass.
    ctx.cpp_stderr = stderr_path;
    hash.hash_delimiter(""runsecondcpp"");
    hash.hash(""false"");
  }

  return hash.digest();
}

// Hash mtime or content of a file, or the output of a command, according to
// the CCACHE_COMPILERCHECK setting.
static void
hash_compiler(const Context& ctx,
              Hash& hash,
              const Stat& st,
              const char* path,
              bool allow_command)
{
  if (ctx.config.compiler_check() == ""none"") {
    // Do nothing.
  } else if (ctx.config.compiler_check() == ""mtime"") {
    hash.hash_delimiter(""cc_mtime"");
    hash.hash(st.size());
    hash.hash(st.mtime());
  } else if (Util::starts_with(ctx.config.compiler_check(), ""string:"")) {
    hash.hash_delimiter(""cc_hash"");
    hash.hash(ctx.config.compiler_check().c_str() + strlen(""string:""));
  } else if (ctx.config.compiler_check() == ""content"" || !allow_command) {
    hash.hash_delimiter(""cc_content"");
    hash_binary_file(ctx, hash, path);
  } else { // command string
    if (!hash_multicommand_output(hash,
                                  ctx.config.compiler_check().c_str(),
                                  ctx.orig_args[0].c_str())) {
      cc_log(""Failure running compiler check command: %s"",
             ctx.config.compiler_check().c_str());
      failed(STATS_COMPCHECK);
    }
  }
}

// Hash the host compiler(s) invoked by nvcc.
//
// If ccbin_st and ccbin are set, they refer to a directory or compiler set
// with -ccbin/--compiler-bindir. If they are NULL, the compilers are looked up
// in PATH instead.
static void
hash_nvcc_host_compiler(const Context& ctx,
                        Hash& hash,
                        const Stat* ccbin_st,
                        const char* ccbin)
{
  // From <http://docs.nvidia.com/cuda/cuda-compiler-driver-nvcc/index.html>:
  //
  //   ""[...] Specify the directory in which the compiler executable resides.
  //   The host compiler executable name can be also specified to ensure that
  //   the correct host compiler is selected.""
  //
  // and
  //
  //   ""On all platforms, the default host compiler executable (gcc and g++ on
  //   Linux, clang and clang++ on Mac OS X, and cl.exe on Windows) found in
  //   the current execution search path will be used"".

  if (!ccbin || ccbin_st->is_directory()) {
#if defined(__APPLE__)
    const char* compilers[] = {""clang"", ""clang++""};
#elif defined(_WIN32)
    const char* compilers[] = {""cl.exe""};
#else
    const char* compilers[] = {""gcc"", ""g++""};
#endif
    for (const char* compiler : compilers) {
      if (ccbin) {
        char* path = format(""%s/%s"", ccbin, compiler);
        auto st = Stat::stat(path);
        if (st) {
          hash_compiler(ctx, hash, st, path, false);
        }
        free(path);
      } else {
        std::string path = find_executable(ctx, compiler, MYNAME);
        if (!path.empty()) {
          auto st = Stat::stat(path, Stat::OnError::log);
          hash_compiler(ctx, hash, st, ccbin, false);
        }
      }
    }
  } else {
    hash_compiler(ctx, hash, *ccbin_st, ccbin, false);
  }
}

// Update a hash with information common for the direct and preprocessor modes.
static void
hash_common_info(const Context& ctx,
                 const Args& args,
                 Hash& hash,
                 const ArgsInfo& args_info)
{
  hash.hash(HASH_PREFIX);

  // We have to hash the extension, as a .i file isn't treated the same by the
  // compiler as a .ii file.
  hash.hash_delimiter(""ext"");
  hash.hash(ctx.config.cpp_extension().c_str());

#ifdef _WIN32
  const char* ext = strrchr(args[0].c_str(), '.');
  char full_path_win_ext[MAX_PATH + 1] = {0};
  add_exe_ext_if_no_to_fullpath(
    full_path_win_ext, MAX_PATH, ext, args[0].c_str());
  const char* full_path = full_path_win_ext;
#else
  const char* full_path = args[0].c_str();
#endif

  auto st = Stat::stat(full_path, Stat::OnError::log);
  if (!st) {
    failed(STATS_COMPILER);
  }

  // Hash information about the compiler.
  hash_compiler(ctx, hash, st, args[0].c_str(), true);

  // Also hash the compiler name as some compilers use hard links and behave
  // differently depending on the real name.
  hash.hash_delimiter(""cc_name"");
  hash.hash(Util::base_name(args[0]));

  if (!(ctx.config.sloppiness() & SLOPPY_LOCALE)) {
    // Hash environment variables that may affect localization of compiler
    // warning messages.
    const char* envvars[] = {
      ""LANG"", ""LC_ALL"", ""LC_CTYPE"", ""LC_MESSAGES"", nullptr};
    for (const char** p = envvars; *p; ++p) {
      char* v = getenv(*p);
      if (v) {
        hash.hash_delimiter(*p);
        hash.hash(v);
      }
    }
  }

  // Possibly hash the current working directory.
  if (args_info.generating_debuginfo && ctx.config.hash_dir()) {
    std::string dir_to_hash = ctx.apparent_cwd;
    for (const auto& map : args_info.debug_prefix_maps) {
      size_t sep_pos = map.find('=');
      if (sep_pos != std::string::npos) {
        std::string old_path = map.substr(0, sep_pos);
        std::string new_path = map.substr(sep_pos + 1);
        cc_log(""Relocating debuginfo from %s to %s (CWD: %s)"",
               old_path.c_str(),
               new_path.c_str(),
               ctx.apparent_cwd.c_str());
        if (Util::starts_with(ctx.apparent_cwd, old_path)) {
          dir_to_hash = new_path + ctx.apparent_cwd.substr(old_path.size());
        }
      }
    }
    cc_log(""Hashing CWD %s"", dir_to_hash.c_str());
    hash.hash_delimiter(""cwd"");
    hash.hash(dir_to_hash);
  }

  if (ctx.args_info.generating_dependencies || ctx.args_info.seen_split_dwarf) {
    // The output object file name is part of the .d file, so include the path
    // in the hash if generating dependencies.
    //
    // Object files include a link to the corresponding .dwo file based on the
    // target object filename when using -gsplit-dwarf, so hashing the object
    // file path will do it, although just hashing the object file base name
    // would be enough.
    hash.hash_delimiter(""object file"");
    hash.hash(ctx.args_info.output_obj);
  }

  // Possibly hash the coverage data file path.
  if (ctx.args_info.generating_coverage && ctx.args_info.profile_arcs) {
    std::string dir;
    if (!ctx.args_info.profile_path.empty()) {
      dir = ctx.args_info.profile_path;
    } else {
      dir =
        Util::real_path(std::string(Util::dir_name(ctx.args_info.output_obj)));
    }
    string_view stem =
      Util::remove_extension(Util::base_name(ctx.args_info.output_obj));
    std::string gcda_path = fmt::format(""{}/{}.gcda"", dir, stem);
    cc_log(""Hashing coverage path %s"", gcda_path.c_str());
    hash.hash_delimiter(""gcda"");
    hash.hash(gcda_path);
  }

  // Possibly hash the sanitize blacklist file path.
  for (const auto& sanitize_blacklist : args_info.sanitize_blacklists) {
    cc_log(""Hashing sanitize blacklist %s"", sanitize_blacklist.c_str());
    hash.hash(""sanitizeblacklist"");
    if (!hash_binary_file(ctx, hash, sanitize_blacklist.c_str())) {
      failed(STATS_BADEXTRAFILE);
    }
  }

  if (!ctx.config.extra_files_to_hash().empty()) {
    for (const std::string& path : Util::split_into_strings(
           ctx.config.extra_files_to_hash(), PATH_DELIM)) {
      cc_log(""Hashing extra file %s"", path.c_str());
      hash.hash_delimiter(""extrafile"");
      if (!hash_binary_file(ctx, hash, path.c_str())) {
        failed(STATS_BADEXTRAFILE);
      }
    }
  }

  // Possibly hash GCC_COLORS (for color diagnostics).
  if (ctx.guessed_compiler == GuessedCompiler::gcc) {
    const char* gcc_colors = getenv(""GCC_COLORS"");
    if (gcc_colors) {
      hash.hash_delimiter(""gcccolors"");
      hash.hash(gcc_colors);
    }
  }
}

static bool
hash_profile_data_file(const Context& ctx, Hash& hash)
{
  const std::string& profile_path = ctx.args_info.profile_path;
  string_view base_name = Util::remove_extension(ctx.args_info.output_obj);
  std::string hashified_cwd = ctx.apparent_cwd;
  std::replace(hashified_cwd.begin(), hashified_cwd.end(), '/', '#');

  std::vector<std::string> paths_to_try{
    // -fprofile-use[=dir]/-fbranch-probabilities (GCC <9)
    fmt::format(""{}/{}.gcda"", profile_path, base_name),
    // -fprofile-use[=dir]/-fbranch-probabilities (GCC >=9)
    fmt::format(""{}/{}#{}.gcda"", profile_path, hashified_cwd, base_name),
    // -fprofile(-instr|-sample)-use=file (Clang), -fauto-profile=file (GCC >=5)
    profile_path,
    // -fprofile(-instr|-sample)-use=dir (Clang)
    fmt::format(""{}/default.profdata"", profile_path),
    // -fauto-profile (GCC >=5)
    ""fbdata.afdo"", // -fprofile-dir is not used
  };

  bool found = false;
  for (const std::string& p : paths_to_try) {
    cc_log(""Checking for profile data file %s"", p.c_str());
    auto st = Stat::stat(p);
    if (st && !st.is_directory()) {
      cc_log(""Adding profile data %s to the hash"", p.c_str());
      hash.hash_delimiter(""-fprofile-use"");
      if (hash_binary_file(ctx, hash, p.c_str())) {
        found = true;
      }
    }
  }

  return found;
}

static bool
option_should_be_ignored(const std::string& arg,
                         const std::vector<std::string>& patterns)
{
  return std::any_of(
    patterns.cbegin(), patterns.cend(), [&arg](const std::string& pattern) {
      const auto& prefix = string_view(pattern).substr(0, pattern.length() - 1);
      return (
        pattern == arg
        || (Util::ends_with(pattern, ""*"") && Util::starts_with(arg, prefix)));
    });
}

// Update a hash sum with information specific to the direct and preprocessor
// modes and calculate the result name. Returns the result name on success,
// otherwise NULL. Caller frees.
static optional<Digest>
calculate_result_name(Context& ctx,
                      const Args& args,
                      Args& preprocessor_args,
                      Hash& hash,
                      bool direct_mode)
{
  bool found_ccbin = false;

  hash.hash_delimiter(""result version"");
  hash.hash(Result::k_version);

  if (direct_mode) {
    hash.hash_delimiter(""manifest version"");
    hash.hash(k_manifest_version);
  }

  // clang will emit warnings for unused linker flags, so we shouldn't skip
  // those arguments.
  int is_clang = ctx.guessed_compiler == GuessedCompiler::clang
                 || ctx.guessed_compiler == GuessedCompiler::unknown;

  // First the arguments.
  for (size_t i = 1; i < args.size(); i++) {
    // Trust the user if they've said we should not hash a given option.
    if (option_should_be_ignored(args[i], ctx.ignore_options())) {
      cc_log(""Not hashing ignored option: %s"", args[i].c_str());
      if (i + 1 < args.size() && compopt_takes_arg(args[i])) {
        i++;
        cc_log(""Not hashing argument of ignored option: %s"", args[i].c_str());
      }
      continue;
    }

    // -L doesn't affect compilation (except for clang).
    if (i < args.size() - 1 && args[i] == ""-L"" && !is_clang) {
      i++;
      continue;
    }
    if (Util::starts_with(args[i], ""-L"") && !is_clang) {
      continue;
    }

    // -Wl,... doesn't affect compilation (except for clang).
    if (Util::starts_with(args[i], ""-Wl,"") && !is_clang) {
      continue;
    }

    // The -fdebug-prefix-map option may be used in combination with
    // CCACHE_BASEDIR to reuse results across different directories. Skip using
    // the value of the option from hashing but still hash the existence of the
    // option.
    if (Util::starts_with(args[i], ""-fdebug-prefix-map="")) {
      hash.hash_delimiter(""arg"");
      hash.hash(""-fdebug-prefix-map="");
      continue;
    }
    if (Util::starts_with(args[i], ""-ffile-prefix-map="")) {
      hash.hash_delimiter(""arg"");
      hash.hash(""-ffile-prefix-map="");
      continue;
    }
    if (Util::starts_with(args[i], ""-fmacro-prefix-map="")) {
      hash.hash_delimiter(""arg"");
      hash.hash(""-fmacro-prefix-map="");
      continue;
    }

    // When using the preprocessor, some arguments don't contribute to the
    // hash. The theory is that these arguments will change the output of -E if
    // they are going to have any effect at all. For precompiled headers this
    // might not be the case.
    if (!direct_mode && !ctx.args_info.output_is_precompiled_header
        && !ctx.args_info.using_precompiled_header) {
      if (compopt_affects_cpp(args[i])) {
        if (compopt_takes_arg(args[i])) {
          i++;
        }
        continue;
      }
      if (compopt_short(compopt_affects_cpp, args[i])) {
        continue;
      }
    }

    // If we're generating dependencies, we make sure to skip the filename of
    // the dependency file, since it doesn't impact the output.
    if (ctx.args_info.generating_dependencies) {
      if (Util::starts_with(args[i], ""-Wp,"")) {
        if (Util::starts_with(args[i], ""-Wp,-MD,"")
            && !strchr(args[i].c_str() + 8, ',')) {
          hash.hash(args[i].c_str(), 8);
          continue;
        } else if (Util::starts_with(args[i], ""-Wp,-MMD,"")
                   && !strchr(args[i].c_str() + 9, ',')) {
          hash.hash(args[i].c_str(), 9);
          continue;
        }
      } else if (Util::starts_with(args[i], ""-MF"")) {
        // In either case, hash the ""-MF"" part.
        hash.hash_delimiter(""arg"");
        hash.hash(args[i].c_str(), 3);

        if (ctx.args_info.output_dep != ""/dev/null"") {
          bool separate_argument = (args[i].size() == 3);
          if (separate_argument) {
            // Next argument is dependency name, so skip it.
            i++;
          }
        }
        continue;
      }
    }

    const char* p = nullptr;
    if (Util::starts_with(args[i], ""-specs="")) {
      p = args[i].c_str() + 7;
    } else if (Util::starts_with(args[i], ""--specs="")) {
      p = args[i].c_str() + 8;
    }

    if (p) {
      auto st = Stat::stat(p, Stat::OnError::log);
      if (st) {
        // If given an explicit specs file, then hash that file, but don't
        // include the path to it in the hash.
        hash.hash_delimiter(""specs"");
        hash_compiler(ctx, hash, st, p, false);
        continue;
      }
    }

    if (Util::starts_with(args[i], ""-fplugin="")) {
      auto st = Stat::stat(args[i].c_str() + 9, Stat::OnError::log);
      if (st) {
        hash.hash_delimiter(""plugin"");
        hash_compiler(ctx, hash, st, args[i].c_str() + 9, false);
        continue;
      }
    }

    if (args[i] == ""-Xclang"" && i + 3 < args.size() && args[i + 1] == ""-load""
        && args[i + 2] == ""-Xclang"") {
      auto st = Stat::stat(args[i + 3], Stat::OnError::log);
      if (st) {
        hash.hash_delimiter(""plugin"");
        hash_compiler(ctx, hash, st, args[i + 3].c_str(), false);
        i += 3;
        continue;
      }
    }

    if ((args[i] == ""-ccbin"" || args[i] == ""--compiler-bindir"")
        && i + 1 < args.size()) {
      auto st = Stat::stat(args[i + 1], Stat::OnError::log);
      if (st) {
        found_ccbin = true;
        hash.hash_delimiter(""ccbin"");
        hash_nvcc_host_compiler(ctx, hash, &st, args[i + 1].c_str());
        i++;
        continue;
      }
    }

    // All other arguments are included in the hash.
    hash.hash_delimiter(""arg"");
    hash.hash(args[i]);
    if (i + 1 < args.size() && compopt_takes_arg(args[i])) {
      i++;
      hash.hash_delimiter(""arg"");
      hash.hash(args[i]);
    }
  }

  // Make results with dependency file /dev/null different from those without
  // it.
  if (ctx.args_info.generating_dependencies
      && ctx.args_info.output_dep == ""/dev/null"") {
    hash.hash_delimiter(""/dev/null dependency file"");
  }

  if (!found_ccbin && ctx.args_info.actual_language == ""cu"") {
    hash_nvcc_host_compiler(ctx, hash, nullptr, nullptr);
  }

  // For profile generation (-fprofile(-instr)-generate[=path])
  // - hash profile path
  //
  // For profile usage (-fprofile(-instr|-sample)-use, -fbranch-probabilities):
  // - hash profile data
  //
  // -fbranch-probabilities and -fvpt usage is covered by
  // -fprofile-generate/-fprofile-use.
  //
  // The profile directory can be specified as an argument to
  // -fprofile(-instr)-generate=, -fprofile(-instr|-sample)-use= or
  // -fprofile-dir=.

  if (ctx.args_info.profile_generate) {
    assert(!ctx.args_info.profile_path.empty());
    cc_log(""Adding profile directory %s to our hash"",
           ctx.args_info.profile_path.c_str());
    hash.hash_delimiter(""-fprofile-dir"");
    hash.hash(ctx.args_info.profile_path);
  }

  if (ctx.args_info.profile_use && !hash_profile_data_file(ctx, hash)) {
    cc_log(""No profile data file found"");
    failed(STATS_NOINPUT);
  }

  // Adding -arch to hash since cpp output is affected.
  for (const auto& arch : ctx.args_info.arch_args) {
    hash.hash_delimiter(""-arch"");
    hash.hash(arch);
  }

  optional<Digest> result_name;
  if (direct_mode) {
    // Hash environment variables that affect the preprocessor output.
    const char* envvars[] = {""CPATH"",
                             ""C_INCLUDE_PATH"",
                             ""CPLUS_INCLUDE_PATH"",
                             ""OBJC_INCLUDE_PATH"",
                             ""OBJCPLUS_INCLUDE_PATH"", // clang
                             nullptr};
    for (const char** p = envvars; *p; ++p) {
      char* v = getenv(*p);
      if (v) {
        hash.hash_delimiter(*p);
        hash.hash(v);
      }
    }

    // Make sure that the direct mode hash is unique for the input file path.
    // If this would not be the case:
    //
    // * An false cache hit may be produced. Scenario:
    //   - a/r.h exists.
    //   - a/x.c has #include ""r.h"".
    //   - b/x.c is identical to a/x.c.
    //   - Compiling a/x.c records a/r.h in the manifest.
    //   - Compiling b/x.c results in a false cache hit since a/x.c and b/x.c
    //     share manifests and a/r.h exists.
    // * The expansion of __FILE__ may be incorrect.
    hash.hash_delimiter(""inputfile"");
    hash.hash(ctx.args_info.input_file);

    hash.hash_delimiter(""sourcecode"");
    int result =
      hash_source_code_file(ctx, hash, ctx.args_info.input_file.c_str());
    if (result & HASH_SOURCE_CODE_ERROR) {
      failed(STATS_ERROR);
    }
    if (result & HASH_SOURCE_CODE_FOUND_TIME) {
      cc_log(""Disabling direct mode"");
      ctx.config.set_direct_mode(false);
      return nullopt;
    }

    ctx.set_manifest_name(hash.digest());

    cc_log(""Looking for result name in %s"", ctx.manifest_path().c_str());
    MTR_BEGIN(""manifest"", ""manifest_get"");
    result_name = manifest_get(ctx, ctx.manifest_path());
    MTR_END(""manifest"", ""manifest_get"");
    if (result_name) {
      cc_log(""Got result name from manifest"");
    } else {
      cc_log(""Did not find result name in manifest"");
    }
  } else {
    if (ctx.args_info.arch_args.empty()) {
      result_name = get_result_name_from_cpp(ctx, preprocessor_args, hash);
      cc_log(""Got result name from preprocessor"");
    } else {
      preprocessor_args.push_back(""-arch"");
      for (size_t i = 0; i < ctx.args_info.arch_args.size(); ++i) {
        preprocessor_args.push_back(ctx.args_info.arch_args[i]);
        result_name = get_result_name_from_cpp(ctx, preprocessor_args, hash);
        cc_log(""Got result name from preprocessor with -arch %s"",
               ctx.args_info.arch_args[i].c_str());
        if (i != ctx.args_info.arch_args.size() - 1) {
          result_name = nullopt;
        }
        preprocessor_args.pop_back();
      }
      preprocessor_args.pop_back();
    }
  }

  return result_name;
}

// Try to return the compile result from cache.
static optional<enum stats>
from_cache(Context& ctx, enum fromcache_call_mode mode)
{
  // The user might be disabling cache hits.
  if (ctx.config.recache()) {
    return nullopt;
  }

  // If we're using Clang, we can't trust a precompiled header object based on
  // running the preprocessor since clang will produce a fatal error when the
  // precompiled header is used and one of the included files has an updated
  // timestamp:
  //
  //     file 'foo.h' has been modified since the precompiled header 'foo.pch'
  //     was built
  if ((ctx.guessed_compiler == GuessedCompiler::clang
       || ctx.guessed_compiler == GuessedCompiler::unknown)
      && ctx.args_info.output_is_precompiled_header
      && mode == FROMCACHE_CPP_MODE) {
    cc_log(""Not considering cached precompiled header in preprocessor mode"");
    return nullopt;
  }

  MTR_BEGIN(""cache"", ""from_cache"");

  // Get result from cache.
  Result::Reader result_reader(ctx.result_path());
  ResultRetriever result_retriever(ctx);

  auto error = result_reader.read(result_retriever);
  if (error) {
    cc_log(""Failed to get result from cache: %s"", error->c_str());
    return nullopt;
  } else {
    // Update modification timestamp to save file from LRU cleanup.
    update_mtime(ctx.result_path().c_str());
  }

  cc_log(""Succeeded getting cached result"");

  MTR_END(""cache"", ""from_cache"");

  return mode == FROMCACHE_DIRECT_MODE ? STATS_CACHEHIT_DIR
                                       : STATS_CACHEHIT_CPP;
}

// Find the real compiler. We just search the PATH to find an executable of the
// same name that isn't a link to ourselves.
static void
find_compiler(Context& ctx, const char* const* argv)
{
  // We might be being invoked like ""ccache gcc -c foo.c"".
  std::string base(Util::base_name(argv[0]));
  if (same_executable_name(base.c_str(), MYNAME)) {
    ctx.orig_args.pop_front();
    if (is_full_path(ctx.orig_args[0].c_str())) {
      // A full path was given.
      return;
    }
    base = std::string(Util::base_name(ctx.orig_args[0]));
  }

  // Support user override of the compiler.
  if (!ctx.config.compiler().empty()) {
    base = ctx.config.compiler();
  }

  std::string compiler = find_executable(ctx, base.c_str(), MYNAME);
  if (compiler.empty()) {
    fatal(""Could not find compiler \""%s\"" in PATH"", base.c_str());
  }
  if (compiler == argv[0]) {
    fatal(""Recursive invocation (the name of the ccache binary must be \""%s\"")"",
          MYNAME);
  }
  ctx.orig_args[0] = compiler;
}

bool
is_precompiled_header(const char* path)
{
  // See ""Precompiled Headers"" in GCC docs.
  string_view ext = Util::get_extension(path);
  return ext == "".gch"" || ext == "".pch"" || ext == "".pth""
         || Util::get_extension(Util::dir_name(path)) == "".gch"";
}

static void
create_initial_config_file(Config& config)
{
  if (!Util::create_dir(Util::dir_name(config.primary_config_path()))) {
    return;
  }

  unsigned max_files;
  uint64_t max_size;
  char* stats_dir = format(""%s/0"", config.cache_dir().c_str());
  if (Stat::stat(stats_dir)) {
    stats_get_obsolete_limits(stats_dir, &max_files, &max_size);
    // STATS_MAXFILES and STATS_MAXSIZE was stored for each top directory.
    max_files *= 16;
    max_size *= 16;
  } else {
    max_files = 0;
    max_size = config.max_size();
  }
  free(stats_dir);

  FILE* f = fopen(config.primary_config_path().c_str(), ""w"");
  if (!f) {
    return;
  }
  if (max_files != 0) {
    fprintf(f, ""max_files = %u\n"", max_files);
    config.set_max_files(max_files);
  }
  if (max_size != 0) {
    char* size = format_parsable_size_with_suffix(max_size);
    fprintf(f, ""max_size = %s\n"", size);
    free(size);
    config.set_max_size(max_size);
  }
  fclose(f);
}

// Read config file(s), populate variables, create configuration file in cache
// directory if missing, etc.
static void
set_up_config(Config& config)
{
  char* p = getenv(""CCACHE_CONFIGPATH"");
  if (p) {
    config.set_primary_config_path(p);
  } else {
    config.set_secondary_config_path(fmt::format(""{}/ccache.conf"", SYSCONFDIR));
    MTR_BEGIN(""config"", ""conf_read_secondary"");
    // A missing config file in SYSCONFDIR is OK so don't check return value.
    config.update_from_file(config.secondary_config_path());
    MTR_END(""config"", ""conf_read_secondary"");

    if (config.cache_dir().empty()) {
      fatal(""configuration setting \""cache_dir\"" must not be the empty string"");
    }
    if ((p = getenv(""CCACHE_DIR""))) {
      config.set_cache_dir(p);
    }
    if (config.cache_dir().empty()) {
      fatal(""CCACHE_DIR must not be the empty string"");
    }

    config.set_primary_config_path(
      fmt::format(""{}/ccache.conf"", config.cache_dir()));
  }

  bool should_create_initial_config = false;
  MTR_BEGIN(""config"", ""conf_read_primary"");
  if (!config.update_from_file(config.primary_config_path())
      && !config.disable()) {
    should_create_initial_config = true;
  }
  MTR_END(""config"", ""conf_read_primary"");

  MTR_BEGIN(""config"", ""conf_update_from_environment"");
  config.update_from_environment();
  MTR_END(""config"", ""conf_update_from_environment"");

  if (should_create_initial_config) {
    create_initial_config_file(config);
  }

  if (config.umask() != std::numeric_limits<uint32_t>::max()) {
    umask(config.umask());
  }
}

static void
set_up_context(Context& ctx, int argc, const char* const* argv)
{
  ctx.orig_args = Args::from_argv(argc, argv);
  ctx.ignore_header_paths = Util::split_into_strings(
    ctx.config.ignore_headers_in_manifest(), PATH_DELIM);
  ctx.set_ignore_options(
    Util::split_into_strings(ctx.config.ignore_options(), "" ""));
}

// Initialize ccache, must be called once before anything else is run.
static void
initialize(Context& ctx, int argc, const char* const* argv)
{
  set_up_config(ctx.config);
  set_up_context(ctx, argc, argv);
  init_log(ctx.config);

  cc_log(""=== CCACHE %s STARTED ========================================="",
         CCACHE_VERSION);

  if (getenv(""CCACHE_INTERNAL_TRACE"")) {
#ifdef MTR_ENABLED
    ctx.mini_trace = std::make_unique<MiniTrace>(ctx->args_info);
#else
    cc_log(""Error: tracing is not enabled!"");
#endif
  }
}

// Make a copy of stderr that will not be cached, so things like distcc can
// send networking errors to it.
static void
set_up_uncached_err()
{
  int uncached_fd =
    dup(STDERR_FILENO); // The file descriptor is intentionally leaked.
  if (uncached_fd == -1) {
    cc_log(""dup(2) failed: %s"", strerror(errno));
    failed(STATS_ERROR);
  }

  x_setenv(""UNCACHED_ERR_FD"", fmt::format(""{}"", uncached_fd).c_str());
}

static void
configuration_logger(const std::string& key,
                     const std::string& value,
                     const std::string& origin)
{
  cc_bulklog(
    ""Config: (%s) %s = %s"", origin.c_str(), key.c_str(), value.c_str());
}

static void
configuration_printer(const std::string& key,
                      const std::string& value,
                      const std::string& origin)
{
  fmt::print(""({}) {} = {}\n"", origin, key, value);
}

static int cache_compilation(int argc, const char* const* argv);
static enum stats do_cache_compilation(Context& ctx, const char* const* argv);

// The entry point when invoked to cache a compilation.
static int
cache_compilation(int argc, const char* const* argv)
{
  // Needed for portability when using localtime_r.
  tzset();

  auto ctx = std::make_unique<Context>();
  SignalHandler signal_handler(*ctx);

  initialize(*ctx, argc, argv);

  MTR_BEGIN(""main"", ""find_compiler"");
  find_compiler(*ctx, argv);
  MTR_END(""main"", ""find_compiler"");

  try {
    enum stats stat = do_cache_compilation(*ctx, argv);
    stats_update(*ctx, stat);
    return EXIT_SUCCESS;
  } catch (const Failure& e) {
    if (e.stat() != STATS_NONE) {
      stats_update(*ctx, e.stat());
    }

    if (e.exit_code()) {
      return *e.exit_code();
    }
    // Else: Fall back to running the real compiler.

    assert(!ctx->orig_args.empty());

    ctx->orig_args.erase_with_prefix(""--ccache-"");
    add_prefix(*ctx, ctx->orig_args, ctx->config.prefix_command());

    cc_log(""Failed; falling back to running the real compiler"");

    Args saved_orig_args(std::move(ctx->orig_args));
    auto execv_argv = saved_orig_args.to_argv();

    cc_log_argv(""Executing "", execv_argv.data());
    ctx.reset(); // Dump debug logs last thing before executing.
    execv(execv_argv[0], const_cast<char* const*>(execv_argv.data()));
    fatal(""execv of %s failed: %s"", execv_argv[0], strerror(errno));
  }
}

static enum stats
do_cache_compilation(Context& ctx, const char* const* argv)
{
  if (ctx.actual_cwd.empty()) {
    cc_log(""Unable to determine current working directory: %s"",
           strerror(errno));
    failed(STATS_ERROR);
  }

  MTR_BEGIN(""main"", ""clean_up_internal_tempdir"");
  if (ctx.config.temporary_dir() == ctx.config.cache_dir() + ""/tmp"") {
    clean_up_internal_tempdir(ctx.config);
  }
  MTR_END(""main"", ""clean_up_internal_tempdir"");

  if (!ctx.config.log_file().empty() || ctx.config.debug()) {
    ctx.config.visit_items(configuration_logger);
  }

  if (ctx.config.disable()) {
    cc_log(""ccache is disabled"");
    // STATS_CACHEMISS is a dummy to trigger stats_flush.
    failed(STATS_CACHEMISS);
  }

  MTR_BEGIN(""main"", ""set_up_uncached_err"");
  set_up_uncached_err();
  MTR_END(""main"", ""set_up_uncached_err"");

  cc_log_argv(""Command line: "", argv);
  cc_log(""Hostname: %s"", get_hostname());
  cc_log(""Working directory: %s"", ctx.actual_cwd.c_str());
  if (ctx.apparent_cwd != ctx.actual_cwd) {
    cc_log(""Apparent working directory: %s"", ctx.apparent_cwd.c_str());
  }

  ctx.config.set_limit_multiple(
    std::min(std::max(ctx.config.limit_multiple(), 0.0), 1.0));

  MTR_BEGIN(""main"", ""guess_compiler"");
  ctx.guessed_compiler = guess_compiler(ctx.orig_args[0].c_str());
  MTR_END(""main"", ""guess_compiler"");

  // Arguments (except -E) to send to the preprocessor.
  Args preprocessor_args;
  // Arguments not sent to the preprocessor but that should be part of the
  // hash.
  Args extra_args_to_hash;
  // Arguments to send to the real compiler.
  Args compiler_args;
  MTR_BEGIN(""main"", ""process_args"");

  auto error =
    process_args(ctx, preprocessor_args, extra_args_to_hash, compiler_args);
  if (error) {
    failed(*error);
  }

  MTR_END(""main"", ""process_args"");

  if (ctx.config.depend_mode()
      && (!ctx.args_info.generating_dependencies
          || ctx.args_info.output_dep == ""/dev/null""
          || !ctx.config.run_second_cpp())) {
    cc_log(""Disabling depend mode"");
    ctx.config.set_depend_mode(false);
  }

  cc_log(""Source file: %s"", ctx.args_info.input_file.c_str());
  if (ctx.args_info.generating_dependencies) {
    cc_log(""Dependency file: %s"", ctx.args_info.output_dep.c_str());
  }
  if (ctx.args_info.generating_coverage) {
    cc_log(""Coverage file: %s"", ctx.args_info.output_cov.c_str());
  }
  if (ctx.args_info.generating_stackusage) {
    cc_log(""Stack usage file: %s"", ctx.args_info.output_su.c_str());
  }
  if (ctx.args_info.generating_diagnostics) {
    cc_log(""Diagnostics file: %s"", ctx.args_info.output_dia.c_str());
  }
  if (!ctx.args_info.output_dwo.empty()) {
    cc_log(""Split dwarf file: %s"", ctx.args_info.output_dwo.c_str());
  }

  cc_log(""Object file: %s"", ctx.args_info.output_obj.c_str());
  MTR_META_THREAD_NAME(ctx.args_info.output_obj.c_str());

  if (ctx.config.debug()) {
    std::string path =
      fmt::format(""{}.ccache-input-text"", ctx.args_info.output_obj);
    File debug_text_file(path, ""w"");
    if (debug_text_file) {
      ctx.hash_debug_files.push_back(std::move(debug_text_file));
    } else {
      cc_log(""Failed to open %s: %s"", path.c_str(), strerror(errno));
    }
  }

  FILE* debug_text_file = !ctx.hash_debug_files.empty()
                            ? ctx.hash_debug_files.front().get()
                            : nullptr;

  Hash common_hash;
  init_hash_debug(ctx,
                  common_hash,
                  ctx.args_info.output_obj.c_str(),
                  'c',
                  ""COMMON"",
                  debug_text_file);

  MTR_BEGIN(""hash"", ""common_hash"");
  hash_common_info(ctx, preprocessor_args, common_hash, ctx.args_info);
  MTR_END(""hash"", ""common_hash"");

  // Try to find the hash using the manifest.
  Hash direct_hash = common_hash;
  init_hash_debug(ctx,
                  direct_hash,
                  ctx.args_info.output_obj.c_str(),
                  'd',
                  ""DIRECT MODE"",
                  debug_text_file);

  Args args_to_hash = preprocessor_args;
  args_to_hash.push_back(extra_args_to_hash);

  bool put_result_in_manifest = false;
  optional<Digest> result_name;
  optional<Digest> result_name_from_manifest;
  if (ctx.config.direct_mode()) {
    cc_log(""Trying direct lookup"");
    MTR_BEGIN(""hash"", ""direct_hash"");
    Args dummy_args;
    result_name =
      calculate_result_name(ctx, args_to_hash, dummy_args, direct_hash, true);
    MTR_END(""hash"", ""direct_hash"");
    if (result_name) {
      ctx.set_result_name(*result_name);

      // If we can return from cache at this point then do so.
      auto result = from_cache(ctx, FROMCACHE_DIRECT_MODE);
      if (result) {
        return *result;
      }

      // Wasn't able to return from cache at this point. However, the result
      // was already found in manifest, so don't re-add it later.
      put_result_in_manifest = false;

      result_name_from_manifest = result_name;
    } else {
      // Add result to manifest later.
      put_result_in_manifest = true;
    }
  }

  if (ctx.config.read_only_direct()) {
    cc_log(""Read-only direct mode; running real compiler"");
    failed(STATS_CACHEMISS);
  }

  if (!ctx.config.depend_mode()) {
    // Find the hash using the preprocessed output. Also updates
    // g_included_files.
    Hash cpp_hash = common_hash;
    init_hash_debug(ctx,
                    cpp_hash,
                    ctx.args_info.output_obj.c_str(),
                    'p',
                    ""PREPROCESSOR MODE"",
                    debug_text_file);

    MTR_BEGIN(""hash"", ""cpp_hash"");
    result_name = calculate_result_name(
      ctx, args_to_hash, preprocessor_args, cpp_hash, false);
    MTR_END(""hash"", ""cpp_hash"");
    if (!result_name) {
      fatal(""internal error: calculate_result_name returned NULL for cpp"");
    }
    ctx.set_result_name(*result_name);

    if (result_name_from_manifest && result_name_from_manifest != result_name) {
      // The hash from manifest differs from the hash of the preprocessor
      // output. This could be because:
      //
      // - The preprocessor produces different output for the same input (not
      //   likely).
      // - There's a bug in ccache (maybe incorrect handling of compiler
      //   arguments).
      // - The user has used a different CCACHE_BASEDIR (most likely).
      //
      // The best thing here would probably be to remove the hash entry from
      // the manifest. For now, we use a simpler method: just remove the
      // manifest file.
      cc_log(""Hash from manifest doesn't match preprocessor output"");
      cc_log(""Likely reason: different CCACHE_BASEDIRs used"");
      cc_log(""Removing manifest as a safety measure"");
      Util::unlink_safe(ctx.manifest_path());

      put_result_in_manifest = true;
    }

    // If we can return from cache at this point then do.
    auto result = from_cache(ctx, FROMCACHE_CPP_MODE);
    if (result) {
      if (put_result_in_manifest) {
        update_manifest_file(ctx);
      }
      return *result;
    }
  }

  if (ctx.config.read_only()) {
    cc_log(""Read-only mode; running real compiler"");
    failed(STATS_CACHEMISS);
  }

  add_prefix(ctx, compiler_args, ctx.config.prefix_command());

  // In depend_mode, extend the direct hash.
  Hash* depend_mode_hash = ctx.config.depend_mode() ? &direct_hash : nullptr;

  // Run real compiler, sending output to cache.
  MTR_BEGIN(""cache"", ""to_cache"");
  to_cache(
    ctx, compiler_args, ctx.args_info.depend_extra_args, depend_mode_hash);
  update_manifest_file(ctx);
  MTR_END(""cache"", ""to_cache"");

  return STATS_CACHEMISS;
}

// The main program when not doing a compile.
static int
handle_main_options(int argc, const char* const* argv)
{
  enum longopts {
    DUMP_MANIFEST,
    DUMP_RESULT,
    EXTRACT_RESULT,
    HASH_FILE,
    PRINT_STATS,
  };
  static const struct option options[] = {
    {""cleanup"", no_argument, nullptr, 'c'},
    {""clear"", no_argument, nullptr, 'C'},
    {""dump-manifest"", required_argument, nullptr, DUMP_MANIFEST},
    {""dump-result"", required_argument, nullptr, DUMP_RESULT},
    {""extract-result"", required_argument, nullptr, EXTRACT_RESULT},
    {""get-config"", required_argument, nullptr, 'k'},
    {""hash-file"", required_argument, nullptr, HASH_FILE},
    {""help"", no_argument, nullptr, 'h'},
    {""max-files"", required_argument, nullptr, 'F'},
    {""max-size"", required_argument, nullptr, 'M'},
    {""print-stats"", no_argument, nullptr, PRINT_STATS},
    {""recompress"", required_argument, nullptr, 'X'},
    {""set-config"", required_argument, nullptr, 'o'},
    {""show-compression"", no_argument, nullptr, 'x'},
    {""show-config"", no_argument, nullptr, 'p'},
    {""show-stats"", no_argument, nullptr, 's'},
    {""version"", no_argument, nullptr, 'V'},
    {""zero-stats"", no_argument, nullptr, 'z'},
    {nullptr, 0, nullptr, 0}};

  Context ctx;
  initialize(ctx, argc, argv);

  int c;
  while ((c = getopt_long(argc,
                          const_cast<char* const*>(argv),
                          ""cCk:hF:M:po:sVxX:z"",
                          options,
                          nullptr))
         != -1) {
    switch (c) {
    case DUMP_MANIFEST:
      return manifest_dump(optarg, stdout) ? 0 : 1;

    case DUMP_RESULT: {
      ResultDumper result_dumper(stdout);
      Result::Reader result_reader(optarg);
      auto error = result_reader.read(result_dumper);
      if (error) {
        fmt::print(stderr, ""Error: {}\n"", *error);
      }
      return error ? EXIT_FAILURE : EXIT_SUCCESS;
    }

    case EXTRACT_RESULT: {
      ResultExtractor result_extractor(""."");
      Result::Reader result_reader(optarg);
      auto error = result_reader.read(result_extractor);
      if (error) {
        fmt::print(stderr, ""Error: {}\n"", *error);
      }
      return error ? EXIT_FAILURE : EXIT_SUCCESS;
    }

    case HASH_FILE: {
      Hash hash;
      if (str_eq(optarg, ""-"")) {
        hash.hash_fd(STDIN_FILENO);
      } else {
        hash.hash_file(optarg);
      }
      fmt::print(""{}"", hash.digest().to_string());
      break;
    }

    case PRINT_STATS:
      stats_print(ctx.config);
      break;

    case 'c': // --cleanup
    {
      ProgressBar progress_bar(""Cleaning..."");
      clean_up_all(ctx.config,
                   [&](double progress) { progress_bar.update(progress); });
      if (isatty(STDOUT_FILENO)) {
        printf(""\n"");
      }
      break;
    }

    case 'C': // --clear
    {
      ProgressBar progress_bar(""Clearing..."");
      wipe_all(ctx, [&](double progress) { progress_bar.update(progress); });
      if (isatty(STDOUT_FILENO)) {
        printf(""\n"");
      }
      break;
    }

    case 'h': // --help
      fprintf(stdout, USAGE_TEXT, MYNAME, MYNAME);
      x_exit(0);

    case 'k': // --get-config
      fmt::print(""{}\n"", ctx.config.get_string_value(optarg));
      break;

    case 'F': { // --max-files
      Config::set_value_in_file(
        ctx.config.primary_config_path(), ""max_files"", optarg);
      unsigned files = atoi(optarg);
      if (files == 0) {
        printf(""Unset cache file limit\n"");
      } else {
        printf(""Set cache file limit to %u\n"", files);
      }
      break;
    }

    case 'M': { // --max-size
      uint64_t size;
      if (!parse_size_with_suffix(optarg, &size)) {
        fatal(""invalid size: %s"", optarg);
      }
      Config::set_value_in_file(
        ctx.config.primary_config_path(), ""max_size"", optarg);
      if (size == 0) {
        printf(""Unset cache size limit\n"");
      } else {
        char* s = format_human_readable_size(size);
        printf(""Set cache size limit to %s\n"", s);
        free(s);
      }
      break;
    }

    case 'o': {                          // --set-config
      char* p = strchr(optarg + 1, '='); // Improve error message for -o=K=V
      if (!p) {
        fatal(""missing equal sign in \""%s\"""", optarg);
      }
      char* key = x_strndup(optarg, p - optarg);
      char* value = p + 1;
      Config::set_value_in_file(ctx.config.primary_config_path(), key, value);
      free(key);
      break;
    }

    case 'p': // --show-config
      ctx.config.visit_items(configuration_printer);
      break;

    case 's': // --show-stats
      stats_summary(ctx);
      break;

    case 'V': // --version
      fprintf(stdout, VERSION_TEXT, MYNAME, CCACHE_VERSION);
      x_exit(0);

    case 'x': // --show-compression
    {
      ProgressBar progress_bar(""Scanning..."");
      compress_stats(ctx.config,
                     [&](double progress) { progress_bar.update(progress); });
      break;
    }

    case 'X': // --recompress
    {
      int level;
      if (std::string(optarg) == ""uncompressed"") {
        level = 0;
      } else {
        level = Util::parse_int(optarg);
        if (level < -128 || level > 127) {
          throw Error(""compression level must be between -128 and 127"");
        }
        if (level == 0) {
          level = ctx.config.compression_level();
        }
      }

      ProgressBar progress_bar(""Recompressing..."");
      compress_recompress(
        ctx, level, [&](double progress) { progress_bar.update(progress); });
      break;
    }

    case 'z': // --zero-stats
      stats_zero(ctx);
      printf(""Statistics zeroed\n"");
      break;

    default:
      fprintf(stderr, USAGE_TEXT, MYNAME, MYNAME);
      x_exit(1);
    }

    // Some of the above switches might have changed config settings, so run the
    // setup again.
    set_up_config(ctx.config);
  }

  return 0;
}

int ccache_main(int argc, const char* const* argv);

int
ccache_main(int argc, const char* const* argv)
{
  try {
    // Check if we are being invoked as ""ccache"".
    std::string program_name(Util::base_name(argv[0]));
    if (same_executable_name(program_name.c_str(), MYNAME)) {
      if (argc < 2) {
        fprintf(stderr, USAGE_TEXT, MYNAME, MYNAME);
        x_exit(1);
      }
      // If the first argument isn't an option, then assume we are being passed
      // a compiler name and options.
      if (argv[1][0] == '-') {
        return handle_main_options(argc, argv);
      }
    }

    return cache_compilation(argc, argv);
  } catch (const ErrorBase& e) {
    fmt::print(stderr, ""ccache: error: {}\n"", e.what());
    return EXIT_FAILURE;
  }
}
""",to_cache,[809:1013]
ccache,https://github.com/ccache/ccache/commit/7f55660f0c03b3edae809f2e6097f4be2a707329,"""Handle missing .gcno file gracefully

GCC ≥9 has changed behavior for -ftest-coverage and --coverage in
combination with -fprofile-dir=dir:

- Without -fprofile-dir=dir the file is placed next to the object file
  but with a “.gcno” extension.
- With -fprofile-dir=dir the file is also place next to the object file
  (i.e. not in the specified profile directory) but the same style of
  name as used for “.gcda” files (full pathname with slashes replaced
  with hash characters).

Fix this by:

- Checking if the expected (GCC <9) .gcno file is present. If not, fall
  back to running the compiler and increment the “unsupported option”
  counter.
- Making sure to perform the above check before copying the object file
  to the cache so that a later ccache invocation won’t believe that
  there is a result in the cache.
- Improving the copy_file routine to not create the destination file
  until it knows that there is a source file to copy from.

Fixes #674.

(cherry picked from commit 6abd78b5ec7cdfeedff36454b07a8dbff312b554)""","""// Copyright (C) 2002-2007 Andrew Tridgell
// Copyright (C) 2009-2020 Joel Rosdahl and other contributors
//
// See doc/AUTHORS.adoc for a complete list of contributors.
//
// This program is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by the Free
// Software Foundation; either version 3 of the License, or (at your option)
// any later version.
//
// This program is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
// more details.
//
// You should have received a copy of the GNU General Public License along with
// this program; if not, write to the Free Software Foundation, Inc., 51
// Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA

#include ""ccache.hpp""

#include ""Args.hpp""
#include ""ArgsInfo.hpp""
#include ""Checksum.hpp""
#include ""Compression.hpp""
#include ""Context.hpp""
#include ""Fd.hpp""
#include ""File.hpp""
#include ""Finalizer.hpp""
#include ""FormatNonstdStringView.hpp""
#include ""Hash.hpp""
#include ""Lockfile.hpp""
#include ""Logging.hpp""
#include ""Manifest.hpp""
#include ""MiniTrace.hpp""
#include ""ProgressBar.hpp""
#include ""Result.hpp""
#include ""ResultDumper.hpp""
#include ""ResultExtractor.hpp""
#include ""ResultRetriever.hpp""
#include ""SignalHandler.hpp""
#include ""StdMakeUnique.hpp""
#include ""TemporaryFile.hpp""
#include ""UmaskScope.hpp""
#include ""Util.hpp""
#include ""argprocessing.hpp""
#include ""cleanup.hpp""
#include ""compopt.hpp""
#include ""compress.hpp""
#include ""exceptions.hpp""
#include ""execute.hpp""
#include ""hashutil.hpp""
#include ""language.hpp""

#include ""third_party/fmt/core.h""
#include ""third_party/nonstd/optional.hpp""
#include ""third_party/nonstd/string_view.hpp""

#ifdef HAVE_GETOPT_LONG
#  include <getopt.h>
#elif defined(_WIN32)
#  include ""third_party/win32/getopt.h""
#else
#  include ""third_party/getopt_long.h""
#endif

#ifdef _WIN32
#  include ""Win32Util.hpp""
#endif

#include <algorithm>
#include <cmath>
#include <limits>

#ifndef MYNAME
#  define MYNAME ""ccache""
#endif
const char CCACHE_NAME[] = MYNAME;

using Logging::log;
using nonstd::nullopt;
using nonstd::optional;
using nonstd::string_view;

const char VERSION_TEXT[] =
  R""({} version {}

Copyright (C) 2002-2007 Andrew Tridgell
Copyright (C) 2009-2020 Joel Rosdahl and other contributors

See <https://ccache.dev/credits.html> for a complete list of contributors.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 3 of the License, or (at your option) any later
version.
)"";

const char USAGE_TEXT[] =
  R""(Usage:
    {} [options]
    {} compiler [compiler options]
    compiler [compiler options]          (via symbolic link)

Common options:
    -c, --cleanup              delete old files and recalculate size counters
                               (normally not needed as this is done
                               automatically)
    -C, --clear                clear the cache completely (except configuration)
    -d, --directory PATH       operate on cache directory PATH instead of the
                               default
        --evict-older-than AGE remove files older than AGE (unsigned integer
                               with a d (days) or s (seconds) suffix)
    -F, --max-files NUM        set maximum number of files in cache to NUM (use
                               0 for no limit)
    -M, --max-size SIZE        set maximum size of cache to SIZE (use 0 for no
                               limit); available suffixes: k, M, G, T (decimal)
                               and Ki, Mi, Gi, Ti (binary); default suffix: G
    -X, --recompress LEVEL     recompress the cache to LEVEL (integer level or
                               ""uncompressed"")
    -o, --set-config KEY=VAL   set configuration item KEY to value VAL
    -x, --show-compression     show compression statistics
    -p, --show-config          show current configuration options in
                               human-readable format
    -s, --show-stats           show summary of configuration and statistics
                               counters in human-readable format
    -z, --zero-stats           zero statistics counters

    -h, --help                 print this help text
    -V, --version              print version and copyright information

Options for scripting or debugging:
        --checksum-file PATH   print the checksum (64 bit XXH3) of the file at
                               PATH
        --dump-manifest PATH   dump manifest file at PATH in text format
        --dump-result PATH     dump result file at PATH in text format
        --extract-result PATH  extract data stored in result file at PATH to the
                               current working directory
    -k, --get-config KEY       print the value of configuration key KEY
        --hash-file PATH       print the hash (160 bit BLAKE3) of the file at
                               PATH
        --print-stats          print statistics counter IDs and corresponding
                               values in machine-parsable format

See also <https://ccache.dev>.
)"";

// How often (in seconds) to scan $CCACHE_DIR/tmp for left-over temporary
// files.
const int k_tempdir_cleanup_interval = 2 * 24 * 60 * 60; // 2 days

// Maximum files per cache directory. This constant is somewhat arbitrarily
// chosen to be large enough to avoid unnecessary cache levels but small enough
// not to make esoteric file systems (with bad performance for large
// directories) too slow. It could be made configurable, but hopefully there
// will be no need to do that.
const uint64_t k_max_cache_files_per_directory = 2000;

// Minimum number of cache levels ($CCACHE_DIR/1/2/stored_file).
const uint8_t k_min_cache_levels = 2;

// Maximum number of cache levels ($CCACHE_DIR/1/2/3/stored_file).
//
// On a cache miss, (k_max_cache_levels - k_min_cache_levels + 1) cache lookups
// (i.e. stat system calls) will be performed for a cache entry.
//
// An assumption made here is that if a cache is so large that it holds more
// than 16^4 * k_max_cache_files_per_directory files then we can assume that the
// file system is sane enough to handle more than
// k_max_cache_files_per_directory.
const uint8_t k_max_cache_levels = 4;

// This is a string that identifies the current ""version"" of the hash sum
// computed by ccache. If, for any reason, we want to force the hash sum to be
// different for the same input in a new ccache version, we can just change
// this string. A typical example would be if the format of one of the files
// stored in the cache changes in a backwards-incompatible way.
const char HASH_PREFIX[] = ""3"";

static void
add_prefix(const Context& ctx, Args& args, const std::string& prefix_command)
{
  if (prefix_command.empty()) {
    return;
  }

  Args prefix;
  for (const auto& word : Util::split_into_strings(prefix_command, "" "")) {
    std::string path = find_executable(ctx, word, CCACHE_NAME);
    if (path.empty()) {
      throw Fatal(""{}: {}"", word, strerror(errno));
    }

    prefix.push_back(path);
  }

  log(""Using command-line prefix {}"", prefix_command);
  for (size_t i = prefix.size(); i != 0; i--) {
    args.push_front(prefix[i - 1]);
  }
}

static void
clean_up_internal_tempdir(const Config& config)
{
  time_t now = time(nullptr);
  auto dir_st = Stat::stat(config.cache_dir(), Stat::OnError::log);
  if (!dir_st || dir_st.mtime() + k_tempdir_cleanup_interval >= now) {
    // No cleanup needed.
    return;
  }

  Util::update_mtime(config.cache_dir());

  const std::string& temp_dir = config.temporary_dir();
  if (!Stat::lstat(temp_dir)) {
    return;
  }

  Util::traverse(temp_dir, [now](const std::string& path, bool is_dir) {
    if (is_dir) {
      return;
    }
    auto st = Stat::lstat(path, Stat::OnError::log);
    if (st && st.mtime() + k_tempdir_cleanup_interval < now) {
      Util::unlink_tmp(path);
    }
  });
}

static void
init_hash_debug(Context& ctx,
                Hash& hash,
                string_view obj_path,
                char type,
                string_view section_name,
                FILE* debug_text_file)
{
  if (!ctx.config.debug()) {
    return;
  }

  std::string path = fmt::format(""{}.ccache-input-{}"", obj_path, type);
  File debug_binary_file(path, ""wb"");
  if (debug_binary_file) {
    hash.enable_debug(section_name, debug_binary_file.get(), debug_text_file);
    ctx.hash_debug_files.push_back(std::move(debug_binary_file));
  } else {
    log(""Failed to open {}: {}"", path, strerror(errno));
  }
}

static GuessedCompiler
guess_compiler(string_view path)
{
  string_view name = Util::base_name(path);
  GuessedCompiler result = GuessedCompiler::unknown;
  if (name.find(""clang"") != std::string::npos) {
    result = GuessedCompiler::clang;
  } else if (name.find(""gcc"") != std::string::npos
             || name.find(""g++"") != std::string::npos) {
    result = GuessedCompiler::gcc;
  } else if (name.find(""nvcc"") != std::string::npos) {
    result = GuessedCompiler::nvcc;
  } else if (name == ""pump"" || name == ""distcc-pump"") {
    result = GuessedCompiler::pump;
  }
  return result;
}

static bool
do_remember_include_file(Context& ctx,
                         std::string path,
                         Hash& cpp_hash,
                         bool system,
                         Hash* depend_mode_hash)
{
  bool is_pch = false;

  if (path.length() >= 2 && path[0] == '<' && path[path.length() - 1] == '>') {
    // Typically <built-in> or <command-line>.
    return true;
  }

  if (path == ctx.args_info.input_file) {
    // Don't remember the input file.
    return true;
  }

  if (system && (ctx.config.sloppiness() & SLOPPY_SYSTEM_HEADERS)) {
    // Don't remember this system header.
    return true;
  }

  if (ctx.included_files.find(path) != ctx.included_files.end()) {
    // Already known include file.
    return true;
  }

  // Canonicalize path for comparison; Clang uses ./header.h.
  if (Util::starts_with(path, ""./"")) {
    path.erase(0, 2);
  }

#ifdef _WIN32
  {
    // stat fails on directories on win32.
    DWORD attributes = GetFileAttributes(path.c_str());
    if (attributes != INVALID_FILE_ATTRIBUTES
        && attributes & FILE_ATTRIBUTE_DIRECTORY) {
      return true;
    }
  }
#endif

  auto st = Stat::stat(path, Stat::OnError::log);
  if (!st) {
    return false;
  }
  if (st.is_directory()) {
    // Ignore directory, typically $PWD.
    return true;
  }
  if (!st.is_regular()) {
    // Device, pipe, socket or other strange creature.
    log(""Non-regular include file {}"", path);
    return false;
  }

  for (const auto& ignore_header_path : ctx.ignore_header_paths) {
    if (Util::matches_dir_prefix_or_file(ignore_header_path, path)) {
      return true;
    }
  }

  // The comparison using >= is intentional, due to a possible race between
  // starting compilation and writing the include file. See also the notes
  // under ""Performance"" in doc/MANUAL.adoc.
  if (!(ctx.config.sloppiness() & SLOPPY_INCLUDE_FILE_MTIME)
      && st.mtime() >= ctx.time_of_compilation) {
    log(""Include file {} too new"", path);
    return false;
  }

  // The same >= logic as above applies to the change time of the file.
  if (!(ctx.config.sloppiness() & SLOPPY_INCLUDE_FILE_CTIME)
      && st.ctime() >= ctx.time_of_compilation) {
    log(""Include file {} ctime too new"", path);
    return false;
  }

  // Let's hash the include file content.
  Hash fhash;

  is_pch = Util::is_precompiled_header(path);
  if (is_pch) {
    if (ctx.included_pch_file.empty()) {
      log(""Detected use of precompiled header: {}"", path);
    }
    bool using_pch_sum = false;
    if (ctx.config.pch_external_checksum()) {
      // hash pch.sum instead of pch when it exists
      // to prevent hashing a very large .pch file every time
      std::string pch_sum_path = fmt::format(""{}.sum"", path);
      if (Stat::stat(pch_sum_path, Stat::OnError::log)) {
        path = std::move(pch_sum_path);
        using_pch_sum = true;
        log(""Using pch.sum file {}"", path);
      }
    }

    if (!hash_binary_file(ctx, fhash, path)) {
      return false;
    }
    cpp_hash.hash_delimiter(using_pch_sum ? ""pch_sum_hash"" : ""pch_hash"");
    cpp_hash.hash(fhash.digest().to_string());
  }

  if (ctx.config.direct_mode()) {
    if (!is_pch) { // else: the file has already been hashed.
      int result = hash_source_code_file(ctx, fhash, path);
      if (result & HASH_SOURCE_CODE_ERROR
          || result & HASH_SOURCE_CODE_FOUND_TIME) {
        return false;
      }
    }

    Digest d = fhash.digest();
    ctx.included_files.emplace(path, d);

    if (depend_mode_hash) {
      depend_mode_hash->hash_delimiter(""include"");
      depend_mode_hash->hash(d.to_string());
    }
  }

  return true;
}

// This function hashes an include file and stores the path and hash in
// ctx.included_files. If the include file is a PCH, cpp_hash is also updated.
static void
remember_include_file(Context& ctx,
                      const std::string& path,
                      Hash& cpp_hash,
                      bool system,
                      Hash* depend_mode_hash)
{
  if (!do_remember_include_file(ctx, path, cpp_hash, system, depend_mode_hash)
      && ctx.config.direct_mode()) {
    log(""Disabling direct mode"");
    ctx.config.set_direct_mode(false);
  }
}

static void
print_included_files(const Context& ctx, FILE* fp)
{
  for (const auto& item : ctx.included_files) {
    fmt::print(fp, ""{}\n"", item.first);
  }
}

// This function reads and hashes a file. While doing this, it also does these
// things:
//
// - Makes include file paths for which the base directory is a prefix relative
//   when computing the hash sum.
// - Stores the paths and hashes of included files in ctx.included_files.
static bool
process_preprocessed_file(Context& ctx,
                          Hash& hash,
                          const std::string& path,
                          bool pump)
{
  std::string data;
  try {
    data = Util::read_file(path);
  } catch (Error&) {
    return false;
  }

  // Bytes between p and q are pending to be hashed.
  const char* p = &data[0];
  char* q = &data[0];
  const char* end = p + data.length();

  // There must be at least 7 characters (# 1 ""x"") left to potentially find an
  // include file path.
  while (q < end - 7) {
    static const string_view pragma_gcc_pch_preprocess =
      ""pragma GCC pch_preprocess "";
    static const string_view hash_31_command_line_newline =
      ""# 31 \""<command-line>\""\n"";
    static const string_view hash_32_command_line_2_newline =
      ""# 32 \""<command-line>\"" 2\n"";

    // Check if we look at a line containing the file name of an included file.
    // At least the following formats exist (where N is a positive integer):
    //
    // GCC:
    //
    //   # N ""file""
    //   # N ""file"" N
    //   #pragma GCC pch_preprocess ""file""
    //
    // HP's compiler:
    //
    //   #line N ""file""
    //
    // AIX's compiler:
    //
    //   #line N ""file""
    //   #line N
    //
    // Note that there may be other lines starting with '#' left after
    // preprocessing as well, for instance ""#    pragma"".
    if (q[0] == '#'
        // GCC:
        && ((q[1] == ' ' && q[2] >= '0' && q[2] <= '9')
            // GCC precompiled header:
            || Util::starts_with(&q[1], pragma_gcc_pch_preprocess)
            // HP/AIX:
            || (q[1] == 'l' && q[2] == 'i' && q[3] == 'n' && q[4] == 'e'
                && q[5] == ' '))
        && (q == data.data() || q[-1] == '\n')) {
      // Workarounds for preprocessor linemarker bugs in GCC version 6.
      if (q[2] == '3') {
        if (Util::starts_with(q, hash_31_command_line_newline)) {
          // Bogus extra line with #31, after the regular #1: Ignore the whole
          // line, and continue parsing.
          hash.hash(p, q - p);
          while (q < end && *q != '\n') {
            q++;
          }
          q++;
          p = q;
          continue;
        } else if (Util::starts_with(q, hash_32_command_line_2_newline)) {
          // Bogus wrong line with #32, instead of regular #1: Replace the line
          // number with the usual one.
          hash.hash(p, q - p);
          q += 1;
          q[0] = '#';
          q[1] = ' ';
          q[2] = '1';
          p = q;
        }
      }

      while (q < end && *q != '""' && *q != '\n') {
        q++;
      }
      if (q < end && *q == '\n') {
        // A newline before the quotation mark -> no match.
        continue;
      }
      q++;
      if (q >= end) {
        log(""Failed to parse included file path"");
        return false;
      }
      // q points to the beginning of an include file path
      hash.hash(p, q - p);
      p = q;
      while (q < end && *q != '""') {
        q++;
      }
      // Look for preprocessor flags, after the ""filename"".
      bool system = false;
      const char* r = q + 1;
      while (r < end && *r != '\n') {
        if (*r == '3') { // System header.
          system = true;
        }
        r++;
      }
      // p and q span the include file path.
      std::string inc_path(p, q - p);
      if (!ctx.has_absolute_include_headers) {
        ctx.has_absolute_include_headers = Util::is_absolute_path(inc_path);
      }
      inc_path = Util::make_relative_path(ctx, inc_path);

      bool should_hash_inc_path = true;
      if (!ctx.config.hash_dir()) {
        if (Util::starts_with(inc_path, ctx.apparent_cwd)
            && Util::ends_with(inc_path, ""//"")) {
          // When compiling with -g or similar, GCC adds the absolute path to
          // CWD like this:
          //
          //   # 1 ""CWD//""
          //
          // If the user has opted out of including the CWD in the hash, don't
          // hash it. See also how debug_prefix_map is handled.
          should_hash_inc_path = false;
        }
      }
      if (should_hash_inc_path) {
        hash.hash(inc_path);
      }

      remember_include_file(ctx, inc_path, hash, system, nullptr);
      p = q; // Everything of interest between p and q has been hashed now.
    } else if (q[0] == '.' && q[1] == 'i' && q[2] == 'n' && q[3] == 'c'
               && q[4] == 'b' && q[5] == 'i' && q[6] == 'n') {
      // An assembler .inc bin (without the space) statement, which could be
      // part of inline assembly, refers to an external file. If the file
      // changes, the hash should change as well, but finding out what file to
      // hash is too hard for ccache, so just bail out.
      log(
        ""Found unsupported .inc""
        ""bin directive in source code"");
      throw Failure(Statistic::unsupported_code_directive);
    } else if (pump && strncmp(q, ""_________"", 9) == 0) {
      // Unfortunately the distcc-pump wrapper outputs standard output lines:
      // __________Using distcc-pump from /usr/bin
      // __________Using # distcc servers in pump mode
      // __________Shutting down distcc-pump include server
      while (q < end && *q != '\n') {
        q++;
      }
      if (*q == '\n') {
        q++;
      }
      p = q;
      continue;
    } else {
      q++;
    }
  }

  hash.hash(p, (end - p));

  // Explicitly check the .gch/.pch/.pth file as Clang does not include any
  // mention of it in the preprocessed output.
  if (!ctx.included_pch_file.empty()) {
    std::string pch_path = Util::make_relative_path(ctx, ctx.included_pch_file);
    hash.hash(pch_path);
    remember_include_file(ctx, pch_path, hash, false, nullptr);
  }

  bool debug_included = getenv(""CCACHE_DEBUG_INCLUDED"");
  if (debug_included) {
    print_included_files(ctx, stdout);
  }

  return true;
}

// Replace absolute paths with relative paths in the provided dependency file.
static void
use_relative_paths_in_depfile(const Context& ctx)
{
  if (ctx.config.base_dir().empty()) {
    log(""Base dir not set, skip using relative paths"");
    return; // nothing to do
  }
  if (!ctx.has_absolute_include_headers) {
    log(""No absolute path for included files found, skip using relative paths"");
    return; // nothing to do
  }

  const std::string& output_dep = ctx.args_info.output_dep;
  std::string file_content;
  try {
    file_content = Util::read_file(output_dep);
  } catch (const Error& e) {
    log(""Cannot open dependency file {}: {}"", output_dep, e.what());
    return;
  }

  std::string adjusted_file_content;
  adjusted_file_content.reserve(file_content.size());

  bool rewritten = false;

  for (string_view token : Util::split_into_views(file_content, "" \t\r\n"")) {
    if (Util::is_absolute_path(token)
        && token.starts_with(ctx.config.base_dir())) {
      adjusted_file_content.append(Util::make_relative_path(ctx, token));
      rewritten = true;
    } else {
      adjusted_file_content.append(token.begin(), token.end());
    }
    adjusted_file_content.push_back(' ');
  }

  if (!rewritten) {
    log(
      ""No paths in dependency file {} made relative, skip relative path usage"",
      output_dep);
    return;
  }

  std::string tmp_file = output_dep + "".tmp"";
  Util::write_file(tmp_file, adjusted_file_content);
  Util::rename(tmp_file, output_dep);
}

// Extract the used includes from the dependency file. Note that we cannot
// distinguish system headers from other includes here.
static optional<Digest>
result_name_from_depfile(Context& ctx, Hash& hash)
{
  std::string file_content;
  try {
    file_content = Util::read_file(ctx.args_info.output_dep);
  } catch (const Error& e) {
    log(
      ""Cannot open dependency file {}: {}"", ctx.args_info.output_dep, e.what());
    return nullopt;
  }

  for (string_view token : Util::split_into_views(file_content, "" \t\r\n"")) {
    if (token == ""\\"" || token.ends_with("":"")) {
      continue;
    }
    if (!ctx.has_absolute_include_headers) {
      ctx.has_absolute_include_headers = Util::is_absolute_path(token);
    }
    std::string path = Util::make_relative_path(ctx, token);
    remember_include_file(ctx, path, hash, false, &hash);
  }

  // Explicitly check the .gch/.pch/.pth file as it may not be mentioned in the
  // dependencies output.
  if (!ctx.included_pch_file.empty()) {
    std::string pch_path = Util::make_relative_path(ctx, ctx.included_pch_file);
    hash.hash(pch_path);
    remember_include_file(ctx, pch_path, hash, false, nullptr);
  }

  bool debug_included = getenv(""CCACHE_DEBUG_INCLUDED"");
  if (debug_included) {
    print_included_files(ctx, stdout);
  }

  return hash.digest();
}

// Execute the compiler/preprocessor, with logic to retry without requesting
// colored diagnostics messages if that fails.
static int
do_execute(Context& ctx,
           Args& args,
           TemporaryFile&& tmp_stdout,
           TemporaryFile&& tmp_stderr)
{
  UmaskScope umask_scope(ctx.original_umask);

  if (ctx.diagnostics_color_failed
      && ctx.guessed_compiler == GuessedCompiler::gcc) {
    args.erase_with_prefix(""-fdiagnostics-color"");
  }
  int status = execute(args.to_argv().data(),
                       std::move(tmp_stdout.fd),
                       std::move(tmp_stderr.fd),
                       &ctx.compiler_pid);
  if (status != 0 && !ctx.diagnostics_color_failed
      && ctx.guessed_compiler == GuessedCompiler::gcc) {
    auto errors = Util::read_file(tmp_stderr.path);
    if (errors.find(""unrecognized command line option"") != std::string::npos
        && errors.find(""-fdiagnostics-color"") != std::string::npos) {
      // Old versions of GCC do not support colored diagnostics.
      log(""-fdiagnostics-color is unsupported; trying again without it"");

      tmp_stdout.fd = Fd(open(
        tmp_stdout.path.c_str(), O_RDWR | O_CREAT | O_TRUNC | O_BINARY, 0600));
      if (!tmp_stdout.fd) {
        log(""Failed to truncate {}: {}"", tmp_stdout.path, strerror(errno));
        throw Failure(Statistic::internal_error);
      }

      tmp_stderr.fd = Fd(open(
        tmp_stderr.path.c_str(), O_RDWR | O_CREAT | O_TRUNC | O_BINARY, 0600));
      if (!tmp_stderr.fd) {
        log(""Failed to truncate {}: {}"", tmp_stderr.path, strerror(errno));
        throw Failure(Statistic::internal_error);
      }

      ctx.diagnostics_color_failed = true;
      return do_execute(
        ctx, args, std::move(tmp_stdout), std::move(tmp_stderr));
    }
  }
  return status;
}

struct LookUpCacheFileResult
{
  std::string path;
  Stat stat;
  uint8_t level;
};

static LookUpCacheFileResult
look_up_cache_file(const std::string& cache_dir,
                   const Digest& name,
                   nonstd::string_view suffix)
{
  const auto name_string = fmt::format(""{}{}"", name.to_string(), suffix);

  for (uint8_t level = k_min_cache_levels; level <= k_max_cache_levels;
       ++level) {
    const auto path = Util::get_path_in_cache(cache_dir, level, name_string);
    const auto stat = Stat::stat(path);
    if (stat) {
      return {path, stat, level};
    }
  }

  const auto shallowest_path =
    Util::get_path_in_cache(cache_dir, k_min_cache_levels, name_string);
  return {shallowest_path, Stat(), k_min_cache_levels};
}

// Create or update the manifest file.
static void
update_manifest_file(Context& ctx)
{
  if (!ctx.config.direct_mode() || ctx.config.read_only()
      || ctx.config.read_only_direct()) {
    return;
  }

  ASSERT(ctx.manifest_path());
  ASSERT(ctx.result_path());

  MTR_BEGIN(""manifest"", ""manifest_put"");

  const auto old_stat = Stat::stat(*ctx.manifest_path());

  // See comment in get_file_hash_index for why saving of timestamps is forced
  // for precompiled headers.
  const bool save_timestamp =
    (ctx.config.sloppiness() & SLOPPY_FILE_STAT_MATCHES)
    || ctx.args_info.output_is_precompiled_header;

  log(""Adding result name to {}"", *ctx.manifest_path());
  if (!Manifest::put(ctx.config,
                     *ctx.manifest_path(),
                     *ctx.result_name(),
                     ctx.included_files,
                     ctx.time_of_compilation,
                     save_timestamp)) {
    log(""Failed to add result name to {}"", *ctx.manifest_path());
  } else {
    const auto new_stat = Stat::stat(*ctx.manifest_path(), Stat::OnError::log);
    ctx.manifest_counter_updates.increment(
      Statistic::cache_size_kibibyte,
      Util::size_change_kibibyte(old_stat, new_stat));
    ctx.manifest_counter_updates.increment(Statistic::files_in_cache,
                                           !old_stat && new_stat ? 1 : 0);
  }
  MTR_END(""manifest"", ""manifest_put"");
}

static void
create_cachedir_tag(const Context& ctx)
{
  constexpr char cachedir_tag[] =
    ""Signature: 8a477f597d28d172789f06886806bc55\n""
    ""# This file is a cache directory tag created by ccache.\n""
    ""# For information about cache directory tags, see:\n""
    ""#\thttp://www.brynosaurus.com/cachedir/\n"";

  const std::string path = fmt::format(""{}/{}/CACHEDIR.TAG"",
                                       ctx.config.cache_dir(),
                                       ctx.result_name()->to_string()[0]);
  const auto stat = Stat::stat(path);
  if (stat) {
    return;
  }
  try {
    Util::write_file(path, cachedir_tag);
  } catch (const Error& e) {
    log(""Failed to create {}: {}"", path, e.what());
  }
}

// Run the real compiler and put the result in cache.
static void
to_cache(Context& ctx,
         Args& args,
         Args& depend_extra_args,
         Hash* depend_mode_hash)
{
  args.push_back(""-o"");
  args.push_back(ctx.args_info.output_obj);

  if (ctx.config.hard_link() && ctx.args_info.output_obj != ""/dev/null"") {
    // Workaround for Clang bug where it overwrites an existing object file
    // when it's compiling an assembler file, see
    // <https://bugs.llvm.org/show_bug.cgi?id=39782>.
    Util::unlink_safe(ctx.args_info.output_obj);
  }

  if (ctx.args_info.generating_diagnostics) {
    args.push_back(""--serialize-diagnostics"");
    args.push_back(ctx.args_info.output_dia);
  }

  // Turn off DEPENDENCIES_OUTPUT when running cc1, because otherwise it will
  // emit a line like this:
  //
  //   tmp.stdout.vexed.732.o: /home/mbp/.ccache/tmp.stdout.vexed.732.i
  Util::unsetenv(""DEPENDENCIES_OUTPUT"");
  Util::unsetenv(""SUNPRO_DEPENDENCIES"");

  if (ctx.config.run_second_cpp()) {
    args.push_back(ctx.args_info.input_file);
  } else {
    args.push_back(ctx.i_tmpfile);
  }

  if (ctx.args_info.seen_split_dwarf) {
    // Remove any pre-existing .dwo file since we want to check if the compiler
    // produced one, intentionally not using x_unlink or tmp_unlink since we're
    // not interested in logging successful deletions or failures due to
    // non-existent .dwo files.
    if (unlink(ctx.args_info.output_dwo.c_str()) != 0 && errno != ENOENT
        && errno != ESTALE) {
      log(""Failed to unlink {}: {}"", ctx.args_info.output_dwo, strerror(errno));
      throw Failure(Statistic::bad_output_file);
    }
  }

  log(""Running real compiler"");
  MTR_BEGIN(""execute"", ""compiler"");

  TemporaryFile tmp_stdout(
    fmt::format(""{}/tmp.stdout"", ctx.config.temporary_dir()));
  ctx.register_pending_tmp_file(tmp_stdout.path);
  std::string tmp_stdout_path = tmp_stdout.path;

  TemporaryFile tmp_stderr(
    fmt::format(""{}/tmp.stderr"", ctx.config.temporary_dir()));
  ctx.register_pending_tmp_file(tmp_stderr.path);
  std::string tmp_stderr_path = tmp_stderr.path;

  int status;
  if (!ctx.config.depend_mode()) {
    status =
      do_execute(ctx, args, std::move(tmp_stdout), std::move(tmp_stderr));
    args.pop_back(3);
  } else {
    // Use the original arguments (including dependency options) in depend
    // mode.
    Args depend_mode_args = ctx.orig_args;
    depend_mode_args.erase_with_prefix(""--ccache-"");
    depend_mode_args.push_back(depend_extra_args);
    add_prefix(ctx, depend_mode_args, ctx.config.prefix_command());

    ctx.time_of_compilation = time(nullptr);
    status = do_execute(
      ctx, depend_mode_args, std::move(tmp_stdout), std::move(tmp_stderr));
  }
  MTR_END(""execute"", ""compiler"");

  auto st = Stat::stat(tmp_stdout_path, Stat::OnError::log);
  if (!st) {
    // The stdout file was removed - cleanup in progress? Better bail out.
    throw Failure(Statistic::missing_cache_file);
  }

  // distcc-pump outputs lines like this:
  // __________Using # distcc servers in pump mode
  if (st.size() != 0 && ctx.guessed_compiler != GuessedCompiler::pump) {
    log(""Compiler produced stdout"");
    throw Failure(Statistic::compiler_produced_stdout);
  }

  // Merge stderr from the preprocessor (if any) and stderr from the real
  // compiler into tmp_stderr.
  if (!ctx.cpp_stderr.empty()) {
    std::string combined_stderr =
      Util::read_file(ctx.cpp_stderr) + Util::read_file(tmp_stderr_path);
    Util::write_file(tmp_stderr_path, combined_stderr);
  }

  if (status != 0) {
    log(""Compiler gave exit status {}"", status);

    // We can output stderr immediately instead of rerunning the compiler.
    Util::send_to_stderr(ctx, Util::read_file(tmp_stderr_path));

    throw Failure(Statistic::compile_failed, status);
  }

  if (ctx.config.depend_mode()) {
    ASSERT(depend_mode_hash);
    auto result_name = result_name_from_depfile(ctx, *depend_mode_hash);
    if (!result_name) {
      throw Failure(Statistic::internal_error);
    }
    ctx.set_result_name(*result_name);
  }

  bool produce_dep_file = ctx.args_info.generating_dependencies
                          && ctx.args_info.output_dep != ""/dev/null"";

  if (produce_dep_file) {
    use_relative_paths_in_depfile(ctx);
  }

  const auto obj_stat = Stat::stat(ctx.args_info.output_obj);
  if (!obj_stat) {
    log(""Compiler didn't produce an object file"");
    throw Failure(Statistic::compiler_produced_no_output);
  }
  if (obj_stat.size() == 0) {
    log(""Compiler produced an empty object file"");
    throw Failure(Statistic::compiler_produced_empty_output);
  }

  const auto stderr_stat = Stat::stat(tmp_stderr_path, Stat::OnError::log);
  if (!stderr_stat) {
    throw Failure(Statistic::internal_error);
  }

  const auto result_file = look_up_cache_file(
    ctx.config.cache_dir(), *ctx.result_name(), Result::k_file_suffix);
  ctx.set_result_path(result_file.path);
  Result::Writer result_writer(ctx, result_file.path);

  if (stderr_stat.size() > 0) {
    result_writer.write(Result::FileType::stderr_output, tmp_stderr_path);
  }
  result_writer.write(Result::FileType::object, ctx.args_info.output_obj);
  if (ctx.args_info.generating_dependencies) {
    result_writer.write(Result::FileType::dependency, ctx.args_info.output_dep);
  }
  if (ctx.args_info.generating_coverage) {
    result_writer.write(Result::FileType::coverage, ctx.args_info.output_cov);
  }
  if (ctx.args_info.generating_stackusage) {
    result_writer.write(Result::FileType::stackusage, ctx.args_info.output_su);
  }
  if (ctx.args_info.generating_diagnostics) {
    result_writer.write(Result::FileType::diagnostic, ctx.args_info.output_dia);
  }
  if (ctx.args_info.seen_split_dwarf && Stat::stat(ctx.args_info.output_dwo)) {
    // Only store .dwo file if it was created by the compiler (GCC and Clang
    // behave differently e.g. for ""-gsplit-dwarf -g1"").
    result_writer.write(Result::FileType::dwarf_object,
                        ctx.args_info.output_dwo);
  }

  auto error = result_writer.finalize();
  if (error) {
    log(""Error: {}"", *error);
  } else {
    log(""Stored in cache: {}"", result_file.path);
  }

  auto new_result_stat = Stat::stat(result_file.path, Stat::OnError::log);
  if (!new_result_stat) {
    throw Failure(Statistic::internal_error);
  }
  ctx.counter_updates.increment(
    Statistic::cache_size_kibibyte,
    Util::size_change_kibibyte(result_file.stat, new_result_stat));
  ctx.counter_updates.increment(Statistic::files_in_cache,
                                result_file.stat ? 0 : 1);

  MTR_END(""file"", ""file_put"");

  // Make sure we have a CACHEDIR.TAG in the cache part of cache_dir. This can
  // be done almost anywhere, but we might as well do it near the end as we save
  // the stat call if we exit early.
  create_cachedir_tag(ctx);

  // Everything OK.
  Util::send_to_stderr(ctx, Util::read_file(tmp_stderr_path));
}

// Find the result name by running the compiler in preprocessor mode and
// hashing the result.
static Digest
get_result_name_from_cpp(Context& ctx, Args& args, Hash& hash)
{
  ctx.time_of_compilation = time(nullptr);

  std::string stderr_path;
  std::string stdout_path;
  int status;
  if (ctx.args_info.direct_i_file) {
    // We are compiling a .i or .ii file - that means we can skip the cpp stage
    // and directly form the correct i_tmpfile.
    stdout_path = ctx.args_info.input_file;
    status = 0;
  } else {
    // Run cpp on the input file to obtain the .i.

    TemporaryFile tmp_stdout(
      fmt::format(""{}/tmp.cpp_stdout"", ctx.config.temporary_dir()));
    stdout_path = tmp_stdout.path;
    ctx.register_pending_tmp_file(stdout_path);

    TemporaryFile tmp_stderr(
      fmt::format(""{}/tmp.cpp_stderr"", ctx.config.temporary_dir()));
    stderr_path = tmp_stderr.path;
    ctx.register_pending_tmp_file(stderr_path);

    size_t args_added = 2;
    args.push_back(""-E"");
    if (ctx.args_info.actual_language == ""hip"") {
      args.push_back(""-o"");
      args.push_back(""-"");
      args_added += 2;
    }
    if (ctx.config.keep_comments_cpp()) {
      args.push_back(""-C"");
      args_added++;
    }
    args.push_back(ctx.args_info.input_file);
    add_prefix(ctx, args, ctx.config.prefix_command_cpp());
    log(""Running preprocessor"");
    MTR_BEGIN(""execute"", ""preprocessor"");
    status =
      do_execute(ctx, args, std::move(tmp_stdout), std::move(tmp_stderr));
    MTR_END(""execute"", ""preprocessor"");
    args.pop_back(args_added);
  }

  if (status != 0) {
    log(""Preprocessor gave exit status {}"", status);
    throw Failure(Statistic::preprocessor_error);
  }

  hash.hash_delimiter(""cpp"");
  bool is_pump = ctx.guessed_compiler == GuessedCompiler::pump;
  if (!process_preprocessed_file(ctx, hash, stdout_path, is_pump)) {
    throw Failure(Statistic::internal_error);
  }

  hash.hash_delimiter(""cppstderr"");
  if (!ctx.args_info.direct_i_file && !hash.hash_file(stderr_path)) {
    // Somebody removed the temporary file?
    log(""Failed to open {}: {}"", stderr_path, strerror(errno));
    throw Failure(Statistic::internal_error);
  }

  if (ctx.args_info.direct_i_file) {
    ctx.i_tmpfile = ctx.args_info.input_file;
  } else {
    // i_tmpfile needs the proper cpp_extension for the compiler to do its
    // thing correctly
    ctx.i_tmpfile =
      fmt::format(""{}.{}"", stdout_path, ctx.config.cpp_extension());
    Util::rename(stdout_path, ctx.i_tmpfile);
    ctx.register_pending_tmp_file(ctx.i_tmpfile);
  }

  if (!ctx.config.run_second_cpp()) {
    // If we are using the CPP trick, we need to remember this stderr data and
    // output it just before the main stderr from the compiler pass.
    ctx.cpp_stderr = stderr_path;
    hash.hash_delimiter(""runsecondcpp"");
    hash.hash(""false"");
  }

  return hash.digest();
}

// Hash mtime or content of a file, or the output of a command, according to
// the CCACHE_COMPILERCHECK setting.
static void
hash_compiler(const Context& ctx,
              Hash& hash,
              const Stat& st,
              const std::string& path,
              bool allow_command)
{
  if (ctx.config.compiler_check() == ""none"") {
    // Do nothing.
  } else if (ctx.config.compiler_check() == ""mtime"") {
    hash.hash_delimiter(""cc_mtime"");
    hash.hash(st.size());
    hash.hash(st.mtime());
  } else if (Util::starts_with(ctx.config.compiler_check(), ""string:"")) {
    hash.hash_delimiter(""cc_hash"");
    hash.hash(&ctx.config.compiler_check()[7]);
  } else if (ctx.config.compiler_check() == ""content"" || !allow_command) {
    hash.hash_delimiter(""cc_content"");
    hash_binary_file(ctx, hash, path);
  } else { // command string
    if (!hash_multicommand_output(
          hash, ctx.config.compiler_check(), ctx.orig_args[0])) {
      log(""Failure running compiler check command: {}"",
          ctx.config.compiler_check());
      throw Failure(Statistic::compiler_check_failed);
    }
  }
}

// Hash the host compiler(s) invoked by nvcc.
//
// If `ccbin_st` and `ccbin` are set, they refer to a directory or compiler set
// with -ccbin/--compiler-bindir. If `ccbin_st` is nullptr or `ccbin` is the
// empty string, the compilers are looked up in PATH instead.
static void
hash_nvcc_host_compiler(const Context& ctx,
                        Hash& hash,
                        const Stat* ccbin_st = nullptr,
                        const std::string& ccbin = {})
{
  // From <http://docs.nvidia.com/cuda/cuda-compiler-driver-nvcc/index.html>:
  //
  //   ""[...] Specify the directory in which the compiler executable resides.
  //   The host compiler executable name can be also specified to ensure that
  //   the correct host compiler is selected.""
  //
  // and
  //
  //   ""On all platforms, the default host compiler executable (gcc and g++ on
  //   Linux, clang and clang++ on Mac OS X, and cl.exe on Windows) found in
  //   the current execution search path will be used"".

  if (ccbin.empty() || !ccbin_st || ccbin_st->is_directory()) {
#if defined(__APPLE__)
    const char* compilers[] = {""clang"", ""clang++""};
#elif defined(_WIN32)
    const char* compilers[] = {""cl.exe""};
#else
    const char* compilers[] = {""gcc"", ""g++""};
#endif
    for (const char* compiler : compilers) {
      if (!ccbin.empty()) {
        std::string path = fmt::format(""{}/{}"", ccbin, compiler);
        auto st = Stat::stat(path);
        if (st) {
          hash_compiler(ctx, hash, st, path, false);
        }
      } else {
        std::string path = find_executable(ctx, compiler, CCACHE_NAME);
        if (!path.empty()) {
          auto st = Stat::stat(path, Stat::OnError::log);
          hash_compiler(ctx, hash, st, ccbin, false);
        }
      }
    }
  } else {
    hash_compiler(ctx, hash, *ccbin_st, ccbin, false);
  }
}

static bool
should_rewrite_dependency_target(const ArgsInfo& args_info)
{
  return !args_info.dependency_target_specified && args_info.seen_MD_MMD;
}

// update a hash with information common for the direct and preprocessor modes.
static void
hash_common_info(const Context& ctx,
                 const Args& args,
                 Hash& hash,
                 const ArgsInfo& args_info)
{
  hash.hash(HASH_PREFIX);

  // We have to hash the extension, as a .i file isn't treated the same by the
  // compiler as a .ii file.
  hash.hash_delimiter(""ext"");
  hash.hash(ctx.config.cpp_extension());

#ifdef _WIN32
  const std::string compiler_path = Win32Util::add_exe_suffix(args[0]);
#else
  const std::string compiler_path = args[0];
#endif

  auto st = Stat::stat(compiler_path, Stat::OnError::log);
  if (!st) {
    throw Failure(Statistic::could_not_find_compiler);
  }

  // Hash information about the compiler.
  hash_compiler(ctx, hash, st, compiler_path, true);

  // Also hash the compiler name as some compilers use hard links and behave
  // differently depending on the real name.
  hash.hash_delimiter(""cc_name"");
  hash.hash(Util::base_name(args[0]));

  if (!(ctx.config.sloppiness() & SLOPPY_LOCALE)) {
    // Hash environment variables that may affect localization of compiler
    // warning messages.
    const char* envvars[] = {
      ""LANG"", ""LC_ALL"", ""LC_CTYPE"", ""LC_MESSAGES"", nullptr};
    for (const char** p = envvars; *p; ++p) {
      const char* v = getenv(*p);
      if (v) {
        hash.hash_delimiter(*p);
        hash.hash(v);
      }
    }
  }

  // Possibly hash the current working directory.
  if (args_info.generating_debuginfo && ctx.config.hash_dir()) {
    std::string dir_to_hash = ctx.apparent_cwd;
    for (const auto& map : args_info.debug_prefix_maps) {
      size_t sep_pos = map.find('=');
      if (sep_pos != std::string::npos) {
        std::string old_path = map.substr(0, sep_pos);
        std::string new_path = map.substr(sep_pos + 1);
        log(""Relocating debuginfo from {} to {} (CWD: {})"",
            old_path,
            new_path,
            ctx.apparent_cwd);
        if (Util::starts_with(ctx.apparent_cwd, old_path)) {
          dir_to_hash = new_path + ctx.apparent_cwd.substr(old_path.size());
        }
      }
    }
    log(""Hashing CWD {}"", dir_to_hash);
    hash.hash_delimiter(""cwd"");
    hash.hash(dir_to_hash);
  }

  if ((!should_rewrite_dependency_target(ctx.args_info)
       && ctx.args_info.generating_dependencies)
      || ctx.args_info.seen_split_dwarf) {
    // The output object file name is part of the .d file, so include the path
    // in the hash if generating dependencies.
    //
    // Object files include a link to the corresponding .dwo file based on the
    // target object filename when using -gsplit-dwarf, so hashing the object
    // file path will do it, although just hashing the object file base name
    // would be enough.
    hash.hash_delimiter(""object file"");
    hash.hash(ctx.args_info.output_obj);
  }

  // Possibly hash the coverage data file path.
  if (ctx.args_info.generating_coverage && ctx.args_info.profile_arcs) {
    std::string dir;
    if (!ctx.args_info.profile_path.empty()) {
      dir = ctx.args_info.profile_path;
    } else {
      dir =
        Util::real_path(std::string(Util::dir_name(ctx.args_info.output_obj)));
    }
    string_view stem =
      Util::remove_extension(Util::base_name(ctx.args_info.output_obj));
    std::string gcda_path = fmt::format(""{}/{}.gcda"", dir, stem);
    log(""Hashing coverage path {}"", gcda_path);
    hash.hash_delimiter(""gcda"");
    hash.hash(gcda_path);
  }

  // Possibly hash the sanitize blacklist file path.
  for (const auto& sanitize_blacklist : args_info.sanitize_blacklists) {
    log(""Hashing sanitize blacklist {}"", sanitize_blacklist);
    hash.hash(""sanitizeblacklist"");
    if (!hash_binary_file(ctx, hash, sanitize_blacklist)) {
      throw Failure(Statistic::error_hashing_extra_file);
    }
  }

  if (!ctx.config.extra_files_to_hash().empty()) {
    for (const std::string& path : Util::split_into_strings(
           ctx.config.extra_files_to_hash(), PATH_DELIM)) {
      log(""Hashing extra file {}"", path);
      hash.hash_delimiter(""extrafile"");
      if (!hash_binary_file(ctx, hash, path)) {
        throw Failure(Statistic::error_hashing_extra_file);
      }
    }
  }

  // Possibly hash GCC_COLORS (for color diagnostics).
  if (ctx.guessed_compiler == GuessedCompiler::gcc) {
    const char* gcc_colors = getenv(""GCC_COLORS"");
    if (gcc_colors) {
      hash.hash_delimiter(""gcccolors"");
      hash.hash(gcc_colors);
    }
  }
}

static bool
hash_profile_data_file(const Context& ctx, Hash& hash)
{
  const std::string& profile_path = ctx.args_info.profile_path;
  string_view base_name = Util::remove_extension(ctx.args_info.output_obj);
  std::string hashified_cwd = ctx.apparent_cwd;
  std::replace(hashified_cwd.begin(), hashified_cwd.end(), '/', '#');

  std::vector<std::string> paths_to_try{
    // -fprofile-use[=dir]/-fbranch-probabilities (GCC <9)
    fmt::format(""{}/{}.gcda"", profile_path, base_name),
    // -fprofile-use[=dir]/-fbranch-probabilities (GCC >=9)
    fmt::format(""{}/{}#{}.gcda"", profile_path, hashified_cwd, base_name),
    // -fprofile(-instr|-sample)-use=file (Clang), -fauto-profile=file (GCC >=5)
    profile_path,
    // -fprofile(-instr|-sample)-use=dir (Clang)
    fmt::format(""{}/default.profdata"", profile_path),
    // -fauto-profile (GCC >=5)
    ""fbdata.afdo"", // -fprofile-dir is not used
  };

  bool found = false;
  for (const std::string& p : paths_to_try) {
    log(""Checking for profile data file {}"", p);
    auto st = Stat::stat(p);
    if (st && !st.is_directory()) {
      log(""Adding profile data {} to the hash"", p);
      hash.hash_delimiter(""-fprofile-use"");
      if (hash_binary_file(ctx, hash, p)) {
        found = true;
      }
    }
  }

  return found;
}

static bool
option_should_be_ignored(const std::string& arg,
                         const std::vector<std::string>& patterns)
{
  return std::any_of(
    patterns.cbegin(), patterns.cend(), [&arg](const std::string& pattern) {
      const auto& prefix = string_view(pattern).substr(0, pattern.length() - 1);
      return (
        pattern == arg
        || (Util::ends_with(pattern, ""*"") && Util::starts_with(arg, prefix)));
    });
}

// Update a hash sum with information specific to the direct and preprocessor
// modes and calculate the result name. Returns the result name on success,
// otherwise nullopt.
static optional<Digest>
calculate_result_name(Context& ctx,
                      const Args& args,
                      Args& preprocessor_args,
                      Hash& hash,
                      bool direct_mode)
{
  bool found_ccbin = false;

  hash.hash_delimiter(""result version"");
  hash.hash(Result::k_version);

  if (direct_mode) {
    hash.hash_delimiter(""manifest version"");
    hash.hash(Manifest::k_version);
  }

  // clang will emit warnings for unused linker flags, so we shouldn't skip
  // those arguments.
  int is_clang = ctx.guessed_compiler == GuessedCompiler::clang
                 || ctx.guessed_compiler == GuessedCompiler::unknown;

  // First the arguments.
  for (size_t i = 1; i < args.size(); i++) {
    // Trust the user if they've said we should not hash a given option.
    if (option_should_be_ignored(args[i], ctx.ignore_options())) {
      log(""Not hashing ignored option: {}"", args[i]);
      if (i + 1 < args.size() && compopt_takes_arg(args[i])) {
        i++;
        log(""Not hashing argument of ignored option: {}"", args[i]);
      }
      continue;
    }

    // -L doesn't affect compilation (except for clang).
    if (i < args.size() - 1 && args[i] == ""-L"" && !is_clang) {
      i++;
      continue;
    }
    if (Util::starts_with(args[i], ""-L"") && !is_clang) {
      continue;
    }

    // -Wl,... doesn't affect compilation (except for clang).
    if (Util::starts_with(args[i], ""-Wl,"") && !is_clang) {
      continue;
    }

    // The -fdebug-prefix-map option may be used in combination with
    // CCACHE_BASEDIR to reuse results across different directories. Skip using
    // the value of the option from hashing but still hash the existence of the
    // option.
    if (Util::starts_with(args[i], ""-fdebug-prefix-map="")) {
      hash.hash_delimiter(""arg"");
      hash.hash(""-fdebug-prefix-map="");
      continue;
    }
    if (Util::starts_with(args[i], ""-ffile-prefix-map="")) {
      hash.hash_delimiter(""arg"");
      hash.hash(""-ffile-prefix-map="");
      continue;
    }
    if (Util::starts_with(args[i], ""-fmacro-prefix-map="")) {
      hash.hash_delimiter(""arg"");
      hash.hash(""-fmacro-prefix-map="");
      continue;
    }

    // When using the preprocessor, some arguments don't contribute to the
    // hash. The theory is that these arguments will change the output of -E if
    // they are going to have any effect at all. For precompiled headers this
    // might not be the case.
    if (!direct_mode && !ctx.args_info.output_is_precompiled_header
        && !ctx.args_info.using_precompiled_header) {
      if (compopt_affects_cpp(args[i])) {
        if (compopt_takes_arg(args[i])) {
          i++;
        }
        continue;
      }
      if (compopt_short(compopt_affects_cpp, args[i])) {
        continue;
      }
    }

    // If we're generating dependencies, we make sure to skip the filename of
    // the dependency file, since it doesn't impact the output.
    if (ctx.args_info.generating_dependencies) {
      if (Util::starts_with(args[i], ""-Wp,"")) {
        if (Util::starts_with(args[i], ""-Wp,-MD,"")
            && args[i].find(',', 8) == std::string::npos) {
          hash.hash(args[i].data(), 8);
          continue;
        } else if (Util::starts_with(args[i], ""-Wp,-MMD,"")
                   && args[i].find(',', 9) == std::string::npos) {
          hash.hash(args[i].data(), 9);
          continue;
        }
      } else if (Util::starts_with(args[i], ""-MF"")) {
        // In either case, hash the ""-MF"" part.
        hash.hash_delimiter(""arg"");
        hash.hash(args[i].data(), 3);

        if (ctx.args_info.output_dep != ""/dev/null"") {
          bool separate_argument = (args[i].size() == 3);
          if (separate_argument) {
            // Next argument is dependency name, so skip it.
            i++;
          }
        }
        continue;
      }
    }

    if (Util::starts_with(args[i], ""-specs="")
        || Util::starts_with(args[i], ""--specs="")) {
      std::string path = args[i].substr(args[i].find('=') + 1);
      auto st = Stat::stat(path, Stat::OnError::log);
      if (st) {
        // If given an explicit specs file, then hash that file, but don't
        // include the path to it in the hash.
        hash.hash_delimiter(""specs"");
        hash_compiler(ctx, hash, st, path, false);
        continue;
      }
    }

    if (Util::starts_with(args[i], ""-fplugin="")) {
      auto st = Stat::stat(&args[i][9], Stat::OnError::log);
      if (st) {
        hash.hash_delimiter(""plugin"");
        hash_compiler(ctx, hash, st, &args[i][9], false);
        continue;
      }
    }

    if (args[i] == ""-Xclang"" && i + 3 < args.size() && args[i + 1] == ""-load""
        && args[i + 2] == ""-Xclang"") {
      auto st = Stat::stat(args[i + 3], Stat::OnError::log);
      if (st) {
        hash.hash_delimiter(""plugin"");
        hash_compiler(ctx, hash, st, args[i + 3], false);
        i += 3;
        continue;
      }
    }

    if ((args[i] == ""-ccbin"" || args[i] == ""--compiler-bindir"")
        && i + 1 < args.size()) {
      auto st = Stat::stat(args[i + 1]);
      if (st) {
        found_ccbin = true;
        hash.hash_delimiter(""ccbin"");
        hash_nvcc_host_compiler(ctx, hash, &st, args[i + 1]);
        i++;
        continue;
      }
    }

    // All other arguments are included in the hash.
    hash.hash_delimiter(""arg"");
    hash.hash(args[i]);
    if (i + 1 < args.size() && compopt_takes_arg(args[i])) {
      i++;
      hash.hash_delimiter(""arg"");
      hash.hash(args[i]);
    }
  }

  // Make results with dependency file /dev/null different from those without
  // it.
  if (ctx.args_info.generating_dependencies
      && ctx.args_info.output_dep == ""/dev/null"") {
    hash.hash_delimiter(""/dev/null dependency file"");
  }

  if (!found_ccbin && ctx.args_info.actual_language == ""cu"") {
    hash_nvcc_host_compiler(ctx, hash);
  }

  // For profile generation (-fprofile(-instr)-generate[=path])
  // - hash profile path
  //
  // For profile usage (-fprofile(-instr|-sample)-use, -fbranch-probabilities):
  // - hash profile data
  //
  // -fbranch-probabilities and -fvpt usage is covered by
  // -fprofile-generate/-fprofile-use.
  //
  // The profile directory can be specified as an argument to
  // -fprofile(-instr)-generate=, -fprofile(-instr|-sample)-use= or
  // -fprofile-dir=.

  if (ctx.args_info.profile_generate) {
    ASSERT(!ctx.args_info.profile_path.empty());
    log(""Adding profile directory {} to our hash"", ctx.args_info.profile_path);
    hash.hash_delimiter(""-fprofile-dir"");
    hash.hash(ctx.args_info.profile_path);
  }

  if (ctx.args_info.profile_use && !hash_profile_data_file(ctx, hash)) {
    log(""No profile data file found"");
    throw Failure(Statistic::no_input_file);
  }

  // Adding -arch to hash since cpp output is affected.
  for (const auto& arch : ctx.args_info.arch_args) {
    hash.hash_delimiter(""-arch"");
    hash.hash(arch);
  }

  optional<Digest> result_name;
  if (direct_mode) {
    // Hash environment variables that affect the preprocessor output.
    const char* envvars[] = {""CPATH"",
                             ""C_INCLUDE_PATH"",
                             ""CPLUS_INCLUDE_PATH"",
                             ""OBJC_INCLUDE_PATH"",
                             ""OBJCPLUS_INCLUDE_PATH"", // clang
                             nullptr};
    for (const char** p = envvars; *p; ++p) {
      const char* v = getenv(*p);
      if (v) {
        hash.hash_delimiter(*p);
        hash.hash(v);
      }
    }

    // Make sure that the direct mode hash is unique for the input file path.
    // If this would not be the case:
    //
    // * An false cache hit may be produced. Scenario:
    //   - a/r.h exists.
    //   - a/x.c has #include ""r.h"".
    //   - b/x.c is identical to a/x.c.
    //   - Compiling a/x.c records a/r.h in the manifest.
    //   - Compiling b/x.c results in a false cache hit since a/x.c and b/x.c
    //     share manifests and a/r.h exists.
    // * The expansion of __FILE__ may be incorrect.
    hash.hash_delimiter(""inputfile"");
    hash.hash(ctx.args_info.input_file);

    hash.hash_delimiter(""sourcecode"");
    int result = hash_source_code_file(ctx, hash, ctx.args_info.input_file);
    if (result & HASH_SOURCE_CODE_ERROR) {
      throw Failure(Statistic::internal_error);
    }
    if (result & HASH_SOURCE_CODE_FOUND_TIME) {
      log(""Disabling direct mode"");
      ctx.config.set_direct_mode(false);
      return nullopt;
    }

    const auto manifest_name = hash.digest();
    ctx.set_manifest_name(manifest_name);

    const auto manifest_file = look_up_cache_file(
      ctx.config.cache_dir(), manifest_name, Manifest::k_file_suffix);
    ctx.set_manifest_path(manifest_file.path);

    if (manifest_file.stat) {
      log(""Looking for result name in {}"", manifest_file.path);
      MTR_BEGIN(""manifest"", ""manifest_get"");
      result_name = Manifest::get(ctx, manifest_file.path);
      MTR_END(""manifest"", ""manifest_get"");
      if (result_name) {
        log(""Got result name from manifest"");
      } else {
        log(""Did not find result name in manifest"");
      }
    } else {
      log(""No manifest with name {} in the cache"", manifest_name.to_string());
    }
  } else {
    if (ctx.args_info.arch_args.empty()) {
      result_name = get_result_name_from_cpp(ctx, preprocessor_args, hash);
      log(""Got result name from preprocessor"");
    } else {
      preprocessor_args.push_back(""-arch"");
      for (size_t i = 0; i < ctx.args_info.arch_args.size(); ++i) {
        preprocessor_args.push_back(ctx.args_info.arch_args[i]);
        result_name = get_result_name_from_cpp(ctx, preprocessor_args, hash);
        log(""Got result name from preprocessor with -arch {}"",
            ctx.args_info.arch_args[i]);
        if (i != ctx.args_info.arch_args.size() - 1) {
          result_name = nullopt;
        }
        preprocessor_args.pop_back();
      }
      preprocessor_args.pop_back();
    }
  }

  return result_name;
}

enum class FromCacheCallMode { direct, cpp };

// Try to return the compile result from cache.
static optional<Statistic>
from_cache(Context& ctx, FromCacheCallMode mode)
{
  UmaskScope umask_scope(ctx.original_umask);

  // The user might be disabling cache hits.
  if (ctx.config.recache()) {
    return nullopt;
  }

  // If we're using Clang, we can't trust a precompiled header object based on
  // running the preprocessor since clang will produce a fatal error when the
  // precompiled header is used and one of the included files has an updated
  // timestamp:
  //
  //     file 'foo.h' has been modified since the precompiled header 'foo.pch'
  //     was built
  if ((ctx.guessed_compiler == GuessedCompiler::clang
       || ctx.guessed_compiler == GuessedCompiler::unknown)
      && ctx.args_info.output_is_precompiled_header
      && !ctx.args_info.fno_pch_timestamp && mode == FromCacheCallMode::cpp) {
    log(""Not considering cached precompiled header in preprocessor mode"");
    return nullopt;
  }

  MTR_BEGIN(""cache"", ""from_cache"");

  // Get result from cache.
  const auto result_file = look_up_cache_file(
    ctx.config.cache_dir(), *ctx.result_name(), Result::k_file_suffix);
  if (!result_file.stat) {
    log(""No result with name {} in the cache"", ctx.result_name()->to_string());
    return nullopt;
  }
  ctx.set_result_path(result_file.path);
  Result::Reader result_reader(result_file.path);
  ResultRetriever result_retriever(
    ctx, should_rewrite_dependency_target(ctx.args_info));

  auto error = result_reader.read(result_retriever);
  MTR_END(""cache"", ""from_cache"");
  if (error) {
    log(""Failed to get result from cache: {}"", *error);
    return nullopt;
  }

  // Update modification timestamp to save file from LRU cleanup.
  Util::update_mtime(*ctx.result_path());

  log(""Succeeded getting cached result"");

  return mode == FromCacheCallMode::direct ? Statistic::direct_cache_hit
                                           : Statistic::preprocessed_cache_hit;
}

// Find the real compiler and put it into ctx.orig_args[0]. We just search the
// PATH to find an executable of the same name that isn't a link to ourselves.
// Pass find_executable function as second parameter.
void
find_compiler(Context& ctx,
              const FindExecutableFunction& find_executable_function)
{
  const std::string orig_first_arg = ctx.orig_args[0];

  // We might be being invoked like ""ccache gcc -c foo.c"".
  std::string base(Util::base_name(ctx.orig_args[0]));
  if (Util::same_program_name(base, CCACHE_NAME)) {
    ctx.orig_args.pop_front();
    if (Util::is_full_path(ctx.orig_args[0])) {
      return;
    }
    base = std::string(Util::base_name(ctx.orig_args[0]));
  }

  // Support user override of the compiler.
  if (!ctx.config.compiler().empty()) {
    base = ctx.config.compiler();
  }

  std::string compiler = find_executable_function(ctx, base, CCACHE_NAME);
  if (compiler.empty()) {
    throw Fatal(""Could not find compiler \""{}\"" in PATH"", base);
  }
  if (compiler == orig_first_arg) {
    throw Fatal(
      ""Recursive invocation (the name of the ccache binary must be \""{}\"")"",
      CCACHE_NAME);
  }
  ctx.orig_args[0] = compiler;
}

static std::string
default_cache_dir(const std::string& home_dir)
{
#ifdef _WIN32
  return home_dir + ""/ccache"";
#elif defined(__APPLE__)
  return home_dir + ""/Library/Caches/ccache"";
#else
  return home_dir + ""/.cache/ccache"";
#endif
}

static std::string
default_config_dir(const std::string& home_dir)
{
#ifdef _WIN32
  return home_dir + ""/ccache"";
#elif defined(__APPLE__)
  return home_dir + ""/Library/Preferences/ccache"";
#else
  return home_dir + ""/.config/ccache"";
#endif
}

// Read config file(s), populate variables, create configuration file in cache
// directory if missing, etc.
static void
set_up_config(Config& config)
{
  const std::string home_dir = Util::get_home_directory();
  const std::string legacy_ccache_dir = home_dir + ""/.ccache"";
  const bool legacy_ccache_dir_exists =
    Stat::stat(legacy_ccache_dir).is_directory();
  const char* const env_xdg_cache_home = getenv(""XDG_CACHE_HOME"");
  const char* const env_xdg_config_home = getenv(""XDG_CONFIG_HOME"");

  const char* env_ccache_configpath = getenv(""CCACHE_CONFIGPATH"");
  if (env_ccache_configpath) {
    config.set_primary_config_path(env_ccache_configpath);
  } else {
    // Only used for ccache tests:
    const char* const env_ccache_configpath2 = getenv(""CCACHE_CONFIGPATH2"");

    config.set_secondary_config_path(
      env_ccache_configpath2 ? env_ccache_configpath2
                             : fmt::format(""{}/ccache.conf"", SYSCONFDIR));
    MTR_BEGIN(""config"", ""conf_read_secondary"");
    // A missing config file in SYSCONFDIR is OK so don't check return value.
    config.update_from_file(config.secondary_config_path());
    MTR_END(""config"", ""conf_read_secondary"");

    const char* const env_ccache_dir = getenv(""CCACHE_DIR"");
    std::string primary_config_dir;
    if (env_ccache_dir && *env_ccache_dir) {
      primary_config_dir = env_ccache_dir;
    } else if (!config.cache_dir().empty() && !env_ccache_dir) {
      primary_config_dir = config.cache_dir();
    } else if (legacy_ccache_dir_exists) {
      primary_config_dir = legacy_ccache_dir;
    } else if (env_xdg_config_home) {
      primary_config_dir = fmt::format(""{}/ccache"", env_xdg_config_home);
    } else {
      primary_config_dir = default_config_dir(home_dir);
    }
    config.set_primary_config_path(primary_config_dir + ""/ccache.conf"");
  }

  const std::string& cache_dir_before_primary_config = config.cache_dir();

  MTR_BEGIN(""config"", ""conf_read_primary"");
  config.update_from_file(config.primary_config_path());
  MTR_END(""config"", ""conf_read_primary"");

  // Ignore cache_dir set in primary config.
  config.set_cache_dir(cache_dir_before_primary_config);

  MTR_BEGIN(""config"", ""conf_update_from_environment"");
  config.update_from_environment();
  // (config.cache_dir is set above if CCACHE_DIR is set.)
  MTR_END(""config"", ""conf_update_from_environment"");

  if (config.cache_dir().empty()) {
    if (legacy_ccache_dir_exists) {
      config.set_cache_dir(legacy_ccache_dir);
    } else if (env_xdg_cache_home) {
      config.set_cache_dir(fmt::format(""{}/ccache"", env_xdg_cache_home));
    } else {
      config.set_cache_dir(default_cache_dir(home_dir));
    }
  }
  // else: cache_dir was set explicitly via environment or via secondary config.

  // We have now determined config.cache_dir and populated the rest of config in
  // prio order (1. environment, 2. primary config, 3. secondary config).
}

static void
set_up_context(Context& ctx, int argc, const char* const* argv)
{
  ctx.orig_args = Args::from_argv(argc, argv);
  ctx.ignore_header_paths = Util::split_into_strings(
    ctx.config.ignore_headers_in_manifest(), PATH_DELIM);
  ctx.set_ignore_options(
    Util::split_into_strings(ctx.config.ignore_options(), "" ""));
}

// Initialize ccache, must be called once before anything else is run.
static void
initialize(Context& ctx, int argc, const char* const* argv)
{
  set_up_config(ctx.config);
  set_up_context(ctx, argc, argv);
  Logging::init(ctx.config);

  // Set default umask for all files created by ccache from now on (if
  // configured to). This is intentionally done after calling init_log so that
  // the log file won't be affected by the umask but before creating the initial
  // configuration file. The intention is that all files and directories in the
  // cache directory should be affected by the configured umask and that no
  // other files and directories should.
  if (ctx.config.umask() != std::numeric_limits<uint32_t>::max()) {
    ctx.original_umask = umask(ctx.config.umask());
  }

  log(""=== CCACHE {} STARTED ========================================="",
      CCACHE_VERSION);

  if (getenv(""CCACHE_INTERNAL_TRACE"")) {
#ifdef MTR_ENABLED
    ctx.mini_trace = std::make_unique<MiniTrace>(ctx.args_info);
#else
    log(""Error: tracing is not enabled!"");
#endif
  }
}

// Make a copy of stderr that will not be cached, so things like distcc can
// send networking errors to it.
static void
set_up_uncached_err()
{
  int uncached_fd =
    dup(STDERR_FILENO); // The file descriptor is intentionally leaked.
  if (uncached_fd == -1) {
    log(""dup(2) failed: {}"", strerror(errno));
    throw Failure(Statistic::internal_error);
  }

  Util::setenv(""UNCACHED_ERR_FD"", fmt::format(""{}"", uncached_fd));
}

static void
configuration_logger(const std::string& key,
                     const std::string& value,
                     const std::string& origin)
{
  Logging::bulk_log(""Config: ({}) {} = {}"", origin, key, value);
}

static void
configuration_printer(const std::string& key,
                      const std::string& value,
                      const std::string& origin)
{
  fmt::print(""({}) {} = {}\n"", origin, key, value);
}

static int cache_compilation(int argc, const char* const* argv);
static Statistic do_cache_compilation(Context& ctx, const char* const* argv);

static uint8_t
calculate_wanted_cache_level(uint64_t files_in_level_1)
{
  uint64_t files_per_directory = files_in_level_1 / 16;
  for (uint8_t i = k_min_cache_levels; i <= k_max_cache_levels; ++i) {
    if (files_per_directory < k_max_cache_files_per_directory) {
      return i;
    }
    files_per_directory /= 16;
  }
  return k_max_cache_levels;
}

static optional<Counters>
update_stats_and_maybe_move_cache_file(const Context& ctx,
                                       const Digest& name,
                                       const std::string& current_path,
                                       const Counters& counter_updates,
                                       const std::string& file_suffix)
{
  if (counter_updates.all_zero()) {
    return nullopt;
  }

  // Use stats file in the level one subdirectory for cache bookkeeping counters
  // since cleanup is performed on level one. Use stats file in the level two
  // subdirectory for other counters to reduce lock contention.
  const bool updated_file_size_or_count =
    counter_updates.get(Statistic::cache_size_kibibyte) != 0
    || counter_updates.get(Statistic::files_in_cache) != 0;
  std::string level_string = fmt::format(""{:x}"", name.bytes()[0] >> 4);
  if (!updated_file_size_or_count) {
    level_string += fmt::format(""/{:x}"", name.bytes()[0] & 0xF);
  }
  const auto stats_file =
    fmt::format(""{}/{}/stats"", ctx.config.cache_dir(), level_string);

  auto counters =
    Statistics::update(stats_file, [&counter_updates](Counters& cs) {
      cs.increment(counter_updates);
    });
  if (!counters) {
    return nullopt;
  }

  const auto wanted_level =
    calculate_wanted_cache_level(counters->get(Statistic::files_in_cache));
  const auto wanted_path = Util::get_path_in_cache(
    ctx.config.cache_dir(), wanted_level, name.to_string() + file_suffix);
  if (current_path != wanted_path) {
    Util::ensure_dir_exists(Util::dir_name(wanted_path));
    log(""Moving {} to {}"", current_path, wanted_path);
    try {
      Util::rename(current_path, wanted_path);
    } catch (const Error&) {
      // Two ccache processes may move the file at the same time, so failure to
      // rename is OK.
    }
  }
  return counters;
}

static void
finalize_stats_and_trigger_cleanup(Context& ctx)
{
  const auto& config = ctx.config;

  if (config.disable()) {
    // Just log result, don't update statistics.
    log(""Result: disabled"");
    return;
  }

  if (!config.log_file().empty() || config.debug()) {
    const auto result = Statistics::get_result(ctx.counter_updates);
    if (result) {
      log(""Result: {}"", *result);
    }
  }

  if (!config.stats()) {
    return;
  }

  if (!ctx.result_path()) {
    ASSERT(ctx.counter_updates.get(Statistic::cache_size_kibibyte) == 0);
    ASSERT(ctx.counter_updates.get(Statistic::files_in_cache) == 0);

    // Context::set_result_path hasn't been called yet, so we just choose one of
    // the stats files in the 256 level 2 directories.
    const auto bucket = getpid() % 256;
    const auto stats_file = fmt::format(
      ""{}/{:x}/{:x}/stats"", config.cache_dir(), bucket / 16, bucket % 16);
    Statistics::update(
      stats_file, [&ctx](Counters& cs) { cs.increment(ctx.counter_updates); });
    return;
  }

  if (ctx.manifest_path()) {
    update_stats_and_maybe_move_cache_file(ctx,
                                           *ctx.manifest_name(),
                                           *ctx.manifest_path(),
                                           ctx.manifest_counter_updates,
                                           Manifest::k_file_suffix);
  }

  const auto counters =
    update_stats_and_maybe_move_cache_file(ctx,
                                           *ctx.result_name(),
                                           *ctx.result_path(),
                                           ctx.counter_updates,
                                           Result::k_file_suffix);
  if (!counters) {
    return;
  }

  const auto subdir = fmt::format(
    ""{}/{:x}"", config.cache_dir(), ctx.result_name()->bytes()[0] >> 4);
  bool need_cleanup = false;

  if (config.max_files() != 0
      && counters->get(Statistic::files_in_cache) > config.max_files() / 16) {
    log(""Need to clean up {} since it holds {} files (limit: {} files)"",
        subdir,
        counters->get(Statistic::files_in_cache),
        config.max_files() / 16);
    need_cleanup = true;
  }
  if (config.max_size() != 0
      && counters->get(Statistic::cache_size_kibibyte)
           > config.max_size() / 1024 / 16) {
    log(""Need to clean up {} since it holds {} KiB (limit: {} KiB)"",
        subdir,
        counters->get(Statistic::cache_size_kibibyte),
        config.max_size() / 1024 / 16);
    need_cleanup = true;
  }

  if (need_cleanup) {
    const double factor = config.limit_multiple() / 16;
    const uint64_t max_size = round(config.max_size() * factor);
    const uint32_t max_files = round(config.max_files() * factor);
    const time_t max_age = 0;
    clean_up_dir(
      subdir, max_size, max_files, max_age, [](double /*progress*/) {});
  }
}

static void
finalize_at_exit(Context& ctx)
{
  try {
    finalize_stats_and_trigger_cleanup(ctx);
  } catch (const ErrorBase& e) {
    // finalize_at_exit must not throw since it's called by a destructor.
    log(""Error while finalizing stats: {}"", e.what());
  }

  // Dump log buffer last to not lose any logs.
  if (ctx.config.debug() && !ctx.args_info.output_obj.empty()) {
    const auto path = fmt::format(""{}.ccache-log"", ctx.args_info.output_obj);
    Logging::dump_log(path);
  }
}

// The entry point when invoked to cache a compilation.
static int
cache_compilation(int argc, const char* const* argv)
{
  tzset(); // Needed for localtime_r.

  bool fall_back_to_original_compiler = false;
  Args saved_orig_args;

  {
    Context ctx;
    SignalHandler signal_handler(ctx);
    Finalizer finalizer([&ctx] { finalize_at_exit(ctx); });

    initialize(ctx, argc, argv);

    MTR_BEGIN(""main"", ""find_compiler"");
    find_compiler(ctx, &find_executable);
    MTR_END(""main"", ""find_compiler"");

    try {
      Statistic statistic = do_cache_compilation(ctx, argv);
      ctx.counter_updates.increment(statistic);
    } catch (const Failure& e) {
      if (e.statistic() != Statistic::none) {
        ctx.counter_updates.increment(e.statistic());
      }

      if (e.exit_code()) {
        return *e.exit_code();
      }
      // Else: Fall back to running the real compiler.
      fall_back_to_original_compiler = true;

      if (ctx.original_umask) {
        umask(*ctx.original_umask);
      }

      ASSERT(!ctx.orig_args.empty());

      ctx.orig_args.erase_with_prefix(""--ccache-"");
      add_prefix(ctx, ctx.orig_args, ctx.config.prefix_command());

      log(""Failed; falling back to running the real compiler"");

      saved_orig_args = std::move(ctx.orig_args);
      auto execv_argv = saved_orig_args.to_argv();
      log(""Executing {}"", Util::format_argv_for_logging(execv_argv.data()));
      // Run execv below after ctx and finalizer have been destructed.
    }
  }

  if (fall_back_to_original_compiler) {
    auto execv_argv = saved_orig_args.to_argv();
    execv(execv_argv[0], const_cast<char* const*>(execv_argv.data()));
    throw Fatal(""execv of {} failed: {}"", execv_argv[0], strerror(errno));
  }

  return EXIT_SUCCESS;
}

static Statistic
do_cache_compilation(Context& ctx, const char* const* argv)
{
  if (ctx.actual_cwd.empty()) {
    log(""Unable to determine current working directory: {}"", strerror(errno));
    throw Failure(Statistic::internal_error);
  }

  MTR_BEGIN(""main"", ""clean_up_internal_tempdir"");
  if (ctx.config.temporary_dir() == ctx.config.cache_dir() + ""/tmp"") {
    clean_up_internal_tempdir(ctx.config);
  }
  MTR_END(""main"", ""clean_up_internal_tempdir"");

  if (!ctx.config.log_file().empty() || ctx.config.debug()) {
    ctx.config.visit_items(configuration_logger);
  }

  if (ctx.config.disable()) {
    log(""ccache is disabled"");
    // Statistic::cache_miss is a dummy to trigger stats_flush.
    throw Failure(Statistic::cache_miss);
  }

  MTR_BEGIN(""main"", ""set_up_uncached_err"");
  set_up_uncached_err();
  MTR_END(""main"", ""set_up_uncached_err"");

  log(""Command line: {}"", Util::format_argv_for_logging(argv));
  log(""Hostname: {}"", Util::get_hostname());
  log(""Working directory: {}"", ctx.actual_cwd);
  if (ctx.apparent_cwd != ctx.actual_cwd) {
    log(""Apparent working directory: {}"", ctx.apparent_cwd);
  }

  ctx.config.set_limit_multiple(
    Util::clamp(ctx.config.limit_multiple(), 0.0, 1.0));

  MTR_BEGIN(""main"", ""guess_compiler"");
  ctx.guessed_compiler = guess_compiler(ctx.orig_args[0]);
  MTR_END(""main"", ""guess_compiler"");

  MTR_BEGIN(""main"", ""process_args"");
  ProcessArgsResult processed = process_args(ctx);
  MTR_END(""main"", ""process_args"");

  if (processed.error) {
    throw Failure(*processed.error);
  }

  if (ctx.config.depend_mode()
      && (!ctx.args_info.generating_dependencies
          || ctx.args_info.output_dep == ""/dev/null""
          || !ctx.config.run_second_cpp())) {
    log(""Disabling depend mode"");
    ctx.config.set_depend_mode(false);
  }

  log(""Source file: {}"", ctx.args_info.input_file);
  if (ctx.args_info.generating_dependencies) {
    log(""Dependency file: {}"", ctx.args_info.output_dep);
  }
  if (ctx.args_info.generating_coverage) {
    log(""Coverage file: {}"", ctx.args_info.output_cov);
  }
  if (ctx.args_info.generating_stackusage) {
    log(""Stack usage file: {}"", ctx.args_info.output_su);
  }
  if (ctx.args_info.generating_diagnostics) {
    log(""Diagnostics file: {}"", ctx.args_info.output_dia);
  }
  if (!ctx.args_info.output_dwo.empty()) {
    log(""Split dwarf file: {}"", ctx.args_info.output_dwo);
  }

  log(""Object file: {}"", ctx.args_info.output_obj);
  MTR_META_THREAD_NAME(ctx.args_info.output_obj.c_str());

  if (ctx.config.debug()) {
    std::string path =
      fmt::format(""{}.ccache-input-text"", ctx.args_info.output_obj);
    File debug_text_file(path, ""w"");
    if (debug_text_file) {
      ctx.hash_debug_files.push_back(std::move(debug_text_file));
    } else {
      log(""Failed to open {}: {}"", path, strerror(errno));
    }
  }

  FILE* debug_text_file = !ctx.hash_debug_files.empty()
                            ? ctx.hash_debug_files.front().get()
                            : nullptr;

  Hash common_hash;
  init_hash_debug(
    ctx, common_hash, ctx.args_info.output_obj, 'c', ""COMMON"", debug_text_file);

  MTR_BEGIN(""hash"", ""common_hash"");
  hash_common_info(
    ctx, processed.preprocessor_args, common_hash, ctx.args_info);
  MTR_END(""hash"", ""common_hash"");

  // Try to find the hash using the manifest.
  Hash direct_hash = common_hash;
  init_hash_debug(ctx,
                  direct_hash,
                  ctx.args_info.output_obj,
                  'd',
                  ""DIRECT MODE"",
                  debug_text_file);

  Args args_to_hash = processed.preprocessor_args;
  args_to_hash.push_back(processed.extra_args_to_hash);

  bool put_result_in_manifest = false;
  optional<Digest> result_name;
  optional<Digest> result_name_from_manifest;
  if (ctx.config.direct_mode()) {
    log(""Trying direct lookup"");
    MTR_BEGIN(""hash"", ""direct_hash"");
    Args dummy_args;
    result_name =
      calculate_result_name(ctx, args_to_hash, dummy_args, direct_hash, true);
    MTR_END(""hash"", ""direct_hash"");
    if (result_name) {
      ctx.set_result_name(*result_name);

      // If we can return from cache at this point then do so.
      auto result = from_cache(ctx, FromCacheCallMode::direct);
      if (result) {
        return *result;
      }

      // Wasn't able to return from cache at this point. However, the result
      // was already found in manifest, so don't re-add it later.
      put_result_in_manifest = false;

      result_name_from_manifest = result_name;
    } else {
      // Add result to manifest later.
      put_result_in_manifest = true;
    }
  }

  if (ctx.config.read_only_direct()) {
    log(""Read-only direct mode; running real compiler"");
    throw Failure(Statistic::cache_miss);
  }

  if (!ctx.config.depend_mode()) {
    // Find the hash using the preprocessed output. Also updates
    // ctx.included_files.
    Hash cpp_hash = common_hash;
    init_hash_debug(ctx,
                    cpp_hash,
                    ctx.args_info.output_obj,
                    'p',
                    ""PREPROCESSOR MODE"",
                    debug_text_file);

    MTR_BEGIN(""hash"", ""cpp_hash"");
    result_name = calculate_result_name(
      ctx, args_to_hash, processed.preprocessor_args, cpp_hash, false);
    MTR_END(""hash"", ""cpp_hash"");

    // calculate_result_name does not return nullopt if the last (direct_mode)
    // argument is false.
    ASSERT(result_name);
    ctx.set_result_name(*result_name);

    if (result_name_from_manifest && result_name_from_manifest != result_name) {
      // manifest_path is guaranteed to be set when calculate_result_name
      // returns a non-nullopt result in direct mode, i.e. when
      // result_name_from_manifest is set.
      ASSERT(ctx.manifest_path());

      // The hash from manifest differs from the hash of the preprocessor
      // output. This could be because:
      //
      // - The preprocessor produces different output for the same input (not
      //   likely).
      // - There's a bug in ccache (maybe incorrect handling of compiler
      //   arguments).
      // - The user has used a different CCACHE_BASEDIR (most likely).
      //
      // The best thing here would probably be to remove the hash entry from
      // the manifest. For now, we use a simpler method: just remove the
      // manifest file.
      log(""Hash from manifest doesn't match preprocessor output"");
      log(""Likely reason: different CCACHE_BASEDIRs used"");
      log(""Removing manifest as a safety measure"");
      Util::unlink_safe(*ctx.manifest_path());

      put_result_in_manifest = true;
    }

    // If we can return from cache at this point then do.
    auto result = from_cache(ctx, FromCacheCallMode::cpp);
    if (result) {
      if (put_result_in_manifest) {
        update_manifest_file(ctx);
      }
      return *result;
    }
  }

  if (ctx.config.read_only()) {
    log(""Read-only mode; running real compiler"");
    throw Failure(Statistic::cache_miss);
  }

  add_prefix(ctx, processed.compiler_args, ctx.config.prefix_command());

  // In depend_mode, extend the direct hash.
  Hash* depend_mode_hash = ctx.config.depend_mode() ? &direct_hash : nullptr;

  // Run real compiler, sending output to cache.
  MTR_BEGIN(""cache"", ""to_cache"");
  to_cache(ctx,
           processed.compiler_args,
           ctx.args_info.depend_extra_args,
           depend_mode_hash);
  update_manifest_file(ctx);
  MTR_END(""cache"", ""to_cache"");

  return Statistic::cache_miss;
}

// The main program when not doing a compile.
static int
handle_main_options(int argc, const char* const* argv)
{
  enum longopts {
    CHECKSUM_FILE,
    DUMP_MANIFEST,
    DUMP_RESULT,
    EVICT_OLDER_THAN,
    EXTRACT_RESULT,
    HASH_FILE,
    PRINT_STATS,
  };
  static const struct option options[] = {
    {""checksum-file"", required_argument, nullptr, CHECKSUM_FILE},
    {""cleanup"", no_argument, nullptr, 'c'},
    {""clear"", no_argument, nullptr, 'C'},
    {""directory"", no_argument, nullptr, 'd'},
    {""dump-manifest"", required_argument, nullptr, DUMP_MANIFEST},
    {""dump-result"", required_argument, nullptr, DUMP_RESULT},
    {""evict-older-than"", required_argument, nullptr, EVICT_OLDER_THAN},
    {""extract-result"", required_argument, nullptr, EXTRACT_RESULT},
    {""get-config"", required_argument, nullptr, 'k'},
    {""hash-file"", required_argument, nullptr, HASH_FILE},
    {""help"", no_argument, nullptr, 'h'},
    {""max-files"", required_argument, nullptr, 'F'},
    {""max-size"", required_argument, nullptr, 'M'},
    {""print-stats"", no_argument, nullptr, PRINT_STATS},
    {""recompress"", required_argument, nullptr, 'X'},
    {""set-config"", required_argument, nullptr, 'o'},
    {""show-compression"", no_argument, nullptr, 'x'},
    {""show-config"", no_argument, nullptr, 'p'},
    {""show-stats"", no_argument, nullptr, 's'},
    {""version"", no_argument, nullptr, 'V'},
    {""zero-stats"", no_argument, nullptr, 'z'},
    {nullptr, 0, nullptr, 0}};

  Context ctx;
  initialize(ctx, argc, argv);

  int c;
  while ((c = getopt_long(argc,
                          const_cast<char* const*>(argv),
                          ""cCd:k:hF:M:po:sVxX:z"",
                          options,
                          nullptr))
         != -1) {
    std::string arg = optarg ? optarg : std::string();

    switch (c) {
    case CHECKSUM_FILE: {
      Checksum checksum;
      Fd fd(arg == ""-"" ? STDIN_FILENO : open(arg.c_str(), O_RDONLY));
      Util::read_fd(*fd, [&checksum](const void* data, size_t size) {
        checksum.update(data, size);
      });
      fmt::print(""{:016x}\n"", checksum.digest());
      break;
    }

    case DUMP_MANIFEST:
      return Manifest::dump(arg, stdout) ? 0 : 1;

    case DUMP_RESULT: {
      ResultDumper result_dumper(stdout);
      Result::Reader result_reader(arg);
      auto error = result_reader.read(result_dumper);
      if (error) {
        fmt::print(stderr, ""Error: {}\n"", *error);
      }
      return error ? EXIT_FAILURE : EXIT_SUCCESS;
    }

    case EVICT_OLDER_THAN: {
      auto seconds = Util::parse_duration(arg);
      ProgressBar progress_bar(""Evicting..."");
      clean_old(
        ctx, [&](double progress) { progress_bar.update(progress); }, seconds);
      if (isatty(STDOUT_FILENO)) {
        fmt::print(""\n"");
      }
      break;
    }

    case EXTRACT_RESULT: {
      ResultExtractor result_extractor(""."");
      Result::Reader result_reader(arg);
      auto error = result_reader.read(result_extractor);
      if (error) {
        fmt::print(stderr, ""Error: {}\n"", *error);
      }
      return error ? EXIT_FAILURE : EXIT_SUCCESS;
    }

    case HASH_FILE: {
      Hash hash;
      if (arg == ""-"") {
        hash.hash_fd(STDIN_FILENO);
      } else {
        hash.hash_file(arg);
      }
      fmt::print(""{}\n"", hash.digest().to_string());
      break;
    }

    case PRINT_STATS:
      fmt::print(Statistics::format_machine_readable(ctx.config));
      break;

    case 'c': // --cleanup
    {
      ProgressBar progress_bar(""Cleaning..."");
      clean_up_all(ctx.config,
                   [&](double progress) { progress_bar.update(progress); });
      if (isatty(STDOUT_FILENO)) {
        fmt::print(""\n"");
      }
      break;
    }

    case 'C': // --clear
    {
      ProgressBar progress_bar(""Clearing..."");
      wipe_all(ctx, [&](double progress) { progress_bar.update(progress); });
      if (isatty(STDOUT_FILENO)) {
        fmt::print(""\n"");
      }
      break;
    }

    case 'd': // --directory
      Util::setenv(""CCACHE_DIR"", arg);
      break;

    case 'h': // --help
      fmt::print(stdout, USAGE_TEXT, CCACHE_NAME, CCACHE_NAME);
      exit(EXIT_SUCCESS);

    case 'k': // --get-config
      fmt::print(""{}\n"", ctx.config.get_string_value(arg));
      break;

    case 'F': { // --max-files
      auto files = Util::parse_unsigned(arg);
      Config::set_value_in_file(
        ctx.config.primary_config_path(), ""max_files"", arg);
      if (files == 0) {
        fmt::print(""Unset cache file limit\n"");
      } else {
        fmt::print(""Set cache file limit to {}\n"", files);
      }
      break;
    }

    case 'M': { // --max-size
      uint64_t size = Util::parse_size(arg);
      Config::set_value_in_file(
        ctx.config.primary_config_path(), ""max_size"", arg);
      if (size == 0) {
        fmt::print(""Unset cache size limit\n"");
      } else {
        fmt::print(""Set cache size limit to {}\n"",
                   Util::format_human_readable_size(size));
      }
      break;
    }

    case 'o': { // --set-config
      // Start searching for equal sign at position 1 to improve error message
      // for the -o=K=V case (key ""=K"" and value ""V"").
      size_t eq_pos = arg.find('=', 1);
      if (eq_pos == std::string::npos) {
        throw Error(""missing equal sign in \""{}\"""", arg);
      }
      std::string key = arg.substr(0, eq_pos);
      std::string value = arg.substr(eq_pos + 1);
      Config::set_value_in_file(ctx.config.primary_config_path(), key, value);
      break;
    }

    case 'p': // --show-config
      ctx.config.visit_items(configuration_printer);
      break;

    case 's': // --show-stats
      fmt::print(Statistics::format_human_readable(ctx.config));
      break;

    case 'V': // --version
      fmt::print(VERSION_TEXT, CCACHE_NAME, CCACHE_VERSION);
      exit(EXIT_SUCCESS);

    case 'x': // --show-compression
    {
      ProgressBar progress_bar(""Scanning..."");
      compress_stats(ctx.config,
                     [&](double progress) { progress_bar.update(progress); });
      break;
    }

    case 'X': // --recompress
    {
      optional<int8_t> wanted_level;
      if (arg == ""uncompressed"") {
        wanted_level = nullopt;
      } else {
        wanted_level =
          Util::parse_signed(arg, INT8_MIN, INT8_MAX, ""compression level"");
      }

      ProgressBar progress_bar(""Recompressing..."");
      compress_recompress(ctx, wanted_level, [&](double progress) {
        progress_bar.update(progress);
      });
      break;
    }

    case 'z': // --zero-stats
      Statistics::zero_all_counters(ctx.config);
      fmt::print(""Statistics zeroed\n"");
      break;

    default:
      fmt::print(stderr, USAGE_TEXT, CCACHE_NAME, CCACHE_NAME);
      exit(EXIT_FAILURE);
    }

    // Some of the above switches might have changed config settings, so run the
    // setup again.
    ctx.config = Config();
    set_up_config(ctx.config);
  }

  return 0;
}

int ccache_main(int argc, const char* const* argv);

int
ccache_main(int argc, const char* const* argv)
{
  try {
    // Check if we are being invoked as ""ccache"".
    std::string program_name(Util::base_name(argv[0]));
    if (Util::same_program_name(program_name, CCACHE_NAME)) {
      if (argc < 2) {
        fmt::print(stderr, USAGE_TEXT, CCACHE_NAME, CCACHE_NAME);
        exit(EXIT_FAILURE);
      }
      // If the first argument isn't an option, then assume we are being passed
      // a compiler name and options.
      if (argv[1][0] == '-') {
        return handle_main_options(argc, argv);
      }
    }

    return cache_compilation(argc, argv);
  } catch (const ErrorBase& e) {
    fmt::print(stderr, ""ccache: error: {}\n"", e.what());
    return EXIT_FAILURE;
  }
}
""","""// Copyright (C) 2002-2007 Andrew Tridgell
// Copyright (C) 2009-2020 Joel Rosdahl and other contributors
//
// See doc/AUTHORS.adoc for a complete list of contributors.
//
// This program is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by the Free
// Software Foundation; either version 3 of the License, or (at your option)
// any later version.
//
// This program is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
// more details.
//
// You should have received a copy of the GNU General Public License along with
// this program; if not, write to the Free Software Foundation, Inc., 51
// Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA

#include ""ccache.hpp""

#include ""Args.hpp""
#include ""ArgsInfo.hpp""
#include ""Checksum.hpp""
#include ""Compression.hpp""
#include ""Context.hpp""
#include ""Fd.hpp""
#include ""File.hpp""
#include ""Finalizer.hpp""
#include ""FormatNonstdStringView.hpp""
#include ""Hash.hpp""
#include ""Lockfile.hpp""
#include ""Logging.hpp""
#include ""Manifest.hpp""
#include ""MiniTrace.hpp""
#include ""ProgressBar.hpp""
#include ""Result.hpp""
#include ""ResultDumper.hpp""
#include ""ResultExtractor.hpp""
#include ""ResultRetriever.hpp""
#include ""SignalHandler.hpp""
#include ""StdMakeUnique.hpp""
#include ""TemporaryFile.hpp""
#include ""UmaskScope.hpp""
#include ""Util.hpp""
#include ""argprocessing.hpp""
#include ""cleanup.hpp""
#include ""compopt.hpp""
#include ""compress.hpp""
#include ""exceptions.hpp""
#include ""execute.hpp""
#include ""hashutil.hpp""
#include ""language.hpp""

#include ""third_party/fmt/core.h""
#include ""third_party/nonstd/optional.hpp""
#include ""third_party/nonstd/string_view.hpp""

#ifdef HAVE_GETOPT_LONG
#  include <getopt.h>
#elif defined(_WIN32)
#  include ""third_party/win32/getopt.h""
#else
#  include ""third_party/getopt_long.h""
#endif

#ifdef _WIN32
#  include ""Win32Util.hpp""
#endif

#include <algorithm>
#include <cmath>
#include <limits>

#ifndef MYNAME
#  define MYNAME ""ccache""
#endif
const char CCACHE_NAME[] = MYNAME;

using Logging::log;
using nonstd::nullopt;
using nonstd::optional;
using nonstd::string_view;

const char VERSION_TEXT[] =
  R""({} version {}

Copyright (C) 2002-2007 Andrew Tridgell
Copyright (C) 2009-2020 Joel Rosdahl and other contributors

See <https://ccache.dev/credits.html> for a complete list of contributors.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 3 of the License, or (at your option) any later
version.
)"";

const char USAGE_TEXT[] =
  R""(Usage:
    {} [options]
    {} compiler [compiler options]
    compiler [compiler options]          (via symbolic link)

Common options:
    -c, --cleanup              delete old files and recalculate size counters
                               (normally not needed as this is done
                               automatically)
    -C, --clear                clear the cache completely (except configuration)
    -d, --directory PATH       operate on cache directory PATH instead of the
                               default
        --evict-older-than AGE remove files older than AGE (unsigned integer
                               with a d (days) or s (seconds) suffix)
    -F, --max-files NUM        set maximum number of files in cache to NUM (use
                               0 for no limit)
    -M, --max-size SIZE        set maximum size of cache to SIZE (use 0 for no
                               limit); available suffixes: k, M, G, T (decimal)
                               and Ki, Mi, Gi, Ti (binary); default suffix: G
    -X, --recompress LEVEL     recompress the cache to LEVEL (integer level or
                               ""uncompressed"")
    -o, --set-config KEY=VAL   set configuration item KEY to value VAL
    -x, --show-compression     show compression statistics
    -p, --show-config          show current configuration options in
                               human-readable format
    -s, --show-stats           show summary of configuration and statistics
                               counters in human-readable format
    -z, --zero-stats           zero statistics counters

    -h, --help                 print this help text
    -V, --version              print version and copyright information

Options for scripting or debugging:
        --checksum-file PATH   print the checksum (64 bit XXH3) of the file at
                               PATH
        --dump-manifest PATH   dump manifest file at PATH in text format
        --dump-result PATH     dump result file at PATH in text format
        --extract-result PATH  extract data stored in result file at PATH to the
                               current working directory
    -k, --get-config KEY       print the value of configuration key KEY
        --hash-file PATH       print the hash (160 bit BLAKE3) of the file at
                               PATH
        --print-stats          print statistics counter IDs and corresponding
                               values in machine-parsable format

See also <https://ccache.dev>.
)"";

// How often (in seconds) to scan $CCACHE_DIR/tmp for left-over temporary
// files.
const int k_tempdir_cleanup_interval = 2 * 24 * 60 * 60; // 2 days

// Maximum files per cache directory. This constant is somewhat arbitrarily
// chosen to be large enough to avoid unnecessary cache levels but small enough
// not to make esoteric file systems (with bad performance for large
// directories) too slow. It could be made configurable, but hopefully there
// will be no need to do that.
const uint64_t k_max_cache_files_per_directory = 2000;

// Minimum number of cache levels ($CCACHE_DIR/1/2/stored_file).
const uint8_t k_min_cache_levels = 2;

// Maximum number of cache levels ($CCACHE_DIR/1/2/3/stored_file).
//
// On a cache miss, (k_max_cache_levels - k_min_cache_levels + 1) cache lookups
// (i.e. stat system calls) will be performed for a cache entry.
//
// An assumption made here is that if a cache is so large that it holds more
// than 16^4 * k_max_cache_files_per_directory files then we can assume that the
// file system is sane enough to handle more than
// k_max_cache_files_per_directory.
const uint8_t k_max_cache_levels = 4;

// This is a string that identifies the current ""version"" of the hash sum
// computed by ccache. If, for any reason, we want to force the hash sum to be
// different for the same input in a new ccache version, we can just change
// this string. A typical example would be if the format of one of the files
// stored in the cache changes in a backwards-incompatible way.
const char HASH_PREFIX[] = ""3"";

static void
add_prefix(const Context& ctx, Args& args, const std::string& prefix_command)
{
  if (prefix_command.empty()) {
    return;
  }

  Args prefix;
  for (const auto& word : Util::split_into_strings(prefix_command, "" "")) {
    std::string path = find_executable(ctx, word, CCACHE_NAME);
    if (path.empty()) {
      throw Fatal(""{}: {}"", word, strerror(errno));
    }

    prefix.push_back(path);
  }

  log(""Using command-line prefix {}"", prefix_command);
  for (size_t i = prefix.size(); i != 0; i--) {
    args.push_front(prefix[i - 1]);
  }
}

static void
clean_up_internal_tempdir(const Config& config)
{
  time_t now = time(nullptr);
  auto dir_st = Stat::stat(config.cache_dir(), Stat::OnError::log);
  if (!dir_st || dir_st.mtime() + k_tempdir_cleanup_interval >= now) {
    // No cleanup needed.
    return;
  }

  Util::update_mtime(config.cache_dir());

  const std::string& temp_dir = config.temporary_dir();
  if (!Stat::lstat(temp_dir)) {
    return;
  }

  Util::traverse(temp_dir, [now](const std::string& path, bool is_dir) {
    if (is_dir) {
      return;
    }
    auto st = Stat::lstat(path, Stat::OnError::log);
    if (st && st.mtime() + k_tempdir_cleanup_interval < now) {
      Util::unlink_tmp(path);
    }
  });
}

static void
init_hash_debug(Context& ctx,
                Hash& hash,
                string_view obj_path,
                char type,
                string_view section_name,
                FILE* debug_text_file)
{
  if (!ctx.config.debug()) {
    return;
  }

  std::string path = fmt::format(""{}.ccache-input-{}"", obj_path, type);
  File debug_binary_file(path, ""wb"");
  if (debug_binary_file) {
    hash.enable_debug(section_name, debug_binary_file.get(), debug_text_file);
    ctx.hash_debug_files.push_back(std::move(debug_binary_file));
  } else {
    log(""Failed to open {}: {}"", path, strerror(errno));
  }
}

static GuessedCompiler
guess_compiler(string_view path)
{
  string_view name = Util::base_name(path);
  GuessedCompiler result = GuessedCompiler::unknown;
  if (name.find(""clang"") != std::string::npos) {
    result = GuessedCompiler::clang;
  } else if (name.find(""gcc"") != std::string::npos
             || name.find(""g++"") != std::string::npos) {
    result = GuessedCompiler::gcc;
  } else if (name.find(""nvcc"") != std::string::npos) {
    result = GuessedCompiler::nvcc;
  } else if (name == ""pump"" || name == ""distcc-pump"") {
    result = GuessedCompiler::pump;
  }
  return result;
}

static bool
do_remember_include_file(Context& ctx,
                         std::string path,
                         Hash& cpp_hash,
                         bool system,
                         Hash* depend_mode_hash)
{
  bool is_pch = false;

  if (path.length() >= 2 && path[0] == '<' && path[path.length() - 1] == '>') {
    // Typically <built-in> or <command-line>.
    return true;
  }

  if (path == ctx.args_info.input_file) {
    // Don't remember the input file.
    return true;
  }

  if (system && (ctx.config.sloppiness() & SLOPPY_SYSTEM_HEADERS)) {
    // Don't remember this system header.
    return true;
  }

  if (ctx.included_files.find(path) != ctx.included_files.end()) {
    // Already known include file.
    return true;
  }

  // Canonicalize path for comparison; Clang uses ./header.h.
  if (Util::starts_with(path, ""./"")) {
    path.erase(0, 2);
  }

#ifdef _WIN32
  {
    // stat fails on directories on win32.
    DWORD attributes = GetFileAttributes(path.c_str());
    if (attributes != INVALID_FILE_ATTRIBUTES
        && attributes & FILE_ATTRIBUTE_DIRECTORY) {
      return true;
    }
  }
#endif

  auto st = Stat::stat(path, Stat::OnError::log);
  if (!st) {
    return false;
  }
  if (st.is_directory()) {
    // Ignore directory, typically $PWD.
    return true;
  }
  if (!st.is_regular()) {
    // Device, pipe, socket or other strange creature.
    log(""Non-regular include file {}"", path);
    return false;
  }

  for (const auto& ignore_header_path : ctx.ignore_header_paths) {
    if (Util::matches_dir_prefix_or_file(ignore_header_path, path)) {
      return true;
    }
  }

  // The comparison using >= is intentional, due to a possible race between
  // starting compilation and writing the include file. See also the notes
  // under ""Performance"" in doc/MANUAL.adoc.
  if (!(ctx.config.sloppiness() & SLOPPY_INCLUDE_FILE_MTIME)
      && st.mtime() >= ctx.time_of_compilation) {
    log(""Include file {} too new"", path);
    return false;
  }

  // The same >= logic as above applies to the change time of the file.
  if (!(ctx.config.sloppiness() & SLOPPY_INCLUDE_FILE_CTIME)
      && st.ctime() >= ctx.time_of_compilation) {
    log(""Include file {} ctime too new"", path);
    return false;
  }

  // Let's hash the include file content.
  Hash fhash;

  is_pch = Util::is_precompiled_header(path);
  if (is_pch) {
    if (ctx.included_pch_file.empty()) {
      log(""Detected use of precompiled header: {}"", path);
    }
    bool using_pch_sum = false;
    if (ctx.config.pch_external_checksum()) {
      // hash pch.sum instead of pch when it exists
      // to prevent hashing a very large .pch file every time
      std::string pch_sum_path = fmt::format(""{}.sum"", path);
      if (Stat::stat(pch_sum_path, Stat::OnError::log)) {
        path = std::move(pch_sum_path);
        using_pch_sum = true;
        log(""Using pch.sum file {}"", path);
      }
    }

    if (!hash_binary_file(ctx, fhash, path)) {
      return false;
    }
    cpp_hash.hash_delimiter(using_pch_sum ? ""pch_sum_hash"" : ""pch_hash"");
    cpp_hash.hash(fhash.digest().to_string());
  }

  if (ctx.config.direct_mode()) {
    if (!is_pch) { // else: the file has already been hashed.
      int result = hash_source_code_file(ctx, fhash, path);
      if (result & HASH_SOURCE_CODE_ERROR
          || result & HASH_SOURCE_CODE_FOUND_TIME) {
        return false;
      }
    }

    Digest d = fhash.digest();
    ctx.included_files.emplace(path, d);

    if (depend_mode_hash) {
      depend_mode_hash->hash_delimiter(""include"");
      depend_mode_hash->hash(d.to_string());
    }
  }

  return true;
}

// This function hashes an include file and stores the path and hash in
// ctx.included_files. If the include file is a PCH, cpp_hash is also updated.
static void
remember_include_file(Context& ctx,
                      const std::string& path,
                      Hash& cpp_hash,
                      bool system,
                      Hash* depend_mode_hash)
{
  if (!do_remember_include_file(ctx, path, cpp_hash, system, depend_mode_hash)
      && ctx.config.direct_mode()) {
    log(""Disabling direct mode"");
    ctx.config.set_direct_mode(false);
  }
}

static void
print_included_files(const Context& ctx, FILE* fp)
{
  for (const auto& item : ctx.included_files) {
    fmt::print(fp, ""{}\n"", item.first);
  }
}

// This function reads and hashes a file. While doing this, it also does these
// things:
//
// - Makes include file paths for which the base directory is a prefix relative
//   when computing the hash sum.
// - Stores the paths and hashes of included files in ctx.included_files.
static bool
process_preprocessed_file(Context& ctx,
                          Hash& hash,
                          const std::string& path,
                          bool pump)
{
  std::string data;
  try {
    data = Util::read_file(path);
  } catch (Error&) {
    return false;
  }

  // Bytes between p and q are pending to be hashed.
  const char* p = &data[0];
  char* q = &data[0];
  const char* end = p + data.length();

  // There must be at least 7 characters (# 1 ""x"") left to potentially find an
  // include file path.
  while (q < end - 7) {
    static const string_view pragma_gcc_pch_preprocess =
      ""pragma GCC pch_preprocess "";
    static const string_view hash_31_command_line_newline =
      ""# 31 \""<command-line>\""\n"";
    static const string_view hash_32_command_line_2_newline =
      ""# 32 \""<command-line>\"" 2\n"";

    // Check if we look at a line containing the file name of an included file.
    // At least the following formats exist (where N is a positive integer):
    //
    // GCC:
    //
    //   # N ""file""
    //   # N ""file"" N
    //   #pragma GCC pch_preprocess ""file""
    //
    // HP's compiler:
    //
    //   #line N ""file""
    //
    // AIX's compiler:
    //
    //   #line N ""file""
    //   #line N
    //
    // Note that there may be other lines starting with '#' left after
    // preprocessing as well, for instance ""#    pragma"".
    if (q[0] == '#'
        // GCC:
        && ((q[1] == ' ' && q[2] >= '0' && q[2] <= '9')
            // GCC precompiled header:
            || Util::starts_with(&q[1], pragma_gcc_pch_preprocess)
            // HP/AIX:
            || (q[1] == 'l' && q[2] == 'i' && q[3] == 'n' && q[4] == 'e'
                && q[5] == ' '))
        && (q == data.data() || q[-1] == '\n')) {
      // Workarounds for preprocessor linemarker bugs in GCC version 6.
      if (q[2] == '3') {
        if (Util::starts_with(q, hash_31_command_line_newline)) {
          // Bogus extra line with #31, after the regular #1: Ignore the whole
          // line, and continue parsing.
          hash.hash(p, q - p);
          while (q < end && *q != '\n') {
            q++;
          }
          q++;
          p = q;
          continue;
        } else if (Util::starts_with(q, hash_32_command_line_2_newline)) {
          // Bogus wrong line with #32, instead of regular #1: Replace the line
          // number with the usual one.
          hash.hash(p, q - p);
          q += 1;
          q[0] = '#';
          q[1] = ' ';
          q[2] = '1';
          p = q;
        }
      }

      while (q < end && *q != '""' && *q != '\n') {
        q++;
      }
      if (q < end && *q == '\n') {
        // A newline before the quotation mark -> no match.
        continue;
      }
      q++;
      if (q >= end) {
        log(""Failed to parse included file path"");
        return false;
      }
      // q points to the beginning of an include file path
      hash.hash(p, q - p);
      p = q;
      while (q < end && *q != '""') {
        q++;
      }
      // Look for preprocessor flags, after the ""filename"".
      bool system = false;
      const char* r = q + 1;
      while (r < end && *r != '\n') {
        if (*r == '3') { // System header.
          system = true;
        }
        r++;
      }
      // p and q span the include file path.
      std::string inc_path(p, q - p);
      if (!ctx.has_absolute_include_headers) {
        ctx.has_absolute_include_headers = Util::is_absolute_path(inc_path);
      }
      inc_path = Util::make_relative_path(ctx, inc_path);

      bool should_hash_inc_path = true;
      if (!ctx.config.hash_dir()) {
        if (Util::starts_with(inc_path, ctx.apparent_cwd)
            && Util::ends_with(inc_path, ""//"")) {
          // When compiling with -g or similar, GCC adds the absolute path to
          // CWD like this:
          //
          //   # 1 ""CWD//""
          //
          // If the user has opted out of including the CWD in the hash, don't
          // hash it. See also how debug_prefix_map is handled.
          should_hash_inc_path = false;
        }
      }
      if (should_hash_inc_path) {
        hash.hash(inc_path);
      }

      remember_include_file(ctx, inc_path, hash, system, nullptr);
      p = q; // Everything of interest between p and q has been hashed now.
    } else if (q[0] == '.' && q[1] == 'i' && q[2] == 'n' && q[3] == 'c'
               && q[4] == 'b' && q[5] == 'i' && q[6] == 'n') {
      // An assembler .inc bin (without the space) statement, which could be
      // part of inline assembly, refers to an external file. If the file
      // changes, the hash should change as well, but finding out what file to
      // hash is too hard for ccache, so just bail out.
      log(
        ""Found unsupported .inc""
        ""bin directive in source code"");
      throw Failure(Statistic::unsupported_code_directive);
    } else if (pump && strncmp(q, ""_________"", 9) == 0) {
      // Unfortunately the distcc-pump wrapper outputs standard output lines:
      // __________Using distcc-pump from /usr/bin
      // __________Using # distcc servers in pump mode
      // __________Shutting down distcc-pump include server
      while (q < end && *q != '\n') {
        q++;
      }
      if (*q == '\n') {
        q++;
      }
      p = q;
      continue;
    } else {
      q++;
    }
  }

  hash.hash(p, (end - p));

  // Explicitly check the .gch/.pch/.pth file as Clang does not include any
  // mention of it in the preprocessed output.
  if (!ctx.included_pch_file.empty()) {
    std::string pch_path = Util::make_relative_path(ctx, ctx.included_pch_file);
    hash.hash(pch_path);
    remember_include_file(ctx, pch_path, hash, false, nullptr);
  }

  bool debug_included = getenv(""CCACHE_DEBUG_INCLUDED"");
  if (debug_included) {
    print_included_files(ctx, stdout);
  }

  return true;
}

// Replace absolute paths with relative paths in the provided dependency file.
static void
use_relative_paths_in_depfile(const Context& ctx)
{
  if (ctx.config.base_dir().empty()) {
    log(""Base dir not set, skip using relative paths"");
    return; // nothing to do
  }
  if (!ctx.has_absolute_include_headers) {
    log(""No absolute path for included files found, skip using relative paths"");
    return; // nothing to do
  }

  const std::string& output_dep = ctx.args_info.output_dep;
  std::string file_content;
  try {
    file_content = Util::read_file(output_dep);
  } catch (const Error& e) {
    log(""Cannot open dependency file {}: {}"", output_dep, e.what());
    return;
  }

  std::string adjusted_file_content;
  adjusted_file_content.reserve(file_content.size());

  bool rewritten = false;

  for (string_view token : Util::split_into_views(file_content, "" \t\r\n"")) {
    if (Util::is_absolute_path(token)
        && token.starts_with(ctx.config.base_dir())) {
      adjusted_file_content.append(Util::make_relative_path(ctx, token));
      rewritten = true;
    } else {
      adjusted_file_content.append(token.begin(), token.end());
    }
    adjusted_file_content.push_back(' ');
  }

  if (!rewritten) {
    log(
      ""No paths in dependency file {} made relative, skip relative path usage"",
      output_dep);
    return;
  }

  std::string tmp_file = output_dep + "".tmp"";
  Util::write_file(tmp_file, adjusted_file_content);
  Util::rename(tmp_file, output_dep);
}

// Extract the used includes from the dependency file. Note that we cannot
// distinguish system headers from other includes here.
static optional<Digest>
result_name_from_depfile(Context& ctx, Hash& hash)
{
  std::string file_content;
  try {
    file_content = Util::read_file(ctx.args_info.output_dep);
  } catch (const Error& e) {
    log(
      ""Cannot open dependency file {}: {}"", ctx.args_info.output_dep, e.what());
    return nullopt;
  }

  for (string_view token : Util::split_into_views(file_content, "" \t\r\n"")) {
    if (token == ""\\"" || token.ends_with("":"")) {
      continue;
    }
    if (!ctx.has_absolute_include_headers) {
      ctx.has_absolute_include_headers = Util::is_absolute_path(token);
    }
    std::string path = Util::make_relative_path(ctx, token);
    remember_include_file(ctx, path, hash, false, &hash);
  }

  // Explicitly check the .gch/.pch/.pth file as it may not be mentioned in the
  // dependencies output.
  if (!ctx.included_pch_file.empty()) {
    std::string pch_path = Util::make_relative_path(ctx, ctx.included_pch_file);
    hash.hash(pch_path);
    remember_include_file(ctx, pch_path, hash, false, nullptr);
  }

  bool debug_included = getenv(""CCACHE_DEBUG_INCLUDED"");
  if (debug_included) {
    print_included_files(ctx, stdout);
  }

  return hash.digest();
}

// Execute the compiler/preprocessor, with logic to retry without requesting
// colored diagnostics messages if that fails.
static int
do_execute(Context& ctx,
           Args& args,
           TemporaryFile&& tmp_stdout,
           TemporaryFile&& tmp_stderr)
{
  UmaskScope umask_scope(ctx.original_umask);

  if (ctx.diagnostics_color_failed
      && ctx.guessed_compiler == GuessedCompiler::gcc) {
    args.erase_with_prefix(""-fdiagnostics-color"");
  }
  int status = execute(args.to_argv().data(),
                       std::move(tmp_stdout.fd),
                       std::move(tmp_stderr.fd),
                       &ctx.compiler_pid);
  if (status != 0 && !ctx.diagnostics_color_failed
      && ctx.guessed_compiler == GuessedCompiler::gcc) {
    auto errors = Util::read_file(tmp_stderr.path);
    if (errors.find(""unrecognized command line option"") != std::string::npos
        && errors.find(""-fdiagnostics-color"") != std::string::npos) {
      // Old versions of GCC do not support colored diagnostics.
      log(""-fdiagnostics-color is unsupported; trying again without it"");

      tmp_stdout.fd = Fd(open(
        tmp_stdout.path.c_str(), O_RDWR | O_CREAT | O_TRUNC | O_BINARY, 0600));
      if (!tmp_stdout.fd) {
        log(""Failed to truncate {}: {}"", tmp_stdout.path, strerror(errno));
        throw Failure(Statistic::internal_error);
      }

      tmp_stderr.fd = Fd(open(
        tmp_stderr.path.c_str(), O_RDWR | O_CREAT | O_TRUNC | O_BINARY, 0600));
      if (!tmp_stderr.fd) {
        log(""Failed to truncate {}: {}"", tmp_stderr.path, strerror(errno));
        throw Failure(Statistic::internal_error);
      }

      ctx.diagnostics_color_failed = true;
      return do_execute(
        ctx, args, std::move(tmp_stdout), std::move(tmp_stderr));
    }
  }
  return status;
}

struct LookUpCacheFileResult
{
  std::string path;
  Stat stat;
  uint8_t level;
};

static LookUpCacheFileResult
look_up_cache_file(const std::string& cache_dir,
                   const Digest& name,
                   nonstd::string_view suffix)
{
  const auto name_string = fmt::format(""{}{}"", name.to_string(), suffix);

  for (uint8_t level = k_min_cache_levels; level <= k_max_cache_levels;
       ++level) {
    const auto path = Util::get_path_in_cache(cache_dir, level, name_string);
    const auto stat = Stat::stat(path);
    if (stat) {
      return {path, stat, level};
    }
  }

  const auto shallowest_path =
    Util::get_path_in_cache(cache_dir, k_min_cache_levels, name_string);
  return {shallowest_path, Stat(), k_min_cache_levels};
}

// Create or update the manifest file.
static void
update_manifest_file(Context& ctx)
{
  if (!ctx.config.direct_mode() || ctx.config.read_only()
      || ctx.config.read_only_direct()) {
    return;
  }

  ASSERT(ctx.manifest_path());
  ASSERT(ctx.result_path());

  MTR_BEGIN(""manifest"", ""manifest_put"");

  const auto old_stat = Stat::stat(*ctx.manifest_path());

  // See comment in get_file_hash_index for why saving of timestamps is forced
  // for precompiled headers.
  const bool save_timestamp =
    (ctx.config.sloppiness() & SLOPPY_FILE_STAT_MATCHES)
    || ctx.args_info.output_is_precompiled_header;

  log(""Adding result name to {}"", *ctx.manifest_path());
  if (!Manifest::put(ctx.config,
                     *ctx.manifest_path(),
                     *ctx.result_name(),
                     ctx.included_files,
                     ctx.time_of_compilation,
                     save_timestamp)) {
    log(""Failed to add result name to {}"", *ctx.manifest_path());
  } else {
    const auto new_stat = Stat::stat(*ctx.manifest_path(), Stat::OnError::log);
    ctx.manifest_counter_updates.increment(
      Statistic::cache_size_kibibyte,
      Util::size_change_kibibyte(old_stat, new_stat));
    ctx.manifest_counter_updates.increment(Statistic::files_in_cache,
                                           !old_stat && new_stat ? 1 : 0);
  }
  MTR_END(""manifest"", ""manifest_put"");
}

static void
create_cachedir_tag(const Context& ctx)
{
  constexpr char cachedir_tag[] =
    ""Signature: 8a477f597d28d172789f06886806bc55\n""
    ""# This file is a cache directory tag created by ccache.\n""
    ""# For information about cache directory tags, see:\n""
    ""#\thttp://www.brynosaurus.com/cachedir/\n"";

  const std::string path = fmt::format(""{}/{}/CACHEDIR.TAG"",
                                       ctx.config.cache_dir(),
                                       ctx.result_name()->to_string()[0]);
  const auto stat = Stat::stat(path);
  if (stat) {
    return;
  }
  try {
    Util::write_file(path, cachedir_tag);
  } catch (const Error& e) {
    log(""Failed to create {}: {}"", path, e.what());
  }
}

// Run the real compiler and put the result in cache.
static void
to_cache(Context& ctx,
         Args& args,
         Args& depend_extra_args,
         Hash* depend_mode_hash)
{
  args.push_back(""-o"");
  args.push_back(ctx.args_info.output_obj);

  if (ctx.config.hard_link() && ctx.args_info.output_obj != ""/dev/null"") {
    // Workaround for Clang bug where it overwrites an existing object file
    // when it's compiling an assembler file, see
    // <https://bugs.llvm.org/show_bug.cgi?id=39782>.
    Util::unlink_safe(ctx.args_info.output_obj);
  }

  if (ctx.args_info.generating_diagnostics) {
    args.push_back(""--serialize-diagnostics"");
    args.push_back(ctx.args_info.output_dia);
  }

  // Turn off DEPENDENCIES_OUTPUT when running cc1, because otherwise it will
  // emit a line like this:
  //
  //   tmp.stdout.vexed.732.o: /home/mbp/.ccache/tmp.stdout.vexed.732.i
  Util::unsetenv(""DEPENDENCIES_OUTPUT"");
  Util::unsetenv(""SUNPRO_DEPENDENCIES"");

  if (ctx.config.run_second_cpp()) {
    args.push_back(ctx.args_info.input_file);
  } else {
    args.push_back(ctx.i_tmpfile);
  }

  if (ctx.args_info.seen_split_dwarf) {
    // Remove any pre-existing .dwo file since we want to check if the compiler
    // produced one, intentionally not using x_unlink or tmp_unlink since we're
    // not interested in logging successful deletions or failures due to
    // non-existent .dwo files.
    if (unlink(ctx.args_info.output_dwo.c_str()) != 0 && errno != ENOENT
        && errno != ESTALE) {
      log(""Failed to unlink {}: {}"", ctx.args_info.output_dwo, strerror(errno));
      throw Failure(Statistic::bad_output_file);
    }
  }

  log(""Running real compiler"");
  MTR_BEGIN(""execute"", ""compiler"");

  TemporaryFile tmp_stdout(
    fmt::format(""{}/tmp.stdout"", ctx.config.temporary_dir()));
  ctx.register_pending_tmp_file(tmp_stdout.path);
  std::string tmp_stdout_path = tmp_stdout.path;

  TemporaryFile tmp_stderr(
    fmt::format(""{}/tmp.stderr"", ctx.config.temporary_dir()));
  ctx.register_pending_tmp_file(tmp_stderr.path);
  std::string tmp_stderr_path = tmp_stderr.path;

  int status;
  if (!ctx.config.depend_mode()) {
    status =
      do_execute(ctx, args, std::move(tmp_stdout), std::move(tmp_stderr));
    args.pop_back(3);
  } else {
    // Use the original arguments (including dependency options) in depend
    // mode.
    Args depend_mode_args = ctx.orig_args;
    depend_mode_args.erase_with_prefix(""--ccache-"");
    depend_mode_args.push_back(depend_extra_args);
    add_prefix(ctx, depend_mode_args, ctx.config.prefix_command());

    ctx.time_of_compilation = time(nullptr);
    status = do_execute(
      ctx, depend_mode_args, std::move(tmp_stdout), std::move(tmp_stderr));
  }
  MTR_END(""execute"", ""compiler"");

  auto st = Stat::stat(tmp_stdout_path, Stat::OnError::log);
  if (!st) {
    // The stdout file was removed - cleanup in progress? Better bail out.
    throw Failure(Statistic::missing_cache_file);
  }

  // distcc-pump outputs lines like this:
  // __________Using # distcc servers in pump mode
  if (st.size() != 0 && ctx.guessed_compiler != GuessedCompiler::pump) {
    log(""Compiler produced stdout"");
    throw Failure(Statistic::compiler_produced_stdout);
  }

  // Merge stderr from the preprocessor (if any) and stderr from the real
  // compiler into tmp_stderr.
  if (!ctx.cpp_stderr.empty()) {
    std::string combined_stderr =
      Util::read_file(ctx.cpp_stderr) + Util::read_file(tmp_stderr_path);
    Util::write_file(tmp_stderr_path, combined_stderr);
  }

  if (status != 0) {
    log(""Compiler gave exit status {}"", status);

    // We can output stderr immediately instead of rerunning the compiler.
    Util::send_to_stderr(ctx, Util::read_file(tmp_stderr_path));

    throw Failure(Statistic::compile_failed, status);
  }

  if (ctx.config.depend_mode()) {
    ASSERT(depend_mode_hash);
    auto result_name = result_name_from_depfile(ctx, *depend_mode_hash);
    if (!result_name) {
      throw Failure(Statistic::internal_error);
    }
    ctx.set_result_name(*result_name);
  }

  bool produce_dep_file = ctx.args_info.generating_dependencies
                          && ctx.args_info.output_dep != ""/dev/null"";

  if (produce_dep_file) {
    use_relative_paths_in_depfile(ctx);
  }

  const auto obj_stat = Stat::stat(ctx.args_info.output_obj);
  if (!obj_stat) {
    log(""Compiler didn't produce an object file"");
    throw Failure(Statistic::compiler_produced_no_output);
  }
  if (obj_stat.size() == 0) {
    log(""Compiler produced an empty object file"");
    throw Failure(Statistic::compiler_produced_empty_output);
  }

  const auto stderr_stat = Stat::stat(tmp_stderr_path, Stat::OnError::log);
  if (!stderr_stat) {
    throw Failure(Statistic::internal_error);
  }

  const auto result_file = look_up_cache_file(
    ctx.config.cache_dir(), *ctx.result_name(), Result::k_file_suffix);
  ctx.set_result_path(result_file.path);
  Result::Writer result_writer(ctx, result_file.path);

  if (stderr_stat.size() > 0) {
    result_writer.write(Result::FileType::stderr_output, tmp_stderr_path);
  }
  result_writer.write(Result::FileType::object, ctx.args_info.output_obj);
  if (ctx.args_info.generating_dependencies) {
    result_writer.write(Result::FileType::dependency, ctx.args_info.output_dep);
  }
  if (ctx.args_info.generating_coverage) {
    if (!Stat::stat(ctx.args_info.output_cov)) {
      // The .gcno file is missing. This is likely due to compiling with GCC 9+,
      // which uses another name for the .gcno file when using -ftest-coverage
      // or --coverage when -fprofile-dir=dir is given. The .gcno file is still
      // placed next to the object file, not in the specified profile directory,
      // though.
      log(""{} is missing"", ctx.args_info.output_cov);
      throw Failure(Statistic::unsupported_compiler_option);
    }
    result_writer.write(Result::FileType::coverage, ctx.args_info.output_cov);
  }
  if (ctx.args_info.generating_stackusage) {
    result_writer.write(Result::FileType::stackusage, ctx.args_info.output_su);
  }
  if (ctx.args_info.generating_diagnostics) {
    result_writer.write(Result::FileType::diagnostic, ctx.args_info.output_dia);
  }
  if (ctx.args_info.seen_split_dwarf && Stat::stat(ctx.args_info.output_dwo)) {
    // Only store .dwo file if it was created by the compiler (GCC and Clang
    // behave differently e.g. for ""-gsplit-dwarf -g1"").
    result_writer.write(Result::FileType::dwarf_object,
                        ctx.args_info.output_dwo);
  }

  auto error = result_writer.finalize();
  if (error) {
    log(""Error: {}"", *error);
  } else {
    log(""Stored in cache: {}"", result_file.path);
  }

  auto new_result_stat = Stat::stat(result_file.path, Stat::OnError::log);
  if (!new_result_stat) {
    throw Failure(Statistic::internal_error);
  }
  ctx.counter_updates.increment(
    Statistic::cache_size_kibibyte,
    Util::size_change_kibibyte(result_file.stat, new_result_stat));
  ctx.counter_updates.increment(Statistic::files_in_cache,
                                result_file.stat ? 0 : 1);

  MTR_END(""file"", ""file_put"");

  // Make sure we have a CACHEDIR.TAG in the cache part of cache_dir. This can
  // be done almost anywhere, but we might as well do it near the end as we save
  // the stat call if we exit early.
  create_cachedir_tag(ctx);

  // Everything OK.
  Util::send_to_stderr(ctx, Util::read_file(tmp_stderr_path));
}

// Find the result name by running the compiler in preprocessor mode and
// hashing the result.
static Digest
get_result_name_from_cpp(Context& ctx, Args& args, Hash& hash)
{
  ctx.time_of_compilation = time(nullptr);

  std::string stderr_path;
  std::string stdout_path;
  int status;
  if (ctx.args_info.direct_i_file) {
    // We are compiling a .i or .ii file - that means we can skip the cpp stage
    // and directly form the correct i_tmpfile.
    stdout_path = ctx.args_info.input_file;
    status = 0;
  } else {
    // Run cpp on the input file to obtain the .i.

    TemporaryFile tmp_stdout(
      fmt::format(""{}/tmp.cpp_stdout"", ctx.config.temporary_dir()));
    stdout_path = tmp_stdout.path;
    ctx.register_pending_tmp_file(stdout_path);

    TemporaryFile tmp_stderr(
      fmt::format(""{}/tmp.cpp_stderr"", ctx.config.temporary_dir()));
    stderr_path = tmp_stderr.path;
    ctx.register_pending_tmp_file(stderr_path);

    size_t args_added = 2;
    args.push_back(""-E"");
    if (ctx.args_info.actual_language == ""hip"") {
      args.push_back(""-o"");
      args.push_back(""-"");
      args_added += 2;
    }
    if (ctx.config.keep_comments_cpp()) {
      args.push_back(""-C"");
      args_added++;
    }
    args.push_back(ctx.args_info.input_file);
    add_prefix(ctx, args, ctx.config.prefix_command_cpp());
    log(""Running preprocessor"");
    MTR_BEGIN(""execute"", ""preprocessor"");
    status =
      do_execute(ctx, args, std::move(tmp_stdout), std::move(tmp_stderr));
    MTR_END(""execute"", ""preprocessor"");
    args.pop_back(args_added);
  }

  if (status != 0) {
    log(""Preprocessor gave exit status {}"", status);
    throw Failure(Statistic::preprocessor_error);
  }

  hash.hash_delimiter(""cpp"");
  bool is_pump = ctx.guessed_compiler == GuessedCompiler::pump;
  if (!process_preprocessed_file(ctx, hash, stdout_path, is_pump)) {
    throw Failure(Statistic::internal_error);
  }

  hash.hash_delimiter(""cppstderr"");
  if (!ctx.args_info.direct_i_file && !hash.hash_file(stderr_path)) {
    // Somebody removed the temporary file?
    log(""Failed to open {}: {}"", stderr_path, strerror(errno));
    throw Failure(Statistic::internal_error);
  }

  if (ctx.args_info.direct_i_file) {
    ctx.i_tmpfile = ctx.args_info.input_file;
  } else {
    // i_tmpfile needs the proper cpp_extension for the compiler to do its
    // thing correctly
    ctx.i_tmpfile =
      fmt::format(""{}.{}"", stdout_path, ctx.config.cpp_extension());
    Util::rename(stdout_path, ctx.i_tmpfile);
    ctx.register_pending_tmp_file(ctx.i_tmpfile);
  }

  if (!ctx.config.run_second_cpp()) {
    // If we are using the CPP trick, we need to remember this stderr data and
    // output it just before the main stderr from the compiler pass.
    ctx.cpp_stderr = stderr_path;
    hash.hash_delimiter(""runsecondcpp"");
    hash.hash(""false"");
  }

  return hash.digest();
}

// Hash mtime or content of a file, or the output of a command, according to
// the CCACHE_COMPILERCHECK setting.
static void
hash_compiler(const Context& ctx,
              Hash& hash,
              const Stat& st,
              const std::string& path,
              bool allow_command)
{
  if (ctx.config.compiler_check() == ""none"") {
    // Do nothing.
  } else if (ctx.config.compiler_check() == ""mtime"") {
    hash.hash_delimiter(""cc_mtime"");
    hash.hash(st.size());
    hash.hash(st.mtime());
  } else if (Util::starts_with(ctx.config.compiler_check(), ""string:"")) {
    hash.hash_delimiter(""cc_hash"");
    hash.hash(&ctx.config.compiler_check()[7]);
  } else if (ctx.config.compiler_check() == ""content"" || !allow_command) {
    hash.hash_delimiter(""cc_content"");
    hash_binary_file(ctx, hash, path);
  } else { // command string
    if (!hash_multicommand_output(
          hash, ctx.config.compiler_check(), ctx.orig_args[0])) {
      log(""Failure running compiler check command: {}"",
          ctx.config.compiler_check());
      throw Failure(Statistic::compiler_check_failed);
    }
  }
}

// Hash the host compiler(s) invoked by nvcc.
//
// If `ccbin_st` and `ccbin` are set, they refer to a directory or compiler set
// with -ccbin/--compiler-bindir. If `ccbin_st` is nullptr or `ccbin` is the
// empty string, the compilers are looked up in PATH instead.
static void
hash_nvcc_host_compiler(const Context& ctx,
                        Hash& hash,
                        const Stat* ccbin_st = nullptr,
                        const std::string& ccbin = {})
{
  // From <http://docs.nvidia.com/cuda/cuda-compiler-driver-nvcc/index.html>:
  //
  //   ""[...] Specify the directory in which the compiler executable resides.
  //   The host compiler executable name can be also specified to ensure that
  //   the correct host compiler is selected.""
  //
  // and
  //
  //   ""On all platforms, the default host compiler executable (gcc and g++ on
  //   Linux, clang and clang++ on Mac OS X, and cl.exe on Windows) found in
  //   the current execution search path will be used"".

  if (ccbin.empty() || !ccbin_st || ccbin_st->is_directory()) {
#if defined(__APPLE__)
    const char* compilers[] = {""clang"", ""clang++""};
#elif defined(_WIN32)
    const char* compilers[] = {""cl.exe""};
#else
    const char* compilers[] = {""gcc"", ""g++""};
#endif
    for (const char* compiler : compilers) {
      if (!ccbin.empty()) {
        std::string path = fmt::format(""{}/{}"", ccbin, compiler);
        auto st = Stat::stat(path);
        if (st) {
          hash_compiler(ctx, hash, st, path, false);
        }
      } else {
        std::string path = find_executable(ctx, compiler, CCACHE_NAME);
        if (!path.empty()) {
          auto st = Stat::stat(path, Stat::OnError::log);
          hash_compiler(ctx, hash, st, ccbin, false);
        }
      }
    }
  } else {
    hash_compiler(ctx, hash, *ccbin_st, ccbin, false);
  }
}

static bool
should_rewrite_dependency_target(const ArgsInfo& args_info)
{
  return !args_info.dependency_target_specified && args_info.seen_MD_MMD;
}

// update a hash with information common for the direct and preprocessor modes.
static void
hash_common_info(const Context& ctx,
                 const Args& args,
                 Hash& hash,
                 const ArgsInfo& args_info)
{
  hash.hash(HASH_PREFIX);

  // We have to hash the extension, as a .i file isn't treated the same by the
  // compiler as a .ii file.
  hash.hash_delimiter(""ext"");
  hash.hash(ctx.config.cpp_extension());

#ifdef _WIN32
  const std::string compiler_path = Win32Util::add_exe_suffix(args[0]);
#else
  const std::string compiler_path = args[0];
#endif

  auto st = Stat::stat(compiler_path, Stat::OnError::log);
  if (!st) {
    throw Failure(Statistic::could_not_find_compiler);
  }

  // Hash information about the compiler.
  hash_compiler(ctx, hash, st, compiler_path, true);

  // Also hash the compiler name as some compilers use hard links and behave
  // differently depending on the real name.
  hash.hash_delimiter(""cc_name"");
  hash.hash(Util::base_name(args[0]));

  if (!(ctx.config.sloppiness() & SLOPPY_LOCALE)) {
    // Hash environment variables that may affect localization of compiler
    // warning messages.
    const char* envvars[] = {
      ""LANG"", ""LC_ALL"", ""LC_CTYPE"", ""LC_MESSAGES"", nullptr};
    for (const char** p = envvars; *p; ++p) {
      const char* v = getenv(*p);
      if (v) {
        hash.hash_delimiter(*p);
        hash.hash(v);
      }
    }
  }

  // Possibly hash the current working directory.
  if (args_info.generating_debuginfo && ctx.config.hash_dir()) {
    std::string dir_to_hash = ctx.apparent_cwd;
    for (const auto& map : args_info.debug_prefix_maps) {
      size_t sep_pos = map.find('=');
      if (sep_pos != std::string::npos) {
        std::string old_path = map.substr(0, sep_pos);
        std::string new_path = map.substr(sep_pos + 1);
        log(""Relocating debuginfo from {} to {} (CWD: {})"",
            old_path,
            new_path,
            ctx.apparent_cwd);
        if (Util::starts_with(ctx.apparent_cwd, old_path)) {
          dir_to_hash = new_path + ctx.apparent_cwd.substr(old_path.size());
        }
      }
    }
    log(""Hashing CWD {}"", dir_to_hash);
    hash.hash_delimiter(""cwd"");
    hash.hash(dir_to_hash);
  }

  if ((!should_rewrite_dependency_target(ctx.args_info)
       && ctx.args_info.generating_dependencies)
      || ctx.args_info.seen_split_dwarf) {
    // The output object file name is part of the .d file, so include the path
    // in the hash if generating dependencies.
    //
    // Object files include a link to the corresponding .dwo file based on the
    // target object filename when using -gsplit-dwarf, so hashing the object
    // file path will do it, although just hashing the object file base name
    // would be enough.
    hash.hash_delimiter(""object file"");
    hash.hash(ctx.args_info.output_obj);
  }

  // Possibly hash the coverage data file path.
  if (ctx.args_info.generating_coverage && ctx.args_info.profile_arcs) {
    std::string dir;
    if (!ctx.args_info.profile_path.empty()) {
      dir = ctx.args_info.profile_path;
    } else {
      dir =
        Util::real_path(std::string(Util::dir_name(ctx.args_info.output_obj)));
    }
    string_view stem =
      Util::remove_extension(Util::base_name(ctx.args_info.output_obj));
    std::string gcda_path = fmt::format(""{}/{}.gcda"", dir, stem);
    log(""Hashing coverage path {}"", gcda_path);
    hash.hash_delimiter(""gcda"");
    hash.hash(gcda_path);
  }

  // Possibly hash the sanitize blacklist file path.
  for (const auto& sanitize_blacklist : args_info.sanitize_blacklists) {
    log(""Hashing sanitize blacklist {}"", sanitize_blacklist);
    hash.hash(""sanitizeblacklist"");
    if (!hash_binary_file(ctx, hash, sanitize_blacklist)) {
      throw Failure(Statistic::error_hashing_extra_file);
    }
  }

  if (!ctx.config.extra_files_to_hash().empty()) {
    for (const std::string& path : Util::split_into_strings(
           ctx.config.extra_files_to_hash(), PATH_DELIM)) {
      log(""Hashing extra file {}"", path);
      hash.hash_delimiter(""extrafile"");
      if (!hash_binary_file(ctx, hash, path)) {
        throw Failure(Statistic::error_hashing_extra_file);
      }
    }
  }

  // Possibly hash GCC_COLORS (for color diagnostics).
  if (ctx.guessed_compiler == GuessedCompiler::gcc) {
    const char* gcc_colors = getenv(""GCC_COLORS"");
    if (gcc_colors) {
      hash.hash_delimiter(""gcccolors"");
      hash.hash(gcc_colors);
    }
  }
}

static bool
hash_profile_data_file(const Context& ctx, Hash& hash)
{
  const std::string& profile_path = ctx.args_info.profile_path;
  string_view base_name = Util::remove_extension(ctx.args_info.output_obj);
  std::string hashified_cwd = ctx.apparent_cwd;
  std::replace(hashified_cwd.begin(), hashified_cwd.end(), '/', '#');

  std::vector<std::string> paths_to_try{
    // -fprofile-use[=dir]/-fbranch-probabilities (GCC <9)
    fmt::format(""{}/{}.gcda"", profile_path, base_name),
    // -fprofile-use[=dir]/-fbranch-probabilities (GCC >=9)
    fmt::format(""{}/{}#{}.gcda"", profile_path, hashified_cwd, base_name),
    // -fprofile(-instr|-sample)-use=file (Clang), -fauto-profile=file (GCC >=5)
    profile_path,
    // -fprofile(-instr|-sample)-use=dir (Clang)
    fmt::format(""{}/default.profdata"", profile_path),
    // -fauto-profile (GCC >=5)
    ""fbdata.afdo"", // -fprofile-dir is not used
  };

  bool found = false;
  for (const std::string& p : paths_to_try) {
    log(""Checking for profile data file {}"", p);
    auto st = Stat::stat(p);
    if (st && !st.is_directory()) {
      log(""Adding profile data {} to the hash"", p);
      hash.hash_delimiter(""-fprofile-use"");
      if (hash_binary_file(ctx, hash, p)) {
        found = true;
      }
    }
  }

  return found;
}

static bool
option_should_be_ignored(const std::string& arg,
                         const std::vector<std::string>& patterns)
{
  return std::any_of(
    patterns.cbegin(), patterns.cend(), [&arg](const std::string& pattern) {
      const auto& prefix = string_view(pattern).substr(0, pattern.length() - 1);
      return (
        pattern == arg
        || (Util::ends_with(pattern, ""*"") && Util::starts_with(arg, prefix)));
    });
}

// Update a hash sum with information specific to the direct and preprocessor
// modes and calculate the result name. Returns the result name on success,
// otherwise nullopt.
static optional<Digest>
calculate_result_name(Context& ctx,
                      const Args& args,
                      Args& preprocessor_args,
                      Hash& hash,
                      bool direct_mode)
{
  bool found_ccbin = false;

  hash.hash_delimiter(""result version"");
  hash.hash(Result::k_version);

  if (direct_mode) {
    hash.hash_delimiter(""manifest version"");
    hash.hash(Manifest::k_version);
  }

  // clang will emit warnings for unused linker flags, so we shouldn't skip
  // those arguments.
  int is_clang = ctx.guessed_compiler == GuessedCompiler::clang
                 || ctx.guessed_compiler == GuessedCompiler::unknown;

  // First the arguments.
  for (size_t i = 1; i < args.size(); i++) {
    // Trust the user if they've said we should not hash a given option.
    if (option_should_be_ignored(args[i], ctx.ignore_options())) {
      log(""Not hashing ignored option: {}"", args[i]);
      if (i + 1 < args.size() && compopt_takes_arg(args[i])) {
        i++;
        log(""Not hashing argument of ignored option: {}"", args[i]);
      }
      continue;
    }

    // -L doesn't affect compilation (except for clang).
    if (i < args.size() - 1 && args[i] == ""-L"" && !is_clang) {
      i++;
      continue;
    }
    if (Util::starts_with(args[i], ""-L"") && !is_clang) {
      continue;
    }

    // -Wl,... doesn't affect compilation (except for clang).
    if (Util::starts_with(args[i], ""-Wl,"") && !is_clang) {
      continue;
    }

    // The -fdebug-prefix-map option may be used in combination with
    // CCACHE_BASEDIR to reuse results across different directories. Skip using
    // the value of the option from hashing but still hash the existence of the
    // option.
    if (Util::starts_with(args[i], ""-fdebug-prefix-map="")) {
      hash.hash_delimiter(""arg"");
      hash.hash(""-fdebug-prefix-map="");
      continue;
    }
    if (Util::starts_with(args[i], ""-ffile-prefix-map="")) {
      hash.hash_delimiter(""arg"");
      hash.hash(""-ffile-prefix-map="");
      continue;
    }
    if (Util::starts_with(args[i], ""-fmacro-prefix-map="")) {
      hash.hash_delimiter(""arg"");
      hash.hash(""-fmacro-prefix-map="");
      continue;
    }

    // When using the preprocessor, some arguments don't contribute to the
    // hash. The theory is that these arguments will change the output of -E if
    // they are going to have any effect at all. For precompiled headers this
    // might not be the case.
    if (!direct_mode && !ctx.args_info.output_is_precompiled_header
        && !ctx.args_info.using_precompiled_header) {
      if (compopt_affects_cpp(args[i])) {
        if (compopt_takes_arg(args[i])) {
          i++;
        }
        continue;
      }
      if (compopt_short(compopt_affects_cpp, args[i])) {
        continue;
      }
    }

    // If we're generating dependencies, we make sure to skip the filename of
    // the dependency file, since it doesn't impact the output.
    if (ctx.args_info.generating_dependencies) {
      if (Util::starts_with(args[i], ""-Wp,"")) {
        if (Util::starts_with(args[i], ""-Wp,-MD,"")
            && args[i].find(',', 8) == std::string::npos) {
          hash.hash(args[i].data(), 8);
          continue;
        } else if (Util::starts_with(args[i], ""-Wp,-MMD,"")
                   && args[i].find(',', 9) == std::string::npos) {
          hash.hash(args[i].data(), 9);
          continue;
        }
      } else if (Util::starts_with(args[i], ""-MF"")) {
        // In either case, hash the ""-MF"" part.
        hash.hash_delimiter(""arg"");
        hash.hash(args[i].data(), 3);

        if (ctx.args_info.output_dep != ""/dev/null"") {
          bool separate_argument = (args[i].size() == 3);
          if (separate_argument) {
            // Next argument is dependency name, so skip it.
            i++;
          }
        }
        continue;
      }
    }

    if (Util::starts_with(args[i], ""-specs="")
        || Util::starts_with(args[i], ""--specs="")) {
      std::string path = args[i].substr(args[i].find('=') + 1);
      auto st = Stat::stat(path, Stat::OnError::log);
      if (st) {
        // If given an explicit specs file, then hash that file, but don't
        // include the path to it in the hash.
        hash.hash_delimiter(""specs"");
        hash_compiler(ctx, hash, st, path, false);
        continue;
      }
    }

    if (Util::starts_with(args[i], ""-fplugin="")) {
      auto st = Stat::stat(&args[i][9], Stat::OnError::log);
      if (st) {
        hash.hash_delimiter(""plugin"");
        hash_compiler(ctx, hash, st, &args[i][9], false);
        continue;
      }
    }

    if (args[i] == ""-Xclang"" && i + 3 < args.size() && args[i + 1] == ""-load""
        && args[i + 2] == ""-Xclang"") {
      auto st = Stat::stat(args[i + 3], Stat::OnError::log);
      if (st) {
        hash.hash_delimiter(""plugin"");
        hash_compiler(ctx, hash, st, args[i + 3], false);
        i += 3;
        continue;
      }
    }

    if ((args[i] == ""-ccbin"" || args[i] == ""--compiler-bindir"")
        && i + 1 < args.size()) {
      auto st = Stat::stat(args[i + 1]);
      if (st) {
        found_ccbin = true;
        hash.hash_delimiter(""ccbin"");
        hash_nvcc_host_compiler(ctx, hash, &st, args[i + 1]);
        i++;
        continue;
      }
    }

    // All other arguments are included in the hash.
    hash.hash_delimiter(""arg"");
    hash.hash(args[i]);
    if (i + 1 < args.size() && compopt_takes_arg(args[i])) {
      i++;
      hash.hash_delimiter(""arg"");
      hash.hash(args[i]);
    }
  }

  // Make results with dependency file /dev/null different from those without
  // it.
  if (ctx.args_info.generating_dependencies
      && ctx.args_info.output_dep == ""/dev/null"") {
    hash.hash_delimiter(""/dev/null dependency file"");
  }

  if (!found_ccbin && ctx.args_info.actual_language == ""cu"") {
    hash_nvcc_host_compiler(ctx, hash);
  }

  // For profile generation (-fprofile(-instr)-generate[=path])
  // - hash profile path
  //
  // For profile usage (-fprofile(-instr|-sample)-use, -fbranch-probabilities):
  // - hash profile data
  //
  // -fbranch-probabilities and -fvpt usage is covered by
  // -fprofile-generate/-fprofile-use.
  //
  // The profile directory can be specified as an argument to
  // -fprofile(-instr)-generate=, -fprofile(-instr|-sample)-use= or
  // -fprofile-dir=.

  if (ctx.args_info.profile_generate) {
    ASSERT(!ctx.args_info.profile_path.empty());
    log(""Adding profile directory {} to our hash"", ctx.args_info.profile_path);
    hash.hash_delimiter(""-fprofile-dir"");
    hash.hash(ctx.args_info.profile_path);
  }

  if (ctx.args_info.profile_use && !hash_profile_data_file(ctx, hash)) {
    log(""No profile data file found"");
    throw Failure(Statistic::no_input_file);
  }

  // Adding -arch to hash since cpp output is affected.
  for (const auto& arch : ctx.args_info.arch_args) {
    hash.hash_delimiter(""-arch"");
    hash.hash(arch);
  }

  optional<Digest> result_name;
  if (direct_mode) {
    // Hash environment variables that affect the preprocessor output.
    const char* envvars[] = {""CPATH"",
                             ""C_INCLUDE_PATH"",
                             ""CPLUS_INCLUDE_PATH"",
                             ""OBJC_INCLUDE_PATH"",
                             ""OBJCPLUS_INCLUDE_PATH"", // clang
                             nullptr};
    for (const char** p = envvars; *p; ++p) {
      const char* v = getenv(*p);
      if (v) {
        hash.hash_delimiter(*p);
        hash.hash(v);
      }
    }

    // Make sure that the direct mode hash is unique for the input file path.
    // If this would not be the case:
    //
    // * An false cache hit may be produced. Scenario:
    //   - a/r.h exists.
    //   - a/x.c has #include ""r.h"".
    //   - b/x.c is identical to a/x.c.
    //   - Compiling a/x.c records a/r.h in the manifest.
    //   - Compiling b/x.c results in a false cache hit since a/x.c and b/x.c
    //     share manifests and a/r.h exists.
    // * The expansion of __FILE__ may be incorrect.
    hash.hash_delimiter(""inputfile"");
    hash.hash(ctx.args_info.input_file);

    hash.hash_delimiter(""sourcecode"");
    int result = hash_source_code_file(ctx, hash, ctx.args_info.input_file);
    if (result & HASH_SOURCE_CODE_ERROR) {
      throw Failure(Statistic::internal_error);
    }
    if (result & HASH_SOURCE_CODE_FOUND_TIME) {
      log(""Disabling direct mode"");
      ctx.config.set_direct_mode(false);
      return nullopt;
    }

    const auto manifest_name = hash.digest();
    ctx.set_manifest_name(manifest_name);

    const auto manifest_file = look_up_cache_file(
      ctx.config.cache_dir(), manifest_name, Manifest::k_file_suffix);
    ctx.set_manifest_path(manifest_file.path);

    if (manifest_file.stat) {
      log(""Looking for result name in {}"", manifest_file.path);
      MTR_BEGIN(""manifest"", ""manifest_get"");
      result_name = Manifest::get(ctx, manifest_file.path);
      MTR_END(""manifest"", ""manifest_get"");
      if (result_name) {
        log(""Got result name from manifest"");
      } else {
        log(""Did not find result name in manifest"");
      }
    } else {
      log(""No manifest with name {} in the cache"", manifest_name.to_string());
    }
  } else {
    if (ctx.args_info.arch_args.empty()) {
      result_name = get_result_name_from_cpp(ctx, preprocessor_args, hash);
      log(""Got result name from preprocessor"");
    } else {
      preprocessor_args.push_back(""-arch"");
      for (size_t i = 0; i < ctx.args_info.arch_args.size(); ++i) {
        preprocessor_args.push_back(ctx.args_info.arch_args[i]);
        result_name = get_result_name_from_cpp(ctx, preprocessor_args, hash);
        log(""Got result name from preprocessor with -arch {}"",
            ctx.args_info.arch_args[i]);
        if (i != ctx.args_info.arch_args.size() - 1) {
          result_name = nullopt;
        }
        preprocessor_args.pop_back();
      }
      preprocessor_args.pop_back();
    }
  }

  return result_name;
}

enum class FromCacheCallMode { direct, cpp };

// Try to return the compile result from cache.
static optional<Statistic>
from_cache(Context& ctx, FromCacheCallMode mode)
{
  UmaskScope umask_scope(ctx.original_umask);

  // The user might be disabling cache hits.
  if (ctx.config.recache()) {
    return nullopt;
  }

  // If we're using Clang, we can't trust a precompiled header object based on
  // running the preprocessor since clang will produce a fatal error when the
  // precompiled header is used and one of the included files has an updated
  // timestamp:
  //
  //     file 'foo.h' has been modified since the precompiled header 'foo.pch'
  //     was built
  if ((ctx.guessed_compiler == GuessedCompiler::clang
       || ctx.guessed_compiler == GuessedCompiler::unknown)
      && ctx.args_info.output_is_precompiled_header
      && !ctx.args_info.fno_pch_timestamp && mode == FromCacheCallMode::cpp) {
    log(""Not considering cached precompiled header in preprocessor mode"");
    return nullopt;
  }

  MTR_BEGIN(""cache"", ""from_cache"");

  // Get result from cache.
  const auto result_file = look_up_cache_file(
    ctx.config.cache_dir(), *ctx.result_name(), Result::k_file_suffix);
  if (!result_file.stat) {
    log(""No result with name {} in the cache"", ctx.result_name()->to_string());
    return nullopt;
  }
  ctx.set_result_path(result_file.path);
  Result::Reader result_reader(result_file.path);
  ResultRetriever result_retriever(
    ctx, should_rewrite_dependency_target(ctx.args_info));

  auto error = result_reader.read(result_retriever);
  MTR_END(""cache"", ""from_cache"");
  if (error) {
    log(""Failed to get result from cache: {}"", *error);
    return nullopt;
  }

  // Update modification timestamp to save file from LRU cleanup.
  Util::update_mtime(*ctx.result_path());

  log(""Succeeded getting cached result"");

  return mode == FromCacheCallMode::direct ? Statistic::direct_cache_hit
                                           : Statistic::preprocessed_cache_hit;
}

// Find the real compiler and put it into ctx.orig_args[0]. We just search the
// PATH to find an executable of the same name that isn't a link to ourselves.
// Pass find_executable function as second parameter.
void
find_compiler(Context& ctx,
              const FindExecutableFunction& find_executable_function)
{
  const std::string orig_first_arg = ctx.orig_args[0];

  // We might be being invoked like ""ccache gcc -c foo.c"".
  std::string base(Util::base_name(ctx.orig_args[0]));
  if (Util::same_program_name(base, CCACHE_NAME)) {
    ctx.orig_args.pop_front();
    if (Util::is_full_path(ctx.orig_args[0])) {
      return;
    }
    base = std::string(Util::base_name(ctx.orig_args[0]));
  }

  // Support user override of the compiler.
  if (!ctx.config.compiler().empty()) {
    base = ctx.config.compiler();
  }

  std::string compiler = find_executable_function(ctx, base, CCACHE_NAME);
  if (compiler.empty()) {
    throw Fatal(""Could not find compiler \""{}\"" in PATH"", base);
  }
  if (compiler == orig_first_arg) {
    throw Fatal(
      ""Recursive invocation (the name of the ccache binary must be \""{}\"")"",
      CCACHE_NAME);
  }
  ctx.orig_args[0] = compiler;
}

static std::string
default_cache_dir(const std::string& home_dir)
{
#ifdef _WIN32
  return home_dir + ""/ccache"";
#elif defined(__APPLE__)
  return home_dir + ""/Library/Caches/ccache"";
#else
  return home_dir + ""/.cache/ccache"";
#endif
}

static std::string
default_config_dir(const std::string& home_dir)
{
#ifdef _WIN32
  return home_dir + ""/ccache"";
#elif defined(__APPLE__)
  return home_dir + ""/Library/Preferences/ccache"";
#else
  return home_dir + ""/.config/ccache"";
#endif
}

// Read config file(s), populate variables, create configuration file in cache
// directory if missing, etc.
static void
set_up_config(Config& config)
{
  const std::string home_dir = Util::get_home_directory();
  const std::string legacy_ccache_dir = home_dir + ""/.ccache"";
  const bool legacy_ccache_dir_exists =
    Stat::stat(legacy_ccache_dir).is_directory();
  const char* const env_xdg_cache_home = getenv(""XDG_CACHE_HOME"");
  const char* const env_xdg_config_home = getenv(""XDG_CONFIG_HOME"");

  const char* env_ccache_configpath = getenv(""CCACHE_CONFIGPATH"");
  if (env_ccache_configpath) {
    config.set_primary_config_path(env_ccache_configpath);
  } else {
    // Only used for ccache tests:
    const char* const env_ccache_configpath2 = getenv(""CCACHE_CONFIGPATH2"");

    config.set_secondary_config_path(
      env_ccache_configpath2 ? env_ccache_configpath2
                             : fmt::format(""{}/ccache.conf"", SYSCONFDIR));
    MTR_BEGIN(""config"", ""conf_read_secondary"");
    // A missing config file in SYSCONFDIR is OK so don't check return value.
    config.update_from_file(config.secondary_config_path());
    MTR_END(""config"", ""conf_read_secondary"");

    const char* const env_ccache_dir = getenv(""CCACHE_DIR"");
    std::string primary_config_dir;
    if (env_ccache_dir && *env_ccache_dir) {
      primary_config_dir = env_ccache_dir;
    } else if (!config.cache_dir().empty() && !env_ccache_dir) {
      primary_config_dir = config.cache_dir();
    } else if (legacy_ccache_dir_exists) {
      primary_config_dir = legacy_ccache_dir;
    } else if (env_xdg_config_home) {
      primary_config_dir = fmt::format(""{}/ccache"", env_xdg_config_home);
    } else {
      primary_config_dir = default_config_dir(home_dir);
    }
    config.set_primary_config_path(primary_config_dir + ""/ccache.conf"");
  }

  const std::string& cache_dir_before_primary_config = config.cache_dir();

  MTR_BEGIN(""config"", ""conf_read_primary"");
  config.update_from_file(config.primary_config_path());
  MTR_END(""config"", ""conf_read_primary"");

  // Ignore cache_dir set in primary config.
  config.set_cache_dir(cache_dir_before_primary_config);

  MTR_BEGIN(""config"", ""conf_update_from_environment"");
  config.update_from_environment();
  // (config.cache_dir is set above if CCACHE_DIR is set.)
  MTR_END(""config"", ""conf_update_from_environment"");

  if (config.cache_dir().empty()) {
    if (legacy_ccache_dir_exists) {
      config.set_cache_dir(legacy_ccache_dir);
    } else if (env_xdg_cache_home) {
      config.set_cache_dir(fmt::format(""{}/ccache"", env_xdg_cache_home));
    } else {
      config.set_cache_dir(default_cache_dir(home_dir));
    }
  }
  // else: cache_dir was set explicitly via environment or via secondary config.

  // We have now determined config.cache_dir and populated the rest of config in
  // prio order (1. environment, 2. primary config, 3. secondary config).
}

static void
set_up_context(Context& ctx, int argc, const char* const* argv)
{
  ctx.orig_args = Args::from_argv(argc, argv);
  ctx.ignore_header_paths = Util::split_into_strings(
    ctx.config.ignore_headers_in_manifest(), PATH_DELIM);
  ctx.set_ignore_options(
    Util::split_into_strings(ctx.config.ignore_options(), "" ""));
}

// Initialize ccache, must be called once before anything else is run.
static void
initialize(Context& ctx, int argc, const char* const* argv)
{
  set_up_config(ctx.config);
  set_up_context(ctx, argc, argv);
  Logging::init(ctx.config);

  // Set default umask for all files created by ccache from now on (if
  // configured to). This is intentionally done after calling init_log so that
  // the log file won't be affected by the umask but before creating the initial
  // configuration file. The intention is that all files and directories in the
  // cache directory should be affected by the configured umask and that no
  // other files and directories should.
  if (ctx.config.umask() != std::numeric_limits<uint32_t>::max()) {
    ctx.original_umask = umask(ctx.config.umask());
  }

  log(""=== CCACHE {} STARTED ========================================="",
      CCACHE_VERSION);

  if (getenv(""CCACHE_INTERNAL_TRACE"")) {
#ifdef MTR_ENABLED
    ctx.mini_trace = std::make_unique<MiniTrace>(ctx.args_info);
#else
    log(""Error: tracing is not enabled!"");
#endif
  }
}

// Make a copy of stderr that will not be cached, so things like distcc can
// send networking errors to it.
static void
set_up_uncached_err()
{
  int uncached_fd =
    dup(STDERR_FILENO); // The file descriptor is intentionally leaked.
  if (uncached_fd == -1) {
    log(""dup(2) failed: {}"", strerror(errno));
    throw Failure(Statistic::internal_error);
  }

  Util::setenv(""UNCACHED_ERR_FD"", fmt::format(""{}"", uncached_fd));
}

static void
configuration_logger(const std::string& key,
                     const std::string& value,
                     const std::string& origin)
{
  Logging::bulk_log(""Config: ({}) {} = {}"", origin, key, value);
}

static void
configuration_printer(const std::string& key,
                      const std::string& value,
                      const std::string& origin)
{
  fmt::print(""({}) {} = {}\n"", origin, key, value);
}

static int cache_compilation(int argc, const char* const* argv);
static Statistic do_cache_compilation(Context& ctx, const char* const* argv);

static uint8_t
calculate_wanted_cache_level(uint64_t files_in_level_1)
{
  uint64_t files_per_directory = files_in_level_1 / 16;
  for (uint8_t i = k_min_cache_levels; i <= k_max_cache_levels; ++i) {
    if (files_per_directory < k_max_cache_files_per_directory) {
      return i;
    }
    files_per_directory /= 16;
  }
  return k_max_cache_levels;
}

static optional<Counters>
update_stats_and_maybe_move_cache_file(const Context& ctx,
                                       const Digest& name,
                                       const std::string& current_path,
                                       const Counters& counter_updates,
                                       const std::string& file_suffix)
{
  if (counter_updates.all_zero()) {
    return nullopt;
  }

  // Use stats file in the level one subdirectory for cache bookkeeping counters
  // since cleanup is performed on level one. Use stats file in the level two
  // subdirectory for other counters to reduce lock contention.
  const bool updated_file_size_or_count =
    counter_updates.get(Statistic::cache_size_kibibyte) != 0
    || counter_updates.get(Statistic::files_in_cache) != 0;
  std::string level_string = fmt::format(""{:x}"", name.bytes()[0] >> 4);
  if (!updated_file_size_or_count) {
    level_string += fmt::format(""/{:x}"", name.bytes()[0] & 0xF);
  }
  const auto stats_file =
    fmt::format(""{}/{}/stats"", ctx.config.cache_dir(), level_string);

  auto counters =
    Statistics::update(stats_file, [&counter_updates](Counters& cs) {
      cs.increment(counter_updates);
    });
  if (!counters) {
    return nullopt;
  }

  const auto wanted_level =
    calculate_wanted_cache_level(counters->get(Statistic::files_in_cache));
  const auto wanted_path = Util::get_path_in_cache(
    ctx.config.cache_dir(), wanted_level, name.to_string() + file_suffix);
  if (current_path != wanted_path) {
    Util::ensure_dir_exists(Util::dir_name(wanted_path));
    log(""Moving {} to {}"", current_path, wanted_path);
    try {
      Util::rename(current_path, wanted_path);
    } catch (const Error&) {
      // Two ccache processes may move the file at the same time, so failure to
      // rename is OK.
    }
  }
  return counters;
}

static void
finalize_stats_and_trigger_cleanup(Context& ctx)
{
  const auto& config = ctx.config;

  if (config.disable()) {
    // Just log result, don't update statistics.
    log(""Result: disabled"");
    return;
  }

  if (!config.log_file().empty() || config.debug()) {
    const auto result = Statistics::get_result(ctx.counter_updates);
    if (result) {
      log(""Result: {}"", *result);
    }
  }

  if (!config.stats()) {
    return;
  }

  if (!ctx.result_path()) {
    ASSERT(ctx.counter_updates.get(Statistic::cache_size_kibibyte) == 0);
    ASSERT(ctx.counter_updates.get(Statistic::files_in_cache) == 0);

    // Context::set_result_path hasn't been called yet, so we just choose one of
    // the stats files in the 256 level 2 directories.
    const auto bucket = getpid() % 256;
    const auto stats_file = fmt::format(
      ""{}/{:x}/{:x}/stats"", config.cache_dir(), bucket / 16, bucket % 16);
    Statistics::update(
      stats_file, [&ctx](Counters& cs) { cs.increment(ctx.counter_updates); });
    return;
  }

  if (ctx.manifest_path()) {
    update_stats_and_maybe_move_cache_file(ctx,
                                           *ctx.manifest_name(),
                                           *ctx.manifest_path(),
                                           ctx.manifest_counter_updates,
                                           Manifest::k_file_suffix);
  }

  const auto counters =
    update_stats_and_maybe_move_cache_file(ctx,
                                           *ctx.result_name(),
                                           *ctx.result_path(),
                                           ctx.counter_updates,
                                           Result::k_file_suffix);
  if (!counters) {
    return;
  }

  const auto subdir = fmt::format(
    ""{}/{:x}"", config.cache_dir(), ctx.result_name()->bytes()[0] >> 4);
  bool need_cleanup = false;

  if (config.max_files() != 0
      && counters->get(Statistic::files_in_cache) > config.max_files() / 16) {
    log(""Need to clean up {} since it holds {} files (limit: {} files)"",
        subdir,
        counters->get(Statistic::files_in_cache),
        config.max_files() / 16);
    need_cleanup = true;
  }
  if (config.max_size() != 0
      && counters->get(Statistic::cache_size_kibibyte)
           > config.max_size() / 1024 / 16) {
    log(""Need to clean up {} since it holds {} KiB (limit: {} KiB)"",
        subdir,
        counters->get(Statistic::cache_size_kibibyte),
        config.max_size() / 1024 / 16);
    need_cleanup = true;
  }

  if (need_cleanup) {
    const double factor = config.limit_multiple() / 16;
    const uint64_t max_size = round(config.max_size() * factor);
    const uint32_t max_files = round(config.max_files() * factor);
    const time_t max_age = 0;
    clean_up_dir(
      subdir, max_size, max_files, max_age, [](double /*progress*/) {});
  }
}

static void
finalize_at_exit(Context& ctx)
{
  try {
    finalize_stats_and_trigger_cleanup(ctx);
  } catch (const ErrorBase& e) {
    // finalize_at_exit must not throw since it's called by a destructor.
    log(""Error while finalizing stats: {}"", e.what());
  }

  // Dump log buffer last to not lose any logs.
  if (ctx.config.debug() && !ctx.args_info.output_obj.empty()) {
    const auto path = fmt::format(""{}.ccache-log"", ctx.args_info.output_obj);
    Logging::dump_log(path);
  }
}

// The entry point when invoked to cache a compilation.
static int
cache_compilation(int argc, const char* const* argv)
{
  tzset(); // Needed for localtime_r.

  bool fall_back_to_original_compiler = false;
  Args saved_orig_args;

  {
    Context ctx;
    SignalHandler signal_handler(ctx);
    Finalizer finalizer([&ctx] { finalize_at_exit(ctx); });

    initialize(ctx, argc, argv);

    MTR_BEGIN(""main"", ""find_compiler"");
    find_compiler(ctx, &find_executable);
    MTR_END(""main"", ""find_compiler"");

    try {
      Statistic statistic = do_cache_compilation(ctx, argv);
      ctx.counter_updates.increment(statistic);
    } catch (const Failure& e) {
      if (e.statistic() != Statistic::none) {
        ctx.counter_updates.increment(e.statistic());
      }

      if (e.exit_code()) {
        return *e.exit_code();
      }
      // Else: Fall back to running the real compiler.
      fall_back_to_original_compiler = true;

      if (ctx.original_umask) {
        umask(*ctx.original_umask);
      }

      ASSERT(!ctx.orig_args.empty());

      ctx.orig_args.erase_with_prefix(""--ccache-"");
      add_prefix(ctx, ctx.orig_args, ctx.config.prefix_command());

      log(""Failed; falling back to running the real compiler"");

      saved_orig_args = std::move(ctx.orig_args);
      auto execv_argv = saved_orig_args.to_argv();
      log(""Executing {}"", Util::format_argv_for_logging(execv_argv.data()));
      // Run execv below after ctx and finalizer have been destructed.
    }
  }

  if (fall_back_to_original_compiler) {
    auto execv_argv = saved_orig_args.to_argv();
    execv(execv_argv[0], const_cast<char* const*>(execv_argv.data()));
    throw Fatal(""execv of {} failed: {}"", execv_argv[0], strerror(errno));
  }

  return EXIT_SUCCESS;
}

static Statistic
do_cache_compilation(Context& ctx, const char* const* argv)
{
  if (ctx.actual_cwd.empty()) {
    log(""Unable to determine current working directory: {}"", strerror(errno));
    throw Failure(Statistic::internal_error);
  }

  MTR_BEGIN(""main"", ""clean_up_internal_tempdir"");
  if (ctx.config.temporary_dir() == ctx.config.cache_dir() + ""/tmp"") {
    clean_up_internal_tempdir(ctx.config);
  }
  MTR_END(""main"", ""clean_up_internal_tempdir"");

  if (!ctx.config.log_file().empty() || ctx.config.debug()) {
    ctx.config.visit_items(configuration_logger);
  }

  if (ctx.config.disable()) {
    log(""ccache is disabled"");
    // Statistic::cache_miss is a dummy to trigger stats_flush.
    throw Failure(Statistic::cache_miss);
  }

  MTR_BEGIN(""main"", ""set_up_uncached_err"");
  set_up_uncached_err();
  MTR_END(""main"", ""set_up_uncached_err"");

  log(""Command line: {}"", Util::format_argv_for_logging(argv));
  log(""Hostname: {}"", Util::get_hostname());
  log(""Working directory: {}"", ctx.actual_cwd);
  if (ctx.apparent_cwd != ctx.actual_cwd) {
    log(""Apparent working directory: {}"", ctx.apparent_cwd);
  }

  ctx.config.set_limit_multiple(
    Util::clamp(ctx.config.limit_multiple(), 0.0, 1.0));

  MTR_BEGIN(""main"", ""guess_compiler"");
  ctx.guessed_compiler = guess_compiler(ctx.orig_args[0]);
  MTR_END(""main"", ""guess_compiler"");

  MTR_BEGIN(""main"", ""process_args"");
  ProcessArgsResult processed = process_args(ctx);
  MTR_END(""main"", ""process_args"");

  if (processed.error) {
    throw Failure(*processed.error);
  }

  if (ctx.config.depend_mode()
      && (!ctx.args_info.generating_dependencies
          || ctx.args_info.output_dep == ""/dev/null""
          || !ctx.config.run_second_cpp())) {
    log(""Disabling depend mode"");
    ctx.config.set_depend_mode(false);
  }

  log(""Source file: {}"", ctx.args_info.input_file);
  if (ctx.args_info.generating_dependencies) {
    log(""Dependency file: {}"", ctx.args_info.output_dep);
  }
  if (ctx.args_info.generating_coverage) {
    log(""Coverage file: {}"", ctx.args_info.output_cov);
  }
  if (ctx.args_info.generating_stackusage) {
    log(""Stack usage file: {}"", ctx.args_info.output_su);
  }
  if (ctx.args_info.generating_diagnostics) {
    log(""Diagnostics file: {}"", ctx.args_info.output_dia);
  }
  if (!ctx.args_info.output_dwo.empty()) {
    log(""Split dwarf file: {}"", ctx.args_info.output_dwo);
  }

  log(""Object file: {}"", ctx.args_info.output_obj);
  MTR_META_THREAD_NAME(ctx.args_info.output_obj.c_str());

  if (ctx.config.debug()) {
    std::string path =
      fmt::format(""{}.ccache-input-text"", ctx.args_info.output_obj);
    File debug_text_file(path, ""w"");
    if (debug_text_file) {
      ctx.hash_debug_files.push_back(std::move(debug_text_file));
    } else {
      log(""Failed to open {}: {}"", path, strerror(errno));
    }
  }

  FILE* debug_text_file = !ctx.hash_debug_files.empty()
                            ? ctx.hash_debug_files.front().get()
                            : nullptr;

  Hash common_hash;
  init_hash_debug(
    ctx, common_hash, ctx.args_info.output_obj, 'c', ""COMMON"", debug_text_file);

  MTR_BEGIN(""hash"", ""common_hash"");
  hash_common_info(
    ctx, processed.preprocessor_args, common_hash, ctx.args_info);
  MTR_END(""hash"", ""common_hash"");

  // Try to find the hash using the manifest.
  Hash direct_hash = common_hash;
  init_hash_debug(ctx,
                  direct_hash,
                  ctx.args_info.output_obj,
                  'd',
                  ""DIRECT MODE"",
                  debug_text_file);

  Args args_to_hash = processed.preprocessor_args;
  args_to_hash.push_back(processed.extra_args_to_hash);

  bool put_result_in_manifest = false;
  optional<Digest> result_name;
  optional<Digest> result_name_from_manifest;
  if (ctx.config.direct_mode()) {
    log(""Trying direct lookup"");
    MTR_BEGIN(""hash"", ""direct_hash"");
    Args dummy_args;
    result_name =
      calculate_result_name(ctx, args_to_hash, dummy_args, direct_hash, true);
    MTR_END(""hash"", ""direct_hash"");
    if (result_name) {
      ctx.set_result_name(*result_name);

      // If we can return from cache at this point then do so.
      auto result = from_cache(ctx, FromCacheCallMode::direct);
      if (result) {
        return *result;
      }

      // Wasn't able to return from cache at this point. However, the result
      // was already found in manifest, so don't re-add it later.
      put_result_in_manifest = false;

      result_name_from_manifest = result_name;
    } else {
      // Add result to manifest later.
      put_result_in_manifest = true;
    }
  }

  if (ctx.config.read_only_direct()) {
    log(""Read-only direct mode; running real compiler"");
    throw Failure(Statistic::cache_miss);
  }

  if (!ctx.config.depend_mode()) {
    // Find the hash using the preprocessed output. Also updates
    // ctx.included_files.
    Hash cpp_hash = common_hash;
    init_hash_debug(ctx,
                    cpp_hash,
                    ctx.args_info.output_obj,
                    'p',
                    ""PREPROCESSOR MODE"",
                    debug_text_file);

    MTR_BEGIN(""hash"", ""cpp_hash"");
    result_name = calculate_result_name(
      ctx, args_to_hash, processed.preprocessor_args, cpp_hash, false);
    MTR_END(""hash"", ""cpp_hash"");

    // calculate_result_name does not return nullopt if the last (direct_mode)
    // argument is false.
    ASSERT(result_name);
    ctx.set_result_name(*result_name);

    if (result_name_from_manifest && result_name_from_manifest != result_name) {
      // manifest_path is guaranteed to be set when calculate_result_name
      // returns a non-nullopt result in direct mode, i.e. when
      // result_name_from_manifest is set.
      ASSERT(ctx.manifest_path());

      // The hash from manifest differs from the hash of the preprocessor
      // output. This could be because:
      //
      // - The preprocessor produces different output for the same input (not
      //   likely).
      // - There's a bug in ccache (maybe incorrect handling of compiler
      //   arguments).
      // - The user has used a different CCACHE_BASEDIR (most likely).
      //
      // The best thing here would probably be to remove the hash entry from
      // the manifest. For now, we use a simpler method: just remove the
      // manifest file.
      log(""Hash from manifest doesn't match preprocessor output"");
      log(""Likely reason: different CCACHE_BASEDIRs used"");
      log(""Removing manifest as a safety measure"");
      Util::unlink_safe(*ctx.manifest_path());

      put_result_in_manifest = true;
    }

    // If we can return from cache at this point then do.
    auto result = from_cache(ctx, FromCacheCallMode::cpp);
    if (result) {
      if (put_result_in_manifest) {
        update_manifest_file(ctx);
      }
      return *result;
    }
  }

  if (ctx.config.read_only()) {
    log(""Read-only mode; running real compiler"");
    throw Failure(Statistic::cache_miss);
  }

  add_prefix(ctx, processed.compiler_args, ctx.config.prefix_command());

  // In depend_mode, extend the direct hash.
  Hash* depend_mode_hash = ctx.config.depend_mode() ? &direct_hash : nullptr;

  // Run real compiler, sending output to cache.
  MTR_BEGIN(""cache"", ""to_cache"");
  to_cache(ctx,
           processed.compiler_args,
           ctx.args_info.depend_extra_args,
           depend_mode_hash);
  update_manifest_file(ctx);
  MTR_END(""cache"", ""to_cache"");

  return Statistic::cache_miss;
}

// The main program when not doing a compile.
static int
handle_main_options(int argc, const char* const* argv)
{
  enum longopts {
    CHECKSUM_FILE,
    DUMP_MANIFEST,
    DUMP_RESULT,
    EVICT_OLDER_THAN,
    EXTRACT_RESULT,
    HASH_FILE,
    PRINT_STATS,
  };
  static const struct option options[] = {
    {""checksum-file"", required_argument, nullptr, CHECKSUM_FILE},
    {""cleanup"", no_argument, nullptr, 'c'},
    {""clear"", no_argument, nullptr, 'C'},
    {""directory"", no_argument, nullptr, 'd'},
    {""dump-manifest"", required_argument, nullptr, DUMP_MANIFEST},
    {""dump-result"", required_argument, nullptr, DUMP_RESULT},
    {""evict-older-than"", required_argument, nullptr, EVICT_OLDER_THAN},
    {""extract-result"", required_argument, nullptr, EXTRACT_RESULT},
    {""get-config"", required_argument, nullptr, 'k'},
    {""hash-file"", required_argument, nullptr, HASH_FILE},
    {""help"", no_argument, nullptr, 'h'},
    {""max-files"", required_argument, nullptr, 'F'},
    {""max-size"", required_argument, nullptr, 'M'},
    {""print-stats"", no_argument, nullptr, PRINT_STATS},
    {""recompress"", required_argument, nullptr, 'X'},
    {""set-config"", required_argument, nullptr, 'o'},
    {""show-compression"", no_argument, nullptr, 'x'},
    {""show-config"", no_argument, nullptr, 'p'},
    {""show-stats"", no_argument, nullptr, 's'},
    {""version"", no_argument, nullptr, 'V'},
    {""zero-stats"", no_argument, nullptr, 'z'},
    {nullptr, 0, nullptr, 0}};

  Context ctx;
  initialize(ctx, argc, argv);

  int c;
  while ((c = getopt_long(argc,
                          const_cast<char* const*>(argv),
                          ""cCd:k:hF:M:po:sVxX:z"",
                          options,
                          nullptr))
         != -1) {
    std::string arg = optarg ? optarg : std::string();

    switch (c) {
    case CHECKSUM_FILE: {
      Checksum checksum;
      Fd fd(arg == ""-"" ? STDIN_FILENO : open(arg.c_str(), O_RDONLY));
      Util::read_fd(*fd, [&checksum](const void* data, size_t size) {
        checksum.update(data, size);
      });
      fmt::print(""{:016x}\n"", checksum.digest());
      break;
    }

    case DUMP_MANIFEST:
      return Manifest::dump(arg, stdout) ? 0 : 1;

    case DUMP_RESULT: {
      ResultDumper result_dumper(stdout);
      Result::Reader result_reader(arg);
      auto error = result_reader.read(result_dumper);
      if (error) {
        fmt::print(stderr, ""Error: {}\n"", *error);
      }
      return error ? EXIT_FAILURE : EXIT_SUCCESS;
    }

    case EVICT_OLDER_THAN: {
      auto seconds = Util::parse_duration(arg);
      ProgressBar progress_bar(""Evicting..."");
      clean_old(
        ctx, [&](double progress) { progress_bar.update(progress); }, seconds);
      if (isatty(STDOUT_FILENO)) {
        fmt::print(""\n"");
      }
      break;
    }

    case EXTRACT_RESULT: {
      ResultExtractor result_extractor(""."");
      Result::Reader result_reader(arg);
      auto error = result_reader.read(result_extractor);
      if (error) {
        fmt::print(stderr, ""Error: {}\n"", *error);
      }
      return error ? EXIT_FAILURE : EXIT_SUCCESS;
    }

    case HASH_FILE: {
      Hash hash;
      if (arg == ""-"") {
        hash.hash_fd(STDIN_FILENO);
      } else {
        hash.hash_file(arg);
      }
      fmt::print(""{}\n"", hash.digest().to_string());
      break;
    }

    case PRINT_STATS:
      fmt::print(Statistics::format_machine_readable(ctx.config));
      break;

    case 'c': // --cleanup
    {
      ProgressBar progress_bar(""Cleaning..."");
      clean_up_all(ctx.config,
                   [&](double progress) { progress_bar.update(progress); });
      if (isatty(STDOUT_FILENO)) {
        fmt::print(""\n"");
      }
      break;
    }

    case 'C': // --clear
    {
      ProgressBar progress_bar(""Clearing..."");
      wipe_all(ctx, [&](double progress) { progress_bar.update(progress); });
      if (isatty(STDOUT_FILENO)) {
        fmt::print(""\n"");
      }
      break;
    }

    case 'd': // --directory
      Util::setenv(""CCACHE_DIR"", arg);
      break;

    case 'h': // --help
      fmt::print(stdout, USAGE_TEXT, CCACHE_NAME, CCACHE_NAME);
      exit(EXIT_SUCCESS);

    case 'k': // --get-config
      fmt::print(""{}\n"", ctx.config.get_string_value(arg));
      break;

    case 'F': { // --max-files
      auto files = Util::parse_unsigned(arg);
      Config::set_value_in_file(
        ctx.config.primary_config_path(), ""max_files"", arg);
      if (files == 0) {
        fmt::print(""Unset cache file limit\n"");
      } else {
        fmt::print(""Set cache file limit to {}\n"", files);
      }
      break;
    }

    case 'M': { // --max-size
      uint64_t size = Util::parse_size(arg);
      Config::set_value_in_file(
        ctx.config.primary_config_path(), ""max_size"", arg);
      if (size == 0) {
        fmt::print(""Unset cache size limit\n"");
      } else {
        fmt::print(""Set cache size limit to {}\n"",
                   Util::format_human_readable_size(size));
      }
      break;
    }

    case 'o': { // --set-config
      // Start searching for equal sign at position 1 to improve error message
      // for the -o=K=V case (key ""=K"" and value ""V"").
      size_t eq_pos = arg.find('=', 1);
      if (eq_pos == std::string::npos) {
        throw Error(""missing equal sign in \""{}\"""", arg);
      }
      std::string key = arg.substr(0, eq_pos);
      std::string value = arg.substr(eq_pos + 1);
      Config::set_value_in_file(ctx.config.primary_config_path(), key, value);
      break;
    }

    case 'p': // --show-config
      ctx.config.visit_items(configuration_printer);
      break;

    case 's': // --show-stats
      fmt::print(Statistics::format_human_readable(ctx.config));
      break;

    case 'V': // --version
      fmt::print(VERSION_TEXT, CCACHE_NAME, CCACHE_VERSION);
      exit(EXIT_SUCCESS);

    case 'x': // --show-compression
    {
      ProgressBar progress_bar(""Scanning..."");
      compress_stats(ctx.config,
                     [&](double progress) { progress_bar.update(progress); });
      break;
    }

    case 'X': // --recompress
    {
      optional<int8_t> wanted_level;
      if (arg == ""uncompressed"") {
        wanted_level = nullopt;
      } else {
        wanted_level =
          Util::parse_signed(arg, INT8_MIN, INT8_MAX, ""compression level"");
      }

      ProgressBar progress_bar(""Recompressing..."");
      compress_recompress(ctx, wanted_level, [&](double progress) {
        progress_bar.update(progress);
      });
      break;
    }

    case 'z': // --zero-stats
      Statistics::zero_all_counters(ctx.config);
      fmt::print(""Statistics zeroed\n"");
      break;

    default:
      fmt::print(stderr, USAGE_TEXT, CCACHE_NAME, CCACHE_NAME);
      exit(EXIT_FAILURE);
    }

    // Some of the above switches might have changed config settings, so run the
    // setup again.
    ctx.config = Config();
    set_up_config(ctx.config);
  }

  return 0;
}

int ccache_main(int argc, const char* const* argv);

int
ccache_main(int argc, const char* const* argv)
{
  try {
    // Check if we are being invoked as ""ccache"".
    std::string program_name(Util::base_name(argv[0]));
    if (Util::same_program_name(program_name, CCACHE_NAME)) {
      if (argc < 2) {
        fmt::print(stderr, USAGE_TEXT, CCACHE_NAME, CCACHE_NAME);
        exit(EXIT_FAILURE);
      }
      // If the first argument isn't an option, then assume we are being passed
      // a compiler name and options.
      if (argv[1][0] == '-') {
        return handle_main_options(argc, argv);
      }
    }

    return cache_compilation(argc, argv);
  } catch (const ErrorBase& e) {
    fmt::print(stderr, ""ccache: error: {}\n"", e.what());
    return EXIT_FAILURE;
  }
}
""",to_cache,[844:1045]
ccache,https://github.com/ccache/ccache/commit/971f1183568afd12af714936546c602940279c28,"""Canonicalize header path earlier to improve performance (#838)

The ctx.included_files.find(path) check was done before removing the ""./"" prefix
from the path, leading to decreased performance for such headers since the check
would always fail for such paths.""","""// Copyright (C) 2002-2007 Andrew Tridgell
// Copyright (C) 2009-2021 Joel Rosdahl and other contributors
//
// See doc/AUTHORS.adoc for a complete list of contributors.
//
// This program is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by the Free
// Software Foundation; either version 3 of the License, or (at your option)
// any later version.
//
// This program is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
// more details.
//
// You should have received a copy of the GNU General Public License along with
// this program; if not, write to the Free Software Foundation, Inc., 51
// Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA

#include ""ccache.hpp""

#include ""Args.hpp""
#include ""ArgsInfo.hpp""
#include ""Checksum.hpp""
#include ""Compression.hpp""
#include ""Context.hpp""
#include ""Depfile.hpp""
#include ""Fd.hpp""
#include ""File.hpp""
#include ""Finalizer.hpp""
#include ""FormatNonstdStringView.hpp""
#include ""Hash.hpp""
#include ""Lockfile.hpp""
#include ""Logging.hpp""
#include ""Manifest.hpp""
#include ""MiniTrace.hpp""
#include ""ProgressBar.hpp""
#include ""Result.hpp""
#include ""ResultDumper.hpp""
#include ""ResultExtractor.hpp""
#include ""ResultRetriever.hpp""
#include ""SignalHandler.hpp""
#include ""Statistics.hpp""
#include ""StdMakeUnique.hpp""
#include ""TemporaryFile.hpp""
#include ""UmaskScope.hpp""
#include ""Util.hpp""
#include ""argprocessing.hpp""
#include ""cleanup.hpp""
#include ""compopt.hpp""
#include ""compress.hpp""
#include ""exceptions.hpp""
#include ""execute.hpp""
#include ""fmtmacros.hpp""
#include ""hashutil.hpp""
#include ""language.hpp""

#include ""third_party/fmt/core.h""
#include ""third_party/nonstd/optional.hpp""
#include ""third_party/nonstd/string_view.hpp""

#ifdef HAVE_GETOPT_LONG
#  include <getopt.h>
#elif defined(_WIN32)
#  include ""third_party/win32/getopt.h""
#else
extern ""C"" {
#  include ""third_party/getopt_long.h""
}
#endif

#ifdef _WIN32
#  include ""Win32Util.hpp""
#endif

#include <algorithm>
#include <cmath>
#include <limits>

#ifndef MYNAME
#  define MYNAME ""ccache""
#endif
const char CCACHE_NAME[] = MYNAME;

using nonstd::nullopt;
using nonstd::optional;
using nonstd::string_view;

constexpr const char VERSION_TEXT[] =
  R""({} version {}

Copyright (C) 2002-2007 Andrew Tridgell
Copyright (C) 2009-2021 Joel Rosdahl and other contributors

See <https://ccache.dev/credits.html> for a complete list of contributors.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 3 of the License, or (at your option) any later
version.
)"";

constexpr const char USAGE_TEXT[] =
  R""(Usage:
    {} [options]
    {} compiler [compiler options]
    compiler [compiler options]          (via symbolic link)

Common options:
    -c, --cleanup              delete old files and recalculate size counters
                               (normally not needed as this is done
                               automatically)
    -C, --clear                clear the cache completely (except configuration)
        --config-path PATH     operate on configuration file PATH instead of the
                               default
    -d, --directory PATH       operate on cache directory PATH instead of the
                               default
        --evict-older-than AGE remove files older than AGE (unsigned integer
                               with a d (days) or s (seconds) suffix)
    -F, --max-files NUM        set maximum number of files in cache to NUM (use
                               0 for no limit)
    -M, --max-size SIZE        set maximum size of cache to SIZE (use 0 for no
                               limit); available suffixes: k, M, G, T (decimal)
                               and Ki, Mi, Gi, Ti (binary); default suffix: G
    -X, --recompress LEVEL     recompress the cache to level LEVEL (integer or
                               ""uncompressed"") using the Zstandard algorithm;
                               see ""Cache compression"" in the manual for details
    -o, --set-config KEY=VAL   set configuration item KEY to value VAL
    -x, --show-compression     show compression statistics
    -p, --show-config          show current configuration options in
                               human-readable format
    -s, --show-stats           show summary of configuration and statistics
                               counters in human-readable format
    -z, --zero-stats           zero statistics counters

    -h, --help                 print this help text
    -V, --version              print version and copyright information

Options for scripting or debugging:
        --checksum-file PATH   print the checksum (64 bit XXH3) of the file at
                               PATH
        --dump-manifest PATH   dump manifest file at PATH in text format
        --dump-result PATH     dump result file at PATH in text format
        --extract-result PATH  extract data stored in result file at PATH to the
                               current working directory
    -k, --get-config KEY       print the value of configuration key KEY
        --hash-file PATH       print the hash (160 bit BLAKE3) of the file at
                               PATH
        --print-stats          print statistics counter IDs and corresponding
                               values in machine-parsable format

See also the manual on <https://ccache.dev/documentation.html>.
)"";

// How often (in seconds) to scan $CCACHE_DIR/tmp for left-over temporary
// files.
const int k_tempdir_cleanup_interval = 2 * 24 * 60 * 60; // 2 days

// Maximum files per cache directory. This constant is somewhat arbitrarily
// chosen to be large enough to avoid unnecessary cache levels but small enough
// not to make esoteric file systems (with bad performance for large
// directories) too slow. It could be made configurable, but hopefully there
// will be no need to do that.
const uint64_t k_max_cache_files_per_directory = 2000;

// Minimum number of cache levels ($CCACHE_DIR/1/2/stored_file).
const uint8_t k_min_cache_levels = 2;

// Maximum number of cache levels ($CCACHE_DIR/1/2/3/stored_file).
//
// On a cache miss, (k_max_cache_levels - k_min_cache_levels + 1) cache lookups
// (i.e. stat system calls) will be performed for a cache entry.
//
// An assumption made here is that if a cache is so large that it holds more
// than 16^4 * k_max_cache_files_per_directory files then we can assume that the
// file system is sane enough to handle more than
// k_max_cache_files_per_directory.
const uint8_t k_max_cache_levels = 4;

// This is a string that identifies the current ""version"" of the hash sum
// computed by ccache. If, for any reason, we want to force the hash sum to be
// different for the same input in a new ccache version, we can just change
// this string. A typical example would be if the format of one of the files
// stored in the cache changes in a backwards-incompatible way.
const char HASH_PREFIX[] = ""3"";

namespace {

// Throw a Failure if ccache did not succeed in getting or putting a result in
// the cache. If `exit_code` is set, just exit with that code directly,
// otherwise execute the real compiler and exit with its exit code. Also updates
// statistics counter `statistic` if it's not `Statistic::none`.
class Failure : public std::exception
{
public:
  Failure(Statistic statistic,
          nonstd::optional<int> exit_code = nonstd::nullopt);

  nonstd::optional<int> exit_code() const;
  Statistic statistic() const;

private:
  Statistic m_statistic;
  nonstd::optional<int> m_exit_code;
};

inline Failure::Failure(Statistic statistic, nonstd::optional<int> exit_code)
  : m_statistic(statistic), m_exit_code(exit_code)
{
}

inline nonstd::optional<int>
Failure::exit_code() const
{
  return m_exit_code;
}

inline Statistic
Failure::statistic() const
{
  return m_statistic;
}

} // namespace

static void
add_prefix(const Context& ctx, Args& args, const std::string& prefix_command)
{
  if (prefix_command.empty()) {
    return;
  }

  Args prefix;
  for (const auto& word : Util::split_into_strings(prefix_command, "" "")) {
    std::string path = find_executable(ctx, word, CCACHE_NAME);
    if (path.empty()) {
      throw Fatal(""{}: {}"", word, strerror(errno));
    }

    prefix.push_back(path);
  }

  LOG(""Using command-line prefix {}"", prefix_command);
  for (size_t i = prefix.size(); i != 0; i--) {
    args.push_front(prefix[i - 1]);
  }
}

static void
clean_up_internal_tempdir(const Config& config)
{
  time_t now = time(nullptr);
  auto dir_st = Stat::stat(config.cache_dir(), Stat::OnError::log);
  if (!dir_st || dir_st.mtime() + k_tempdir_cleanup_interval >= now) {
    // No cleanup needed.
    return;
  }

  Util::update_mtime(config.cache_dir());

  const std::string& temp_dir = config.temporary_dir();
  if (!Stat::lstat(temp_dir)) {
    return;
  }

  Util::traverse(temp_dir, [now](const std::string& path, bool is_dir) {
    if (is_dir) {
      return;
    }
    auto st = Stat::lstat(path, Stat::OnError::log);
    if (st && st.mtime() + k_tempdir_cleanup_interval < now) {
      Util::unlink_tmp(path);
    }
  });
}

static std::string
prepare_debug_path(const std::string& debug_dir,
                   const std::string& output_obj,
                   string_view suffix)
{
  const std::string prefix =
    debug_dir.empty() ? output_obj : debug_dir + Util::real_path(output_obj);
  try {
    Util::ensure_dir_exists(Util::dir_name(prefix));
  } catch (Error&) {
    // Ignore since we can't handle an error in another way in this context. The
    // caller takes care of logging when trying to open the path for writing.
  }
  return FMT(""{}.ccache-{}"", prefix, suffix);
}

static void
init_hash_debug(Context& ctx,
                Hash& hash,
                char type,
                string_view section_name,
                FILE* debug_text_file)
{
  if (!ctx.config.debug()) {
    return;
  }

  const auto path = prepare_debug_path(
    ctx.config.debug_dir(), ctx.args_info.output_obj, FMT(""input-{}"", type));
  File debug_binary_file(path, ""wb"");
  if (debug_binary_file) {
    hash.enable_debug(section_name, debug_binary_file.get(), debug_text_file);
    ctx.hash_debug_files.push_back(std::move(debug_binary_file));
  } else {
    LOG(""Failed to open {}: {}"", path, strerror(errno));
  }
}

CompilerType
guess_compiler(string_view path)
{
  std::string compiler_path(path);

#ifndef _WIN32
  // Follow symlinks to the real compiler to learn its name. We're not using
  // Util::real_path in order to save some unnecessary stat calls.
  while (true) {
    std::string symlink_value = Util::read_link(compiler_path);
    if (symlink_value.empty()) {
      break;
    }
    if (Util::is_absolute_path(symlink_value)) {
      compiler_path = symlink_value;
    } else {
      compiler_path =
        FMT(""{}/{}"", Util::dir_name(compiler_path), symlink_value);
    }
  }
#endif

  const string_view name = Util::base_name(compiler_path);
  if (name.find(""clang"") != nonstd::string_view::npos) {
    return CompilerType::clang;
  } else if (name.find(""gcc"") != nonstd::string_view::npos
             || name.find(""g++"") != nonstd::string_view::npos) {
    return CompilerType::gcc;
  } else if (name.find(""nvcc"") != nonstd::string_view::npos) {
    return CompilerType::nvcc;
  } else if (name == ""pump"" || name == ""distcc-pump"") {
    return CompilerType::pump;
  } else {
    return CompilerType::other;
  }
}

static bool
include_file_too_new(const Context& ctx,
                     const std::string& path,
                     const Stat& path_stat)
{
  // The comparison using >= is intentional, due to a possible race between
  // starting compilation and writing the include file. See also the notes under
  // ""Performance"" in doc/MANUAL.adoc.
  if (!(ctx.config.sloppiness() & SLOPPY_INCLUDE_FILE_MTIME)
      && path_stat.mtime() >= ctx.time_of_compilation) {
    LOG(""Include file {} too new"", path);
    return true;
  }

  // The same >= logic as above applies to the change time of the file.
  if (!(ctx.config.sloppiness() & SLOPPY_INCLUDE_FILE_CTIME)
      && path_stat.ctime() >= ctx.time_of_compilation) {
    LOG(""Include file {} ctime too new"", path);
    return true;
  }

  return false;
}

// Returns false if the include file was ""too new"" and therefore should disable
// the direct mode (or, in the case of a preprocessed header, fall back to just
// running the real compiler), otherwise true.
static bool
do_remember_include_file(Context& ctx,
                         std::string path,
                         Hash& cpp_hash,
                         bool system,
                         Hash* depend_mode_hash)
{
  if (path.length() >= 2 && path[0] == '<' && path[path.length() - 1] == '>') {
    // Typically <built-in> or <command-line>.
    return true;
  }

  if (path == ctx.args_info.input_file) {
    // Don't remember the input file.
    return true;
  }

  if (system && (ctx.config.sloppiness() & SLOPPY_SYSTEM_HEADERS)) {
    // Don't remember this system header.
    return true;
  }

  if (ctx.included_files.find(path) != ctx.included_files.end()) {
    // Already known include file.
    return true;
  }

  // Canonicalize path for comparison; Clang uses ./header.h.
  if (Util::starts_with(path, ""./"")) {
    path.erase(0, 2);
  }

#ifdef _WIN32
  {
    // stat fails on directories on win32.
    DWORD attributes = GetFileAttributes(path.c_str());
    if (attributes != INVALID_FILE_ATTRIBUTES
        && attributes & FILE_ATTRIBUTE_DIRECTORY) {
      return true;
    }
  }
#endif

  auto st = Stat::stat(path, Stat::OnError::log);
  if (!st) {
    return false;
  }
  if (st.is_directory()) {
    // Ignore directory, typically $PWD.
    return true;
  }
  if (!st.is_regular()) {
    // Device, pipe, socket or other strange creature.
    LOG(""Non-regular include file {}"", path);
    return false;
  }

  for (const auto& ignore_header_path : ctx.ignore_header_paths) {
    if (Util::matches_dir_prefix_or_file(ignore_header_path, path)) {
      return true;
    }
  }

  const bool is_pch = Util::is_precompiled_header(path);
  const bool too_new = include_file_too_new(ctx, path, st);

  if (too_new) {
    // Opt out of direct mode because of a race condition.
    //
    // The race condition consists of these events:
    //
    // - the preprocessor is run
    // - an include file is modified by someone
    // - the new include file is hashed by ccache
    // - the real compiler is run on the preprocessor's output, which contains
    //   data from the old header file
    // - the wrong object file is stored in the cache.

    return false;
  }

  // Let's hash the include file content.
  Hash fhash;

  if (is_pch) {
    if (ctx.included_pch_file.empty()) {
      LOG(""Detected use of precompiled header: {}"", path);
    }
    bool using_pch_sum = false;
    if (ctx.config.pch_external_checksum()) {
      // hash pch.sum instead of pch when it exists
      // to prevent hashing a very large .pch file every time
      std::string pch_sum_path = FMT(""{}.sum"", path);
      if (Stat::stat(pch_sum_path, Stat::OnError::log)) {
        path = std::move(pch_sum_path);
        using_pch_sum = true;
        LOG(""Using pch.sum file {}"", path);
      }
    }

    if (!hash_binary_file(ctx, fhash, path)) {
      return false;
    }
    cpp_hash.hash_delimiter(using_pch_sum ? ""pch_sum_hash"" : ""pch_hash"");
    cpp_hash.hash(fhash.digest().to_string());
  }

  if (ctx.config.direct_mode()) {
    if (!is_pch) { // else: the file has already been hashed.
      int result = hash_source_code_file(ctx, fhash, path);
      if (result & HASH_SOURCE_CODE_ERROR
          || result & HASH_SOURCE_CODE_FOUND_TIME) {
        return false;
      }
    }

    Digest d = fhash.digest();
    ctx.included_files.emplace(path, d);

    if (depend_mode_hash) {
      depend_mode_hash->hash_delimiter(""include"");
      depend_mode_hash->hash(d.to_string());
    }
  }

  return true;
}

enum class RememberIncludeFileResult { ok, cannot_use_pch };

// This function hashes an include file and stores the path and hash in
// ctx.included_files. If the include file is a PCH, cpp_hash is also updated.
static RememberIncludeFileResult
remember_include_file(Context& ctx,
                      const std::string& path,
                      Hash& cpp_hash,
                      bool system,
                      Hash* depend_mode_hash)
{
  if (!do_remember_include_file(
        ctx, path, cpp_hash, system, depend_mode_hash)) {
    if (Util::is_precompiled_header(path)) {
      return RememberIncludeFileResult::cannot_use_pch;
    } else if (ctx.config.direct_mode()) {
      LOG_RAW(""Disabling direct mode"");
      ctx.config.set_direct_mode(false);
    }
  }

  return RememberIncludeFileResult::ok;
}

static void
print_included_files(const Context& ctx, FILE* fp)
{
  for (const auto& item : ctx.included_files) {
    PRINT(fp, ""{}\n"", item.first);
  }
}

// This function reads and hashes a file. While doing this, it also does these
// things:
//
// - Makes include file paths for which the base directory is a prefix relative
//   when computing the hash sum.
// - Stores the paths and hashes of included files in ctx.included_files.
//
// Returns Statistic::none on success, otherwise a statistics counter to be
// incremented.
static Statistic
process_preprocessed_file(Context& ctx,
                          Hash& hash,
                          const std::string& path,
                          bool pump)
{
  std::string data;
  try {
    data = Util::read_file(path);
  } catch (Error&) {
    return Statistic::internal_error;
  }

  // Bytes between p and q are pending to be hashed.
  const char* p = &data[0];
  char* q = &data[0];
  const char* end = p + data.length();

  // There must be at least 7 characters (# 1 ""x"") left to potentially find an
  // include file path.
  while (q < end - 7) {
    static const string_view pragma_gcc_pch_preprocess =
      ""pragma GCC pch_preprocess "";
    static const string_view hash_31_command_line_newline =
      ""# 31 \""<command-line>\""\n"";
    static const string_view hash_32_command_line_2_newline =
      ""# 32 \""<command-line>\"" 2\n"";

    // Check if we look at a line containing the file name of an included file.
    // At least the following formats exist (where N is a positive integer):
    //
    // GCC:
    //
    //   # N ""file""
    //   # N ""file"" N
    //   #pragma GCC pch_preprocess ""file""
    //
    // HP's compiler:
    //
    //   #line N ""file""
    //
    // AIX's compiler:
    //
    //   #line N ""file""
    //   #line N
    //
    // Note that there may be other lines starting with '#' left after
    // preprocessing as well, for instance ""#    pragma"".
    if (q[0] == '#'
        // GCC:
        && ((q[1] == ' ' && q[2] >= '0' && q[2] <= '9')
            // GCC precompiled header:
            || Util::starts_with(&q[1], pragma_gcc_pch_preprocess)
            // HP/AIX:
            || (q[1] == 'l' && q[2] == 'i' && q[3] == 'n' && q[4] == 'e'
                && q[5] == ' '))
        && (q == data.data() || q[-1] == '\n')) {
      // Workarounds for preprocessor linemarker bugs in GCC version 6.
      if (q[2] == '3') {
        if (Util::starts_with(q, hash_31_command_line_newline)) {
          // Bogus extra line with #31, after the regular #1: Ignore the whole
          // line, and continue parsing.
          hash.hash(p, q - p);
          while (q < end && *q != '\n') {
            q++;
          }
          q++;
          p = q;
          continue;
        } else if (Util::starts_with(q, hash_32_command_line_2_newline)) {
          // Bogus wrong line with #32, instead of regular #1: Replace the line
          // number with the usual one.
          hash.hash(p, q - p);
          q += 1;
          q[0] = '#';
          q[1] = ' ';
          q[2] = '1';
          p = q;
        }
      }

      while (q < end && *q != '""' && *q != '\n') {
        q++;
      }
      if (q < end && *q == '\n') {
        // A newline before the quotation mark -> no match.
        continue;
      }
      q++;
      if (q >= end) {
        LOG_RAW(""Failed to parse included file path"");
        return Statistic::internal_error;
      }
      // q points to the beginning of an include file path
      hash.hash(p, q - p);
      p = q;
      while (q < end && *q != '""') {
        q++;
      }
      // Look for preprocessor flags, after the ""filename"".
      bool system = false;
      const char* r = q + 1;
      while (r < end && *r != '\n') {
        if (*r == '3') { // System header.
          system = true;
        }
        r++;
      }
      // p and q span the include file path.
      std::string inc_path(p, q - p);
      if (!ctx.has_absolute_include_headers) {
        ctx.has_absolute_include_headers = Util::is_absolute_path(inc_path);
      }
      inc_path = Util::make_relative_path(ctx, inc_path);

      bool should_hash_inc_path = true;
      if (!ctx.config.hash_dir()) {
        if (Util::starts_with(inc_path, ctx.apparent_cwd)
            && Util::ends_with(inc_path, ""//"")) {
          // When compiling with -g or similar, GCC adds the absolute path to
          // CWD like this:
          //
          //   # 1 ""CWD//""
          //
          // If the user has opted out of including the CWD in the hash, don't
          // hash it. See also how debug_prefix_map is handled.
          should_hash_inc_path = false;
        }
      }
      if (should_hash_inc_path) {
        hash.hash(inc_path);
      }

      if (remember_include_file(ctx, inc_path, hash, system, nullptr)
          == RememberIncludeFileResult::cannot_use_pch) {
        return Statistic::could_not_use_precompiled_header;
      }
      p = q; // Everything of interest between p and q has been hashed now.
    } else if (q[0] == '.' && q[1] == 'i' && q[2] == 'n' && q[3] == 'c'
               && q[4] == 'b' && q[5] == 'i' && q[6] == 'n') {
      // An assembler .inc bin (without the space) statement, which could be
      // part of inline assembly, refers to an external file. If the file
      // changes, the hash should change as well, but finding out what file to
      // hash is too hard for ccache, so just bail out.
      LOG_RAW(
        ""Found unsupported .inc""
        ""bin directive in source code"");
      throw Failure(Statistic::unsupported_code_directive);
    } else if (pump && strncmp(q, ""_________"", 9) == 0) {
      // Unfortunately the distcc-pump wrapper outputs standard output lines:
      // __________Using distcc-pump from /usr/bin
      // __________Using # distcc servers in pump mode
      // __________Shutting down distcc-pump include server
      while (q < end && *q != '\n') {
        q++;
      }
      if (*q == '\n') {
        q++;
      }
      p = q;
      continue;
    } else {
      q++;
    }
  }

  hash.hash(p, (end - p));

  // Explicitly check the .gch/.pch/.pth file as Clang does not include any
  // mention of it in the preprocessed output.
  if (!ctx.included_pch_file.empty()) {
    std::string pch_path = Util::make_relative_path(ctx, ctx.included_pch_file);
    hash.hash(pch_path);
    remember_include_file(ctx, pch_path, hash, false, nullptr);
  }

  bool debug_included = getenv(""CCACHE_DEBUG_INCLUDED"");
  if (debug_included) {
    print_included_files(ctx, stdout);
  }

  return Statistic::none;
}

// Extract the used includes from the dependency file. Note that we cannot
// distinguish system headers from other includes here.
static optional<Digest>
result_name_from_depfile(Context& ctx, Hash& hash)
{
  std::string file_content;
  try {
    file_content = Util::read_file(ctx.args_info.output_dep);
  } catch (const Error& e) {
    LOG(
      ""Cannot open dependency file {}: {}"", ctx.args_info.output_dep, e.what());
    return nullopt;
  }

  for (string_view token : Depfile::tokenize(file_content)) {
    if (token.ends_with("":"")) {
      continue;
    }
    if (!ctx.has_absolute_include_headers) {
      ctx.has_absolute_include_headers = Util::is_absolute_path(token);
    }
    std::string path = Util::make_relative_path(ctx, token);
    remember_include_file(ctx, path, hash, false, &hash);
  }

  // Explicitly check the .gch/.pch/.pth file as it may not be mentioned in the
  // dependencies output.
  if (!ctx.included_pch_file.empty()) {
    std::string pch_path = Util::make_relative_path(ctx, ctx.included_pch_file);
    hash.hash(pch_path);
    remember_include_file(ctx, pch_path, hash, false, nullptr);
  }

  bool debug_included = getenv(""CCACHE_DEBUG_INCLUDED"");
  if (debug_included) {
    print_included_files(ctx, stdout);
  }

  return hash.digest();
}
// Execute the compiler/preprocessor, with logic to retry without requesting
// colored diagnostics messages if that fails.
static int
do_execute(Context& ctx,
           Args& args,
           TemporaryFile&& tmp_stdout,
           TemporaryFile&& tmp_stderr)
{
  UmaskScope umask_scope(ctx.original_umask);

  if (ctx.diagnostics_color_failed) {
    DEBUG_ASSERT(ctx.config.compiler_type() == CompilerType::gcc);
    args.erase_last(""-fdiagnostics-color"");
  }
  int status = execute(ctx,
                       args.to_argv().data(),
                       std::move(tmp_stdout.fd),
                       std::move(tmp_stderr.fd));
  if (status != 0 && !ctx.diagnostics_color_failed
      && ctx.config.compiler_type() == CompilerType::gcc) {
    auto errors = Util::read_file(tmp_stderr.path);
    if (errors.find(""fdiagnostics-color"") != std::string::npos) {
      // GCC versions older than 4.9 don't understand -fdiagnostics-color, and
      // non-GCC compilers misclassified as CompilerType::gcc might not do it
      // either. We assume that if the error message contains
      // ""fdiagnostics-color"" then the compilation failed due to
      // -fdiagnostics-color being unsupported and we then retry without the
      // flag. (Note that there intentionally is no leading dash in
      // ""fdiagnostics-color"" since some compilers don't include the dash in the
      // error message.)
      LOG_RAW(""-fdiagnostics-color is unsupported; trying again without it"");

      tmp_stdout.fd = Fd(open(
        tmp_stdout.path.c_str(), O_RDWR | O_CREAT | O_TRUNC | O_BINARY, 0600));
      if (!tmp_stdout.fd) {
        LOG(""Failed to truncate {}: {}"", tmp_stdout.path, strerror(errno));
        throw Failure(Statistic::internal_error);
      }

      tmp_stderr.fd = Fd(open(
        tmp_stderr.path.c_str(), O_RDWR | O_CREAT | O_TRUNC | O_BINARY, 0600));
      if (!tmp_stderr.fd) {
        LOG(""Failed to truncate {}: {}"", tmp_stderr.path, strerror(errno));
        throw Failure(Statistic::internal_error);
      }

      ctx.diagnostics_color_failed = true;
      return do_execute(
        ctx, args, std::move(tmp_stdout), std::move(tmp_stderr));
    }
  }
  return status;
}

struct LookUpCacheFileResult
{
  std::string path;
  Stat stat;
  uint8_t level;
};

static LookUpCacheFileResult
look_up_cache_file(const std::string& cache_dir,
                   const Digest& name,
                   nonstd::string_view suffix)
{
  const auto name_string = FMT(""{}{}"", name.to_string(), suffix);

  for (uint8_t level = k_min_cache_levels; level <= k_max_cache_levels;
       ++level) {
    const auto path = Util::get_path_in_cache(cache_dir, level, name_string);
    const auto stat = Stat::stat(path);
    if (stat) {
      return {path, stat, level};
    }
  }

  const auto shallowest_path =
    Util::get_path_in_cache(cache_dir, k_min_cache_levels, name_string);
  return {shallowest_path, Stat(), k_min_cache_levels};
}

// Create or update the manifest file.
static void
update_manifest_file(Context& ctx)
{
  if (!ctx.config.direct_mode() || ctx.config.read_only()
      || ctx.config.read_only_direct()) {
    return;
  }

  ASSERT(ctx.manifest_path());
  ASSERT(ctx.result_path());

  MTR_BEGIN(""manifest"", ""manifest_put"");

  const auto old_stat = Stat::stat(*ctx.manifest_path());

  // See comment in get_file_hash_index for why saving of timestamps is forced
  // for precompiled headers.
  const bool save_timestamp =
    (ctx.config.sloppiness() & SLOPPY_FILE_STAT_MATCHES)
    || ctx.args_info.output_is_precompiled_header;

  LOG(""Adding result name to {}"", *ctx.manifest_path());
  if (!Manifest::put(ctx.config,
                     *ctx.manifest_path(),
                     *ctx.result_name(),
                     ctx.included_files,
                     ctx.time_of_compilation,
                     save_timestamp)) {
    LOG(""Failed to add result name to {}"", *ctx.manifest_path());
  } else {
    const auto new_stat = Stat::stat(*ctx.manifest_path(), Stat::OnError::log);
    ctx.manifest_counter_updates.increment(
      Statistic::cache_size_kibibyte,
      Util::size_change_kibibyte(old_stat, new_stat));
    ctx.manifest_counter_updates.increment(Statistic::files_in_cache,
                                           !old_stat && new_stat ? 1 : 0);
  }
  MTR_END(""manifest"", ""manifest_put"");
}

static void
create_cachedir_tag(const Context& ctx)
{
  constexpr char cachedir_tag[] =
    ""Signature: 8a477f597d28d172789f06886806bc55\n""
    ""# This file is a cache directory tag created by ccache.\n""
    ""# For information about cache directory tags, see:\n""
    ""#\thttp://www.brynosaurus.com/cachedir/\n"";

  const std::string path = FMT(""{}/{}/CACHEDIR.TAG"",
                               ctx.config.cache_dir(),
                               ctx.result_name()->to_string()[0]);
  const auto stat = Stat::stat(path);
  if (stat) {
    return;
  }
  try {
    Util::write_file(path, cachedir_tag);
  } catch (const Error& e) {
    LOG(""Failed to create {}: {}"", path, e.what());
  }
}

struct FindCoverageFileResult
{
  bool found;
  std::string path;
  bool mangled;
};

static FindCoverageFileResult
find_coverage_file(const Context& ctx)
{
  // GCC 9+ writes coverage data for /dir/to/example.o to #dir#to#example.gcno
  // (in CWD) if -fprofile-dir=DIR is present (regardless of DIR) instead of the
  // traditional /dir/to/example.gcno.

  std::string mangled_form = Result::gcno_file_in_mangled_form(ctx);
  std::string unmangled_form = Result::gcno_file_in_unmangled_form(ctx);
  std::string found_file;
  if (Stat::stat(mangled_form)) {
    LOG(""Found coverage file {}"", mangled_form);
    found_file = mangled_form;
  }
  if (Stat::stat(unmangled_form)) {
    LOG(""Found coverage file {}"", unmangled_form);
    if (!found_file.empty()) {
      LOG_RAW(""Found two coverage files, cannot continue"");
      return {};
    }
    found_file = unmangled_form;
  }
  if (found_file.empty()) {
    LOG(""No coverage file found (tried {} and {}), cannot continue"",
        unmangled_form,
        mangled_form);
    return {};
  }
  return {true, found_file, found_file == mangled_form};
}

// Run the real compiler and put the result in cache.
static void
to_cache(Context& ctx,
         Args& args,
         const Args& depend_extra_args,
         Hash* depend_mode_hash)
{
  args.push_back(""-o"");
  args.push_back(ctx.args_info.output_obj);

  if (ctx.config.hard_link() && ctx.args_info.output_obj != ""/dev/null"") {
    // Workaround for Clang bug where it overwrites an existing object file
    // when it's compiling an assembler file, see
    // <https://bugs.llvm.org/show_bug.cgi?id=39782>.
    Util::unlink_safe(ctx.args_info.output_obj);
  }

  if (ctx.args_info.generating_diagnostics) {
    args.push_back(""--serialize-diagnostics"");
    args.push_back(ctx.args_info.output_dia);
  }

  // Turn off DEPENDENCIES_OUTPUT when running cc1, because otherwise it will
  // emit a line like this:
  //
  //   tmp.stdout.vexed.732.o: /home/mbp/.ccache/tmp.stdout.vexed.732.i
  Util::unsetenv(""DEPENDENCIES_OUTPUT"");
  Util::unsetenv(""SUNPRO_DEPENDENCIES"");

  if (ctx.config.run_second_cpp()) {
    args.push_back(ctx.args_info.input_file);
  } else {
    args.push_back(ctx.i_tmpfile);
  }

  if (ctx.args_info.seen_split_dwarf) {
    // Remove any pre-existing .dwo file since we want to check if the compiler
    // produced one, intentionally not using x_unlink or tmp_unlink since we're
    // not interested in logging successful deletions or failures due to
    // nonexistent .dwo files.
    if (unlink(ctx.args_info.output_dwo.c_str()) != 0 && errno != ENOENT
        && errno != ESTALE) {
      LOG(""Failed to unlink {}: {}"", ctx.args_info.output_dwo, strerror(errno));
      throw Failure(Statistic::bad_output_file);
    }
  }

  LOG_RAW(""Running real compiler"");
  MTR_BEGIN(""execute"", ""compiler"");

  TemporaryFile tmp_stdout(FMT(""{}/tmp.stdout"", ctx.config.temporary_dir()));
  ctx.register_pending_tmp_file(tmp_stdout.path);
  std::string tmp_stdout_path = tmp_stdout.path;

  TemporaryFile tmp_stderr(FMT(""{}/tmp.stderr"", ctx.config.temporary_dir()));
  ctx.register_pending_tmp_file(tmp_stderr.path);
  std::string tmp_stderr_path = tmp_stderr.path;

  int status;
  if (!ctx.config.depend_mode()) {
    status =
      do_execute(ctx, args, std::move(tmp_stdout), std::move(tmp_stderr));
    args.pop_back(3);
  } else {
    // Use the original arguments (including dependency options) in depend
    // mode.
    Args depend_mode_args = ctx.orig_args;
    depend_mode_args.erase_with_prefix(""--ccache-"");
    depend_mode_args.push_back(depend_extra_args);
    add_prefix(ctx, depend_mode_args, ctx.config.prefix_command());

    ctx.time_of_compilation = time(nullptr);
    status = do_execute(
      ctx, depend_mode_args, std::move(tmp_stdout), std::move(tmp_stderr));
  }
  MTR_END(""execute"", ""compiler"");

  auto st = Stat::stat(tmp_stdout_path, Stat::OnError::log);
  if (!st) {
    // The stdout file was removed - cleanup in progress? Better bail out.
    throw Failure(Statistic::missing_cache_file);
  }

  // distcc-pump outputs lines like this:
  // __________Using # distcc servers in pump mode
  if (st.size() != 0 && ctx.config.compiler_type() != CompilerType::pump) {
    LOG_RAW(""Compiler produced stdout"");
    throw Failure(Statistic::compiler_produced_stdout);
  }

  // Merge stderr from the preprocessor (if any) and stderr from the real
  // compiler into tmp_stderr.
  if (!ctx.cpp_stderr.empty()) {
    std::string combined_stderr =
      Util::read_file(ctx.cpp_stderr) + Util::read_file(tmp_stderr_path);
    Util::write_file(tmp_stderr_path, combined_stderr);
  }

  if (status != 0) {
    LOG(""Compiler gave exit status {}"", status);

    // We can output stderr immediately instead of rerunning the compiler.
    Util::send_to_stderr(ctx, Util::read_file(tmp_stderr_path));

    throw Failure(Statistic::compile_failed, status);
  }

  if (ctx.config.depend_mode()) {
    ASSERT(depend_mode_hash);
    auto result_name = result_name_from_depfile(ctx, *depend_mode_hash);
    if (!result_name) {
      throw Failure(Statistic::internal_error);
    }
    ctx.set_result_name(*result_name);
  }

  bool produce_dep_file = ctx.args_info.generating_dependencies
                          && ctx.args_info.output_dep != ""/dev/null"";

  if (produce_dep_file) {
    Depfile::make_paths_relative_in_output_dep(ctx);
  }

  const auto obj_stat = Stat::stat(ctx.args_info.output_obj);
  if (!obj_stat) {
    if (ctx.args_info.expect_output_obj) {
      LOG_RAW(""Compiler didn't produce an object file (unexpected)"");
      throw Failure(Statistic::compiler_produced_no_output);
    } else {
      LOG_RAW(""Compiler didn't produce an object file (expected)"");
    }
  } else if (obj_stat.size() == 0) {
    LOG_RAW(""Compiler produced an empty object file"");
    throw Failure(Statistic::compiler_produced_empty_output);
  }

  const auto stderr_stat = Stat::stat(tmp_stderr_path, Stat::OnError::log);
  if (!stderr_stat) {
    throw Failure(Statistic::internal_error);
  }

  const auto result_file = look_up_cache_file(
    ctx.config.cache_dir(), *ctx.result_name(), Result::k_file_suffix);
  ctx.set_result_path(result_file.path);
  Result::Writer result_writer(ctx, result_file.path);

  if (stderr_stat.size() > 0) {
    result_writer.write(Result::FileType::stderr_output, tmp_stderr_path);
  }
  if (obj_stat) {
    result_writer.write(Result::FileType::object, ctx.args_info.output_obj);
  }
  if (ctx.args_info.generating_dependencies) {
    result_writer.write(Result::FileType::dependency, ctx.args_info.output_dep);
  }
  if (ctx.args_info.generating_coverage) {
    const auto coverage_file = find_coverage_file(ctx);
    if (!coverage_file.found) {
      throw Failure(Statistic::internal_error);
    }
    result_writer.write(coverage_file.mangled
                          ? Result::FileType::coverage_mangled
                          : Result::FileType::coverage_unmangled,
                        coverage_file.path);
  }
  if (ctx.args_info.generating_stackusage) {
    result_writer.write(Result::FileType::stackusage, ctx.args_info.output_su);
  }
  if (ctx.args_info.generating_diagnostics) {
    result_writer.write(Result::FileType::diagnostic, ctx.args_info.output_dia);
  }
  if (ctx.args_info.seen_split_dwarf && Stat::stat(ctx.args_info.output_dwo)) {
    // Only store .dwo file if it was created by the compiler (GCC and Clang
    // behave differently e.g. for ""-gsplit-dwarf -g1"").
    result_writer.write(Result::FileType::dwarf_object,
                        ctx.args_info.output_dwo);
  }

  auto error = result_writer.finalize();
  if (error) {
    LOG(""Error: {}"", *error);
  } else {
    LOG(""Stored in cache: {}"", result_file.path);
  }

  auto new_result_stat = Stat::stat(result_file.path, Stat::OnError::log);
  if (!new_result_stat) {
    throw Failure(Statistic::internal_error);
  }
  ctx.counter_updates.increment(
    Statistic::cache_size_kibibyte,
    Util::size_change_kibibyte(result_file.stat, new_result_stat));
  ctx.counter_updates.increment(Statistic::files_in_cache,
                                result_file.stat ? 0 : 1);

  MTR_END(""file"", ""file_put"");

  // Make sure we have a CACHEDIR.TAG in the cache part of cache_dir. This can
  // be done almost anywhere, but we might as well do it near the end as we save
  // the stat call if we exit early.
  create_cachedir_tag(ctx);

  // Everything OK.
  Util::send_to_stderr(ctx, Util::read_file(tmp_stderr_path));
}

// Find the result name by running the compiler in preprocessor mode and
// hashing the result.
static Digest
get_result_name_from_cpp(Context& ctx, Args& args, Hash& hash)
{
  ctx.time_of_compilation = time(nullptr);

  std::string stderr_path;
  std::string stdout_path;
  int status;
  if (ctx.args_info.direct_i_file) {
    // We are compiling a .i or .ii file - that means we can skip the cpp stage
    // and directly form the correct i_tmpfile.
    stdout_path = ctx.args_info.input_file;
    status = 0;
  } else {
    // Run cpp on the input file to obtain the .i.

    TemporaryFile tmp_stdout(
      FMT(""{}/tmp.cpp_stdout"", ctx.config.temporary_dir()));
    ctx.register_pending_tmp_file(tmp_stdout.path);

    // stdout_path needs the proper cpp_extension for the compiler to do its
    // thing correctly.
    stdout_path = FMT(""{}.{}"", tmp_stdout.path, ctx.config.cpp_extension());
    Util::hard_link(tmp_stdout.path, stdout_path);
    ctx.register_pending_tmp_file(stdout_path);

    TemporaryFile tmp_stderr(
      FMT(""{}/tmp.cpp_stderr"", ctx.config.temporary_dir()));
    stderr_path = tmp_stderr.path;
    ctx.register_pending_tmp_file(stderr_path);

    size_t args_added = 2;
    args.push_back(""-E"");
    if (ctx.args_info.actual_language == ""hip"") {
      args.push_back(""-o"");
      args.push_back(""-"");
      args_added += 2;
    }
    if (ctx.config.keep_comments_cpp()) {
      args.push_back(""-C"");
      args_added++;
    }
    args.push_back(ctx.args_info.input_file);
    add_prefix(ctx, args, ctx.config.prefix_command_cpp());
    LOG_RAW(""Running preprocessor"");
    MTR_BEGIN(""execute"", ""preprocessor"");
    status =
      do_execute(ctx, args, std::move(tmp_stdout), std::move(tmp_stderr));
    MTR_END(""execute"", ""preprocessor"");
    args.pop_back(args_added);
  }

  if (status != 0) {
    LOG(""Preprocessor gave exit status {}"", status);
    throw Failure(Statistic::preprocessor_error);
  }

  hash.hash_delimiter(""cpp"");
  const bool is_pump = ctx.config.compiler_type() == CompilerType::pump;
  const Statistic error =
    process_preprocessed_file(ctx, hash, stdout_path, is_pump);
  if (error != Statistic::none) {
    throw Failure(error);
  }

  hash.hash_delimiter(""cppstderr"");
  if (!ctx.args_info.direct_i_file && !hash.hash_file(stderr_path)) {
    // Somebody removed the temporary file?
    LOG(""Failed to open {}: {}"", stderr_path, strerror(errno));
    throw Failure(Statistic::internal_error);
  }

  if (ctx.args_info.direct_i_file) {
    ctx.i_tmpfile = ctx.args_info.input_file;
  } else {
    ctx.i_tmpfile = stdout_path;
  }

  if (!ctx.config.run_second_cpp()) {
    // If we are using the CPP trick, we need to remember this stderr data and
    // output it just before the main stderr from the compiler pass.
    ctx.cpp_stderr = stderr_path;
    hash.hash_delimiter(""runsecondcpp"");
    hash.hash(""false"");
  }

  return hash.digest();
}

// Hash mtime or content of a file, or the output of a command, according to
// the CCACHE_COMPILERCHECK setting.
static void
hash_compiler(const Context& ctx,
              Hash& hash,
              const Stat& st,
              const std::string& path,
              bool allow_command)
{
  if (ctx.config.compiler_check() == ""none"") {
    // Do nothing.
  } else if (ctx.config.compiler_check() == ""mtime"") {
    hash.hash_delimiter(""cc_mtime"");
    hash.hash(st.size());
    hash.hash(st.mtime());
  } else if (Util::starts_with(ctx.config.compiler_check(), ""string:"")) {
    hash.hash_delimiter(""cc_hash"");
    hash.hash(&ctx.config.compiler_check()[7]);
  } else if (ctx.config.compiler_check() == ""content"" || !allow_command) {
    hash.hash_delimiter(""cc_content"");
    hash_binary_file(ctx, hash, path);
  } else { // command string
    if (!hash_multicommand_output(
          hash, ctx.config.compiler_check(), ctx.orig_args[0])) {
      LOG(""Failure running compiler check command: {}"",
          ctx.config.compiler_check());
      throw Failure(Statistic::compiler_check_failed);
    }
  }
}

// Hash the host compiler(s) invoked by nvcc.
//
// If `ccbin_st` and `ccbin` are set, they refer to a directory or compiler set
// with -ccbin/--compiler-bindir. If `ccbin_st` is nullptr or `ccbin` is the
// empty string, the compilers are looked up in PATH instead.
static void
hash_nvcc_host_compiler(const Context& ctx,
                        Hash& hash,
                        const Stat* ccbin_st = nullptr,
                        const std::string& ccbin = {})
{
  // From <http://docs.nvidia.com/cuda/cuda-compiler-driver-nvcc/index.html>:
  //
  //   ""[...] Specify the directory in which the compiler executable resides.
  //   The host compiler executable name can be also specified to ensure that
  //   the correct host compiler is selected.""
  //
  // and
  //
  //   ""On all platforms, the default host compiler executable (gcc and g++ on
  //   Linux, clang and clang++ on Mac OS X, and cl.exe on Windows) found in
  //   the current execution search path will be used"".

  if (ccbin.empty() || !ccbin_st || ccbin_st->is_directory()) {
#if defined(__APPLE__)
    const char* compilers[] = {""clang"", ""clang++""};
#elif defined(_WIN32)
    const char* compilers[] = {""cl.exe""};
#else
    const char* compilers[] = {""gcc"", ""g++""};
#endif
    for (const char* compiler : compilers) {
      if (!ccbin.empty()) {
        std::string path = FMT(""{}/{}"", ccbin, compiler);
        auto st = Stat::stat(path);
        if (st) {
          hash_compiler(ctx, hash, st, path, false);
        }
      } else {
        std::string path = find_executable(ctx, compiler, CCACHE_NAME);
        if (!path.empty()) {
          auto st = Stat::stat(path, Stat::OnError::log);
          hash_compiler(ctx, hash, st, ccbin, false);
        }
      }
    }
  } else {
    hash_compiler(ctx, hash, *ccbin_st, ccbin, false);
  }
}

static bool
should_rewrite_dependency_target(const ArgsInfo& args_info)
{
  return !args_info.dependency_target_specified && args_info.seen_MD_MMD;
}

// update a hash with information common for the direct and preprocessor modes.
static void
hash_common_info(const Context& ctx,
                 const Args& args,
                 Hash& hash,
                 const ArgsInfo& args_info)
{
  hash.hash(HASH_PREFIX);

  // We have to hash the extension, as a .i file isn't treated the same by the
  // compiler as a .ii file.
  hash.hash_delimiter(""ext"");
  hash.hash(ctx.config.cpp_extension());

#ifdef _WIN32
  const std::string compiler_path = Win32Util::add_exe_suffix(args[0]);
#else
  const std::string compiler_path = args[0];
#endif

  auto st = Stat::stat(compiler_path, Stat::OnError::log);
  if (!st) {
    throw Failure(Statistic::could_not_find_compiler);
  }

  // Hash information about the compiler.
  hash_compiler(ctx, hash, st, compiler_path, true);

  // Also hash the compiler name as some compilers use hard links and behave
  // differently depending on the real name.
  hash.hash_delimiter(""cc_name"");
  hash.hash(Util::base_name(args[0]));

  // Hash variables that may affect the compilation.
  const char* always_hash_env_vars[] = {
    // From <https://gcc.gnu.org/onlinedocs/gcc/Environment-Variables.html>:
    ""COMPILER_PATH"",
    ""GCC_COMPARE_DEBUG"",
    ""GCC_EXEC_PREFIX"",
    // Note: SOURCE_DATE_EPOCH is handled in hash_source_code_string().
  };
  for (const char* name : always_hash_env_vars) {
    const char* value = getenv(name);
    if (value) {
      hash.hash_delimiter(name);
      hash.hash(value);
    }
  }

  if (!(ctx.config.sloppiness() & SLOPPY_LOCALE)) {
    // Hash environment variables that may affect localization of compiler
    // warning messages.
    const char* envvars[] = {
      ""LANG"", ""LC_ALL"", ""LC_CTYPE"", ""LC_MESSAGES"", nullptr};
    for (const char** p = envvars; *p; ++p) {
      const char* v = getenv(*p);
      if (v) {
        hash.hash_delimiter(*p);
        hash.hash(v);
      }
    }
  }

  // Possibly hash the current working directory.
  if (args_info.generating_debuginfo && ctx.config.hash_dir()) {
    std::string dir_to_hash = ctx.apparent_cwd;
    for (const auto& map : args_info.debug_prefix_maps) {
      size_t sep_pos = map.find('=');
      if (sep_pos != std::string::npos) {
        std::string old_path = map.substr(0, sep_pos);
        std::string new_path = map.substr(sep_pos + 1);
        LOG(""Relocating debuginfo from {} to {} (CWD: {})"",
            old_path,
            new_path,
            ctx.apparent_cwd);
        if (Util::starts_with(ctx.apparent_cwd, old_path)) {
          dir_to_hash = new_path + ctx.apparent_cwd.substr(old_path.size());
        }
      }
    }
    LOG(""Hashing CWD {}"", dir_to_hash);
    hash.hash_delimiter(""cwd"");
    hash.hash(dir_to_hash);
  }

  if ((!should_rewrite_dependency_target(ctx.args_info)
       && ctx.args_info.generating_dependencies)
      || ctx.args_info.seen_split_dwarf) {
    // The output object file name is part of the .d file, so include the path
    // in the hash if generating dependencies.
    //
    // Object files include a link to the corresponding .dwo file based on the
    // target object filename when using -gsplit-dwarf, so hashing the object
    // file path will do it, although just hashing the object file base name
    // would be enough.
    hash.hash_delimiter(""object file"");
    hash.hash(ctx.args_info.output_obj);
  }

  // Possibly hash the coverage data file path.
  if (ctx.args_info.generating_coverage && ctx.args_info.profile_arcs) {
    std::string dir;
    if (!ctx.args_info.profile_path.empty()) {
      dir = ctx.args_info.profile_path;
    } else {
      dir =
        Util::real_path(std::string(Util::dir_name(ctx.args_info.output_obj)));
    }
    string_view stem =
      Util::remove_extension(Util::base_name(ctx.args_info.output_obj));
    std::string gcda_path = FMT(""{}/{}.gcda"", dir, stem);
    LOG(""Hashing coverage path {}"", gcda_path);
    hash.hash_delimiter(""gcda"");
    hash.hash(gcda_path);
  }

  // Possibly hash the sanitize blacklist file path.
  for (const auto& sanitize_blacklist : args_info.sanitize_blacklists) {
    LOG(""Hashing sanitize blacklist {}"", sanitize_blacklist);
    hash.hash(""sanitizeblacklist"");
    if (!hash_binary_file(ctx, hash, sanitize_blacklist)) {
      throw Failure(Statistic::error_hashing_extra_file);
    }
  }

  if (!ctx.config.extra_files_to_hash().empty()) {
    for (const std::string& path : Util::split_into_strings(
           ctx.config.extra_files_to_hash(), PATH_DELIM)) {
      LOG(""Hashing extra file {}"", path);
      hash.hash_delimiter(""extrafile"");
      if (!hash_binary_file(ctx, hash, path)) {
        throw Failure(Statistic::error_hashing_extra_file);
      }
    }
  }

  // Possibly hash GCC_COLORS (for color diagnostics).
  if (ctx.config.compiler_type() == CompilerType::gcc) {
    const char* gcc_colors = getenv(""GCC_COLORS"");
    if (gcc_colors) {
      hash.hash_delimiter(""gcccolors"");
      hash.hash(gcc_colors);
    }
  }
}

static bool
hash_profile_data_file(const Context& ctx, Hash& hash)
{
  const std::string& profile_path = ctx.args_info.profile_path;
  string_view base_name = Util::remove_extension(ctx.args_info.output_obj);
  std::string hashified_cwd = ctx.apparent_cwd;
  std::replace(hashified_cwd.begin(), hashified_cwd.end(), '/', '#');

  std::vector<std::string> paths_to_try{
    // -fprofile-use[=dir]/-fbranch-probabilities (GCC <9)
    FMT(""{}/{}.gcda"", profile_path, base_name),
    // -fprofile-use[=dir]/-fbranch-probabilities (GCC >=9)
    FMT(""{}/{}#{}.gcda"", profile_path, hashified_cwd, base_name),
    // -fprofile(-instr|-sample)-use=file (Clang), -fauto-profile=file (GCC >=5)
    profile_path,
    // -fprofile(-instr|-sample)-use=dir (Clang)
    FMT(""{}/default.profdata"", profile_path),
    // -fauto-profile (GCC >=5)
    ""fbdata.afdo"", // -fprofile-dir is not used
  };

  bool found = false;
  for (const std::string& p : paths_to_try) {
    LOG(""Checking for profile data file {}"", p);
    auto st = Stat::stat(p);
    if (st && !st.is_directory()) {
      LOG(""Adding profile data {} to the hash"", p);
      hash.hash_delimiter(""-fprofile-use"");
      if (hash_binary_file(ctx, hash, p)) {
        found = true;
      }
    }
  }

  return found;
}

static bool
option_should_be_ignored(const std::string& arg,
                         const std::vector<std::string>& patterns)
{
  return std::any_of(
    patterns.cbegin(), patterns.cend(), [&arg](const std::string& pattern) {
      const auto& prefix = string_view(pattern).substr(0, pattern.length() - 1);
      return (
        pattern == arg
        || (Util::ends_with(pattern, ""*"") && Util::starts_with(arg, prefix)));
    });
}

// Update a hash sum with information specific to the direct and preprocessor
// modes and calculate the result name. Returns the result name on success,
// otherwise nullopt.
static optional<Digest>
calculate_result_name(Context& ctx,
                      const Args& args,
                      Args& preprocessor_args,
                      Hash& hash,
                      bool direct_mode)
{
  bool found_ccbin = false;

  hash.hash_delimiter(""result version"");
  hash.hash(Result::k_version);

  if (direct_mode) {
    hash.hash_delimiter(""manifest version"");
    hash.hash(Manifest::k_version);
  }

  // clang will emit warnings for unused linker flags, so we shouldn't skip
  // those arguments.
  int is_clang = ctx.config.compiler_type() == CompilerType::clang
                 || ctx.config.compiler_type() == CompilerType::other;

  // First the arguments.
  for (size_t i = 1; i < args.size(); i++) {
    // Trust the user if they've said we should not hash a given option.
    if (option_should_be_ignored(args[i], ctx.ignore_options())) {
      LOG(""Not hashing ignored option: {}"", args[i]);
      if (i + 1 < args.size() && compopt_takes_arg(args[i])) {
        i++;
        LOG(""Not hashing argument of ignored option: {}"", args[i]);
      }
      continue;
    }

    // -L doesn't affect compilation (except for clang).
    if (i < args.size() - 1 && args[i] == ""-L"" && !is_clang) {
      i++;
      continue;
    }
    if (Util::starts_with(args[i], ""-L"") && !is_clang) {
      continue;
    }

    // -Wl,... doesn't affect compilation (except for clang).
    if (Util::starts_with(args[i], ""-Wl,"") && !is_clang) {
      continue;
    }

    // The -fdebug-prefix-map option may be used in combination with
    // CCACHE_BASEDIR to reuse results across different directories. Skip using
    // the value of the option from hashing but still hash the existence of the
    // option.
    if (Util::starts_with(args[i], ""-fdebug-prefix-map="")) {
      hash.hash_delimiter(""arg"");
      hash.hash(""-fdebug-prefix-map="");
      continue;
    }
    if (Util::starts_with(args[i], ""-ffile-prefix-map="")) {
      hash.hash_delimiter(""arg"");
      hash.hash(""-ffile-prefix-map="");
      continue;
    }
    if (Util::starts_with(args[i], ""-fmacro-prefix-map="")) {
      hash.hash_delimiter(""arg"");
      hash.hash(""-fmacro-prefix-map="");
      continue;
    }

    // When using the preprocessor, some arguments don't contribute to the
    // hash. The theory is that these arguments will change the output of -E if
    // they are going to have any effect at all. For precompiled headers this
    // might not be the case.
    if (!direct_mode && !ctx.args_info.output_is_precompiled_header
        && !ctx.args_info.using_precompiled_header) {
      if (compopt_affects_cpp_output(args[i])) {
        if (compopt_takes_arg(args[i])) {
          i++;
        }
        continue;
      }
      if (compopt_affects_cpp_output(args[i].substr(0, 2))) {
        continue;
      }
    }

    // If we're generating dependencies, we make sure to skip the filename of
    // the dependency file, since it doesn't impact the output.
    if (ctx.args_info.generating_dependencies) {
      if (Util::starts_with(args[i], ""-Wp,"")) {
        if (Util::starts_with(args[i], ""-Wp,-MD,"")
            && args[i].find(',', 8) == std::string::npos) {
          hash.hash(args[i].data(), 8);
          continue;
        } else if (Util::starts_with(args[i], ""-Wp,-MMD,"")
                   && args[i].find(',', 9) == std::string::npos) {
          hash.hash(args[i].data(), 9);
          continue;
        }
      } else if (Util::starts_with(args[i], ""-MF"")) {
        // In either case, hash the ""-MF"" part.
        hash.hash_delimiter(""arg"");
        hash.hash(args[i].data(), 3);

        if (ctx.args_info.output_dep != ""/dev/null"") {
          bool separate_argument = (args[i].size() == 3);
          if (separate_argument) {
            // Next argument is dependency name, so skip it.
            i++;
          }
        }
        continue;
      }
    }

    if (Util::starts_with(args[i], ""-specs="")
        || Util::starts_with(args[i], ""--specs="")) {
      std::string path = args[i].substr(args[i].find('=') + 1);
      auto st = Stat::stat(path, Stat::OnError::log);
      if (st) {
        // If given an explicit specs file, then hash that file, but don't
        // include the path to it in the hash.
        hash.hash_delimiter(""specs"");
        hash_compiler(ctx, hash, st, path, false);
        continue;
      }
    }

    if (Util::starts_with(args[i], ""-fplugin="")) {
      auto st = Stat::stat(&args[i][9], Stat::OnError::log);
      if (st) {
        hash.hash_delimiter(""plugin"");
        hash_compiler(ctx, hash, st, &args[i][9], false);
        continue;
      }
    }

    if (args[i] == ""-Xclang"" && i + 3 < args.size() && args[i + 1] == ""-load""
        && args[i + 2] == ""-Xclang"") {
      auto st = Stat::stat(args[i + 3], Stat::OnError::log);
      if (st) {
        hash.hash_delimiter(""plugin"");
        hash_compiler(ctx, hash, st, args[i + 3], false);
        i += 3;
        continue;
      }
    }

    if ((args[i] == ""-ccbin"" || args[i] == ""--compiler-bindir"")
        && i + 1 < args.size()) {
      auto st = Stat::stat(args[i + 1]);
      if (st) {
        found_ccbin = true;
        hash.hash_delimiter(""ccbin"");
        hash_nvcc_host_compiler(ctx, hash, &st, args[i + 1]);
        i++;
        continue;
      }
    }

    // All other arguments are included in the hash.
    hash.hash_delimiter(""arg"");
    hash.hash(args[i]);
    if (i + 1 < args.size() && compopt_takes_arg(args[i])) {
      i++;
      hash.hash_delimiter(""arg"");
      hash.hash(args[i]);
    }
  }

  // Make results with dependency file /dev/null different from those without
  // it.
  if (ctx.args_info.generating_dependencies
      && ctx.args_info.output_dep == ""/dev/null"") {
    hash.hash_delimiter(""/dev/null dependency file"");
  }

  if (!found_ccbin && ctx.args_info.actual_language == ""cu"") {
    hash_nvcc_host_compiler(ctx, hash);
  }

  // For profile generation (-fprofile(-instr)-generate[=path])
  // - hash profile path
  //
  // For profile usage (-fprofile(-instr|-sample)-use, -fbranch-probabilities):
  // - hash profile data
  //
  // -fbranch-probabilities and -fvpt usage is covered by
  // -fprofile-generate/-fprofile-use.
  //
  // The profile directory can be specified as an argument to
  // -fprofile(-instr)-generate=, -fprofile(-instr|-sample)-use= or
  // -fprofile-dir=.

  if (ctx.args_info.profile_generate) {
    ASSERT(!ctx.args_info.profile_path.empty());
    LOG(""Adding profile directory {} to our hash"", ctx.args_info.profile_path);
    hash.hash_delimiter(""-fprofile-dir"");
    hash.hash(ctx.args_info.profile_path);
  }

  if (ctx.args_info.profile_use && !hash_profile_data_file(ctx, hash)) {
    LOG_RAW(""No profile data file found"");
    throw Failure(Statistic::no_input_file);
  }

  // Adding -arch to hash since cpp output is affected.
  for (const auto& arch : ctx.args_info.arch_args) {
    hash.hash_delimiter(""-arch"");
    hash.hash(arch);
  }

  optional<Digest> result_name;
  if (direct_mode) {
    // Hash environment variables that affect the preprocessor output.
    const char* envvars[] = {""CPATH"",
                             ""C_INCLUDE_PATH"",
                             ""CPLUS_INCLUDE_PATH"",
                             ""OBJC_INCLUDE_PATH"",
                             ""OBJCPLUS_INCLUDE_PATH"", // clang
                             nullptr};
    for (const char** p = envvars; *p; ++p) {
      const char* v = getenv(*p);
      if (v) {
        hash.hash_delimiter(*p);
        hash.hash(v);
      }
    }

    // Make sure that the direct mode hash is unique for the input file path.
    // If this would not be the case:
    //
    // * An false cache hit may be produced. Scenario:
    //   - a/r.h exists.
    //   - a/x.c has #include ""r.h"".
    //   - b/x.c is identical to a/x.c.
    //   - Compiling a/x.c records a/r.h in the manifest.
    //   - Compiling b/x.c results in a false cache hit since a/x.c and b/x.c
    //     share manifests and a/r.h exists.
    // * The expansion of __FILE__ may be incorrect.
    hash.hash_delimiter(""inputfile"");
    hash.hash(ctx.args_info.input_file);

    hash.hash_delimiter(""sourcecode"");
    int result = hash_source_code_file(ctx, hash, ctx.args_info.input_file);
    if (result & HASH_SOURCE_CODE_ERROR) {
      throw Failure(Statistic::internal_error);
    }
    if (result & HASH_SOURCE_CODE_FOUND_TIME) {
      LOG_RAW(""Disabling direct mode"");
      ctx.config.set_direct_mode(false);
      return nullopt;
    }

    const auto manifest_name = hash.digest();
    ctx.set_manifest_name(manifest_name);

    const auto manifest_file = look_up_cache_file(
      ctx.config.cache_dir(), manifest_name, Manifest::k_file_suffix);
    ctx.set_manifest_path(manifest_file.path);

    if (manifest_file.stat) {
      LOG(""Looking for result name in {}"", manifest_file.path);
      MTR_BEGIN(""manifest"", ""manifest_get"");
      result_name = Manifest::get(ctx, manifest_file.path);
      MTR_END(""manifest"", ""manifest_get"");
      if (result_name) {
        LOG_RAW(""Got result name from manifest"");
      } else {
        LOG_RAW(""Did not find result name in manifest"");
      }
    } else {
      LOG(""No manifest with name {} in the cache"", manifest_name.to_string());
    }
  } else {
    if (ctx.args_info.arch_args.empty()) {
      result_name = get_result_name_from_cpp(ctx, preprocessor_args, hash);
      LOG_RAW(""Got result name from preprocessor"");
    } else {
      preprocessor_args.push_back(""-arch"");
      for (size_t i = 0; i < ctx.args_info.arch_args.size(); ++i) {
        preprocessor_args.push_back(ctx.args_info.arch_args[i]);
        result_name = get_result_name_from_cpp(ctx, preprocessor_args, hash);
        LOG(""Got result name from preprocessor with -arch {}"",
            ctx.args_info.arch_args[i]);
        if (i != ctx.args_info.arch_args.size() - 1) {
          result_name = nullopt;
        }
        preprocessor_args.pop_back();
      }
      preprocessor_args.pop_back();
    }
  }

  return result_name;
}

enum class FromCacheCallMode { direct, cpp };

// Try to return the compile result from cache.
static optional<Statistic>
from_cache(Context& ctx, FromCacheCallMode mode)
{
  UmaskScope umask_scope(ctx.original_umask);

  // The user might be disabling cache hits.
  if (ctx.config.recache()) {
    return nullopt;
  }

  // If we're using Clang, we can't trust a precompiled header object based on
  // running the preprocessor since clang will produce a fatal error when the
  // precompiled header is used and one of the included files has an updated
  // timestamp:
  //
  //     file 'foo.h' has been modified since the precompiled header 'foo.pch'
  //     was built
  if ((ctx.config.compiler_type() == CompilerType::clang
       || ctx.config.compiler_type() == CompilerType::other)
      && ctx.args_info.output_is_precompiled_header
      && !ctx.args_info.fno_pch_timestamp && mode == FromCacheCallMode::cpp) {
    LOG_RAW(""Not considering cached precompiled header in preprocessor mode"");
    return nullopt;
  }

  MTR_BEGIN(""cache"", ""from_cache"");

  // Get result from cache.
  const auto result_file = look_up_cache_file(
    ctx.config.cache_dir(), *ctx.result_name(), Result::k_file_suffix);
  if (!result_file.stat) {
    LOG(""No result with name {} in the cache"", ctx.result_name()->to_string());
    return nullopt;
  }
  ctx.set_result_path(result_file.path);
  Result::Reader result_reader(result_file.path);
  ResultRetriever result_retriever(
    ctx, should_rewrite_dependency_target(ctx.args_info));

  auto error = result_reader.read(result_retriever);
  MTR_END(""cache"", ""from_cache"");
  if (error) {
    LOG(""Failed to get result from cache: {}"", *error);
    return nullopt;
  }

  // Update modification timestamp to save file from LRU cleanup.
  Util::update_mtime(*ctx.result_path());

  LOG_RAW(""Succeeded getting cached result"");

  return mode == FromCacheCallMode::direct ? Statistic::direct_cache_hit
                                           : Statistic::preprocessed_cache_hit;
}

// Find the real compiler and put it into ctx.orig_args[0]. We just search the
// PATH to find an executable of the same name that isn't a link to ourselves.
// Pass find_executable function as second parameter.
void
find_compiler(Context& ctx,
              const FindExecutableFunction& find_executable_function)
{
  // gcc --> 0
  // ccache gcc --> 1
  // ccache ccache gcc --> 2
  size_t compiler_pos = 0;
  while (compiler_pos < ctx.orig_args.size()
         && Util::same_program_name(
           Util::base_name(ctx.orig_args[compiler_pos]), CCACHE_NAME)) {
    ++compiler_pos;
  }

  // Support user override of the compiler.
  const std::string compiler =
    !ctx.config.compiler().empty()
      ? ctx.config.compiler()
      // In case ccache is masquerading as the compiler, use only base_name so
      // the real compiler can be determined.
      : (compiler_pos == 0 ? std::string(Util::base_name(ctx.orig_args[0]))
                           : ctx.orig_args[compiler_pos]);

  const std::string resolved_compiler =
    Util::is_full_path(compiler)
      ? compiler
      : find_executable_function(ctx, compiler, CCACHE_NAME);

  if (resolved_compiler.empty()) {
    throw Fatal(""Could not find compiler \""{}\"" in PATH"", compiler);
  }

  if (Util::same_program_name(Util::base_name(resolved_compiler),
                              CCACHE_NAME)) {
    throw Fatal(
      ""Recursive invocation (the name of the ccache binary must be \""{}\"")"",
      CCACHE_NAME);
  }

  ctx.orig_args.pop_front(compiler_pos);
  ctx.orig_args[0] = resolved_compiler;
}

static std::string
default_cache_dir(const std::string& home_dir)
{
#ifdef _WIN32
  return home_dir + ""/ccache"";
#elif defined(__APPLE__)
  return home_dir + ""/Library/Caches/ccache"";
#else
  return home_dir + ""/.cache/ccache"";
#endif
}

static std::string
default_config_dir(const std::string& home_dir)
{
#ifdef _WIN32
  return home_dir + ""/ccache"";
#elif defined(__APPLE__)
  return home_dir + ""/Library/Preferences/ccache"";
#else
  return home_dir + ""/.config/ccache"";
#endif
}

// Read config file(s), populate variables, create configuration file in cache
// directory if missing, etc.
static void
set_up_config(Config& config)
{
  const std::string home_dir = Util::get_home_directory();
  const std::string legacy_ccache_dir = home_dir + ""/.ccache"";
  const bool legacy_ccache_dir_exists =
    Stat::stat(legacy_ccache_dir).is_directory();
  const char* const env_xdg_cache_home = getenv(""XDG_CACHE_HOME"");
  const char* const env_xdg_config_home = getenv(""XDG_CONFIG_HOME"");

  const char* env_ccache_configpath = getenv(""CCACHE_CONFIGPATH"");
  if (env_ccache_configpath) {
    config.set_primary_config_path(env_ccache_configpath);
  } else {
    // Only used for ccache tests:
    const char* const env_ccache_configpath2 = getenv(""CCACHE_CONFIGPATH2"");

    config.set_secondary_config_path(env_ccache_configpath2
                                       ? env_ccache_configpath2
                                       : FMT(""{}/ccache.conf"", SYSCONFDIR));
    MTR_BEGIN(""config"", ""conf_read_secondary"");
    // A missing config file in SYSCONFDIR is OK so don't check return value.
    config.update_from_file(config.secondary_config_path());
    MTR_END(""config"", ""conf_read_secondary"");

    const char* const env_ccache_dir = getenv(""CCACHE_DIR"");
    std::string primary_config_dir;
    if (env_ccache_dir && *env_ccache_dir) {
      primary_config_dir = env_ccache_dir;
    } else if (!config.cache_dir().empty() && !env_ccache_dir) {
      primary_config_dir = config.cache_dir();
    } else if (legacy_ccache_dir_exists) {
      primary_config_dir = legacy_ccache_dir;
    } else if (env_xdg_config_home) {
      primary_config_dir = FMT(""{}/ccache"", env_xdg_config_home);
    } else {
      primary_config_dir = default_config_dir(home_dir);
    }
    config.set_primary_config_path(primary_config_dir + ""/ccache.conf"");
  }

  const std::string& cache_dir_before_primary_config = config.cache_dir();

  MTR_BEGIN(""config"", ""conf_read_primary"");
  config.update_from_file(config.primary_config_path());
  MTR_END(""config"", ""conf_read_primary"");

  // Ignore cache_dir set in primary config.
  config.set_cache_dir(cache_dir_before_primary_config);

  MTR_BEGIN(""config"", ""conf_update_from_environment"");
  config.update_from_environment();
  // (config.cache_dir is set above if CCACHE_DIR is set.)
  MTR_END(""config"", ""conf_update_from_environment"");

  if (config.cache_dir().empty()) {
    if (legacy_ccache_dir_exists) {
      config.set_cache_dir(legacy_ccache_dir);
    } else if (env_xdg_cache_home) {
      config.set_cache_dir(FMT(""{}/ccache"", env_xdg_cache_home));
    } else {
      config.set_cache_dir(default_cache_dir(home_dir));
    }
  }
  // else: cache_dir was set explicitly via environment or via secondary config.

  // We have now determined config.cache_dir and populated the rest of config in
  // prio order (1. environment, 2. primary config, 3. secondary config).
}

static void
set_up_context(Context& ctx, int argc, const char* const* argv)
{
  ctx.orig_args = Args::from_argv(argc, argv);
  ctx.ignore_header_paths = Util::split_into_strings(
    ctx.config.ignore_headers_in_manifest(), PATH_DELIM);
  ctx.set_ignore_options(
    Util::split_into_strings(ctx.config.ignore_options(), "" ""));
}

// Initialize ccache, must be called once before anything else is run.
static void
initialize(Context& ctx, int argc, const char* const* argv)
{
  set_up_config(ctx.config);
  set_up_context(ctx, argc, argv);
  Logging::init(ctx.config);

  // Set default umask for all files created by ccache from now on (if
  // configured to). This is intentionally done after calling init_log so that
  // the log file won't be affected by the umask but before creating the initial
  // configuration file. The intention is that all files and directories in the
  // cache directory should be affected by the configured umask and that no
  // other files and directories should.
  if (ctx.config.umask() != std::numeric_limits<uint32_t>::max()) {
    ctx.original_umask = umask(ctx.config.umask());
  }

  LOG(""=== CCACHE {} STARTED ========================================="",
      CCACHE_VERSION);

  if (getenv(""CCACHE_INTERNAL_TRACE"")) {
#ifdef MTR_ENABLED
    ctx.mini_trace = std::make_unique<MiniTrace>(ctx.args_info);
#else
    LOG_RAW(""Error: tracing is not enabled!"");
#endif
  }
}

// Make a copy of stderr that will not be cached, so things like distcc can
// send networking errors to it.
static void
set_up_uncached_err()
{
  int uncached_fd =
    dup(STDERR_FILENO); // The file descriptor is intentionally leaked.
  if (uncached_fd == -1) {
    LOG(""dup(2) failed: {}"", strerror(errno));
    throw Failure(Statistic::internal_error);
  }

  Util::setenv(""UNCACHED_ERR_FD"", FMT(""{}"", uncached_fd));
}

static void
configuration_logger(const std::string& key,
                     const std::string& value,
                     const std::string& origin)
{
  BULK_LOG(""Config: ({}) {} = {}"", origin, key, value);
}

static void
configuration_printer(const std::string& key,
                      const std::string& value,
                      const std::string& origin)
{
  PRINT(stdout, ""({}) {} = {}\n"", origin, key, value);
}

static int cache_compilation(int argc, const char* const* argv);
static Statistic do_cache_compilation(Context& ctx, const char* const* argv);

static uint8_t
calculate_wanted_cache_level(uint64_t files_in_level_1)
{
  uint64_t files_per_directory = files_in_level_1 / 16;
  for (uint8_t i = k_min_cache_levels; i <= k_max_cache_levels; ++i) {
    if (files_per_directory < k_max_cache_files_per_directory) {
      return i;
    }
    files_per_directory /= 16;
  }
  return k_max_cache_levels;
}

static optional<Counters>
update_stats_and_maybe_move_cache_file(const Context& ctx,
                                       const Digest& name,
                                       const std::string& current_path,
                                       const Counters& counter_updates,
                                       const std::string& file_suffix)
{
  if (counter_updates.all_zero()) {
    return nullopt;
  }

  // Use stats file in the level one subdirectory for cache bookkeeping counters
  // since cleanup is performed on level one. Use stats file in the level two
  // subdirectory for other counters to reduce lock contention.
  const bool use_stats_on_level_1 =
    counter_updates.get(Statistic::cache_size_kibibyte) != 0
    || counter_updates.get(Statistic::files_in_cache) != 0;
  std::string level_string = FMT(""{:x}"", name.bytes()[0] >> 4);
  if (!use_stats_on_level_1) {
    level_string += FMT(""/{:x}"", name.bytes()[0] & 0xF);
  }
  const auto stats_file =
    FMT(""{}/{}/stats"", ctx.config.cache_dir(), level_string);

  auto counters =
    Statistics::update(stats_file, [&counter_updates](Counters& cs) {
      cs.increment(counter_updates);
    });
  if (!counters) {
    return nullopt;
  }

  if (use_stats_on_level_1) {
    // Only consider moving the cache file to another level when we have read
    // the level 1 stats file since it's only then we know the proper
    // files_in_cache value.
    const auto wanted_level =
      calculate_wanted_cache_level(counters->get(Statistic::files_in_cache));
    const auto wanted_path = Util::get_path_in_cache(
      ctx.config.cache_dir(), wanted_level, name.to_string() + file_suffix);
    if (current_path != wanted_path) {
      Util::ensure_dir_exists(Util::dir_name(wanted_path));
      LOG(""Moving {} to {}"", current_path, wanted_path);
      try {
        Util::rename(current_path, wanted_path);
      } catch (const Error&) {
        // Two ccache processes may move the file at the same time, so failure
        // to rename is OK.
      }
    }
  }
  return counters;
}

static void
finalize_stats_and_trigger_cleanup(Context& ctx)
{
  const auto& config = ctx.config;

  if (config.disable()) {
    // Just log result, don't update statistics.
    LOG_RAW(""Result: disabled"");
    return;
  }

  if (!config.log_file().empty() || config.debug()) {
    const auto result = Statistics::get_result(ctx.counter_updates);
    if (result) {
      LOG(""Result: {}"", *result);
    }
  }

  if (!config.stats()) {
    return;
  }

  if (!ctx.result_path()) {
    ASSERT(ctx.counter_updates.get(Statistic::cache_size_kibibyte) == 0);
    ASSERT(ctx.counter_updates.get(Statistic::files_in_cache) == 0);

    // Context::set_result_path hasn't been called yet, so we just choose one of
    // the stats files in the 256 level 2 directories.
    const auto bucket = getpid() % 256;
    const auto stats_file =
      FMT(""{}/{:x}/{:x}/stats"", config.cache_dir(), bucket / 16, bucket % 16);
    Statistics::update(
      stats_file, [&ctx](Counters& cs) { cs.increment(ctx.counter_updates); });
    return;
  }

  if (ctx.manifest_path()) {
    update_stats_and_maybe_move_cache_file(ctx,
                                           *ctx.manifest_name(),
                                           *ctx.manifest_path(),
                                           ctx.manifest_counter_updates,
                                           Manifest::k_file_suffix);
  }

  const auto counters =
    update_stats_and_maybe_move_cache_file(ctx,
                                           *ctx.result_name(),
                                           *ctx.result_path(),
                                           ctx.counter_updates,
                                           Result::k_file_suffix);
  if (!counters) {
    return;
  }

  const auto subdir =
    FMT(""{}/{:x}"", config.cache_dir(), ctx.result_name()->bytes()[0] >> 4);
  bool need_cleanup = false;

  if (config.max_files() != 0
      && counters->get(Statistic::files_in_cache) > config.max_files() / 16) {
    LOG(""Need to clean up {} since it holds {} files (limit: {} files)"",
        subdir,
        counters->get(Statistic::files_in_cache),
        config.max_files() / 16);
    need_cleanup = true;
  }
  if (config.max_size() != 0
      && counters->get(Statistic::cache_size_kibibyte)
           > config.max_size() / 1024 / 16) {
    LOG(""Need to clean up {} since it holds {} KiB (limit: {} KiB)"",
        subdir,
        counters->get(Statistic::cache_size_kibibyte),
        config.max_size() / 1024 / 16);
    need_cleanup = true;
  }

  if (need_cleanup) {
    const double factor = config.limit_multiple() / 16;
    const uint64_t max_size = round(config.max_size() * factor);
    const uint32_t max_files = round(config.max_files() * factor);
    const time_t max_age = 0;
    clean_up_dir(
      subdir, max_size, max_files, max_age, [](double /*progress*/) {});
  }
}

static void
finalize_at_exit(Context& ctx)
{
  try {
    finalize_stats_and_trigger_cleanup(ctx);
  } catch (const ErrorBase& e) {
    // finalize_at_exit must not throw since it's called by a destructor.
    LOG(""Error while finalizing stats: {}"", e.what());
  }

  // Dump log buffer last to not lose any logs.
  if (ctx.config.debug() && !ctx.args_info.output_obj.empty()) {
    Logging::dump_log(prepare_debug_path(
      ctx.config.debug_dir(), ctx.args_info.output_obj, ""log""));
  }
}

// The entry point when invoked to cache a compilation.
static int
cache_compilation(int argc, const char* const* argv)
{
  tzset(); // Needed for localtime_r.

  bool fall_back_to_original_compiler = false;
  Args saved_orig_args;
  nonstd::optional<mode_t> original_umask;
  std::string saved_temp_dir;

  {
    Context ctx;
    SignalHandler signal_handler(ctx);
    Finalizer finalizer([&ctx] { finalize_at_exit(ctx); });

    initialize(ctx, argc, argv);

    MTR_BEGIN(""main"", ""find_compiler"");
    find_compiler(ctx, &find_executable);
    MTR_END(""main"", ""find_compiler"");

    try {
      Statistic statistic = do_cache_compilation(ctx, argv);
      ctx.counter_updates.increment(statistic);
    } catch (const Failure& e) {
      if (e.statistic() != Statistic::none) {
        ctx.counter_updates.increment(e.statistic());
      }

      if (e.exit_code()) {
        return *e.exit_code();
      }
      // Else: Fall back to running the real compiler.
      fall_back_to_original_compiler = true;

      original_umask = ctx.original_umask;

      ASSERT(!ctx.orig_args.empty());

      ctx.orig_args.erase_with_prefix(""--ccache-"");
      add_prefix(ctx, ctx.orig_args, ctx.config.prefix_command());

      LOG_RAW(""Failed; falling back to running the real compiler"");

      saved_temp_dir = ctx.config.temporary_dir();
      saved_orig_args = std::move(ctx.orig_args);
      auto execv_argv = saved_orig_args.to_argv();
      LOG(""Executing {}"", Util::format_argv_for_logging(execv_argv.data()));
      // Execute the original command below after ctx and finalizer have been
      // destructed.
    }
  }

  if (fall_back_to_original_compiler) {
    if (original_umask) {
      umask(*original_umask);
    }
    auto execv_argv = saved_orig_args.to_argv();
    execute_noreturn(execv_argv.data(), saved_temp_dir);
    throw Fatal(
      ""execute_noreturn of {} failed: {}"", execv_argv[0], strerror(errno));
  }

  return EXIT_SUCCESS;
}

static Statistic
do_cache_compilation(Context& ctx, const char* const* argv)
{
  if (ctx.actual_cwd.empty()) {
    LOG(""Unable to determine current working directory: {}"", strerror(errno));
    throw Failure(Statistic::internal_error);
  }

  MTR_BEGIN(""main"", ""clean_up_internal_tempdir"");
  if (ctx.config.temporary_dir() == ctx.config.cache_dir() + ""/tmp"") {
    clean_up_internal_tempdir(ctx.config);
  }
  MTR_END(""main"", ""clean_up_internal_tempdir"");

  if (!ctx.config.log_file().empty() || ctx.config.debug()) {
    ctx.config.visit_items(configuration_logger);
  }

  // Guess compiler after logging the config value in order to be able to
  // display ""compiler_type = auto"" before overwriting the value with the guess.
  if (ctx.config.compiler_type() == CompilerType::auto_guess) {
    ctx.config.set_compiler_type(guess_compiler(ctx.orig_args[0]));
  }
  DEBUG_ASSERT(ctx.config.compiler_type() != CompilerType::auto_guess);

  if (ctx.config.disable()) {
    LOG_RAW(""ccache is disabled"");
    // Statistic::cache_miss is a dummy to trigger stats_flush.
    throw Failure(Statistic::cache_miss);
  }

  LOG(""Command line: {}"", Util::format_argv_for_logging(argv));
  LOG(""Hostname: {}"", Util::get_hostname());
  LOG(""Working directory: {}"", ctx.actual_cwd);
  if (ctx.apparent_cwd != ctx.actual_cwd) {
    LOG(""Apparent working directory: {}"", ctx.apparent_cwd);
  }

  LOG(""Compiler type: {}"", compiler_type_to_string(ctx.config.compiler_type()));

  MTR_BEGIN(""main"", ""process_args"");
  ProcessArgsResult processed = process_args(ctx);
  MTR_END(""main"", ""process_args"");

  if (processed.error) {
    throw Failure(*processed.error);
  }

  set_up_uncached_err();

  if (ctx.config.depend_mode()
      && (!ctx.args_info.generating_dependencies
          || ctx.args_info.output_dep == ""/dev/null""
          || !ctx.config.run_second_cpp())) {
    LOG_RAW(""Disabling depend mode"");
    ctx.config.set_depend_mode(false);
  }

  LOG(""Source file: {}"", ctx.args_info.input_file);
  if (ctx.args_info.generating_dependencies) {
    LOG(""Dependency file: {}"", ctx.args_info.output_dep);
  }
  if (ctx.args_info.generating_coverage) {
    LOG_RAW(""Coverage file is being generated"");
  }
  if (ctx.args_info.generating_stackusage) {
    LOG(""Stack usage file: {}"", ctx.args_info.output_su);
  }
  if (ctx.args_info.generating_diagnostics) {
    LOG(""Diagnostics file: {}"", ctx.args_info.output_dia);
  }
  if (!ctx.args_info.output_dwo.empty()) {
    LOG(""Split dwarf file: {}"", ctx.args_info.output_dwo);
  }

  LOG(""Object file: {}"", ctx.args_info.output_obj);
  MTR_META_THREAD_NAME(ctx.args_info.output_obj.c_str());

  if (ctx.config.debug()) {
    const auto path = prepare_debug_path(
      ctx.config.debug_dir(), ctx.args_info.output_obj, ""input-text"");
    File debug_text_file(path, ""w"");
    if (debug_text_file) {
      ctx.hash_debug_files.push_back(std::move(debug_text_file));
    } else {
      LOG(""Failed to open {}: {}"", path, strerror(errno));
    }
  }

  FILE* debug_text_file = !ctx.hash_debug_files.empty()
                            ? ctx.hash_debug_files.front().get()
                            : nullptr;

  Hash common_hash;
  init_hash_debug(ctx, common_hash, 'c', ""COMMON"", debug_text_file);

  MTR_BEGIN(""hash"", ""common_hash"");
  hash_common_info(
    ctx, processed.preprocessor_args, common_hash, ctx.args_info);
  MTR_END(""hash"", ""common_hash"");

  // Try to find the hash using the manifest.
  Hash direct_hash = common_hash;
  init_hash_debug(ctx, direct_hash, 'd', ""DIRECT MODE"", debug_text_file);

  Args args_to_hash = processed.preprocessor_args;
  args_to_hash.push_back(processed.extra_args_to_hash);

  bool put_result_in_manifest = false;
  optional<Digest> result_name;
  optional<Digest> result_name_from_manifest;
  if (ctx.config.direct_mode()) {
    LOG_RAW(""Trying direct lookup"");
    MTR_BEGIN(""hash"", ""direct_hash"");
    Args dummy_args;
    result_name =
      calculate_result_name(ctx, args_to_hash, dummy_args, direct_hash, true);
    MTR_END(""hash"", ""direct_hash"");
    if (result_name) {
      ctx.set_result_name(*result_name);

      // If we can return from cache at this point then do so.
      auto result = from_cache(ctx, FromCacheCallMode::direct);
      if (result) {
        return *result;
      }

      // Wasn't able to return from cache at this point. However, the result
      // was already found in manifest, so don't re-add it later.
      put_result_in_manifest = false;

      result_name_from_manifest = result_name;
    } else {
      // Add result to manifest later.
      put_result_in_manifest = true;
    }
  }

  if (ctx.config.read_only_direct()) {
    LOG_RAW(""Read-only direct mode; running real compiler"");
    throw Failure(Statistic::cache_miss);
  }

  if (!ctx.config.depend_mode()) {
    // Find the hash using the preprocessed output. Also updates
    // ctx.included_files.
    Hash cpp_hash = common_hash;
    init_hash_debug(ctx, cpp_hash, 'p', ""PREPROCESSOR MODE"", debug_text_file);

    MTR_BEGIN(""hash"", ""cpp_hash"");
    result_name = calculate_result_name(
      ctx, args_to_hash, processed.preprocessor_args, cpp_hash, false);
    MTR_END(""hash"", ""cpp_hash"");

    // calculate_result_name does not return nullopt if the last (direct_mode)
    // argument is false.
    ASSERT(result_name);
    ctx.set_result_name(*result_name);

    if (result_name_from_manifest && result_name_from_manifest != result_name) {
      // manifest_path is guaranteed to be set when calculate_result_name
      // returns a non-nullopt result in direct mode, i.e. when
      // result_name_from_manifest is set.
      ASSERT(ctx.manifest_path());

      // The hash from manifest differs from the hash of the preprocessor
      // output. This could be because:
      //
      // - The preprocessor produces different output for the same input (not
      //   likely).
      // - There's a bug in ccache (maybe incorrect handling of compiler
      //   arguments).
      // - The user has used a different CCACHE_BASEDIR (most likely).
      //
      // The best thing here would probably be to remove the hash entry from
      // the manifest. For now, we use a simpler method: just remove the
      // manifest file.
      LOG_RAW(""Hash from manifest doesn't match preprocessor output"");
      LOG_RAW(""Likely reason: different CCACHE_BASEDIRs used"");
      LOG_RAW(""Removing manifest as a safety measure"");
      Util::unlink_safe(*ctx.manifest_path());

      put_result_in_manifest = true;
    }

    // If we can return from cache at this point then do.
    auto result = from_cache(ctx, FromCacheCallMode::cpp);
    if (result) {
      if (put_result_in_manifest) {
        update_manifest_file(ctx);
      }
      return *result;
    }
  }

  if (ctx.config.read_only()) {
    LOG_RAW(""Read-only mode; running real compiler"");
    throw Failure(Statistic::cache_miss);
  }

  add_prefix(ctx, processed.compiler_args, ctx.config.prefix_command());

  // In depend_mode, extend the direct hash.
  Hash* depend_mode_hash = ctx.config.depend_mode() ? &direct_hash : nullptr;

  // Run real compiler, sending output to cache.
  MTR_BEGIN(""cache"", ""to_cache"");
  to_cache(ctx,
           processed.compiler_args,
           ctx.args_info.depend_extra_args,
           depend_mode_hash);
  update_manifest_file(ctx);
  MTR_END(""cache"", ""to_cache"");

  return Statistic::cache_miss;
}

// The main program when not doing a compile.
static int
handle_main_options(int argc, const char* const* argv)
{
  enum longopts {
    CHECKSUM_FILE,
    CONFIG_PATH,
    DUMP_MANIFEST,
    DUMP_RESULT,
    EVICT_OLDER_THAN,
    EXTRACT_RESULT,
    HASH_FILE,
    PRINT_STATS,
  };
  static const struct option options[] = {
    {""checksum-file"", required_argument, nullptr, CHECKSUM_FILE},
    {""cleanup"", no_argument, nullptr, 'c'},
    {""clear"", no_argument, nullptr, 'C'},
    {""config-path"", required_argument, nullptr, CONFIG_PATH},
    {""directory"", required_argument, nullptr, 'd'},
    {""dump-manifest"", required_argument, nullptr, DUMP_MANIFEST},
    {""dump-result"", required_argument, nullptr, DUMP_RESULT},
    {""evict-older-than"", required_argument, nullptr, EVICT_OLDER_THAN},
    {""extract-result"", required_argument, nullptr, EXTRACT_RESULT},
    {""get-config"", required_argument, nullptr, 'k'},
    {""hash-file"", required_argument, nullptr, HASH_FILE},
    {""help"", no_argument, nullptr, 'h'},
    {""max-files"", required_argument, nullptr, 'F'},
    {""max-size"", required_argument, nullptr, 'M'},
    {""print-stats"", no_argument, nullptr, PRINT_STATS},
    {""recompress"", required_argument, nullptr, 'X'},
    {""set-config"", required_argument, nullptr, 'o'},
    {""show-compression"", no_argument, nullptr, 'x'},
    {""show-config"", no_argument, nullptr, 'p'},
    {""show-stats"", no_argument, nullptr, 's'},
    {""version"", no_argument, nullptr, 'V'},
    {""zero-stats"", no_argument, nullptr, 'z'},
    {nullptr, 0, nullptr, 0}};

  Context ctx;
  initialize(ctx, argc, argv);

  int c;
  while ((c = getopt_long(argc,
                          const_cast<char* const*>(argv),
                          ""cCd:k:hF:M:po:sVxX:z"",
                          options,
                          nullptr))
         != -1) {
    std::string arg = optarg ? optarg : std::string();

    switch (c) {
    case CHECKSUM_FILE: {
      Checksum checksum;
      Fd fd(arg == ""-"" ? STDIN_FILENO : open(arg.c_str(), O_RDONLY));
      Util::read_fd(*fd, [&checksum](const void* data, size_t size) {
        checksum.update(data, size);
      });
      PRINT(stdout, ""{:016x}\n"", checksum.digest());
      break;
    }

    case CONFIG_PATH:
      Util::setenv(""CCACHE_CONFIGPATH"", arg);
      break;

    case DUMP_MANIFEST:
      return Manifest::dump(arg, stdout) ? 0 : 1;

    case DUMP_RESULT: {
      ResultDumper result_dumper(stdout);
      Result::Reader result_reader(arg);
      auto error = result_reader.read(result_dumper);
      if (error) {
        PRINT(stderr, ""Error: {}\n"", *error);
      }
      return error ? EXIT_FAILURE : EXIT_SUCCESS;
    }

    case EVICT_OLDER_THAN: {
      auto seconds = Util::parse_duration(arg);
      ProgressBar progress_bar(""Evicting..."");
      clean_old(
        ctx, [&](double progress) { progress_bar.update(progress); }, seconds);
      if (isatty(STDOUT_FILENO)) {
        PRINT_RAW(stdout, ""\n"");
      }
      break;
    }

    case EXTRACT_RESULT: {
      ResultExtractor result_extractor(""."");
      Result::Reader result_reader(arg);
      auto error = result_reader.read(result_extractor);
      if (error) {
        PRINT(stderr, ""Error: {}\n"", *error);
      }
      return error ? EXIT_FAILURE : EXIT_SUCCESS;
    }

    case HASH_FILE: {
      Hash hash;
      if (arg == ""-"") {
        hash.hash_fd(STDIN_FILENO);
      } else {
        hash.hash_file(arg);
      }
      PRINT(stdout, ""{}\n"", hash.digest().to_string());
      break;
    }

    case PRINT_STATS:
      PRINT_RAW(stdout, Statistics::format_machine_readable(ctx.config));
      break;

    case 'c': // --cleanup
    {
      ProgressBar progress_bar(""Cleaning..."");
      clean_up_all(ctx.config,
                   [&](double progress) { progress_bar.update(progress); });
      if (isatty(STDOUT_FILENO)) {
        PRINT_RAW(stdout, ""\n"");
      }
      break;
    }

    case 'C': // --clear
    {
      ProgressBar progress_bar(""Clearing..."");
      wipe_all(ctx, [&](double progress) { progress_bar.update(progress); });
      if (isatty(STDOUT_FILENO)) {
        PRINT_RAW(stdout, ""\n"");
      }
      break;
    }

    case 'd': // --directory
      Util::setenv(""CCACHE_DIR"", arg);
      break;

    case 'h': // --help
      PRINT(stdout, USAGE_TEXT, CCACHE_NAME, CCACHE_NAME);
      exit(EXIT_SUCCESS);

    case 'k': // --get-config
      PRINT(stdout, ""{}\n"", ctx.config.get_string_value(arg));
      break;

    case 'F': { // --max-files
      auto files = Util::parse_unsigned(arg);
      Config::set_value_in_file(
        ctx.config.primary_config_path(), ""max_files"", arg);
      if (files == 0) {
        PRINT_RAW(stdout, ""Unset cache file limit\n"");
      } else {
        PRINT(stdout, ""Set cache file limit to {}\n"", files);
      }
      break;
    }

    case 'M': { // --max-size
      uint64_t size = Util::parse_size(arg);
      Config::set_value_in_file(
        ctx.config.primary_config_path(), ""max_size"", arg);
      if (size == 0) {
        PRINT_RAW(stdout, ""Unset cache size limit\n"");
      } else {
        PRINT(stdout,
              ""Set cache size limit to {}\n"",
              Util::format_human_readable_size(size));
      }
      break;
    }

    case 'o': { // --set-config
      // Start searching for equal sign at position 1 to improve error message
      // for the -o=K=V case (key ""=K"" and value ""V"").
      size_t eq_pos = arg.find('=', 1);
      if (eq_pos == std::string::npos) {
        throw Error(""missing equal sign in \""{}\"""", arg);
      }
      std::string key = arg.substr(0, eq_pos);
      std::string value = arg.substr(eq_pos + 1);
      Config::set_value_in_file(ctx.config.primary_config_path(), key, value);
      break;
    }

    case 'p': // --show-config
      ctx.config.visit_items(configuration_printer);
      break;

    case 's': // --show-stats
      PRINT_RAW(stdout, Statistics::format_human_readable(ctx.config));
      break;

    case 'V': // --version
      PRINT(VERSION_TEXT, CCACHE_NAME, CCACHE_VERSION);
      exit(EXIT_SUCCESS);

    case 'x': // --show-compression
    {
      ProgressBar progress_bar(""Scanning..."");
      compress_stats(ctx.config,
                     [&](double progress) { progress_bar.update(progress); });
      break;
    }

    case 'X': // --recompress
    {
      optional<int8_t> wanted_level;
      if (arg == ""uncompressed"") {
        wanted_level = nullopt;
      } else {
        wanted_level =
          Util::parse_signed(arg, INT8_MIN, INT8_MAX, ""compression level"");
      }

      ProgressBar progress_bar(""Recompressing..."");
      compress_recompress(ctx, wanted_level, [&](double progress) {
        progress_bar.update(progress);
      });
      break;
    }

    case 'z': // --zero-stats
      Statistics::zero_all_counters(ctx.config);
      PRINT_RAW(stdout, ""Statistics zeroed\n"");
      break;

    default:
      PRINT(stderr, USAGE_TEXT, CCACHE_NAME, CCACHE_NAME);
      exit(EXIT_FAILURE);
    }

    // Some of the above switches might have changed config settings, so run the
    // setup again.
    ctx.config = Config();
    set_up_config(ctx.config);
  }

  return 0;
}

int ccache_main(int argc, const char* const* argv);

int
ccache_main(int argc, const char* const* argv)
{
  try {
    // Check if we are being invoked as ""ccache"".
    std::string program_name(Util::base_name(argv[0]));
    if (Util::same_program_name(program_name, CCACHE_NAME)) {
      if (argc < 2) {
        PRINT(stderr, USAGE_TEXT, CCACHE_NAME, CCACHE_NAME);
        exit(EXIT_FAILURE);
      }
      // If the first argument isn't an option, then assume we are being passed
      // a compiler name and options.
      if (argv[1][0] == '-') {
        return handle_main_options(argc, argv);
      }
    }

    return cache_compilation(argc, argv);
  } catch (const ErrorBase& e) {
    PRINT(stderr, ""ccache: error: {}\n"", e.what());
    return EXIT_FAILURE;
  }
}
""","""// Copyright (C) 2002-2007 Andrew Tridgell
// Copyright (C) 2009-2021 Joel Rosdahl and other contributors
//
// See doc/AUTHORS.adoc for a complete list of contributors.
//
// This program is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by the Free
// Software Foundation; either version 3 of the License, or (at your option)
// any later version.
//
// This program is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
// more details.
//
// You should have received a copy of the GNU General Public License along with
// this program; if not, write to the Free Software Foundation, Inc., 51
// Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA

#include ""ccache.hpp""

#include ""Args.hpp""
#include ""ArgsInfo.hpp""
#include ""Checksum.hpp""
#include ""Compression.hpp""
#include ""Context.hpp""
#include ""Depfile.hpp""
#include ""Fd.hpp""
#include ""File.hpp""
#include ""Finalizer.hpp""
#include ""FormatNonstdStringView.hpp""
#include ""Hash.hpp""
#include ""Lockfile.hpp""
#include ""Logging.hpp""
#include ""Manifest.hpp""
#include ""MiniTrace.hpp""
#include ""ProgressBar.hpp""
#include ""Result.hpp""
#include ""ResultDumper.hpp""
#include ""ResultExtractor.hpp""
#include ""ResultRetriever.hpp""
#include ""SignalHandler.hpp""
#include ""Statistics.hpp""
#include ""StdMakeUnique.hpp""
#include ""TemporaryFile.hpp""
#include ""UmaskScope.hpp""
#include ""Util.hpp""
#include ""argprocessing.hpp""
#include ""cleanup.hpp""
#include ""compopt.hpp""
#include ""compress.hpp""
#include ""exceptions.hpp""
#include ""execute.hpp""
#include ""fmtmacros.hpp""
#include ""hashutil.hpp""
#include ""language.hpp""

#include ""third_party/fmt/core.h""
#include ""third_party/nonstd/optional.hpp""
#include ""third_party/nonstd/string_view.hpp""

#ifdef HAVE_GETOPT_LONG
#  include <getopt.h>
#elif defined(_WIN32)
#  include ""third_party/win32/getopt.h""
#else
extern ""C"" {
#  include ""third_party/getopt_long.h""
}
#endif

#ifdef _WIN32
#  include ""Win32Util.hpp""
#endif

#include <algorithm>
#include <cmath>
#include <limits>

#ifndef MYNAME
#  define MYNAME ""ccache""
#endif
const char CCACHE_NAME[] = MYNAME;

using nonstd::nullopt;
using nonstd::optional;
using nonstd::string_view;

constexpr const char VERSION_TEXT[] =
  R""({} version {}

Copyright (C) 2002-2007 Andrew Tridgell
Copyright (C) 2009-2021 Joel Rosdahl and other contributors

See <https://ccache.dev/credits.html> for a complete list of contributors.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 3 of the License, or (at your option) any later
version.
)"";

constexpr const char USAGE_TEXT[] =
  R""(Usage:
    {} [options]
    {} compiler [compiler options]
    compiler [compiler options]          (via symbolic link)

Common options:
    -c, --cleanup              delete old files and recalculate size counters
                               (normally not needed as this is done
                               automatically)
    -C, --clear                clear the cache completely (except configuration)
        --config-path PATH     operate on configuration file PATH instead of the
                               default
    -d, --directory PATH       operate on cache directory PATH instead of the
                               default
        --evict-older-than AGE remove files older than AGE (unsigned integer
                               with a d (days) or s (seconds) suffix)
    -F, --max-files NUM        set maximum number of files in cache to NUM (use
                               0 for no limit)
    -M, --max-size SIZE        set maximum size of cache to SIZE (use 0 for no
                               limit); available suffixes: k, M, G, T (decimal)
                               and Ki, Mi, Gi, Ti (binary); default suffix: G
    -X, --recompress LEVEL     recompress the cache to level LEVEL (integer or
                               ""uncompressed"") using the Zstandard algorithm;
                               see ""Cache compression"" in the manual for details
    -o, --set-config KEY=VAL   set configuration item KEY to value VAL
    -x, --show-compression     show compression statistics
    -p, --show-config          show current configuration options in
                               human-readable format
    -s, --show-stats           show summary of configuration and statistics
                               counters in human-readable format
    -z, --zero-stats           zero statistics counters

    -h, --help                 print this help text
    -V, --version              print version and copyright information

Options for scripting or debugging:
        --checksum-file PATH   print the checksum (64 bit XXH3) of the file at
                               PATH
        --dump-manifest PATH   dump manifest file at PATH in text format
        --dump-result PATH     dump result file at PATH in text format
        --extract-result PATH  extract data stored in result file at PATH to the
                               current working directory
    -k, --get-config KEY       print the value of configuration key KEY
        --hash-file PATH       print the hash (160 bit BLAKE3) of the file at
                               PATH
        --print-stats          print statistics counter IDs and corresponding
                               values in machine-parsable format

See also the manual on <https://ccache.dev/documentation.html>.
)"";

// How often (in seconds) to scan $CCACHE_DIR/tmp for left-over temporary
// files.
const int k_tempdir_cleanup_interval = 2 * 24 * 60 * 60; // 2 days

// Maximum files per cache directory. This constant is somewhat arbitrarily
// chosen to be large enough to avoid unnecessary cache levels but small enough
// not to make esoteric file systems (with bad performance for large
// directories) too slow. It could be made configurable, but hopefully there
// will be no need to do that.
const uint64_t k_max_cache_files_per_directory = 2000;

// Minimum number of cache levels ($CCACHE_DIR/1/2/stored_file).
const uint8_t k_min_cache_levels = 2;

// Maximum number of cache levels ($CCACHE_DIR/1/2/3/stored_file).
//
// On a cache miss, (k_max_cache_levels - k_min_cache_levels + 1) cache lookups
// (i.e. stat system calls) will be performed for a cache entry.
//
// An assumption made here is that if a cache is so large that it holds more
// than 16^4 * k_max_cache_files_per_directory files then we can assume that the
// file system is sane enough to handle more than
// k_max_cache_files_per_directory.
const uint8_t k_max_cache_levels = 4;

// This is a string that identifies the current ""version"" of the hash sum
// computed by ccache. If, for any reason, we want to force the hash sum to be
// different for the same input in a new ccache version, we can just change
// this string. A typical example would be if the format of one of the files
// stored in the cache changes in a backwards-incompatible way.
const char HASH_PREFIX[] = ""3"";

namespace {

// Throw a Failure if ccache did not succeed in getting or putting a result in
// the cache. If `exit_code` is set, just exit with that code directly,
// otherwise execute the real compiler and exit with its exit code. Also updates
// statistics counter `statistic` if it's not `Statistic::none`.
class Failure : public std::exception
{
public:
  Failure(Statistic statistic,
          nonstd::optional<int> exit_code = nonstd::nullopt);

  nonstd::optional<int> exit_code() const;
  Statistic statistic() const;

private:
  Statistic m_statistic;
  nonstd::optional<int> m_exit_code;
};

inline Failure::Failure(Statistic statistic, nonstd::optional<int> exit_code)
  : m_statistic(statistic), m_exit_code(exit_code)
{
}

inline nonstd::optional<int>
Failure::exit_code() const
{
  return m_exit_code;
}

inline Statistic
Failure::statistic() const
{
  return m_statistic;
}

} // namespace

static void
add_prefix(const Context& ctx, Args& args, const std::string& prefix_command)
{
  if (prefix_command.empty()) {
    return;
  }

  Args prefix;
  for (const auto& word : Util::split_into_strings(prefix_command, "" "")) {
    std::string path = find_executable(ctx, word, CCACHE_NAME);
    if (path.empty()) {
      throw Fatal(""{}: {}"", word, strerror(errno));
    }

    prefix.push_back(path);
  }

  LOG(""Using command-line prefix {}"", prefix_command);
  for (size_t i = prefix.size(); i != 0; i--) {
    args.push_front(prefix[i - 1]);
  }
}

static void
clean_up_internal_tempdir(const Config& config)
{
  time_t now = time(nullptr);
  auto dir_st = Stat::stat(config.cache_dir(), Stat::OnError::log);
  if (!dir_st || dir_st.mtime() + k_tempdir_cleanup_interval >= now) {
    // No cleanup needed.
    return;
  }

  Util::update_mtime(config.cache_dir());

  const std::string& temp_dir = config.temporary_dir();
  if (!Stat::lstat(temp_dir)) {
    return;
  }

  Util::traverse(temp_dir, [now](const std::string& path, bool is_dir) {
    if (is_dir) {
      return;
    }
    auto st = Stat::lstat(path, Stat::OnError::log);
    if (st && st.mtime() + k_tempdir_cleanup_interval < now) {
      Util::unlink_tmp(path);
    }
  });
}

static std::string
prepare_debug_path(const std::string& debug_dir,
                   const std::string& output_obj,
                   string_view suffix)
{
  const std::string prefix =
    debug_dir.empty() ? output_obj : debug_dir + Util::real_path(output_obj);
  try {
    Util::ensure_dir_exists(Util::dir_name(prefix));
  } catch (Error&) {
    // Ignore since we can't handle an error in another way in this context. The
    // caller takes care of logging when trying to open the path for writing.
  }
  return FMT(""{}.ccache-{}"", prefix, suffix);
}

static void
init_hash_debug(Context& ctx,
                Hash& hash,
                char type,
                string_view section_name,
                FILE* debug_text_file)
{
  if (!ctx.config.debug()) {
    return;
  }

  const auto path = prepare_debug_path(
    ctx.config.debug_dir(), ctx.args_info.output_obj, FMT(""input-{}"", type));
  File debug_binary_file(path, ""wb"");
  if (debug_binary_file) {
    hash.enable_debug(section_name, debug_binary_file.get(), debug_text_file);
    ctx.hash_debug_files.push_back(std::move(debug_binary_file));
  } else {
    LOG(""Failed to open {}: {}"", path, strerror(errno));
  }
}

CompilerType
guess_compiler(string_view path)
{
  std::string compiler_path(path);

#ifndef _WIN32
  // Follow symlinks to the real compiler to learn its name. We're not using
  // Util::real_path in order to save some unnecessary stat calls.
  while (true) {
    std::string symlink_value = Util::read_link(compiler_path);
    if (symlink_value.empty()) {
      break;
    }
    if (Util::is_absolute_path(symlink_value)) {
      compiler_path = symlink_value;
    } else {
      compiler_path =
        FMT(""{}/{}"", Util::dir_name(compiler_path), symlink_value);
    }
  }
#endif

  const string_view name = Util::base_name(compiler_path);
  if (name.find(""clang"") != nonstd::string_view::npos) {
    return CompilerType::clang;
  } else if (name.find(""gcc"") != nonstd::string_view::npos
             || name.find(""g++"") != nonstd::string_view::npos) {
    return CompilerType::gcc;
  } else if (name.find(""nvcc"") != nonstd::string_view::npos) {
    return CompilerType::nvcc;
  } else if (name == ""pump"" || name == ""distcc-pump"") {
    return CompilerType::pump;
  } else {
    return CompilerType::other;
  }
}

static bool
include_file_too_new(const Context& ctx,
                     const std::string& path,
                     const Stat& path_stat)
{
  // The comparison using >= is intentional, due to a possible race between
  // starting compilation and writing the include file. See also the notes under
  // ""Performance"" in doc/MANUAL.adoc.
  if (!(ctx.config.sloppiness() & SLOPPY_INCLUDE_FILE_MTIME)
      && path_stat.mtime() >= ctx.time_of_compilation) {
    LOG(""Include file {} too new"", path);
    return true;
  }

  // The same >= logic as above applies to the change time of the file.
  if (!(ctx.config.sloppiness() & SLOPPY_INCLUDE_FILE_CTIME)
      && path_stat.ctime() >= ctx.time_of_compilation) {
    LOG(""Include file {} ctime too new"", path);
    return true;
  }

  return false;
}

// Returns false if the include file was ""too new"" and therefore should disable
// the direct mode (or, in the case of a preprocessed header, fall back to just
// running the real compiler), otherwise true.
static bool
do_remember_include_file(Context& ctx,
                         std::string path,
                         Hash& cpp_hash,
                         bool system,
                         Hash* depend_mode_hash)
{
  if (path.length() >= 2 && path[0] == '<' && path[path.length() - 1] == '>') {
    // Typically <built-in> or <command-line>.
    return true;
  }

  if (path == ctx.args_info.input_file) {
    // Don't remember the input file.
    return true;
  }

  if (system && (ctx.config.sloppiness() & SLOPPY_SYSTEM_HEADERS)) {
    // Don't remember this system header.
    return true;
  }

  // Canonicalize path for comparison; Clang uses ./header.h.
  if (Util::starts_with(path, ""./"")) {
    path.erase(0, 2);
  }

  if (ctx.included_files.find(path) != ctx.included_files.end()) {
    // Already known include file.
    return true;
  }

#ifdef _WIN32
  {
    // stat fails on directories on win32.
    DWORD attributes = GetFileAttributes(path.c_str());
    if (attributes != INVALID_FILE_ATTRIBUTES
        && attributes & FILE_ATTRIBUTE_DIRECTORY) {
      return true;
    }
  }
#endif

  auto st = Stat::stat(path, Stat::OnError::log);
  if (!st) {
    return false;
  }
  if (st.is_directory()) {
    // Ignore directory, typically $PWD.
    return true;
  }
  if (!st.is_regular()) {
    // Device, pipe, socket or other strange creature.
    LOG(""Non-regular include file {}"", path);
    return false;
  }

  for (const auto& ignore_header_path : ctx.ignore_header_paths) {
    if (Util::matches_dir_prefix_or_file(ignore_header_path, path)) {
      return true;
    }
  }

  const bool is_pch = Util::is_precompiled_header(path);
  const bool too_new = include_file_too_new(ctx, path, st);

  if (too_new) {
    // Opt out of direct mode because of a race condition.
    //
    // The race condition consists of these events:
    //
    // - the preprocessor is run
    // - an include file is modified by someone
    // - the new include file is hashed by ccache
    // - the real compiler is run on the preprocessor's output, which contains
    //   data from the old header file
    // - the wrong object file is stored in the cache.

    return false;
  }

  // Let's hash the include file content.
  Hash fhash;

  if (is_pch) {
    if (ctx.included_pch_file.empty()) {
      LOG(""Detected use of precompiled header: {}"", path);
    }
    bool using_pch_sum = false;
    if (ctx.config.pch_external_checksum()) {
      // hash pch.sum instead of pch when it exists
      // to prevent hashing a very large .pch file every time
      std::string pch_sum_path = FMT(""{}.sum"", path);
      if (Stat::stat(pch_sum_path, Stat::OnError::log)) {
        path = std::move(pch_sum_path);
        using_pch_sum = true;
        LOG(""Using pch.sum file {}"", path);
      }
    }

    if (!hash_binary_file(ctx, fhash, path)) {
      return false;
    }
    cpp_hash.hash_delimiter(using_pch_sum ? ""pch_sum_hash"" : ""pch_hash"");
    cpp_hash.hash(fhash.digest().to_string());
  }

  if (ctx.config.direct_mode()) {
    if (!is_pch) { // else: the file has already been hashed.
      int result = hash_source_code_file(ctx, fhash, path);
      if (result & HASH_SOURCE_CODE_ERROR
          || result & HASH_SOURCE_CODE_FOUND_TIME) {
        return false;
      }
    }

    Digest d = fhash.digest();
    ctx.included_files.emplace(path, d);

    if (depend_mode_hash) {
      depend_mode_hash->hash_delimiter(""include"");
      depend_mode_hash->hash(d.to_string());
    }
  }

  return true;
}

enum class RememberIncludeFileResult { ok, cannot_use_pch };

// This function hashes an include file and stores the path and hash in
// ctx.included_files. If the include file is a PCH, cpp_hash is also updated.
static RememberIncludeFileResult
remember_include_file(Context& ctx,
                      const std::string& path,
                      Hash& cpp_hash,
                      bool system,
                      Hash* depend_mode_hash)
{
  if (!do_remember_include_file(
        ctx, path, cpp_hash, system, depend_mode_hash)) {
    if (Util::is_precompiled_header(path)) {
      return RememberIncludeFileResult::cannot_use_pch;
    } else if (ctx.config.direct_mode()) {
      LOG_RAW(""Disabling direct mode"");
      ctx.config.set_direct_mode(false);
    }
  }

  return RememberIncludeFileResult::ok;
}

static void
print_included_files(const Context& ctx, FILE* fp)
{
  for (const auto& item : ctx.included_files) {
    PRINT(fp, ""{}\n"", item.first);
  }
}

// This function reads and hashes a file. While doing this, it also does these
// things:
//
// - Makes include file paths for which the base directory is a prefix relative
//   when computing the hash sum.
// - Stores the paths and hashes of included files in ctx.included_files.
//
// Returns Statistic::none on success, otherwise a statistics counter to be
// incremented.
static Statistic
process_preprocessed_file(Context& ctx,
                          Hash& hash,
                          const std::string& path,
                          bool pump)
{
  std::string data;
  try {
    data = Util::read_file(path);
  } catch (Error&) {
    return Statistic::internal_error;
  }

  // Bytes between p and q are pending to be hashed.
  const char* p = &data[0];
  char* q = &data[0];
  const char* end = p + data.length();

  // There must be at least 7 characters (# 1 ""x"") left to potentially find an
  // include file path.
  while (q < end - 7) {
    static const string_view pragma_gcc_pch_preprocess =
      ""pragma GCC pch_preprocess "";
    static const string_view hash_31_command_line_newline =
      ""# 31 \""<command-line>\""\n"";
    static const string_view hash_32_command_line_2_newline =
      ""# 32 \""<command-line>\"" 2\n"";

    // Check if we look at a line containing the file name of an included file.
    // At least the following formats exist (where N is a positive integer):
    //
    // GCC:
    //
    //   # N ""file""
    //   # N ""file"" N
    //   #pragma GCC pch_preprocess ""file""
    //
    // HP's compiler:
    //
    //   #line N ""file""
    //
    // AIX's compiler:
    //
    //   #line N ""file""
    //   #line N
    //
    // Note that there may be other lines starting with '#' left after
    // preprocessing as well, for instance ""#    pragma"".
    if (q[0] == '#'
        // GCC:
        && ((q[1] == ' ' && q[2] >= '0' && q[2] <= '9')
            // GCC precompiled header:
            || Util::starts_with(&q[1], pragma_gcc_pch_preprocess)
            // HP/AIX:
            || (q[1] == 'l' && q[2] == 'i' && q[3] == 'n' && q[4] == 'e'
                && q[5] == ' '))
        && (q == data.data() || q[-1] == '\n')) {
      // Workarounds for preprocessor linemarker bugs in GCC version 6.
      if (q[2] == '3') {
        if (Util::starts_with(q, hash_31_command_line_newline)) {
          // Bogus extra line with #31, after the regular #1: Ignore the whole
          // line, and continue parsing.
          hash.hash(p, q - p);
          while (q < end && *q != '\n') {
            q++;
          }
          q++;
          p = q;
          continue;
        } else if (Util::starts_with(q, hash_32_command_line_2_newline)) {
          // Bogus wrong line with #32, instead of regular #1: Replace the line
          // number with the usual one.
          hash.hash(p, q - p);
          q += 1;
          q[0] = '#';
          q[1] = ' ';
          q[2] = '1';
          p = q;
        }
      }

      while (q < end && *q != '""' && *q != '\n') {
        q++;
      }
      if (q < end && *q == '\n') {
        // A newline before the quotation mark -> no match.
        continue;
      }
      q++;
      if (q >= end) {
        LOG_RAW(""Failed to parse included file path"");
        return Statistic::internal_error;
      }
      // q points to the beginning of an include file path
      hash.hash(p, q - p);
      p = q;
      while (q < end && *q != '""') {
        q++;
      }
      // Look for preprocessor flags, after the ""filename"".
      bool system = false;
      const char* r = q + 1;
      while (r < end && *r != '\n') {
        if (*r == '3') { // System header.
          system = true;
        }
        r++;
      }
      // p and q span the include file path.
      std::string inc_path(p, q - p);
      if (!ctx.has_absolute_include_headers) {
        ctx.has_absolute_include_headers = Util::is_absolute_path(inc_path);
      }
      inc_path = Util::make_relative_path(ctx, inc_path);

      bool should_hash_inc_path = true;
      if (!ctx.config.hash_dir()) {
        if (Util::starts_with(inc_path, ctx.apparent_cwd)
            && Util::ends_with(inc_path, ""//"")) {
          // When compiling with -g or similar, GCC adds the absolute path to
          // CWD like this:
          //
          //   # 1 ""CWD//""
          //
          // If the user has opted out of including the CWD in the hash, don't
          // hash it. See also how debug_prefix_map is handled.
          should_hash_inc_path = false;
        }
      }
      if (should_hash_inc_path) {
        hash.hash(inc_path);
      }

      if (remember_include_file(ctx, inc_path, hash, system, nullptr)
          == RememberIncludeFileResult::cannot_use_pch) {
        return Statistic::could_not_use_precompiled_header;
      }
      p = q; // Everything of interest between p and q has been hashed now.
    } else if (q[0] == '.' && q[1] == 'i' && q[2] == 'n' && q[3] == 'c'
               && q[4] == 'b' && q[5] == 'i' && q[6] == 'n') {
      // An assembler .inc bin (without the space) statement, which could be
      // part of inline assembly, refers to an external file. If the file
      // changes, the hash should change as well, but finding out what file to
      // hash is too hard for ccache, so just bail out.
      LOG_RAW(
        ""Found unsupported .inc""
        ""bin directive in source code"");
      throw Failure(Statistic::unsupported_code_directive);
    } else if (pump && strncmp(q, ""_________"", 9) == 0) {
      // Unfortunately the distcc-pump wrapper outputs standard output lines:
      // __________Using distcc-pump from /usr/bin
      // __________Using # distcc servers in pump mode
      // __________Shutting down distcc-pump include server
      while (q < end && *q != '\n') {
        q++;
      }
      if (*q == '\n') {
        q++;
      }
      p = q;
      continue;
    } else {
      q++;
    }
  }

  hash.hash(p, (end - p));

  // Explicitly check the .gch/.pch/.pth file as Clang does not include any
  // mention of it in the preprocessed output.
  if (!ctx.included_pch_file.empty()) {
    std::string pch_path = Util::make_relative_path(ctx, ctx.included_pch_file);
    hash.hash(pch_path);
    remember_include_file(ctx, pch_path, hash, false, nullptr);
  }

  bool debug_included = getenv(""CCACHE_DEBUG_INCLUDED"");
  if (debug_included) {
    print_included_files(ctx, stdout);
  }

  return Statistic::none;
}

// Extract the used includes from the dependency file. Note that we cannot
// distinguish system headers from other includes here.
static optional<Digest>
result_name_from_depfile(Context& ctx, Hash& hash)
{
  std::string file_content;
  try {
    file_content = Util::read_file(ctx.args_info.output_dep);
  } catch (const Error& e) {
    LOG(
      ""Cannot open dependency file {}: {}"", ctx.args_info.output_dep, e.what());
    return nullopt;
  }

  for (string_view token : Depfile::tokenize(file_content)) {
    if (token.ends_with("":"")) {
      continue;
    }
    if (!ctx.has_absolute_include_headers) {
      ctx.has_absolute_include_headers = Util::is_absolute_path(token);
    }
    std::string path = Util::make_relative_path(ctx, token);
    remember_include_file(ctx, path, hash, false, &hash);
  }

  // Explicitly check the .gch/.pch/.pth file as it may not be mentioned in the
  // dependencies output.
  if (!ctx.included_pch_file.empty()) {
    std::string pch_path = Util::make_relative_path(ctx, ctx.included_pch_file);
    hash.hash(pch_path);
    remember_include_file(ctx, pch_path, hash, false, nullptr);
  }

  bool debug_included = getenv(""CCACHE_DEBUG_INCLUDED"");
  if (debug_included) {
    print_included_files(ctx, stdout);
  }

  return hash.digest();
}
// Execute the compiler/preprocessor, with logic to retry without requesting
// colored diagnostics messages if that fails.
static int
do_execute(Context& ctx,
           Args& args,
           TemporaryFile&& tmp_stdout,
           TemporaryFile&& tmp_stderr)
{
  UmaskScope umask_scope(ctx.original_umask);

  if (ctx.diagnostics_color_failed) {
    DEBUG_ASSERT(ctx.config.compiler_type() == CompilerType::gcc);
    args.erase_last(""-fdiagnostics-color"");
  }
  int status = execute(ctx,
                       args.to_argv().data(),
                       std::move(tmp_stdout.fd),
                       std::move(tmp_stderr.fd));
  if (status != 0 && !ctx.diagnostics_color_failed
      && ctx.config.compiler_type() == CompilerType::gcc) {
    auto errors = Util::read_file(tmp_stderr.path);
    if (errors.find(""fdiagnostics-color"") != std::string::npos) {
      // GCC versions older than 4.9 don't understand -fdiagnostics-color, and
      // non-GCC compilers misclassified as CompilerType::gcc might not do it
      // either. We assume that if the error message contains
      // ""fdiagnostics-color"" then the compilation failed due to
      // -fdiagnostics-color being unsupported and we then retry without the
      // flag. (Note that there intentionally is no leading dash in
      // ""fdiagnostics-color"" since some compilers don't include the dash in the
      // error message.)
      LOG_RAW(""-fdiagnostics-color is unsupported; trying again without it"");

      tmp_stdout.fd = Fd(open(
        tmp_stdout.path.c_str(), O_RDWR | O_CREAT | O_TRUNC | O_BINARY, 0600));
      if (!tmp_stdout.fd) {
        LOG(""Failed to truncate {}: {}"", tmp_stdout.path, strerror(errno));
        throw Failure(Statistic::internal_error);
      }

      tmp_stderr.fd = Fd(open(
        tmp_stderr.path.c_str(), O_RDWR | O_CREAT | O_TRUNC | O_BINARY, 0600));
      if (!tmp_stderr.fd) {
        LOG(""Failed to truncate {}: {}"", tmp_stderr.path, strerror(errno));
        throw Failure(Statistic::internal_error);
      }

      ctx.diagnostics_color_failed = true;
      return do_execute(
        ctx, args, std::move(tmp_stdout), std::move(tmp_stderr));
    }
  }
  return status;
}

struct LookUpCacheFileResult
{
  std::string path;
  Stat stat;
  uint8_t level;
};

static LookUpCacheFileResult
look_up_cache_file(const std::string& cache_dir,
                   const Digest& name,
                   nonstd::string_view suffix)
{
  const auto name_string = FMT(""{}{}"", name.to_string(), suffix);

  for (uint8_t level = k_min_cache_levels; level <= k_max_cache_levels;
       ++level) {
    const auto path = Util::get_path_in_cache(cache_dir, level, name_string);
    const auto stat = Stat::stat(path);
    if (stat) {
      return {path, stat, level};
    }
  }

  const auto shallowest_path =
    Util::get_path_in_cache(cache_dir, k_min_cache_levels, name_string);
  return {shallowest_path, Stat(), k_min_cache_levels};
}

// Create or update the manifest file.
static void
update_manifest_file(Context& ctx)
{
  if (!ctx.config.direct_mode() || ctx.config.read_only()
      || ctx.config.read_only_direct()) {
    return;
  }

  ASSERT(ctx.manifest_path());
  ASSERT(ctx.result_path());

  MTR_BEGIN(""manifest"", ""manifest_put"");

  const auto old_stat = Stat::stat(*ctx.manifest_path());

  // See comment in get_file_hash_index for why saving of timestamps is forced
  // for precompiled headers.
  const bool save_timestamp =
    (ctx.config.sloppiness() & SLOPPY_FILE_STAT_MATCHES)
    || ctx.args_info.output_is_precompiled_header;

  LOG(""Adding result name to {}"", *ctx.manifest_path());
  if (!Manifest::put(ctx.config,
                     *ctx.manifest_path(),
                     *ctx.result_name(),
                     ctx.included_files,
                     ctx.time_of_compilation,
                     save_timestamp)) {
    LOG(""Failed to add result name to {}"", *ctx.manifest_path());
  } else {
    const auto new_stat = Stat::stat(*ctx.manifest_path(), Stat::OnError::log);
    ctx.manifest_counter_updates.increment(
      Statistic::cache_size_kibibyte,
      Util::size_change_kibibyte(old_stat, new_stat));
    ctx.manifest_counter_updates.increment(Statistic::files_in_cache,
                                           !old_stat && new_stat ? 1 : 0);
  }
  MTR_END(""manifest"", ""manifest_put"");
}

static void
create_cachedir_tag(const Context& ctx)
{
  constexpr char cachedir_tag[] =
    ""Signature: 8a477f597d28d172789f06886806bc55\n""
    ""# This file is a cache directory tag created by ccache.\n""
    ""# For information about cache directory tags, see:\n""
    ""#\thttp://www.brynosaurus.com/cachedir/\n"";

  const std::string path = FMT(""{}/{}/CACHEDIR.TAG"",
                               ctx.config.cache_dir(),
                               ctx.result_name()->to_string()[0]);
  const auto stat = Stat::stat(path);
  if (stat) {
    return;
  }
  try {
    Util::write_file(path, cachedir_tag);
  } catch (const Error& e) {
    LOG(""Failed to create {}: {}"", path, e.what());
  }
}

struct FindCoverageFileResult
{
  bool found;
  std::string path;
  bool mangled;
};

static FindCoverageFileResult
find_coverage_file(const Context& ctx)
{
  // GCC 9+ writes coverage data for /dir/to/example.o to #dir#to#example.gcno
  // (in CWD) if -fprofile-dir=DIR is present (regardless of DIR) instead of the
  // traditional /dir/to/example.gcno.

  std::string mangled_form = Result::gcno_file_in_mangled_form(ctx);
  std::string unmangled_form = Result::gcno_file_in_unmangled_form(ctx);
  std::string found_file;
  if (Stat::stat(mangled_form)) {
    LOG(""Found coverage file {}"", mangled_form);
    found_file = mangled_form;
  }
  if (Stat::stat(unmangled_form)) {
    LOG(""Found coverage file {}"", unmangled_form);
    if (!found_file.empty()) {
      LOG_RAW(""Found two coverage files, cannot continue"");
      return {};
    }
    found_file = unmangled_form;
  }
  if (found_file.empty()) {
    LOG(""No coverage file found (tried {} and {}), cannot continue"",
        unmangled_form,
        mangled_form);
    return {};
  }
  return {true, found_file, found_file == mangled_form};
}

// Run the real compiler and put the result in cache.
static void
to_cache(Context& ctx,
         Args& args,
         const Args& depend_extra_args,
         Hash* depend_mode_hash)
{
  args.push_back(""-o"");
  args.push_back(ctx.args_info.output_obj);

  if (ctx.config.hard_link() && ctx.args_info.output_obj != ""/dev/null"") {
    // Workaround for Clang bug where it overwrites an existing object file
    // when it's compiling an assembler file, see
    // <https://bugs.llvm.org/show_bug.cgi?id=39782>.
    Util::unlink_safe(ctx.args_info.output_obj);
  }

  if (ctx.args_info.generating_diagnostics) {
    args.push_back(""--serialize-diagnostics"");
    args.push_back(ctx.args_info.output_dia);
  }

  // Turn off DEPENDENCIES_OUTPUT when running cc1, because otherwise it will
  // emit a line like this:
  //
  //   tmp.stdout.vexed.732.o: /home/mbp/.ccache/tmp.stdout.vexed.732.i
  Util::unsetenv(""DEPENDENCIES_OUTPUT"");
  Util::unsetenv(""SUNPRO_DEPENDENCIES"");

  if (ctx.config.run_second_cpp()) {
    args.push_back(ctx.args_info.input_file);
  } else {
    args.push_back(ctx.i_tmpfile);
  }

  if (ctx.args_info.seen_split_dwarf) {
    // Remove any pre-existing .dwo file since we want to check if the compiler
    // produced one, intentionally not using x_unlink or tmp_unlink since we're
    // not interested in logging successful deletions or failures due to
    // nonexistent .dwo files.
    if (unlink(ctx.args_info.output_dwo.c_str()) != 0 && errno != ENOENT
        && errno != ESTALE) {
      LOG(""Failed to unlink {}: {}"", ctx.args_info.output_dwo, strerror(errno));
      throw Failure(Statistic::bad_output_file);
    }
  }

  LOG_RAW(""Running real compiler"");
  MTR_BEGIN(""execute"", ""compiler"");

  TemporaryFile tmp_stdout(FMT(""{}/tmp.stdout"", ctx.config.temporary_dir()));
  ctx.register_pending_tmp_file(tmp_stdout.path);
  std::string tmp_stdout_path = tmp_stdout.path;

  TemporaryFile tmp_stderr(FMT(""{}/tmp.stderr"", ctx.config.temporary_dir()));
  ctx.register_pending_tmp_file(tmp_stderr.path);
  std::string tmp_stderr_path = tmp_stderr.path;

  int status;
  if (!ctx.config.depend_mode()) {
    status =
      do_execute(ctx, args, std::move(tmp_stdout), std::move(tmp_stderr));
    args.pop_back(3);
  } else {
    // Use the original arguments (including dependency options) in depend
    // mode.
    Args depend_mode_args = ctx.orig_args;
    depend_mode_args.erase_with_prefix(""--ccache-"");
    depend_mode_args.push_back(depend_extra_args);
    add_prefix(ctx, depend_mode_args, ctx.config.prefix_command());

    ctx.time_of_compilation = time(nullptr);
    status = do_execute(
      ctx, depend_mode_args, std::move(tmp_stdout), std::move(tmp_stderr));
  }
  MTR_END(""execute"", ""compiler"");

  auto st = Stat::stat(tmp_stdout_path, Stat::OnError::log);
  if (!st) {
    // The stdout file was removed - cleanup in progress? Better bail out.
    throw Failure(Statistic::missing_cache_file);
  }

  // distcc-pump outputs lines like this:
  // __________Using # distcc servers in pump mode
  if (st.size() != 0 && ctx.config.compiler_type() != CompilerType::pump) {
    LOG_RAW(""Compiler produced stdout"");
    throw Failure(Statistic::compiler_produced_stdout);
  }

  // Merge stderr from the preprocessor (if any) and stderr from the real
  // compiler into tmp_stderr.
  if (!ctx.cpp_stderr.empty()) {
    std::string combined_stderr =
      Util::read_file(ctx.cpp_stderr) + Util::read_file(tmp_stderr_path);
    Util::write_file(tmp_stderr_path, combined_stderr);
  }

  if (status != 0) {
    LOG(""Compiler gave exit status {}"", status);

    // We can output stderr immediately instead of rerunning the compiler.
    Util::send_to_stderr(ctx, Util::read_file(tmp_stderr_path));

    throw Failure(Statistic::compile_failed, status);
  }

  if (ctx.config.depend_mode()) {
    ASSERT(depend_mode_hash);
    auto result_name = result_name_from_depfile(ctx, *depend_mode_hash);
    if (!result_name) {
      throw Failure(Statistic::internal_error);
    }
    ctx.set_result_name(*result_name);
  }

  bool produce_dep_file = ctx.args_info.generating_dependencies
                          && ctx.args_info.output_dep != ""/dev/null"";

  if (produce_dep_file) {
    Depfile::make_paths_relative_in_output_dep(ctx);
  }

  const auto obj_stat = Stat::stat(ctx.args_info.output_obj);
  if (!obj_stat) {
    if (ctx.args_info.expect_output_obj) {
      LOG_RAW(""Compiler didn't produce an object file (unexpected)"");
      throw Failure(Statistic::compiler_produced_no_output);
    } else {
      LOG_RAW(""Compiler didn't produce an object file (expected)"");
    }
  } else if (obj_stat.size() == 0) {
    LOG_RAW(""Compiler produced an empty object file"");
    throw Failure(Statistic::compiler_produced_empty_output);
  }

  const auto stderr_stat = Stat::stat(tmp_stderr_path, Stat::OnError::log);
  if (!stderr_stat) {
    throw Failure(Statistic::internal_error);
  }

  const auto result_file = look_up_cache_file(
    ctx.config.cache_dir(), *ctx.result_name(), Result::k_file_suffix);
  ctx.set_result_path(result_file.path);
  Result::Writer result_writer(ctx, result_file.path);

  if (stderr_stat.size() > 0) {
    result_writer.write(Result::FileType::stderr_output, tmp_stderr_path);
  }
  if (obj_stat) {
    result_writer.write(Result::FileType::object, ctx.args_info.output_obj);
  }
  if (ctx.args_info.generating_dependencies) {
    result_writer.write(Result::FileType::dependency, ctx.args_info.output_dep);
  }
  if (ctx.args_info.generating_coverage) {
    const auto coverage_file = find_coverage_file(ctx);
    if (!coverage_file.found) {
      throw Failure(Statistic::internal_error);
    }
    result_writer.write(coverage_file.mangled
                          ? Result::FileType::coverage_mangled
                          : Result::FileType::coverage_unmangled,
                        coverage_file.path);
  }
  if (ctx.args_info.generating_stackusage) {
    result_writer.write(Result::FileType::stackusage, ctx.args_info.output_su);
  }
  if (ctx.args_info.generating_diagnostics) {
    result_writer.write(Result::FileType::diagnostic, ctx.args_info.output_dia);
  }
  if (ctx.args_info.seen_split_dwarf && Stat::stat(ctx.args_info.output_dwo)) {
    // Only store .dwo file if it was created by the compiler (GCC and Clang
    // behave differently e.g. for ""-gsplit-dwarf -g1"").
    result_writer.write(Result::FileType::dwarf_object,
                        ctx.args_info.output_dwo);
  }

  auto error = result_writer.finalize();
  if (error) {
    LOG(""Error: {}"", *error);
  } else {
    LOG(""Stored in cache: {}"", result_file.path);
  }

  auto new_result_stat = Stat::stat(result_file.path, Stat::OnError::log);
  if (!new_result_stat) {
    throw Failure(Statistic::internal_error);
  }
  ctx.counter_updates.increment(
    Statistic::cache_size_kibibyte,
    Util::size_change_kibibyte(result_file.stat, new_result_stat));
  ctx.counter_updates.increment(Statistic::files_in_cache,
                                result_file.stat ? 0 : 1);

  MTR_END(""file"", ""file_put"");

  // Make sure we have a CACHEDIR.TAG in the cache part of cache_dir. This can
  // be done almost anywhere, but we might as well do it near the end as we save
  // the stat call if we exit early.
  create_cachedir_tag(ctx);

  // Everything OK.
  Util::send_to_stderr(ctx, Util::read_file(tmp_stderr_path));
}

// Find the result name by running the compiler in preprocessor mode and
// hashing the result.
static Digest
get_result_name_from_cpp(Context& ctx, Args& args, Hash& hash)
{
  ctx.time_of_compilation = time(nullptr);

  std::string stderr_path;
  std::string stdout_path;
  int status;
  if (ctx.args_info.direct_i_file) {
    // We are compiling a .i or .ii file - that means we can skip the cpp stage
    // and directly form the correct i_tmpfile.
    stdout_path = ctx.args_info.input_file;
    status = 0;
  } else {
    // Run cpp on the input file to obtain the .i.

    TemporaryFile tmp_stdout(
      FMT(""{}/tmp.cpp_stdout"", ctx.config.temporary_dir()));
    ctx.register_pending_tmp_file(tmp_stdout.path);

    // stdout_path needs the proper cpp_extension for the compiler to do its
    // thing correctly.
    stdout_path = FMT(""{}.{}"", tmp_stdout.path, ctx.config.cpp_extension());
    Util::hard_link(tmp_stdout.path, stdout_path);
    ctx.register_pending_tmp_file(stdout_path);

    TemporaryFile tmp_stderr(
      FMT(""{}/tmp.cpp_stderr"", ctx.config.temporary_dir()));
    stderr_path = tmp_stderr.path;
    ctx.register_pending_tmp_file(stderr_path);

    size_t args_added = 2;
    args.push_back(""-E"");
    if (ctx.args_info.actual_language == ""hip"") {
      args.push_back(""-o"");
      args.push_back(""-"");
      args_added += 2;
    }
    if (ctx.config.keep_comments_cpp()) {
      args.push_back(""-C"");
      args_added++;
    }
    args.push_back(ctx.args_info.input_file);
    add_prefix(ctx, args, ctx.config.prefix_command_cpp());
    LOG_RAW(""Running preprocessor"");
    MTR_BEGIN(""execute"", ""preprocessor"");
    status =
      do_execute(ctx, args, std::move(tmp_stdout), std::move(tmp_stderr));
    MTR_END(""execute"", ""preprocessor"");
    args.pop_back(args_added);
  }

  if (status != 0) {
    LOG(""Preprocessor gave exit status {}"", status);
    throw Failure(Statistic::preprocessor_error);
  }

  hash.hash_delimiter(""cpp"");
  const bool is_pump = ctx.config.compiler_type() == CompilerType::pump;
  const Statistic error =
    process_preprocessed_file(ctx, hash, stdout_path, is_pump);
  if (error != Statistic::none) {
    throw Failure(error);
  }

  hash.hash_delimiter(""cppstderr"");
  if (!ctx.args_info.direct_i_file && !hash.hash_file(stderr_path)) {
    // Somebody removed the temporary file?
    LOG(""Failed to open {}: {}"", stderr_path, strerror(errno));
    throw Failure(Statistic::internal_error);
  }

  if (ctx.args_info.direct_i_file) {
    ctx.i_tmpfile = ctx.args_info.input_file;
  } else {
    ctx.i_tmpfile = stdout_path;
  }

  if (!ctx.config.run_second_cpp()) {
    // If we are using the CPP trick, we need to remember this stderr data and
    // output it just before the main stderr from the compiler pass.
    ctx.cpp_stderr = stderr_path;
    hash.hash_delimiter(""runsecondcpp"");
    hash.hash(""false"");
  }

  return hash.digest();
}

// Hash mtime or content of a file, or the output of a command, according to
// the CCACHE_COMPILERCHECK setting.
static void
hash_compiler(const Context& ctx,
              Hash& hash,
              const Stat& st,
              const std::string& path,
              bool allow_command)
{
  if (ctx.config.compiler_check() == ""none"") {
    // Do nothing.
  } else if (ctx.config.compiler_check() == ""mtime"") {
    hash.hash_delimiter(""cc_mtime"");
    hash.hash(st.size());
    hash.hash(st.mtime());
  } else if (Util::starts_with(ctx.config.compiler_check(), ""string:"")) {
    hash.hash_delimiter(""cc_hash"");
    hash.hash(&ctx.config.compiler_check()[7]);
  } else if (ctx.config.compiler_check() == ""content"" || !allow_command) {
    hash.hash_delimiter(""cc_content"");
    hash_binary_file(ctx, hash, path);
  } else { // command string
    if (!hash_multicommand_output(
          hash, ctx.config.compiler_check(), ctx.orig_args[0])) {
      LOG(""Failure running compiler check command: {}"",
          ctx.config.compiler_check());
      throw Failure(Statistic::compiler_check_failed);
    }
  }
}

// Hash the host compiler(s) invoked by nvcc.
//
// If `ccbin_st` and `ccbin` are set, they refer to a directory or compiler set
// with -ccbin/--compiler-bindir. If `ccbin_st` is nullptr or `ccbin` is the
// empty string, the compilers are looked up in PATH instead.
static void
hash_nvcc_host_compiler(const Context& ctx,
                        Hash& hash,
                        const Stat* ccbin_st = nullptr,
                        const std::string& ccbin = {})
{
  // From <http://docs.nvidia.com/cuda/cuda-compiler-driver-nvcc/index.html>:
  //
  //   ""[...] Specify the directory in which the compiler executable resides.
  //   The host compiler executable name can be also specified to ensure that
  //   the correct host compiler is selected.""
  //
  // and
  //
  //   ""On all platforms, the default host compiler executable (gcc and g++ on
  //   Linux, clang and clang++ on Mac OS X, and cl.exe on Windows) found in
  //   the current execution search path will be used"".

  if (ccbin.empty() || !ccbin_st || ccbin_st->is_directory()) {
#if defined(__APPLE__)
    const char* compilers[] = {""clang"", ""clang++""};
#elif defined(_WIN32)
    const char* compilers[] = {""cl.exe""};
#else
    const char* compilers[] = {""gcc"", ""g++""};
#endif
    for (const char* compiler : compilers) {
      if (!ccbin.empty()) {
        std::string path = FMT(""{}/{}"", ccbin, compiler);
        auto st = Stat::stat(path);
        if (st) {
          hash_compiler(ctx, hash, st, path, false);
        }
      } else {
        std::string path = find_executable(ctx, compiler, CCACHE_NAME);
        if (!path.empty()) {
          auto st = Stat::stat(path, Stat::OnError::log);
          hash_compiler(ctx, hash, st, ccbin, false);
        }
      }
    }
  } else {
    hash_compiler(ctx, hash, *ccbin_st, ccbin, false);
  }
}

static bool
should_rewrite_dependency_target(const ArgsInfo& args_info)
{
  return !args_info.dependency_target_specified && args_info.seen_MD_MMD;
}

// update a hash with information common for the direct and preprocessor modes.
static void
hash_common_info(const Context& ctx,
                 const Args& args,
                 Hash& hash,
                 const ArgsInfo& args_info)
{
  hash.hash(HASH_PREFIX);

  // We have to hash the extension, as a .i file isn't treated the same by the
  // compiler as a .ii file.
  hash.hash_delimiter(""ext"");
  hash.hash(ctx.config.cpp_extension());

#ifdef _WIN32
  const std::string compiler_path = Win32Util::add_exe_suffix(args[0]);
#else
  const std::string compiler_path = args[0];
#endif

  auto st = Stat::stat(compiler_path, Stat::OnError::log);
  if (!st) {
    throw Failure(Statistic::could_not_find_compiler);
  }

  // Hash information about the compiler.
  hash_compiler(ctx, hash, st, compiler_path, true);

  // Also hash the compiler name as some compilers use hard links and behave
  // differently depending on the real name.
  hash.hash_delimiter(""cc_name"");
  hash.hash(Util::base_name(args[0]));

  // Hash variables that may affect the compilation.
  const char* always_hash_env_vars[] = {
    // From <https://gcc.gnu.org/onlinedocs/gcc/Environment-Variables.html>:
    ""COMPILER_PATH"",
    ""GCC_COMPARE_DEBUG"",
    ""GCC_EXEC_PREFIX"",
    // Note: SOURCE_DATE_EPOCH is handled in hash_source_code_string().
  };
  for (const char* name : always_hash_env_vars) {
    const char* value = getenv(name);
    if (value) {
      hash.hash_delimiter(name);
      hash.hash(value);
    }
  }

  if (!(ctx.config.sloppiness() & SLOPPY_LOCALE)) {
    // Hash environment variables that may affect localization of compiler
    // warning messages.
    const char* envvars[] = {
      ""LANG"", ""LC_ALL"", ""LC_CTYPE"", ""LC_MESSAGES"", nullptr};
    for (const char** p = envvars; *p; ++p) {
      const char* v = getenv(*p);
      if (v) {
        hash.hash_delimiter(*p);
        hash.hash(v);
      }
    }
  }

  // Possibly hash the current working directory.
  if (args_info.generating_debuginfo && ctx.config.hash_dir()) {
    std::string dir_to_hash = ctx.apparent_cwd;
    for (const auto& map : args_info.debug_prefix_maps) {
      size_t sep_pos = map.find('=');
      if (sep_pos != std::string::npos) {
        std::string old_path = map.substr(0, sep_pos);
        std::string new_path = map.substr(sep_pos + 1);
        LOG(""Relocating debuginfo from {} to {} (CWD: {})"",
            old_path,
            new_path,
            ctx.apparent_cwd);
        if (Util::starts_with(ctx.apparent_cwd, old_path)) {
          dir_to_hash = new_path + ctx.apparent_cwd.substr(old_path.size());
        }
      }
    }
    LOG(""Hashing CWD {}"", dir_to_hash);
    hash.hash_delimiter(""cwd"");
    hash.hash(dir_to_hash);
  }

  if ((!should_rewrite_dependency_target(ctx.args_info)
       && ctx.args_info.generating_dependencies)
      || ctx.args_info.seen_split_dwarf) {
    // The output object file name is part of the .d file, so include the path
    // in the hash if generating dependencies.
    //
    // Object files include a link to the corresponding .dwo file based on the
    // target object filename when using -gsplit-dwarf, so hashing the object
    // file path will do it, although just hashing the object file base name
    // would be enough.
    hash.hash_delimiter(""object file"");
    hash.hash(ctx.args_info.output_obj);
  }

  // Possibly hash the coverage data file path.
  if (ctx.args_info.generating_coverage && ctx.args_info.profile_arcs) {
    std::string dir;
    if (!ctx.args_info.profile_path.empty()) {
      dir = ctx.args_info.profile_path;
    } else {
      dir =
        Util::real_path(std::string(Util::dir_name(ctx.args_info.output_obj)));
    }
    string_view stem =
      Util::remove_extension(Util::base_name(ctx.args_info.output_obj));
    std::string gcda_path = FMT(""{}/{}.gcda"", dir, stem);
    LOG(""Hashing coverage path {}"", gcda_path);
    hash.hash_delimiter(""gcda"");
    hash.hash(gcda_path);
  }

  // Possibly hash the sanitize blacklist file path.
  for (const auto& sanitize_blacklist : args_info.sanitize_blacklists) {
    LOG(""Hashing sanitize blacklist {}"", sanitize_blacklist);
    hash.hash(""sanitizeblacklist"");
    if (!hash_binary_file(ctx, hash, sanitize_blacklist)) {
      throw Failure(Statistic::error_hashing_extra_file);
    }
  }

  if (!ctx.config.extra_files_to_hash().empty()) {
    for (const std::string& path : Util::split_into_strings(
           ctx.config.extra_files_to_hash(), PATH_DELIM)) {
      LOG(""Hashing extra file {}"", path);
      hash.hash_delimiter(""extrafile"");
      if (!hash_binary_file(ctx, hash, path)) {
        throw Failure(Statistic::error_hashing_extra_file);
      }
    }
  }

  // Possibly hash GCC_COLORS (for color diagnostics).
  if (ctx.config.compiler_type() == CompilerType::gcc) {
    const char* gcc_colors = getenv(""GCC_COLORS"");
    if (gcc_colors) {
      hash.hash_delimiter(""gcccolors"");
      hash.hash(gcc_colors);
    }
  }
}

static bool
hash_profile_data_file(const Context& ctx, Hash& hash)
{
  const std::string& profile_path = ctx.args_info.profile_path;
  string_view base_name = Util::remove_extension(ctx.args_info.output_obj);
  std::string hashified_cwd = ctx.apparent_cwd;
  std::replace(hashified_cwd.begin(), hashified_cwd.end(), '/', '#');

  std::vector<std::string> paths_to_try{
    // -fprofile-use[=dir]/-fbranch-probabilities (GCC <9)
    FMT(""{}/{}.gcda"", profile_path, base_name),
    // -fprofile-use[=dir]/-fbranch-probabilities (GCC >=9)
    FMT(""{}/{}#{}.gcda"", profile_path, hashified_cwd, base_name),
    // -fprofile(-instr|-sample)-use=file (Clang), -fauto-profile=file (GCC >=5)
    profile_path,
    // -fprofile(-instr|-sample)-use=dir (Clang)
    FMT(""{}/default.profdata"", profile_path),
    // -fauto-profile (GCC >=5)
    ""fbdata.afdo"", // -fprofile-dir is not used
  };

  bool found = false;
  for (const std::string& p : paths_to_try) {
    LOG(""Checking for profile data file {}"", p);
    auto st = Stat::stat(p);
    if (st && !st.is_directory()) {
      LOG(""Adding profile data {} to the hash"", p);
      hash.hash_delimiter(""-fprofile-use"");
      if (hash_binary_file(ctx, hash, p)) {
        found = true;
      }
    }
  }

  return found;
}

static bool
option_should_be_ignored(const std::string& arg,
                         const std::vector<std::string>& patterns)
{
  return std::any_of(
    patterns.cbegin(), patterns.cend(), [&arg](const std::string& pattern) {
      const auto& prefix = string_view(pattern).substr(0, pattern.length() - 1);
      return (
        pattern == arg
        || (Util::ends_with(pattern, ""*"") && Util::starts_with(arg, prefix)));
    });
}

// Update a hash sum with information specific to the direct and preprocessor
// modes and calculate the result name. Returns the result name on success,
// otherwise nullopt.
static optional<Digest>
calculate_result_name(Context& ctx,
                      const Args& args,
                      Args& preprocessor_args,
                      Hash& hash,
                      bool direct_mode)
{
  bool found_ccbin = false;

  hash.hash_delimiter(""result version"");
  hash.hash(Result::k_version);

  if (direct_mode) {
    hash.hash_delimiter(""manifest version"");
    hash.hash(Manifest::k_version);
  }

  // clang will emit warnings for unused linker flags, so we shouldn't skip
  // those arguments.
  int is_clang = ctx.config.compiler_type() == CompilerType::clang
                 || ctx.config.compiler_type() == CompilerType::other;

  // First the arguments.
  for (size_t i = 1; i < args.size(); i++) {
    // Trust the user if they've said we should not hash a given option.
    if (option_should_be_ignored(args[i], ctx.ignore_options())) {
      LOG(""Not hashing ignored option: {}"", args[i]);
      if (i + 1 < args.size() && compopt_takes_arg(args[i])) {
        i++;
        LOG(""Not hashing argument of ignored option: {}"", args[i]);
      }
      continue;
    }

    // -L doesn't affect compilation (except for clang).
    if (i < args.size() - 1 && args[i] == ""-L"" && !is_clang) {
      i++;
      continue;
    }
    if (Util::starts_with(args[i], ""-L"") && !is_clang) {
      continue;
    }

    // -Wl,... doesn't affect compilation (except for clang).
    if (Util::starts_with(args[i], ""-Wl,"") && !is_clang) {
      continue;
    }

    // The -fdebug-prefix-map option may be used in combination with
    // CCACHE_BASEDIR to reuse results across different directories. Skip using
    // the value of the option from hashing but still hash the existence of the
    // option.
    if (Util::starts_with(args[i], ""-fdebug-prefix-map="")) {
      hash.hash_delimiter(""arg"");
      hash.hash(""-fdebug-prefix-map="");
      continue;
    }
    if (Util::starts_with(args[i], ""-ffile-prefix-map="")) {
      hash.hash_delimiter(""arg"");
      hash.hash(""-ffile-prefix-map="");
      continue;
    }
    if (Util::starts_with(args[i], ""-fmacro-prefix-map="")) {
      hash.hash_delimiter(""arg"");
      hash.hash(""-fmacro-prefix-map="");
      continue;
    }

    // When using the preprocessor, some arguments don't contribute to the
    // hash. The theory is that these arguments will change the output of -E if
    // they are going to have any effect at all. For precompiled headers this
    // might not be the case.
    if (!direct_mode && !ctx.args_info.output_is_precompiled_header
        && !ctx.args_info.using_precompiled_header) {
      if (compopt_affects_cpp_output(args[i])) {
        if (compopt_takes_arg(args[i])) {
          i++;
        }
        continue;
      }
      if (compopt_affects_cpp_output(args[i].substr(0, 2))) {
        continue;
      }
    }

    // If we're generating dependencies, we make sure to skip the filename of
    // the dependency file, since it doesn't impact the output.
    if (ctx.args_info.generating_dependencies) {
      if (Util::starts_with(args[i], ""-Wp,"")) {
        if (Util::starts_with(args[i], ""-Wp,-MD,"")
            && args[i].find(',', 8) == std::string::npos) {
          hash.hash(args[i].data(), 8);
          continue;
        } else if (Util::starts_with(args[i], ""-Wp,-MMD,"")
                   && args[i].find(',', 9) == std::string::npos) {
          hash.hash(args[i].data(), 9);
          continue;
        }
      } else if (Util::starts_with(args[i], ""-MF"")) {
        // In either case, hash the ""-MF"" part.
        hash.hash_delimiter(""arg"");
        hash.hash(args[i].data(), 3);

        if (ctx.args_info.output_dep != ""/dev/null"") {
          bool separate_argument = (args[i].size() == 3);
          if (separate_argument) {
            // Next argument is dependency name, so skip it.
            i++;
          }
        }
        continue;
      }
    }

    if (Util::starts_with(args[i], ""-specs="")
        || Util::starts_with(args[i], ""--specs="")) {
      std::string path = args[i].substr(args[i].find('=') + 1);
      auto st = Stat::stat(path, Stat::OnError::log);
      if (st) {
        // If given an explicit specs file, then hash that file, but don't
        // include the path to it in the hash.
        hash.hash_delimiter(""specs"");
        hash_compiler(ctx, hash, st, path, false);
        continue;
      }
    }

    if (Util::starts_with(args[i], ""-fplugin="")) {
      auto st = Stat::stat(&args[i][9], Stat::OnError::log);
      if (st) {
        hash.hash_delimiter(""plugin"");
        hash_compiler(ctx, hash, st, &args[i][9], false);
        continue;
      }
    }

    if (args[i] == ""-Xclang"" && i + 3 < args.size() && args[i + 1] == ""-load""
        && args[i + 2] == ""-Xclang"") {
      auto st = Stat::stat(args[i + 3], Stat::OnError::log);
      if (st) {
        hash.hash_delimiter(""plugin"");
        hash_compiler(ctx, hash, st, args[i + 3], false);
        i += 3;
        continue;
      }
    }

    if ((args[i] == ""-ccbin"" || args[i] == ""--compiler-bindir"")
        && i + 1 < args.size()) {
      auto st = Stat::stat(args[i + 1]);
      if (st) {
        found_ccbin = true;
        hash.hash_delimiter(""ccbin"");
        hash_nvcc_host_compiler(ctx, hash, &st, args[i + 1]);
        i++;
        continue;
      }
    }

    // All other arguments are included in the hash.
    hash.hash_delimiter(""arg"");
    hash.hash(args[i]);
    if (i + 1 < args.size() && compopt_takes_arg(args[i])) {
      i++;
      hash.hash_delimiter(""arg"");
      hash.hash(args[i]);
    }
  }

  // Make results with dependency file /dev/null different from those without
  // it.
  if (ctx.args_info.generating_dependencies
      && ctx.args_info.output_dep == ""/dev/null"") {
    hash.hash_delimiter(""/dev/null dependency file"");
  }

  if (!found_ccbin && ctx.args_info.actual_language == ""cu"") {
    hash_nvcc_host_compiler(ctx, hash);
  }

  // For profile generation (-fprofile(-instr)-generate[=path])
  // - hash profile path
  //
  // For profile usage (-fprofile(-instr|-sample)-use, -fbranch-probabilities):
  // - hash profile data
  //
  // -fbranch-probabilities and -fvpt usage is covered by
  // -fprofile-generate/-fprofile-use.
  //
  // The profile directory can be specified as an argument to
  // -fprofile(-instr)-generate=, -fprofile(-instr|-sample)-use= or
  // -fprofile-dir=.

  if (ctx.args_info.profile_generate) {
    ASSERT(!ctx.args_info.profile_path.empty());
    LOG(""Adding profile directory {} to our hash"", ctx.args_info.profile_path);
    hash.hash_delimiter(""-fprofile-dir"");
    hash.hash(ctx.args_info.profile_path);
  }

  if (ctx.args_info.profile_use && !hash_profile_data_file(ctx, hash)) {
    LOG_RAW(""No profile data file found"");
    throw Failure(Statistic::no_input_file);
  }

  // Adding -arch to hash since cpp output is affected.
  for (const auto& arch : ctx.args_info.arch_args) {
    hash.hash_delimiter(""-arch"");
    hash.hash(arch);
  }

  optional<Digest> result_name;
  if (direct_mode) {
    // Hash environment variables that affect the preprocessor output.
    const char* envvars[] = {""CPATH"",
                             ""C_INCLUDE_PATH"",
                             ""CPLUS_INCLUDE_PATH"",
                             ""OBJC_INCLUDE_PATH"",
                             ""OBJCPLUS_INCLUDE_PATH"", // clang
                             nullptr};
    for (const char** p = envvars; *p; ++p) {
      const char* v = getenv(*p);
      if (v) {
        hash.hash_delimiter(*p);
        hash.hash(v);
      }
    }

    // Make sure that the direct mode hash is unique for the input file path.
    // If this would not be the case:
    //
    // * An false cache hit may be produced. Scenario:
    //   - a/r.h exists.
    //   - a/x.c has #include ""r.h"".
    //   - b/x.c is identical to a/x.c.
    //   - Compiling a/x.c records a/r.h in the manifest.
    //   - Compiling b/x.c results in a false cache hit since a/x.c and b/x.c
    //     share manifests and a/r.h exists.
    // * The expansion of __FILE__ may be incorrect.
    hash.hash_delimiter(""inputfile"");
    hash.hash(ctx.args_info.input_file);

    hash.hash_delimiter(""sourcecode"");
    int result = hash_source_code_file(ctx, hash, ctx.args_info.input_file);
    if (result & HASH_SOURCE_CODE_ERROR) {
      throw Failure(Statistic::internal_error);
    }
    if (result & HASH_SOURCE_CODE_FOUND_TIME) {
      LOG_RAW(""Disabling direct mode"");
      ctx.config.set_direct_mode(false);
      return nullopt;
    }

    const auto manifest_name = hash.digest();
    ctx.set_manifest_name(manifest_name);

    const auto manifest_file = look_up_cache_file(
      ctx.config.cache_dir(), manifest_name, Manifest::k_file_suffix);
    ctx.set_manifest_path(manifest_file.path);

    if (manifest_file.stat) {
      LOG(""Looking for result name in {}"", manifest_file.path);
      MTR_BEGIN(""manifest"", ""manifest_get"");
      result_name = Manifest::get(ctx, manifest_file.path);
      MTR_END(""manifest"", ""manifest_get"");
      if (result_name) {
        LOG_RAW(""Got result name from manifest"");
      } else {
        LOG_RAW(""Did not find result name in manifest"");
      }
    } else {
      LOG(""No manifest with name {} in the cache"", manifest_name.to_string());
    }
  } else {
    if (ctx.args_info.arch_args.empty()) {
      result_name = get_result_name_from_cpp(ctx, preprocessor_args, hash);
      LOG_RAW(""Got result name from preprocessor"");
    } else {
      preprocessor_args.push_back(""-arch"");
      for (size_t i = 0; i < ctx.args_info.arch_args.size(); ++i) {
        preprocessor_args.push_back(ctx.args_info.arch_args[i]);
        result_name = get_result_name_from_cpp(ctx, preprocessor_args, hash);
        LOG(""Got result name from preprocessor with -arch {}"",
            ctx.args_info.arch_args[i]);
        if (i != ctx.args_info.arch_args.size() - 1) {
          result_name = nullopt;
        }
        preprocessor_args.pop_back();
      }
      preprocessor_args.pop_back();
    }
  }

  return result_name;
}

enum class FromCacheCallMode { direct, cpp };

// Try to return the compile result from cache.
static optional<Statistic>
from_cache(Context& ctx, FromCacheCallMode mode)
{
  UmaskScope umask_scope(ctx.original_umask);

  // The user might be disabling cache hits.
  if (ctx.config.recache()) {
    return nullopt;
  }

  // If we're using Clang, we can't trust a precompiled header object based on
  // running the preprocessor since clang will produce a fatal error when the
  // precompiled header is used and one of the included files has an updated
  // timestamp:
  //
  //     file 'foo.h' has been modified since the precompiled header 'foo.pch'
  //     was built
  if ((ctx.config.compiler_type() == CompilerType::clang
       || ctx.config.compiler_type() == CompilerType::other)
      && ctx.args_info.output_is_precompiled_header
      && !ctx.args_info.fno_pch_timestamp && mode == FromCacheCallMode::cpp) {
    LOG_RAW(""Not considering cached precompiled header in preprocessor mode"");
    return nullopt;
  }

  MTR_BEGIN(""cache"", ""from_cache"");

  // Get result from cache.
  const auto result_file = look_up_cache_file(
    ctx.config.cache_dir(), *ctx.result_name(), Result::k_file_suffix);
  if (!result_file.stat) {
    LOG(""No result with name {} in the cache"", ctx.result_name()->to_string());
    return nullopt;
  }
  ctx.set_result_path(result_file.path);
  Result::Reader result_reader(result_file.path);
  ResultRetriever result_retriever(
    ctx, should_rewrite_dependency_target(ctx.args_info));

  auto error = result_reader.read(result_retriever);
  MTR_END(""cache"", ""from_cache"");
  if (error) {
    LOG(""Failed to get result from cache: {}"", *error);
    return nullopt;
  }

  // Update modification timestamp to save file from LRU cleanup.
  Util::update_mtime(*ctx.result_path());

  LOG_RAW(""Succeeded getting cached result"");

  return mode == FromCacheCallMode::direct ? Statistic::direct_cache_hit
                                           : Statistic::preprocessed_cache_hit;
}

// Find the real compiler and put it into ctx.orig_args[0]. We just search the
// PATH to find an executable of the same name that isn't a link to ourselves.
// Pass find_executable function as second parameter.
void
find_compiler(Context& ctx,
              const FindExecutableFunction& find_executable_function)
{
  // gcc --> 0
  // ccache gcc --> 1
  // ccache ccache gcc --> 2
  size_t compiler_pos = 0;
  while (compiler_pos < ctx.orig_args.size()
         && Util::same_program_name(
           Util::base_name(ctx.orig_args[compiler_pos]), CCACHE_NAME)) {
    ++compiler_pos;
  }

  // Support user override of the compiler.
  const std::string compiler =
    !ctx.config.compiler().empty()
      ? ctx.config.compiler()
      // In case ccache is masquerading as the compiler, use only base_name so
      // the real compiler can be determined.
      : (compiler_pos == 0 ? std::string(Util::base_name(ctx.orig_args[0]))
                           : ctx.orig_args[compiler_pos]);

  const std::string resolved_compiler =
    Util::is_full_path(compiler)
      ? compiler
      : find_executable_function(ctx, compiler, CCACHE_NAME);

  if (resolved_compiler.empty()) {
    throw Fatal(""Could not find compiler \""{}\"" in PATH"", compiler);
  }

  if (Util::same_program_name(Util::base_name(resolved_compiler),
                              CCACHE_NAME)) {
    throw Fatal(
      ""Recursive invocation (the name of the ccache binary must be \""{}\"")"",
      CCACHE_NAME);
  }

  ctx.orig_args.pop_front(compiler_pos);
  ctx.orig_args[0] = resolved_compiler;
}

static std::string
default_cache_dir(const std::string& home_dir)
{
#ifdef _WIN32
  return home_dir + ""/ccache"";
#elif defined(__APPLE__)
  return home_dir + ""/Library/Caches/ccache"";
#else
  return home_dir + ""/.cache/ccache"";
#endif
}

static std::string
default_config_dir(const std::string& home_dir)
{
#ifdef _WIN32
  return home_dir + ""/ccache"";
#elif defined(__APPLE__)
  return home_dir + ""/Library/Preferences/ccache"";
#else
  return home_dir + ""/.config/ccache"";
#endif
}

// Read config file(s), populate variables, create configuration file in cache
// directory if missing, etc.
static void
set_up_config(Config& config)
{
  const std::string home_dir = Util::get_home_directory();
  const std::string legacy_ccache_dir = home_dir + ""/.ccache"";
  const bool legacy_ccache_dir_exists =
    Stat::stat(legacy_ccache_dir).is_directory();
  const char* const env_xdg_cache_home = getenv(""XDG_CACHE_HOME"");
  const char* const env_xdg_config_home = getenv(""XDG_CONFIG_HOME"");

  const char* env_ccache_configpath = getenv(""CCACHE_CONFIGPATH"");
  if (env_ccache_configpath) {
    config.set_primary_config_path(env_ccache_configpath);
  } else {
    // Only used for ccache tests:
    const char* const env_ccache_configpath2 = getenv(""CCACHE_CONFIGPATH2"");

    config.set_secondary_config_path(env_ccache_configpath2
                                       ? env_ccache_configpath2
                                       : FMT(""{}/ccache.conf"", SYSCONFDIR));
    MTR_BEGIN(""config"", ""conf_read_secondary"");
    // A missing config file in SYSCONFDIR is OK so don't check return value.
    config.update_from_file(config.secondary_config_path());
    MTR_END(""config"", ""conf_read_secondary"");

    const char* const env_ccache_dir = getenv(""CCACHE_DIR"");
    std::string primary_config_dir;
    if (env_ccache_dir && *env_ccache_dir) {
      primary_config_dir = env_ccache_dir;
    } else if (!config.cache_dir().empty() && !env_ccache_dir) {
      primary_config_dir = config.cache_dir();
    } else if (legacy_ccache_dir_exists) {
      primary_config_dir = legacy_ccache_dir;
    } else if (env_xdg_config_home) {
      primary_config_dir = FMT(""{}/ccache"", env_xdg_config_home);
    } else {
      primary_config_dir = default_config_dir(home_dir);
    }
    config.set_primary_config_path(primary_config_dir + ""/ccache.conf"");
  }

  const std::string& cache_dir_before_primary_config = config.cache_dir();

  MTR_BEGIN(""config"", ""conf_read_primary"");
  config.update_from_file(config.primary_config_path());
  MTR_END(""config"", ""conf_read_primary"");

  // Ignore cache_dir set in primary config.
  config.set_cache_dir(cache_dir_before_primary_config);

  MTR_BEGIN(""config"", ""conf_update_from_environment"");
  config.update_from_environment();
  // (config.cache_dir is set above if CCACHE_DIR is set.)
  MTR_END(""config"", ""conf_update_from_environment"");

  if (config.cache_dir().empty()) {
    if (legacy_ccache_dir_exists) {
      config.set_cache_dir(legacy_ccache_dir);
    } else if (env_xdg_cache_home) {
      config.set_cache_dir(FMT(""{}/ccache"", env_xdg_cache_home));
    } else {
      config.set_cache_dir(default_cache_dir(home_dir));
    }
  }
  // else: cache_dir was set explicitly via environment or via secondary config.

  // We have now determined config.cache_dir and populated the rest of config in
  // prio order (1. environment, 2. primary config, 3. secondary config).
}

static void
set_up_context(Context& ctx, int argc, const char* const* argv)
{
  ctx.orig_args = Args::from_argv(argc, argv);
  ctx.ignore_header_paths = Util::split_into_strings(
    ctx.config.ignore_headers_in_manifest(), PATH_DELIM);
  ctx.set_ignore_options(
    Util::split_into_strings(ctx.config.ignore_options(), "" ""));
}

// Initialize ccache, must be called once before anything else is run.
static void
initialize(Context& ctx, int argc, const char* const* argv)
{
  set_up_config(ctx.config);
  set_up_context(ctx, argc, argv);
  Logging::init(ctx.config);

  // Set default umask for all files created by ccache from now on (if
  // configured to). This is intentionally done after calling init_log so that
  // the log file won't be affected by the umask but before creating the initial
  // configuration file. The intention is that all files and directories in the
  // cache directory should be affected by the configured umask and that no
  // other files and directories should.
  if (ctx.config.umask() != std::numeric_limits<uint32_t>::max()) {
    ctx.original_umask = umask(ctx.config.umask());
  }

  LOG(""=== CCACHE {} STARTED ========================================="",
      CCACHE_VERSION);

  if (getenv(""CCACHE_INTERNAL_TRACE"")) {
#ifdef MTR_ENABLED
    ctx.mini_trace = std::make_unique<MiniTrace>(ctx.args_info);
#else
    LOG_RAW(""Error: tracing is not enabled!"");
#endif
  }
}

// Make a copy of stderr that will not be cached, so things like distcc can
// send networking errors to it.
static void
set_up_uncached_err()
{
  int uncached_fd =
    dup(STDERR_FILENO); // The file descriptor is intentionally leaked.
  if (uncached_fd == -1) {
    LOG(""dup(2) failed: {}"", strerror(errno));
    throw Failure(Statistic::internal_error);
  }

  Util::setenv(""UNCACHED_ERR_FD"", FMT(""{}"", uncached_fd));
}

static void
configuration_logger(const std::string& key,
                     const std::string& value,
                     const std::string& origin)
{
  BULK_LOG(""Config: ({}) {} = {}"", origin, key, value);
}

static void
configuration_printer(const std::string& key,
                      const std::string& value,
                      const std::string& origin)
{
  PRINT(stdout, ""({}) {} = {}\n"", origin, key, value);
}

static int cache_compilation(int argc, const char* const* argv);
static Statistic do_cache_compilation(Context& ctx, const char* const* argv);

static uint8_t
calculate_wanted_cache_level(uint64_t files_in_level_1)
{
  uint64_t files_per_directory = files_in_level_1 / 16;
  for (uint8_t i = k_min_cache_levels; i <= k_max_cache_levels; ++i) {
    if (files_per_directory < k_max_cache_files_per_directory) {
      return i;
    }
    files_per_directory /= 16;
  }
  return k_max_cache_levels;
}

static optional<Counters>
update_stats_and_maybe_move_cache_file(const Context& ctx,
                                       const Digest& name,
                                       const std::string& current_path,
                                       const Counters& counter_updates,
                                       const std::string& file_suffix)
{
  if (counter_updates.all_zero()) {
    return nullopt;
  }

  // Use stats file in the level one subdirectory for cache bookkeeping counters
  // since cleanup is performed on level one. Use stats file in the level two
  // subdirectory for other counters to reduce lock contention.
  const bool use_stats_on_level_1 =
    counter_updates.get(Statistic::cache_size_kibibyte) != 0
    || counter_updates.get(Statistic::files_in_cache) != 0;
  std::string level_string = FMT(""{:x}"", name.bytes()[0] >> 4);
  if (!use_stats_on_level_1) {
    level_string += FMT(""/{:x}"", name.bytes()[0] & 0xF);
  }
  const auto stats_file =
    FMT(""{}/{}/stats"", ctx.config.cache_dir(), level_string);

  auto counters =
    Statistics::update(stats_file, [&counter_updates](Counters& cs) {
      cs.increment(counter_updates);
    });
  if (!counters) {
    return nullopt;
  }

  if (use_stats_on_level_1) {
    // Only consider moving the cache file to another level when we have read
    // the level 1 stats file since it's only then we know the proper
    // files_in_cache value.
    const auto wanted_level =
      calculate_wanted_cache_level(counters->get(Statistic::files_in_cache));
    const auto wanted_path = Util::get_path_in_cache(
      ctx.config.cache_dir(), wanted_level, name.to_string() + file_suffix);
    if (current_path != wanted_path) {
      Util::ensure_dir_exists(Util::dir_name(wanted_path));
      LOG(""Moving {} to {}"", current_path, wanted_path);
      try {
        Util::rename(current_path, wanted_path);
      } catch (const Error&) {
        // Two ccache processes may move the file at the same time, so failure
        // to rename is OK.
      }
    }
  }
  return counters;
}

static void
finalize_stats_and_trigger_cleanup(Context& ctx)
{
  const auto& config = ctx.config;

  if (config.disable()) {
    // Just log result, don't update statistics.
    LOG_RAW(""Result: disabled"");
    return;
  }

  if (!config.log_file().empty() || config.debug()) {
    const auto result = Statistics::get_result(ctx.counter_updates);
    if (result) {
      LOG(""Result: {}"", *result);
    }
  }

  if (!config.stats()) {
    return;
  }

  if (!ctx.result_path()) {
    ASSERT(ctx.counter_updates.get(Statistic::cache_size_kibibyte) == 0);
    ASSERT(ctx.counter_updates.get(Statistic::files_in_cache) == 0);

    // Context::set_result_path hasn't been called yet, so we just choose one of
    // the stats files in the 256 level 2 directories.
    const auto bucket = getpid() % 256;
    const auto stats_file =
      FMT(""{}/{:x}/{:x}/stats"", config.cache_dir(), bucket / 16, bucket % 16);
    Statistics::update(
      stats_file, [&ctx](Counters& cs) { cs.increment(ctx.counter_updates); });
    return;
  }

  if (ctx.manifest_path()) {
    update_stats_and_maybe_move_cache_file(ctx,
                                           *ctx.manifest_name(),
                                           *ctx.manifest_path(),
                                           ctx.manifest_counter_updates,
                                           Manifest::k_file_suffix);
  }

  const auto counters =
    update_stats_and_maybe_move_cache_file(ctx,
                                           *ctx.result_name(),
                                           *ctx.result_path(),
                                           ctx.counter_updates,
                                           Result::k_file_suffix);
  if (!counters) {
    return;
  }

  const auto subdir =
    FMT(""{}/{:x}"", config.cache_dir(), ctx.result_name()->bytes()[0] >> 4);
  bool need_cleanup = false;

  if (config.max_files() != 0
      && counters->get(Statistic::files_in_cache) > config.max_files() / 16) {
    LOG(""Need to clean up {} since it holds {} files (limit: {} files)"",
        subdir,
        counters->get(Statistic::files_in_cache),
        config.max_files() / 16);
    need_cleanup = true;
  }
  if (config.max_size() != 0
      && counters->get(Statistic::cache_size_kibibyte)
           > config.max_size() / 1024 / 16) {
    LOG(""Need to clean up {} since it holds {} KiB (limit: {} KiB)"",
        subdir,
        counters->get(Statistic::cache_size_kibibyte),
        config.max_size() / 1024 / 16);
    need_cleanup = true;
  }

  if (need_cleanup) {
    const double factor = config.limit_multiple() / 16;
    const uint64_t max_size = round(config.max_size() * factor);
    const uint32_t max_files = round(config.max_files() * factor);
    const time_t max_age = 0;
    clean_up_dir(
      subdir, max_size, max_files, max_age, [](double /*progress*/) {});
  }
}

static void
finalize_at_exit(Context& ctx)
{
  try {
    finalize_stats_and_trigger_cleanup(ctx);
  } catch (const ErrorBase& e) {
    // finalize_at_exit must not throw since it's called by a destructor.
    LOG(""Error while finalizing stats: {}"", e.what());
  }

  // Dump log buffer last to not lose any logs.
  if (ctx.config.debug() && !ctx.args_info.output_obj.empty()) {
    Logging::dump_log(prepare_debug_path(
      ctx.config.debug_dir(), ctx.args_info.output_obj, ""log""));
  }
}

// The entry point when invoked to cache a compilation.
static int
cache_compilation(int argc, const char* const* argv)
{
  tzset(); // Needed for localtime_r.

  bool fall_back_to_original_compiler = false;
  Args saved_orig_args;
  nonstd::optional<mode_t> original_umask;
  std::string saved_temp_dir;

  {
    Context ctx;
    SignalHandler signal_handler(ctx);
    Finalizer finalizer([&ctx] { finalize_at_exit(ctx); });

    initialize(ctx, argc, argv);

    MTR_BEGIN(""main"", ""find_compiler"");
    find_compiler(ctx, &find_executable);
    MTR_END(""main"", ""find_compiler"");

    try {
      Statistic statistic = do_cache_compilation(ctx, argv);
      ctx.counter_updates.increment(statistic);
    } catch (const Failure& e) {
      if (e.statistic() != Statistic::none) {
        ctx.counter_updates.increment(e.statistic());
      }

      if (e.exit_code()) {
        return *e.exit_code();
      }
      // Else: Fall back to running the real compiler.
      fall_back_to_original_compiler = true;

      original_umask = ctx.original_umask;

      ASSERT(!ctx.orig_args.empty());

      ctx.orig_args.erase_with_prefix(""--ccache-"");
      add_prefix(ctx, ctx.orig_args, ctx.config.prefix_command());

      LOG_RAW(""Failed; falling back to running the real compiler"");

      saved_temp_dir = ctx.config.temporary_dir();
      saved_orig_args = std::move(ctx.orig_args);
      auto execv_argv = saved_orig_args.to_argv();
      LOG(""Executing {}"", Util::format_argv_for_logging(execv_argv.data()));
      // Execute the original command below after ctx and finalizer have been
      // destructed.
    }
  }

  if (fall_back_to_original_compiler) {
    if (original_umask) {
      umask(*original_umask);
    }
    auto execv_argv = saved_orig_args.to_argv();
    execute_noreturn(execv_argv.data(), saved_temp_dir);
    throw Fatal(
      ""execute_noreturn of {} failed: {}"", execv_argv[0], strerror(errno));
  }

  return EXIT_SUCCESS;
}

static Statistic
do_cache_compilation(Context& ctx, const char* const* argv)
{
  if (ctx.actual_cwd.empty()) {
    LOG(""Unable to determine current working directory: {}"", strerror(errno));
    throw Failure(Statistic::internal_error);
  }

  MTR_BEGIN(""main"", ""clean_up_internal_tempdir"");
  if (ctx.config.temporary_dir() == ctx.config.cache_dir() + ""/tmp"") {
    clean_up_internal_tempdir(ctx.config);
  }
  MTR_END(""main"", ""clean_up_internal_tempdir"");

  if (!ctx.config.log_file().empty() || ctx.config.debug()) {
    ctx.config.visit_items(configuration_logger);
  }

  // Guess compiler after logging the config value in order to be able to
  // display ""compiler_type = auto"" before overwriting the value with the guess.
  if (ctx.config.compiler_type() == CompilerType::auto_guess) {
    ctx.config.set_compiler_type(guess_compiler(ctx.orig_args[0]));
  }
  DEBUG_ASSERT(ctx.config.compiler_type() != CompilerType::auto_guess);

  if (ctx.config.disable()) {
    LOG_RAW(""ccache is disabled"");
    // Statistic::cache_miss is a dummy to trigger stats_flush.
    throw Failure(Statistic::cache_miss);
  }

  LOG(""Command line: {}"", Util::format_argv_for_logging(argv));
  LOG(""Hostname: {}"", Util::get_hostname());
  LOG(""Working directory: {}"", ctx.actual_cwd);
  if (ctx.apparent_cwd != ctx.actual_cwd) {
    LOG(""Apparent working directory: {}"", ctx.apparent_cwd);
  }

  LOG(""Compiler type: {}"", compiler_type_to_string(ctx.config.compiler_type()));

  MTR_BEGIN(""main"", ""process_args"");
  ProcessArgsResult processed = process_args(ctx);
  MTR_END(""main"", ""process_args"");

  if (processed.error) {
    throw Failure(*processed.error);
  }

  set_up_uncached_err();

  if (ctx.config.depend_mode()
      && (!ctx.args_info.generating_dependencies
          || ctx.args_info.output_dep == ""/dev/null""
          || !ctx.config.run_second_cpp())) {
    LOG_RAW(""Disabling depend mode"");
    ctx.config.set_depend_mode(false);
  }

  LOG(""Source file: {}"", ctx.args_info.input_file);
  if (ctx.args_info.generating_dependencies) {
    LOG(""Dependency file: {}"", ctx.args_info.output_dep);
  }
  if (ctx.args_info.generating_coverage) {
    LOG_RAW(""Coverage file is being generated"");
  }
  if (ctx.args_info.generating_stackusage) {
    LOG(""Stack usage file: {}"", ctx.args_info.output_su);
  }
  if (ctx.args_info.generating_diagnostics) {
    LOG(""Diagnostics file: {}"", ctx.args_info.output_dia);
  }
  if (!ctx.args_info.output_dwo.empty()) {
    LOG(""Split dwarf file: {}"", ctx.args_info.output_dwo);
  }

  LOG(""Object file: {}"", ctx.args_info.output_obj);
  MTR_META_THREAD_NAME(ctx.args_info.output_obj.c_str());

  if (ctx.config.debug()) {
    const auto path = prepare_debug_path(
      ctx.config.debug_dir(), ctx.args_info.output_obj, ""input-text"");
    File debug_text_file(path, ""w"");
    if (debug_text_file) {
      ctx.hash_debug_files.push_back(std::move(debug_text_file));
    } else {
      LOG(""Failed to open {}: {}"", path, strerror(errno));
    }
  }

  FILE* debug_text_file = !ctx.hash_debug_files.empty()
                            ? ctx.hash_debug_files.front().get()
                            : nullptr;

  Hash common_hash;
  init_hash_debug(ctx, common_hash, 'c', ""COMMON"", debug_text_file);

  MTR_BEGIN(""hash"", ""common_hash"");
  hash_common_info(
    ctx, processed.preprocessor_args, common_hash, ctx.args_info);
  MTR_END(""hash"", ""common_hash"");

  // Try to find the hash using the manifest.
  Hash direct_hash = common_hash;
  init_hash_debug(ctx, direct_hash, 'd', ""DIRECT MODE"", debug_text_file);

  Args args_to_hash = processed.preprocessor_args;
  args_to_hash.push_back(processed.extra_args_to_hash);

  bool put_result_in_manifest = false;
  optional<Digest> result_name;
  optional<Digest> result_name_from_manifest;
  if (ctx.config.direct_mode()) {
    LOG_RAW(""Trying direct lookup"");
    MTR_BEGIN(""hash"", ""direct_hash"");
    Args dummy_args;
    result_name =
      calculate_result_name(ctx, args_to_hash, dummy_args, direct_hash, true);
    MTR_END(""hash"", ""direct_hash"");
    if (result_name) {
      ctx.set_result_name(*result_name);

      // If we can return from cache at this point then do so.
      auto result = from_cache(ctx, FromCacheCallMode::direct);
      if (result) {
        return *result;
      }

      // Wasn't able to return from cache at this point. However, the result
      // was already found in manifest, so don't re-add it later.
      put_result_in_manifest = false;

      result_name_from_manifest = result_name;
    } else {
      // Add result to manifest later.
      put_result_in_manifest = true;
    }
  }

  if (ctx.config.read_only_direct()) {
    LOG_RAW(""Read-only direct mode; running real compiler"");
    throw Failure(Statistic::cache_miss);
  }

  if (!ctx.config.depend_mode()) {
    // Find the hash using the preprocessed output. Also updates
    // ctx.included_files.
    Hash cpp_hash = common_hash;
    init_hash_debug(ctx, cpp_hash, 'p', ""PREPROCESSOR MODE"", debug_text_file);

    MTR_BEGIN(""hash"", ""cpp_hash"");
    result_name = calculate_result_name(
      ctx, args_to_hash, processed.preprocessor_args, cpp_hash, false);
    MTR_END(""hash"", ""cpp_hash"");

    // calculate_result_name does not return nullopt if the last (direct_mode)
    // argument is false.
    ASSERT(result_name);
    ctx.set_result_name(*result_name);

    if (result_name_from_manifest && result_name_from_manifest != result_name) {
      // manifest_path is guaranteed to be set when calculate_result_name
      // returns a non-nullopt result in direct mode, i.e. when
      // result_name_from_manifest is set.
      ASSERT(ctx.manifest_path());

      // The hash from manifest differs from the hash of the preprocessor
      // output. This could be because:
      //
      // - The preprocessor produces different output for the same input (not
      //   likely).
      // - There's a bug in ccache (maybe incorrect handling of compiler
      //   arguments).
      // - The user has used a different CCACHE_BASEDIR (most likely).
      //
      // The best thing here would probably be to remove the hash entry from
      // the manifest. For now, we use a simpler method: just remove the
      // manifest file.
      LOG_RAW(""Hash from manifest doesn't match preprocessor output"");
      LOG_RAW(""Likely reason: different CCACHE_BASEDIRs used"");
      LOG_RAW(""Removing manifest as a safety measure"");
      Util::unlink_safe(*ctx.manifest_path());

      put_result_in_manifest = true;
    }

    // If we can return from cache at this point then do.
    auto result = from_cache(ctx, FromCacheCallMode::cpp);
    if (result) {
      if (put_result_in_manifest) {
        update_manifest_file(ctx);
      }
      return *result;
    }
  }

  if (ctx.config.read_only()) {
    LOG_RAW(""Read-only mode; running real compiler"");
    throw Failure(Statistic::cache_miss);
  }

  add_prefix(ctx, processed.compiler_args, ctx.config.prefix_command());

  // In depend_mode, extend the direct hash.
  Hash* depend_mode_hash = ctx.config.depend_mode() ? &direct_hash : nullptr;

  // Run real compiler, sending output to cache.
  MTR_BEGIN(""cache"", ""to_cache"");
  to_cache(ctx,
           processed.compiler_args,
           ctx.args_info.depend_extra_args,
           depend_mode_hash);
  update_manifest_file(ctx);
  MTR_END(""cache"", ""to_cache"");

  return Statistic::cache_miss;
}

// The main program when not doing a compile.
static int
handle_main_options(int argc, const char* const* argv)
{
  enum longopts {
    CHECKSUM_FILE,
    CONFIG_PATH,
    DUMP_MANIFEST,
    DUMP_RESULT,
    EVICT_OLDER_THAN,
    EXTRACT_RESULT,
    HASH_FILE,
    PRINT_STATS,
  };
  static const struct option options[] = {
    {""checksum-file"", required_argument, nullptr, CHECKSUM_FILE},
    {""cleanup"", no_argument, nullptr, 'c'},
    {""clear"", no_argument, nullptr, 'C'},
    {""config-path"", required_argument, nullptr, CONFIG_PATH},
    {""directory"", required_argument, nullptr, 'd'},
    {""dump-manifest"", required_argument, nullptr, DUMP_MANIFEST},
    {""dump-result"", required_argument, nullptr, DUMP_RESULT},
    {""evict-older-than"", required_argument, nullptr, EVICT_OLDER_THAN},
    {""extract-result"", required_argument, nullptr, EXTRACT_RESULT},
    {""get-config"", required_argument, nullptr, 'k'},
    {""hash-file"", required_argument, nullptr, HASH_FILE},
    {""help"", no_argument, nullptr, 'h'},
    {""max-files"", required_argument, nullptr, 'F'},
    {""max-size"", required_argument, nullptr, 'M'},
    {""print-stats"", no_argument, nullptr, PRINT_STATS},
    {""recompress"", required_argument, nullptr, 'X'},
    {""set-config"", required_argument, nullptr, 'o'},
    {""show-compression"", no_argument, nullptr, 'x'},
    {""show-config"", no_argument, nullptr, 'p'},
    {""show-stats"", no_argument, nullptr, 's'},
    {""version"", no_argument, nullptr, 'V'},
    {""zero-stats"", no_argument, nullptr, 'z'},
    {nullptr, 0, nullptr, 0}};

  Context ctx;
  initialize(ctx, argc, argv);

  int c;
  while ((c = getopt_long(argc,
                          const_cast<char* const*>(argv),
                          ""cCd:k:hF:M:po:sVxX:z"",
                          options,
                          nullptr))
         != -1) {
    std::string arg = optarg ? optarg : std::string();

    switch (c) {
    case CHECKSUM_FILE: {
      Checksum checksum;
      Fd fd(arg == ""-"" ? STDIN_FILENO : open(arg.c_str(), O_RDONLY));
      Util::read_fd(*fd, [&checksum](const void* data, size_t size) {
        checksum.update(data, size);
      });
      PRINT(stdout, ""{:016x}\n"", checksum.digest());
      break;
    }

    case CONFIG_PATH:
      Util::setenv(""CCACHE_CONFIGPATH"", arg);
      break;

    case DUMP_MANIFEST:
      return Manifest::dump(arg, stdout) ? 0 : 1;

    case DUMP_RESULT: {
      ResultDumper result_dumper(stdout);
      Result::Reader result_reader(arg);
      auto error = result_reader.read(result_dumper);
      if (error) {
        PRINT(stderr, ""Error: {}\n"", *error);
      }
      return error ? EXIT_FAILURE : EXIT_SUCCESS;
    }

    case EVICT_OLDER_THAN: {
      auto seconds = Util::parse_duration(arg);
      ProgressBar progress_bar(""Evicting..."");
      clean_old(
        ctx, [&](double progress) { progress_bar.update(progress); }, seconds);
      if (isatty(STDOUT_FILENO)) {
        PRINT_RAW(stdout, ""\n"");
      }
      break;
    }

    case EXTRACT_RESULT: {
      ResultExtractor result_extractor(""."");
      Result::Reader result_reader(arg);
      auto error = result_reader.read(result_extractor);
      if (error) {
        PRINT(stderr, ""Error: {}\n"", *error);
      }
      return error ? EXIT_FAILURE : EXIT_SUCCESS;
    }

    case HASH_FILE: {
      Hash hash;
      if (arg == ""-"") {
        hash.hash_fd(STDIN_FILENO);
      } else {
        hash.hash_file(arg);
      }
      PRINT(stdout, ""{}\n"", hash.digest().to_string());
      break;
    }

    case PRINT_STATS:
      PRINT_RAW(stdout, Statistics::format_machine_readable(ctx.config));
      break;

    case 'c': // --cleanup
    {
      ProgressBar progress_bar(""Cleaning..."");
      clean_up_all(ctx.config,
                   [&](double progress) { progress_bar.update(progress); });
      if (isatty(STDOUT_FILENO)) {
        PRINT_RAW(stdout, ""\n"");
      }
      break;
    }

    case 'C': // --clear
    {
      ProgressBar progress_bar(""Clearing..."");
      wipe_all(ctx, [&](double progress) { progress_bar.update(progress); });
      if (isatty(STDOUT_FILENO)) {
        PRINT_RAW(stdout, ""\n"");
      }
      break;
    }

    case 'd': // --directory
      Util::setenv(""CCACHE_DIR"", arg);
      break;

    case 'h': // --help
      PRINT(stdout, USAGE_TEXT, CCACHE_NAME, CCACHE_NAME);
      exit(EXIT_SUCCESS);

    case 'k': // --get-config
      PRINT(stdout, ""{}\n"", ctx.config.get_string_value(arg));
      break;

    case 'F': { // --max-files
      auto files = Util::parse_unsigned(arg);
      Config::set_value_in_file(
        ctx.config.primary_config_path(), ""max_files"", arg);
      if (files == 0) {
        PRINT_RAW(stdout, ""Unset cache file limit\n"");
      } else {
        PRINT(stdout, ""Set cache file limit to {}\n"", files);
      }
      break;
    }

    case 'M': { // --max-size
      uint64_t size = Util::parse_size(arg);
      Config::set_value_in_file(
        ctx.config.primary_config_path(), ""max_size"", arg);
      if (size == 0) {
        PRINT_RAW(stdout, ""Unset cache size limit\n"");
      } else {
        PRINT(stdout,
              ""Set cache size limit to {}\n"",
              Util::format_human_readable_size(size));
      }
      break;
    }

    case 'o': { // --set-config
      // Start searching for equal sign at position 1 to improve error message
      // for the -o=K=V case (key ""=K"" and value ""V"").
      size_t eq_pos = arg.find('=', 1);
      if (eq_pos == std::string::npos) {
        throw Error(""missing equal sign in \""{}\"""", arg);
      }
      std::string key = arg.substr(0, eq_pos);
      std::string value = arg.substr(eq_pos + 1);
      Config::set_value_in_file(ctx.config.primary_config_path(), key, value);
      break;
    }

    case 'p': // --show-config
      ctx.config.visit_items(configuration_printer);
      break;

    case 's': // --show-stats
      PRINT_RAW(stdout, Statistics::format_human_readable(ctx.config));
      break;

    case 'V': // --version
      PRINT(VERSION_TEXT, CCACHE_NAME, CCACHE_VERSION);
      exit(EXIT_SUCCESS);

    case 'x': // --show-compression
    {
      ProgressBar progress_bar(""Scanning..."");
      compress_stats(ctx.config,
                     [&](double progress) { progress_bar.update(progress); });
      break;
    }

    case 'X': // --recompress
    {
      optional<int8_t> wanted_level;
      if (arg == ""uncompressed"") {
        wanted_level = nullopt;
      } else {
        wanted_level =
          Util::parse_signed(arg, INT8_MIN, INT8_MAX, ""compression level"");
      }

      ProgressBar progress_bar(""Recompressing..."");
      compress_recompress(ctx, wanted_level, [&](double progress) {
        progress_bar.update(progress);
      });
      break;
    }

    case 'z': // --zero-stats
      Statistics::zero_all_counters(ctx.config);
      PRINT_RAW(stdout, ""Statistics zeroed\n"");
      break;

    default:
      PRINT(stderr, USAGE_TEXT, CCACHE_NAME, CCACHE_NAME);
      exit(EXIT_FAILURE);
    }

    // Some of the above switches might have changed config settings, so run the
    // setup again.
    ctx.config = Config();
    set_up_config(ctx.config);
  }

  return 0;
}

int ccache_main(int argc, const char* const* argv);

int
ccache_main(int argc, const char* const* argv)
{
  try {
    // Check if we are being invoked as ""ccache"".
    std::string program_name(Util::base_name(argv[0]));
    if (Util::same_program_name(program_name, CCACHE_NAME)) {
      if (argc < 2) {
        PRINT(stderr, USAGE_TEXT, CCACHE_NAME, CCACHE_NAME);
        exit(EXIT_FAILURE);
      }
      // If the first argument isn't an option, then assume we are being passed
      // a compiler name and options.
      if (argv[1][0] == '-') {
        return handle_main_options(argc, argv);
      }
    }

    return cache_compilation(argc, argv);
  } catch (const ErrorBase& e) {
    PRINT(stderr, ""ccache: error: {}\n"", e.what());
    return EXIT_FAILURE;
  }
}
""",do_remember_include_file,[380:505]
ccache,https://github.com/ccache/ccache/commit/fc5f6d20bb9c661683cb4cde43a745b4d8b2080f,"""fix(http-storage): Disable broken connection keep-alive

After ignoring SIGPIPE (b2a88e7) keep-alive support has been
re-enabled for HTTP Storage. Unfortunately it's still broken
but does not crash ccache, anymore.

This is the tcpdump of a (cache miss) compilation that takes longer
than the server keep-alive timeout:

```
10:51:17.214678 IP 10.34.129.62.37468 > 10.34.132.45.webcache: Flags [S], seq 1018344313, win 62727, options [mss 8961,sackOK,TS val 1638189791 ecr 0,nop,wscale 7], length 0
10:51:17.216386 IP 10.34.132.45.webcache > 10.34.129.62.37468: Flags [S.], seq 2695216843, ack 1018344314, win 26847, options [mss 8645,sackOK,TS val 1598789083 ecr 1638189791,nop,wscale 9], length 0
10:51:17.216424 IP 10.34.129.62.37468 > 10.34.132.45.webcache: Flags [.], ack 1, win 491, options [nop,nop,TS val 1638189793 ecr 1598789083], length 0
10:51:17.216534 IP 10.34.129.62.37468 > 10.34.132.45.webcache: Flags [P.], seq 1:143, ack 1, win 491, options [nop,nop,TS val 1638189793 ecr 1598789083], length 142: HTTP: GET /cache/ff87vlgke3poou7uq1ma2m3hh000gckmq HTTP/1.1
10:51:17.217393 IP 10.34.132.45.webcache > 10.34.129.62.37468: Flags [.], ack 143, win 55, options [nop,nop,TS val 1598789084 ecr 1638189793], length 0
10:51:17.217433 IP 10.34.132.45.webcache > 10.34.129.62.37468: Flags [P.], seq 1:309, ack 143, win 55, options [nop,nop,TS val 1598789085 ecr 1638189793], length 308: HTTP: HTTP/1.1 404 Not Found
10:51:17.217456 IP 10.34.129.62.37468 > 10.34.132.45.webcache: Flags [.], ack 309, win 489, options [nop,nop,TS val 1638189794 ecr 1598789085], length 0
10:51:17.538819 IP 10.34.129.62.37468 > 10.34.132.45.webcache: Flags [P.], seq 143:285, ack 309, win 489, options [nop,nop,TS val 1638190115 ecr 1598789085], length 142: HTTP: GET /cache/135di89r02vv5fgopbtsopfjllo01b8lg HTTP/1.1
10:51:17.539838 IP 10.34.132.45.webcache > 10.34.129.62.37468: Flags [P.], seq 309:617, ack 285, win 57, options [nop,nop,TS val 1598789407 ecr 1638190115], length 308: HTTP: HTTP/1.1 404 Not Found
10:51:17.539876 IP 10.34.129.62.37468 > 10.34.132.45.webcache: Flags [.], ack 617, win 487, options [nop,nop,TS val 1638190117 ecr 1598789407], length 0

10:52:32.536322 IP 10.34.132.45.webcache > 10.34.129.62.37468: Flags [F.], seq 617, ack 285, win 57, options [nop,nop,TS val 1598864404 ecr 1638190117], length 0
10:52:32.577893 IP 10.34.129.62.37468 > 10.34.132.45.webcache: Flags [.], ack 618, win 487, options [nop,nop,TS val 1638265155 ecr 1598864404], length 0

10:52:42.173135 IP 10.34.129.62.37468 > 10.34.132.45.webcache: Flags [P.], seq 285:492, ack 618, win 487, options [nop,nop,TS val 1638274750 ecr 1598864404], length 207: HTTP: PUT /cache/135di89r02vv5fgopbtsopfjllo01b8lg HTTP/1.1
10:52:42.173153 IP 10.34.129.62.37468 > 10.34.132.45.webcache: Flags [.], seq 492:9125, ack 618, win 487, options [nop,nop,TS val 1638274750 ecr 1598864404], length 8633: HTTP
10:52:42.173159 IP 10.34.129.62.37468 > 10.34.132.45.webcache: Flags [P.], seq 9125:17758, ack 618, win 487, options [nop,nop,TS val 1638274750 ecr 1598864404], length 8633: HTTP
10:52:42.173165 IP 10.34.129.62.37468 > 10.34.132.45.webcache: Flags [.], seq 17758:26391, ack 618, win 487, options [nop,nop,TS val 1638274750 ecr 1598864404], length 8633: HTTP
10:52:42.174049 IP 10.34.132.45.webcache > 10.34.129.62.37468: Flags [R], seq 2695217461, win 0, length 0
10:52:42.174056 IP 10.34.132.45.webcache > 10.34.129.62.37468: Flags [R], seq 2695217461, win 0, length 0
10:52:42.174057 IP 10.34.132.45.webcache > 10.34.129.62.37468: Flags [R], seq 2695217461, win 0, length 0
```

The PUT error due to the closed socket is also logged:
```
[2021-09-14T10:52:42.068112 2089 ] Storing result file modules/asyncly/Test/Unit/CMakeFiles/test_asyncly.dir/future/FutureTest.cpp.o
[2021-09-14T10:52:42.068118 2089 ] Storing embedded file #0 .o (36847216 bytes) from modules/asyncly/Test/Unit/CMakeFiles/test_asyncly.dir/future/FutureTest.cpp.o
[2021-09-14T10:52:42.154930 2089 ] Storing result file modules/asyncly/Test/Unit/CMakeFiles/test_asyncly.dir/future/FutureTest.cpp.o.d
[2021-09-14T10:52:42.154951 2089 ] Storing embedded file #1 .d (122626 bytes) from modules/asyncly/Test/Unit/CMakeFiles/test_asyncly.dir/future/FutureTest.cpp.o.d
[2021-09-14T10:52:42.155260 2089 ] Stored 135di89r02vv5fgopbtsopfjllo01b8lg in primary storage (/cache/ccache/1/3/5di89r02vv5fgopbtsopfjllo01b8lgR)
[2021-09-14T10:52:42.175445 2089 ] Failed to put /cache/135di89r02vv5fgopbtsopfjllo01b8lg to http storage: Unknown (1)
[2021-09-14T10:52:42.175999 2089 ] Adding result key to /cache/ccache/f/f/87vlgke3poou7uq1ma2m3hh000gckmqM
[2021-09-14T10:52:42.179375 2089 ] Using default compression level 1
[2021-09-14T10:52:42.180306 2089 ] Stored ff87vlgke3poou7uq1ma2m3hh000gckmq in primary storage (/cache/ccache/f/f/87vlgke3poou7uq1ma2m3hh000gckmqM)
[2021-09-14T10:52:42.180341 2089 ] Not putting in http://jenkins3-bazelcache.ec2.getgotools.net:8080/cache since it failed earlier
```

I believe a 90s compilation is worth caching and more important than
skipping the TCP three-way handshake.""","""// Copyright (C) 2021 Joel Rosdahl and other contributors
//
// See doc/AUTHORS.adoc for a complete list of contributors.
//
// This program is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by the Free
// Software Foundation; either version 3 of the License, or (at your option)
// any later version.
//
// This program is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
// more details.
//
// You should have received a copy of the GNU General Public License along with
// this program; if not, write to the Free Software Foundation, Inc., 51
// Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA

#include ""HttpStorage.hpp""

#include <Digest.hpp>
#include <Logging.hpp>
#include <ccache.hpp>
#include <core/exceptions.hpp>
#include <fmtmacros.hpp>
#include <util/expected.hpp>
#include <util/string.hpp>

#include <third_party/httplib.h>
#include <third_party/nonstd/string_view.hpp>
#include <third_party/url.hpp>

namespace storage {
namespace secondary {

namespace {

class HttpStorageBackend : public SecondaryStorage::Backend
{
public:
  HttpStorageBackend(const Params& params);

  nonstd::expected<nonstd::optional<std::string>, Failure>
  get(const Digest& key) override;

  nonstd::expected<bool, Failure> put(const Digest& key,
                                      const std::string& value,
                                      bool only_if_missing) override;

  nonstd::expected<bool, Failure> remove(const Digest& key) override;

private:
  enum class Layout { bazel, flat, subdirs };

  const std::string m_url_path;
  httplib::Client m_http_client;
  Layout m_layout = Layout::subdirs;

  std::string get_entry_path(const Digest& key) const;
};

std::string
get_url_path(const Url& url)
{
  auto path = url.path();
  if (path.empty() || path.back() != '/') {
    path += '/';
  }
  return path;
}

Url
get_partial_url(const Url& from_url)
{
  Url url;
  url.scheme(from_url.scheme());
  url.host(from_url.host(), from_url.ip_version());
  if (!from_url.port().empty()) {
    url.port(from_url.port());
  }
  return url;
}

std::string
get_url(const Url& url)
{
  if (url.host().empty()) {
    throw core::Fatal(""A host is required in HTTP storage URL \""{}\"""",
                      url.str());
  }

  // httplib requires a partial URL with just scheme, host and port.
  return get_partial_url(url).str();
}

HttpStorageBackend::HttpStorageBackend(const Params& params)
  : m_url_path(get_url_path(params.url)),
    m_http_client(get_url(params.url))
{
  if (!params.url.user_info().empty()) {
    const auto pair = util::split_once(params.url.user_info(), ':');
    if (!pair.second) {
      throw core::Fatal(""Expected username:password in URL but got \""{}\"""",
                        params.url.user_info());
    }
    m_http_client.set_basic_auth(std::string(pair.first).c_str(),
                                 std::string(*pair.second).c_str());
  }

  m_http_client.set_default_headers({
    {""User-Agent"", FMT(""{}/{}"", CCACHE_NAME, CCACHE_VERSION)},
  });
  m_http_client.set_keep_alive(true);

  auto connect_timeout = k_default_connect_timeout;
  auto operation_timeout = k_default_operation_timeout;

  for (const auto& attr : params.attributes) {
    if (attr.key == ""connect-timeout"") {
      connect_timeout = parse_timeout_attribute(attr.value);
    } else if (attr.key == ""layout"") {
      if (attr.value == ""bazel"") {
        m_layout = Layout::bazel;
      } else if (attr.value == ""flat"") {
        m_layout = Layout::flat;
      } else if (attr.value == ""subdirs"") {
        m_layout = Layout::subdirs;
      } else {
        LOG(""Unknown layout: {}"", attr.value);
      }
    } else if (attr.key == ""operation-timeout"") {
      operation_timeout = parse_timeout_attribute(attr.value);
    } else if (!is_framework_attribute(attr.key)) {
      LOG(""Unknown attribute: {}"", attr.key);
    }
  }

  m_http_client.set_connection_timeout(connect_timeout);
  m_http_client.set_read_timeout(operation_timeout);
  m_http_client.set_write_timeout(operation_timeout);
}

nonstd::expected<nonstd::optional<std::string>,
                 SecondaryStorage::Backend::Failure>
HttpStorageBackend::get(const Digest& key)
{
  const auto url_path = get_entry_path(key);
  const auto result = m_http_client.Get(url_path.c_str());

  if (result.error() != httplib::Error::Success || !result) {
    LOG(""Failed to get {} from http storage: {} ({})"",
        url_path,
        to_string(result.error()),
        result.error());
    return nonstd::make_unexpected(Failure::error);
  }

  if (result->status < 200 || result->status >= 300) {
    // Don't log failure if the entry doesn't exist.
    return nonstd::nullopt;
  }

  return result->body;
}

nonstd::expected<bool, SecondaryStorage::Backend::Failure>
HttpStorageBackend::put(const Digest& key,
                        const std::string& value,
                        const bool only_if_missing)
{
  const auto url_path = get_entry_path(key);

  if (only_if_missing) {
    const auto result = m_http_client.Head(url_path.c_str());

    if (result.error() != httplib::Error::Success || !result) {
      LOG(""Failed to check for {} in http storage: {} ({})"",
          url_path,
          to_string(result.error()),
          result.error());
      return nonstd::make_unexpected(Failure::error);
    }

    if (result->status >= 200 && result->status < 300) {
      LOG(""Found entry {} already within http storage: status code: {}"",
          url_path,
          result->status);
      return false;
    }
  }

  static const auto content_type = ""application/octet-stream"";
  const auto result = m_http_client.Put(
    url_path.c_str(), value.data(), value.size(), content_type);

  if (result.error() != httplib::Error::Success || !result) {
    LOG(""Failed to put {} to http storage: {} ({})"",
        url_path,
        to_string(result.error()),
        result.error());
    return nonstd::make_unexpected(Failure::error);
  }

  if (result->status < 200 || result->status >= 300) {
    LOG(""Failed to put {} to http storage: status code: {}"",
        url_path,
        result->status);
    return nonstd::make_unexpected(Failure::error);
  }

  return true;
}

nonstd::expected<bool, SecondaryStorage::Backend::Failure>
HttpStorageBackend::remove(const Digest& key)
{
  const auto url_path = get_entry_path(key);
  const auto result = m_http_client.Delete(url_path.c_str());

  if (result.error() != httplib::Error::Success || !result) {
    LOG(""Failed to delete {} from http storage: {} ({})"",
        url_path,
        to_string(result.error()),
        result.error());
    return nonstd::make_unexpected(Failure::error);
  }

  if (result->status < 200 || result->status >= 300) {
    LOG(""Failed to delete {} from http storage: status code: {}"",
        url_path,
        result->status);
    return nonstd::make_unexpected(Failure::error);
  }

  return true;
}

std::string
HttpStorageBackend::get_entry_path(const Digest& key) const
{
  switch (m_layout) {
  case Layout::bazel: {
    // Mimic hex representation of a SHA256 hash value.
    const auto sha256_hex_size = 64;
    static_assert(Digest::size() == 20, ""Update below if digest size changes"");
    std::string hex_digits = Util::format_base16(key.bytes(), key.size());
    hex_digits.append(hex_digits.data(), sha256_hex_size - hex_digits.size());
    LOG(""Translated key {} to Bazel layout ac/{}"", key.to_string(), hex_digits);
    return FMT(""{}ac/{}"", m_url_path, hex_digits);
  }

  case Layout::flat:
    return m_url_path + key.to_string();

  case Layout::subdirs: {
    const auto key_str = key.to_string();
    const uint8_t digits = 2;
    ASSERT(key_str.length() > digits);
    return FMT(""{}/{:.{}}/{}"", m_url_path, key_str, digits, &key_str[digits]);
  }
  }

  ASSERT(false);
}

} // namespace

std::unique_ptr<SecondaryStorage::Backend>
HttpStorage::create_backend(const Backend::Params& params) const
{
  return std::make_unique<HttpStorageBackend>(params);
}

void
HttpStorage::redact_secrets(Backend::Params& params) const
{
  auto& url = params.url;
  const auto user_info = util::split_once(url.user_info(), ':');
  if (user_info.second) {
    url.user_info(FMT(""{}:{}"", user_info.first, k_redacted_password));
  }
}

} // namespace secondary
} // namespace storage
""","""// Copyright (C) 2021 Joel Rosdahl and other contributors
//
// See doc/AUTHORS.adoc for a complete list of contributors.
//
// This program is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by the Free
// Software Foundation; either version 3 of the License, or (at your option)
// any later version.
//
// This program is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
// more details.
//
// You should have received a copy of the GNU General Public License along with
// this program; if not, write to the Free Software Foundation, Inc., 51
// Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA

#include ""HttpStorage.hpp""

#include <Digest.hpp>
#include <Logging.hpp>
#include <ccache.hpp>
#include <core/exceptions.hpp>
#include <fmtmacros.hpp>
#include <util/expected.hpp>
#include <util/string.hpp>

#include <third_party/httplib.h>
#include <third_party/nonstd/string_view.hpp>
#include <third_party/url.hpp>

namespace storage {
namespace secondary {

namespace {

class HttpStorageBackend : public SecondaryStorage::Backend
{
public:
  HttpStorageBackend(const Params& params);

  nonstd::expected<nonstd::optional<std::string>, Failure>
  get(const Digest& key) override;

  nonstd::expected<bool, Failure> put(const Digest& key,
                                      const std::string& value,
                                      bool only_if_missing) override;

  nonstd::expected<bool, Failure> remove(const Digest& key) override;

private:
  enum class Layout { bazel, flat, subdirs };

  const std::string m_url_path;
  httplib::Client m_http_client;
  Layout m_layout = Layout::subdirs;

  std::string get_entry_path(const Digest& key) const;
};

std::string
get_url_path(const Url& url)
{
  auto path = url.path();
  if (path.empty() || path.back() != '/') {
    path += '/';
  }
  return path;
}

Url
get_partial_url(const Url& from_url)
{
  Url url;
  url.scheme(from_url.scheme());
  url.host(from_url.host(), from_url.ip_version());
  if (!from_url.port().empty()) {
    url.port(from_url.port());
  }
  return url;
}

std::string
get_url(const Url& url)
{
  if (url.host().empty()) {
    throw core::Fatal(""A host is required in HTTP storage URL \""{}\"""",
                      url.str());
  }

  // httplib requires a partial URL with just scheme, host and port.
  return get_partial_url(url).str();
}

HttpStorageBackend::HttpStorageBackend(const Params& params)
  : m_url_path(get_url_path(params.url)),
    m_http_client(get_url(params.url))
{
  if (!params.url.user_info().empty()) {
    const auto pair = util::split_once(params.url.user_info(), ':');
    if (!pair.second) {
      throw core::Fatal(""Expected username:password in URL but got \""{}\"""",
                        params.url.user_info());
    }
    m_http_client.set_basic_auth(std::string(pair.first).c_str(),
                                 std::string(*pair.second).c_str());
  }

  m_http_client.set_default_headers({
    {""User-Agent"", FMT(""{}/{}"", CCACHE_NAME, CCACHE_VERSION)},
  });

  auto connect_timeout = k_default_connect_timeout;
  auto operation_timeout = k_default_operation_timeout;

  for (const auto& attr : params.attributes) {
    if (attr.key == ""connect-timeout"") {
      connect_timeout = parse_timeout_attribute(attr.value);
    } else if (attr.key == ""layout"") {
      if (attr.value == ""bazel"") {
        m_layout = Layout::bazel;
      } else if (attr.value == ""flat"") {
        m_layout = Layout::flat;
      } else if (attr.value == ""subdirs"") {
        m_layout = Layout::subdirs;
      } else {
        LOG(""Unknown layout: {}"", attr.value);
      }
    } else if (attr.key == ""operation-timeout"") {
      operation_timeout = parse_timeout_attribute(attr.value);
    } else if (!is_framework_attribute(attr.key)) {
      LOG(""Unknown attribute: {}"", attr.key);
    }
  }

  m_http_client.set_connection_timeout(connect_timeout);
  m_http_client.set_read_timeout(operation_timeout);
  m_http_client.set_write_timeout(operation_timeout);
}

nonstd::expected<nonstd::optional<std::string>,
                 SecondaryStorage::Backend::Failure>
HttpStorageBackend::get(const Digest& key)
{
  const auto url_path = get_entry_path(key);
  const auto result = m_http_client.Get(url_path.c_str());

  if (result.error() != httplib::Error::Success || !result) {
    LOG(""Failed to get {} from http storage: {} ({})"",
        url_path,
        to_string(result.error()),
        result.error());
    return nonstd::make_unexpected(Failure::error);
  }

  if (result->status < 200 || result->status >= 300) {
    // Don't log failure if the entry doesn't exist.
    return nonstd::nullopt;
  }

  return result->body;
}

nonstd::expected<bool, SecondaryStorage::Backend::Failure>
HttpStorageBackend::put(const Digest& key,
                        const std::string& value,
                        const bool only_if_missing)
{
  const auto url_path = get_entry_path(key);

  if (only_if_missing) {
    const auto result = m_http_client.Head(url_path.c_str());

    if (result.error() != httplib::Error::Success || !result) {
      LOG(""Failed to check for {} in http storage: {} ({})"",
          url_path,
          to_string(result.error()),
          result.error());
      return nonstd::make_unexpected(Failure::error);
    }

    if (result->status >= 200 && result->status < 300) {
      LOG(""Found entry {} already within http storage: status code: {}"",
          url_path,
          result->status);
      return false;
    }
  }

  static const auto content_type = ""application/octet-stream"";
  const auto result = m_http_client.Put(
    url_path.c_str(), value.data(), value.size(), content_type);

  if (result.error() != httplib::Error::Success || !result) {
    LOG(""Failed to put {} to http storage: {} ({})"",
        url_path,
        to_string(result.error()),
        result.error());
    return nonstd::make_unexpected(Failure::error);
  }

  if (result->status < 200 || result->status >= 300) {
    LOG(""Failed to put {} to http storage: status code: {}"",
        url_path,
        result->status);
    return nonstd::make_unexpected(Failure::error);
  }

  return true;
}

nonstd::expected<bool, SecondaryStorage::Backend::Failure>
HttpStorageBackend::remove(const Digest& key)
{
  const auto url_path = get_entry_path(key);
  const auto result = m_http_client.Delete(url_path.c_str());

  if (result.error() != httplib::Error::Success || !result) {
    LOG(""Failed to delete {} from http storage: {} ({})"",
        url_path,
        to_string(result.error()),
        result.error());
    return nonstd::make_unexpected(Failure::error);
  }

  if (result->status < 200 || result->status >= 300) {
    LOG(""Failed to delete {} from http storage: status code: {}"",
        url_path,
        result->status);
    return nonstd::make_unexpected(Failure::error);
  }

  return true;
}

std::string
HttpStorageBackend::get_entry_path(const Digest& key) const
{
  switch (m_layout) {
  case Layout::bazel: {
    // Mimic hex representation of a SHA256 hash value.
    const auto sha256_hex_size = 64;
    static_assert(Digest::size() == 20, ""Update below if digest size changes"");
    std::string hex_digits = Util::format_base16(key.bytes(), key.size());
    hex_digits.append(hex_digits.data(), sha256_hex_size - hex_digits.size());
    LOG(""Translated key {} to Bazel layout ac/{}"", key.to_string(), hex_digits);
    return FMT(""{}ac/{}"", m_url_path, hex_digits);
  }

  case Layout::flat:
    return m_url_path + key.to_string();

  case Layout::subdirs: {
    const auto key_str = key.to_string();
    const uint8_t digits = 2;
    ASSERT(key_str.length() > digits);
    return FMT(""{}/{:.{}}/{}"", m_url_path, key_str, digits, &key_str[digits]);
  }
  }

  ASSERT(false);
}

} // namespace

std::unique_ptr<SecondaryStorage::Backend>
HttpStorage::create_backend(const Backend::Params& params) const
{
  return std::make_unique<HttpStorageBackend>(params);
}

void
HttpStorage::redact_secrets(Backend::Params& params) const
{
  auto& url = params.url;
  const auto user_info = util::split_once(url.user_info(), ':');
  if (user_info.second) {
    url.user_info(FMT(""{}:{}"", user_info.first, k_redacted_password));
  }
}

} // namespace secondary
} // namespace storage
""",storage::secondary::HttpStorageBackend::HttpStorageBackend,[96:141]
ccache,https://github.com/ccache/ccache/commit/4905b1afacb01bff907b89dd4b05dff66b31790b,"""perf: Optimize util::write_file for empty data""","""// Copyright (C) 2021-2022 Joel Rosdahl and other contributors
//
// See doc/AUTHORS.adoc for a complete list of contributors.
//
// This program is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by the Free
// Software Foundation; either version 3 of the License, or (at your option)
// any later version.
//
// This program is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
// more details.
//
// You should have received a copy of the GNU General Public License along with
// this program; if not, write to the Free Software Foundation, Inc., 51
// Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA

#include ""file.hpp""

#include <Fd.hpp>
#include <Logging.hpp>
#include <Stat.hpp>
#include <Win32Util.hpp>
#include <fmtmacros.hpp>
#include <util/Bytes.hpp>

#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#endif

#ifdef HAVE_UTIMENSAT
#  include <fcntl.h>
#  include <sys/stat.h>
#elif defined(HAVE_UTIMES)
#  include <sys/time.h>
#else
#  include <sys/types.h>
#  ifdef HAVE_UTIME_H
#    include <utime.h>
#  elif defined(HAVE_SYS_UTIME_H)
#    include <sys/utime.h>
#  endif
#endif

#include <fcntl.h>
#include <sys/stat.h>
#include <sys/types.h>

#include <cerrno>
#include <cstring>
#include <fstream>
#include <locale>
#include <type_traits>

namespace util {

void
create_cachedir_tag(const std::string& dir)
{
  constexpr char cachedir_tag[] =
    ""Signature: 8a477f597d28d172789f06886806bc55\n""
    ""# This file is a cache directory tag created by ccache.\n""
    ""# For information about cache directory tags, see:\n""
    ""#\thttp://www.brynosaurus.com/cachedir/\n"";

  const std::string path = FMT(""{}/CACHEDIR.TAG"", dir);
  const auto stat = Stat::stat(path);
  if (stat) {
    return;
  }
  const auto result = util::write_file(path, cachedir_tag);
  if (!result) {
    LOG(""Failed to create {}: {}"", path, result.error());
  }
}

nonstd::expected<void, std::string>
read_fd(int fd, DataReceiver data_receiver)
{
  int64_t n;
  uint8_t buffer[CCACHE_READ_BUFFER_SIZE];
  while ((n = read(fd, buffer, sizeof(buffer))) != 0) {
    if (n == -1 && errno != EINTR) {
      break;
    }
    if (n > 0) {
      data_receiver(buffer, n);
    }
  }
  if (n == -1) {
    return nonstd::make_unexpected(strerror(errno));
  }
  return {};
}

#ifdef _WIN32
static bool
has_utf16_le_bom(std::string_view text)
{
  return text.size() > 1
         && ((static_cast<uint8_t>(text[0]) == 0xff
              && static_cast<uint8_t>(text[1]) == 0xfe));
}
#endif

template<typename T>
nonstd::expected<T, std::string>
read_file(const std::string& path, size_t size_hint)
{
  if (size_hint == 0) {
    const auto stat = Stat::stat(path);
    if (!stat) {
      return nonstd::make_unexpected(strerror(errno));
    }
    size_hint = stat.size();
  }

  // +1 to be able to detect EOF in the first read call
  size_hint = (size_hint < 1024) ? 1024 : size_hint + 1;

  const int open_flags = [] {
    if constexpr (std::is_same<T, std::string>::value) {
      return O_RDONLY | O_TEXT;
    } else {
      return O_RDONLY | O_BINARY;
    }
  }();
  Fd fd(open(path.c_str(), open_flags));
  if (!fd) {
    return nonstd::make_unexpected(strerror(errno));
  }

  int64_t ret = 0;
  size_t pos = 0;
  T result;
  result.resize(size_hint);

  while (true) {
    if (pos == result.size()) {
      result.resize(2 * result.size());
    }
    const size_t max_read = result.size() - pos;
    ret = read(*fd, &result[pos], max_read);
    if (ret == 0 || (ret == -1 && errno != EINTR)) {
      break;
    }
    if (ret > 0) {
      pos += ret;
      if (static_cast<size_t>(ret) < max_read) {
        break;
      }
    }
  }

  if (ret == -1) {
    return nonstd::make_unexpected(strerror(errno));
  }

  result.resize(pos);

#ifdef _WIN32
  if constexpr (std::is_same<T, std::string>::value) {
    // Convert to UTF-8 if the content starts with a UTF-16 little-endian BOM.
    if (has_utf16_le_bom(result)) {
      result.erase(0, 2); // Remove BOM.
      if (result.empty()) {
        return result;
      }

      std::wstring result_as_u16((result.size() / 2) + 1, '\0');
      result_as_u16 = reinterpret_cast<const wchar_t*>(result.c_str());
      const int size = WideCharToMultiByte(CP_UTF8,
                                           WC_ERR_INVALID_CHARS,
                                           result_as_u16.c_str(),
                                           int(result_as_u16.size()),
                                           nullptr,
                                           0,
                                           nullptr,
                                           nullptr);
      if (size <= 0) {
        return nonstd::make_unexpected(
          FMT(""Failed to convert {} from UTF-16LE to UTF-8: {}"",
              path,
              Win32Util::error_message(GetLastError())));
      }

      result = std::string(size, '\0');
      WideCharToMultiByte(CP_UTF8,
                          0,
                          result_as_u16.c_str(),
                          int(result_as_u16.size()),
                          &result.at(0),
                          size,
                          nullptr,
                          nullptr);
    }
  }
#endif

  return result;
}

template nonstd::expected<util::Bytes, std::string>
read_file(const std::string& path, size_t size_hint);

template nonstd::expected<std::string, std::string>
read_file(const std::string& path, size_t size_hint);

template nonstd::expected<std::vector<uint8_t>, std::string>
read_file(const std::string& path, size_t size_hint);

template<typename T>
nonstd::expected<T, std::string>
read_file_part(const std::string& path, size_t pos, size_t count)
{
  Fd fd(open(path.c_str(), O_RDONLY | O_BINARY));
  if (!fd) {
    LOG(""Failed to open {}: {}"", path, strerror(errno));
    return nonstd::make_unexpected(strerror(errno));
  }

  if (pos != 0 && lseek(*fd, pos, SEEK_SET) != static_cast<off_t>(pos)) {
    return nonstd::make_unexpected(strerror(errno));
  }

  int64_t ret = 0;
  size_t bytes_read = 0;
  T result;
  result.resize(count);

  while (true) {
    const size_t max_read = count - bytes_read;
    ret = read(*fd, &result[bytes_read], max_read);
    if (ret == 0 || (ret == -1 && errno != EINTR)) {
      break;
    }
    if (ret > 0) {
      bytes_read += ret;
      if (bytes_read == count) {
        break;
      }
    }
  }

  if (ret == -1) {
    LOG(""Failed to read {}: {}"", path, strerror(errno));
    return nonstd::make_unexpected(strerror(errno));
  }

  result.resize(bytes_read);
  return result;
}

template nonstd::expected<util::Bytes, std::string>
read_file_part(const std::string& path, size_t pos, size_t count);

template nonstd::expected<std::vector<uint8_t>, std::string>
read_file_part(const std::string& path, size_t pos, size_t count);

void
set_timestamps(const std::string& path,
               std::optional<util::TimePoint> mtime,
               std::optional<util::TimePoint> atime)
{
#ifdef HAVE_UTIMENSAT
  timespec atime_mtime[2];
  if (mtime) {
    atime_mtime[0] = (atime ? *atime : *mtime).to_timespec();
    atime_mtime[1] = mtime->to_timespec();
  }
  utimensat(AT_FDCWD, path.c_str(), mtime ? atime_mtime : nullptr, 0);
#elif defined(HAVE_UTIMES)
  timeval atime_mtime[2];
  if (mtime) {
    atime_mtime[0].tv_sec = atime ? atime->sec() : mtime->sec();
    atime_mtime[0].tv_usec =
      (atime ? atime->nsec_decimal_part() : mtime->nsec_decimal_part()) / 1000;
    atime_mtime[1].tv_sec = mtime->sec();
    atime_mtime[1].tv_usec = mtime->nsec_decimal_part() / 1000;
  }
  utimes(path.c_str(), mtime ? atime_mtime : nullptr);
#else
  utimbuf atime_mtime;
  if (mtime) {
    atime_mtime.actime = atime ? atime->sec() : mtime->sec();
    atime_mtime.modtime = mtime->sec();
    utime(path.c_str(), &atime_mtime);
  } else {
    utime(path.c_str(), nullptr);
  }
#endif
}

nonstd::expected<void, std::string>
write_fd(int fd, const void* data, size_t size)
{
  int64_t written = 0;
  do {
    const auto count =
      write(fd, static_cast<const uint8_t*>(data) + written, size - written);
    if (count == -1) {
      if (errno != EAGAIN && errno != EINTR) {
        return nonstd::make_unexpected(strerror(errno));
      }
    } else {
      written += count;
    }
  } while (static_cast<size_t>(written) < size);
  return {};
}

nonstd::expected<void, std::string>
write_file(const std::string& path, std::string_view data, InPlace in_place)
{
  if (in_place == InPlace::no) {
    unlink(path.c_str());
  }
  Fd fd(open(path.c_str(), O_WRONLY | O_CREAT | O_TRUNC | O_TEXT, 0666));
  if (!fd) {
    return nonstd::make_unexpected(strerror(errno));
  }
  return write_fd(*fd, data.data(), data.size());
}

nonstd::expected<void, std::string>
write_file(const std::string& path,
           nonstd::span<const uint8_t> data,
           InPlace in_place)
{
  if (in_place == InPlace::no) {
    unlink(path.c_str());
  }
  Fd fd(open(path.c_str(), O_WRONLY | O_CREAT | O_TRUNC | O_BINARY, 0666));
  if (!fd) {
    return nonstd::make_unexpected(strerror(errno));
  }
  return write_fd(*fd, data.data(), data.size());
}

} // namespace util
""","""// Copyright (C) 2021-2022 Joel Rosdahl and other contributors
//
// See doc/AUTHORS.adoc for a complete list of contributors.
//
// This program is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by the Free
// Software Foundation; either version 3 of the License, or (at your option)
// any later version.
//
// This program is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
// more details.
//
// You should have received a copy of the GNU General Public License along with
// this program; if not, write to the Free Software Foundation, Inc., 51
// Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA

#include ""file.hpp""

#include <Fd.hpp>
#include <Logging.hpp>
#include <Stat.hpp>
#include <Win32Util.hpp>
#include <fmtmacros.hpp>
#include <util/Bytes.hpp>

#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#endif

#ifdef HAVE_UTIMENSAT
#  include <fcntl.h>
#  include <sys/stat.h>
#elif defined(HAVE_UTIMES)
#  include <sys/time.h>
#else
#  include <sys/types.h>
#  ifdef HAVE_UTIME_H
#    include <utime.h>
#  elif defined(HAVE_SYS_UTIME_H)
#    include <sys/utime.h>
#  endif
#endif

#include <fcntl.h>
#include <sys/stat.h>
#include <sys/types.h>

#include <cerrno>
#include <cstring>
#include <fstream>
#include <locale>
#include <type_traits>

namespace util {

void
create_cachedir_tag(const std::string& dir)
{
  constexpr char cachedir_tag[] =
    ""Signature: 8a477f597d28d172789f06886806bc55\n""
    ""# This file is a cache directory tag created by ccache.\n""
    ""# For information about cache directory tags, see:\n""
    ""#\thttp://www.brynosaurus.com/cachedir/\n"";

  const std::string path = FMT(""{}/CACHEDIR.TAG"", dir);
  const auto stat = Stat::stat(path);
  if (stat) {
    return;
  }
  const auto result = util::write_file(path, cachedir_tag);
  if (!result) {
    LOG(""Failed to create {}: {}"", path, result.error());
  }
}

nonstd::expected<void, std::string>
read_fd(int fd, DataReceiver data_receiver)
{
  int64_t n;
  uint8_t buffer[CCACHE_READ_BUFFER_SIZE];
  while ((n = read(fd, buffer, sizeof(buffer))) != 0) {
    if (n == -1 && errno != EINTR) {
      break;
    }
    if (n > 0) {
      data_receiver(buffer, n);
    }
  }
  if (n == -1) {
    return nonstd::make_unexpected(strerror(errno));
  }
  return {};
}

#ifdef _WIN32
static bool
has_utf16_le_bom(std::string_view text)
{
  return text.size() > 1
         && ((static_cast<uint8_t>(text[0]) == 0xff
              && static_cast<uint8_t>(text[1]) == 0xfe));
}
#endif

template<typename T>
nonstd::expected<T, std::string>
read_file(const std::string& path, size_t size_hint)
{
  if (size_hint == 0) {
    const auto stat = Stat::stat(path);
    if (!stat) {
      return nonstd::make_unexpected(strerror(errno));
    }
    size_hint = stat.size();
  }

  // +1 to be able to detect EOF in the first read call
  size_hint = (size_hint < 1024) ? 1024 : size_hint + 1;

  const int open_flags = [] {
    if constexpr (std::is_same<T, std::string>::value) {
      return O_RDONLY | O_TEXT;
    } else {
      return O_RDONLY | O_BINARY;
    }
  }();
  Fd fd(open(path.c_str(), open_flags));
  if (!fd) {
    return nonstd::make_unexpected(strerror(errno));
  }

  int64_t ret = 0;
  size_t pos = 0;
  T result;
  result.resize(size_hint);

  while (true) {
    if (pos == result.size()) {
      result.resize(2 * result.size());
    }
    const size_t max_read = result.size() - pos;
    ret = read(*fd, &result[pos], max_read);
    if (ret == 0 || (ret == -1 && errno != EINTR)) {
      break;
    }
    if (ret > 0) {
      pos += ret;
      if (static_cast<size_t>(ret) < max_read) {
        break;
      }
    }
  }

  if (ret == -1) {
    return nonstd::make_unexpected(strerror(errno));
  }

  result.resize(pos);

#ifdef _WIN32
  if constexpr (std::is_same<T, std::string>::value) {
    // Convert to UTF-8 if the content starts with a UTF-16 little-endian BOM.
    if (has_utf16_le_bom(result)) {
      result.erase(0, 2); // Remove BOM.
      if (result.empty()) {
        return result;
      }

      std::wstring result_as_u16((result.size() / 2) + 1, '\0');
      result_as_u16 = reinterpret_cast<const wchar_t*>(result.c_str());
      const int size = WideCharToMultiByte(CP_UTF8,
                                           WC_ERR_INVALID_CHARS,
                                           result_as_u16.c_str(),
                                           int(result_as_u16.size()),
                                           nullptr,
                                           0,
                                           nullptr,
                                           nullptr);
      if (size <= 0) {
        return nonstd::make_unexpected(
          FMT(""Failed to convert {} from UTF-16LE to UTF-8: {}"",
              path,
              Win32Util::error_message(GetLastError())));
      }

      result = std::string(size, '\0');
      WideCharToMultiByte(CP_UTF8,
                          0,
                          result_as_u16.c_str(),
                          int(result_as_u16.size()),
                          &result.at(0),
                          size,
                          nullptr,
                          nullptr);
    }
  }
#endif

  return result;
}

template nonstd::expected<util::Bytes, std::string>
read_file(const std::string& path, size_t size_hint);

template nonstd::expected<std::string, std::string>
read_file(const std::string& path, size_t size_hint);

template nonstd::expected<std::vector<uint8_t>, std::string>
read_file(const std::string& path, size_t size_hint);

template<typename T>
nonstd::expected<T, std::string>
read_file_part(const std::string& path, size_t pos, size_t count)
{
  Fd fd(open(path.c_str(), O_RDONLY | O_BINARY));
  if (!fd) {
    LOG(""Failed to open {}: {}"", path, strerror(errno));
    return nonstd::make_unexpected(strerror(errno));
  }

  if (pos != 0 && lseek(*fd, pos, SEEK_SET) != static_cast<off_t>(pos)) {
    return nonstd::make_unexpected(strerror(errno));
  }

  int64_t ret = 0;
  size_t bytes_read = 0;
  T result;
  result.resize(count);

  while (true) {
    const size_t max_read = count - bytes_read;
    ret = read(*fd, &result[bytes_read], max_read);
    if (ret == 0 || (ret == -1 && errno != EINTR)) {
      break;
    }
    if (ret > 0) {
      bytes_read += ret;
      if (bytes_read == count) {
        break;
      }
    }
  }

  if (ret == -1) {
    LOG(""Failed to read {}: {}"", path, strerror(errno));
    return nonstd::make_unexpected(strerror(errno));
  }

  result.resize(bytes_read);
  return result;
}

template nonstd::expected<util::Bytes, std::string>
read_file_part(const std::string& path, size_t pos, size_t count);

template nonstd::expected<std::vector<uint8_t>, std::string>
read_file_part(const std::string& path, size_t pos, size_t count);

void
set_timestamps(const std::string& path,
               std::optional<util::TimePoint> mtime,
               std::optional<util::TimePoint> atime)
{
#ifdef HAVE_UTIMENSAT
  timespec atime_mtime[2];
  if (mtime) {
    atime_mtime[0] = (atime ? *atime : *mtime).to_timespec();
    atime_mtime[1] = mtime->to_timespec();
  }
  utimensat(AT_FDCWD, path.c_str(), mtime ? atime_mtime : nullptr, 0);
#elif defined(HAVE_UTIMES)
  timeval atime_mtime[2];
  if (mtime) {
    atime_mtime[0].tv_sec = atime ? atime->sec() : mtime->sec();
    atime_mtime[0].tv_usec =
      (atime ? atime->nsec_decimal_part() : mtime->nsec_decimal_part()) / 1000;
    atime_mtime[1].tv_sec = mtime->sec();
    atime_mtime[1].tv_usec = mtime->nsec_decimal_part() / 1000;
  }
  utimes(path.c_str(), mtime ? atime_mtime : nullptr);
#else
  utimbuf atime_mtime;
  if (mtime) {
    atime_mtime.actime = atime ? atime->sec() : mtime->sec();
    atime_mtime.modtime = mtime->sec();
    utime(path.c_str(), &atime_mtime);
  } else {
    utime(path.c_str(), nullptr);
  }
#endif
}

nonstd::expected<void, std::string>
write_fd(int fd, const void* data, size_t size)
{
  int64_t written = 0;
  while (static_cast<size_t>(written) < size) {
    const auto count =
      write(fd, static_cast<const uint8_t*>(data) + written, size - written);
    if (count == -1) {
      if (errno != EAGAIN && errno != EINTR) {
        return nonstd::make_unexpected(strerror(errno));
      }
    } else {
      written += count;
    }
  }
  return {};
}

nonstd::expected<void, std::string>
write_file(const std::string& path, std::string_view data, InPlace in_place)
{
  if (in_place == InPlace::no) {
    unlink(path.c_str());
  }
  Fd fd(open(path.c_str(), O_WRONLY | O_CREAT | O_TRUNC | O_TEXT, 0666));
  if (!fd) {
    return nonstd::make_unexpected(strerror(errno));
  }
  return write_fd(*fd, data.data(), data.size());
}

nonstd::expected<void, std::string>
write_file(const std::string& path,
           nonstd::span<const uint8_t> data,
           InPlace in_place)
{
  if (in_place == InPlace::no) {
    unlink(path.c_str());
  }
  Fd fd(open(path.c_str(), O_WRONLY | O_CREAT | O_TRUNC | O_BINARY, 0666));
  if (!fd) {
    return nonstd::make_unexpected(strerror(errno));
  }
  return write_fd(*fd, data.data(), data.size());
}

} // namespace util
""",util::write_fd,[296:311]
ccache,https://github.com/ccache/ccache/commit/a251091f796a2b67d07ad5b0fa60d1fbc8b5cbff,"""fix: Fix reading of files larger than 2^31 bytes

For some kernels read(2) makes a short read for counts larger than 2^31,
even for files on 64-bit architectures. Other kernels seem to not like
large counts at all, returning a failure.

Fix this by limiting the read buffer to a smaller value. This also
removes a short read optimization which should have been removed in
cff3bf417420ea88fe53e7267ae2a356898ae326.""","""// Copyright (C) 2021-2024 Joel Rosdahl and other contributors
//
// See doc/AUTHORS.adoc for a complete list of contributors.
//
// This program is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by the Free
// Software Foundation; either version 3 of the License, or (at your option)
// any later version.
//
// This program is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
// more details.
//
// You should have received a copy of the GNU General Public License along with
// this program; if not, write to the Free Software Foundation, Inc., 51
// Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA

#include ""file.hpp""

#include <util/Bytes.hpp>
#include <util/DirEntry.hpp>
#include <util/Fd.hpp>
#include <util/Finalizer.hpp>
#include <util/PathString.hpp>
#include <util/TemporaryFile.hpp>
#include <util/error.hpp>
#include <util/expected.hpp>
#include <util/file.hpp>
#include <util/filesystem.hpp>
#include <util/fmtmacros.hpp>
#include <util/logging.hpp>

#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#endif

#ifdef HAVE_UTIMENSAT
#elif defined(HAVE_UTIMES)
#  include <sys/time.h>
#else
#  ifdef HAVE_UTIME_H
#    include <utime.h>
#  elif defined(HAVE_SYS_UTIME_H)
#    include <sys/utime.h>
#  endif
#endif

#include <fcntl.h>
#include <sys/stat.h>
#include <sys/types.h>

#ifdef HAVE_DIRENT_H
#  include <dirent.h>
#endif

#include <cerrno>
#include <cstring>
#include <fstream>
#include <locale>
#include <type_traits>
#include <vector>

namespace fs = util::filesystem;

using pstr = util::PathString;

namespace util {

tl::expected<void, std::string>
copy_file(const fs::path& src, const fs::path& dest, ViaTmpFile via_tmp_file)
{
  Fd src_fd(open(pstr(src), O_RDONLY | O_BINARY));
  if (!src_fd) {
    return tl::unexpected(
      FMT(""Failed to open {} for reading: {}"", src, strerror(errno)));
  }

  unlink(pstr(dest));

  Fd dest_fd;
  fs::path tmp_file;
  if (via_tmp_file == ViaTmpFile::yes) {
    auto temp_file = TemporaryFile::create(dest);
    if (!temp_file) {
      return tl::unexpected(temp_file.error());
    }
    dest_fd = std::move(temp_file->fd);
    tmp_file = std::move(temp_file->path);
  } else {
    dest_fd =
      Fd(open(pstr(dest), O_WRONLY | O_CREAT | O_TRUNC | O_BINARY, 0666));
    if (!dest_fd) {
      return tl::unexpected(
        FMT(""Failed to open {} for writing: {}"", dest, strerror(errno)));
    }
  }
  TRY(read_fd(*src_fd, [&](nonstd::span<const uint8_t> data) {
    write_fd(*dest_fd, data.data(), data.size());
  }));

  dest_fd.close();
  src_fd.close();

  if (via_tmp_file == ViaTmpFile::yes) {
    const auto result = fs::rename(tmp_file, dest);
    if (!result) {
      return tl::unexpected(FMT(""Failed to rename {} to {}: {}"",
                                tmp_file,
                                dest,
                                result.error().message()));
    }
  }

  return {};
}

void
create_cachedir_tag(const fs::path& dir)
{
  constexpr char cachedir_tag[] =
    ""Signature: 8a477f597d28d172789f06886806bc55\n""
    ""# This file is a cache directory tag created by ccache.\n""
    ""# For information about cache directory tags, see:\n""
    ""#\thttp://www.brynosaurus.com/cachedir/\n"";

  auto path = dir / ""CACHEDIR.TAG"";
  if (fs::exists(path)) {
    return;
  }
  const auto result = write_file(path, cachedir_tag);
  if (!result) {
    LOG(""Failed to create {}: {}"", path, result.error());
  }
}

tl::expected<void, std::string>
fallocate(int fd, size_t new_size)
{
#ifdef HAVE_POSIX_FALLOCATE
  const int posix_fallocate_err = posix_fallocate(fd, 0, new_size);
  if (posix_fallocate_err == 0) {
    return {};
  }
  if (posix_fallocate_err != EINVAL) {
    return tl::unexpected(strerror(posix_fallocate_err));
  }
  // The underlying filesystem does not support the operation so fall back to
  // lseek.
#endif
  off_t saved_pos = lseek(fd, 0, SEEK_END);
  off_t old_size = lseek(fd, 0, SEEK_END);
  if (old_size == -1) {
    int err = errno;
    lseek(fd, saved_pos, SEEK_SET);
    return tl::unexpected(strerror(err));
  }
  if (static_cast<size_t>(old_size) >= new_size) {
    lseek(fd, saved_pos, SEEK_SET);
    return {};
  }
  long bytes_to_write = new_size - old_size;

  void* buf = calloc(bytes_to_write, 1);
  if (!buf) {
    lseek(fd, saved_pos, SEEK_SET);
    return tl::unexpected(strerror(ENOMEM));
  }
  Finalizer buf_freer([&] { free(buf); });

  return write_fd(fd, buf, bytes_to_write)
    .and_then([&]() -> tl::expected<void, std::string> {
      lseek(fd, saved_pos, SEEK_SET);
      return {};
    });
}

void
set_cloexec_flag(int fd)
{
#ifndef _WIN32
  int flags = fcntl(fd, F_GETFD, 0);
  if (flags >= 0) {
    fcntl(fd, F_SETFD, flags | FD_CLOEXEC);
  }
#else
  (void)fd;
#endif
}

tl::expected<void, std::string>
read_fd(int fd, DataReceiver data_receiver)
{
  int64_t n;
  uint8_t buffer[CCACHE_READ_BUFFER_SIZE];
  while ((n = read(fd, buffer, sizeof(buffer))) != 0) {
    if (n == -1 && errno != EINTR) {
      break;
    }
    if (n > 0) {
      data_receiver({buffer, static_cast<size_t>(n)});
    }
  }
  if (n == -1) {
    return tl::unexpected(strerror(errno));
  }
  return {};
}

tl::expected<Bytes, std::string>
read_fd(int fd)
{
  Bytes output;
  return read_fd(fd,
                 [&](auto data) {
                   output.insert(output.end(), data.begin(), data.end());
                 })
    .transform([&] { return output; });
}

#ifdef _WIN32
static bool
has_utf16_le_bom(std::string_view text)
{
  return text.size() > 1
         && ((static_cast<uint8_t>(text[0]) == 0xff
              && static_cast<uint8_t>(text[1]) == 0xfe));
}
#endif

template<typename T>
tl::expected<T, std::string>
read_file(const fs::path& path, size_t size_hint)
{
  if (size_hint == 0) {
    DirEntry de(path);
    if (!de) {
      return tl::unexpected(strerror(errno));
    }
    size_hint = de.size();
  }

  // +1 to be able to detect EOF in the first read call
  size_hint = (size_hint < 1024) ? 1024 : size_hint + 1;

  const int open_flags = [] {
    if constexpr (std::is_same<T, std::string>::value) {
      return O_RDONLY | O_TEXT;
    } else {
      return O_RDONLY | O_BINARY;
    }
  }();
  Fd fd(open(pstr(path), open_flags));
  if (!fd) {
    return tl::unexpected(strerror(errno));
  }

  int64_t ret = 0;
  size_t pos = 0;
  T result;
  result.resize(size_hint);

  while (true) {
    if (pos == result.size()) {
      result.resize(2 * result.size());
    }
    const size_t max_read = result.size() - pos;
    ret = read(*fd, &result[pos], max_read);
    if (ret == 0 || (ret == -1 && errno != EINTR)) {
      break;
    }
    if (ret > 0) {
      pos += ret;
      if (static_cast<size_t>(ret) < max_read) {
        break;
      }
    }
  }

  if (ret == -1) {
    return tl::unexpected(strerror(errno));
  }

  result.resize(pos);

#ifdef _WIN32
  if constexpr (std::is_same<T, std::string>::value) {
    // Convert to UTF-8 if the content starts with a UTF-16 little-endian BOM.
    if (has_utf16_le_bom(result)) {
      result.erase(0, 2); // Remove BOM.
      if (result.empty()) {
        return result;
      }

      std::wstring result_as_u16((result.size() / 2) + 1, '\0');
      result_as_u16 = reinterpret_cast<const wchar_t*>(result.c_str());
      const int size = WideCharToMultiByte(CP_UTF8,
                                           WC_ERR_INVALID_CHARS,
                                           result_as_u16.c_str(),
                                           int(result_as_u16.size()),
                                           nullptr,
                                           0,
                                           nullptr,
                                           nullptr);
      if (size <= 0) {
        return tl::unexpected(
          FMT(""Failed to convert {} from UTF-16LE to UTF-8: {}"",
              path,
              util::win32_error_message(GetLastError())));
      }

      result = std::string(size, '\0');
      WideCharToMultiByte(CP_UTF8,
                          0,
                          result_as_u16.c_str(),
                          int(result_as_u16.size()),
                          &result.at(0),
                          size,
                          nullptr,
                          nullptr);
    }
  }
#endif

  return result;
}

template tl::expected<Bytes, std::string> read_file(const fs::path& path,
                                                    size_t size_hint);

template tl::expected<std::string, std::string> read_file(const fs::path& path,
                                                          size_t size_hint);

template tl::expected<std::vector<uint8_t>, std::string>
read_file(const fs::path& path, size_t size_hint);

template<typename T>
tl::expected<T, std::string>
read_file_part(const fs::path& path, size_t pos, size_t count)
{
  T result;
  if (count == 0) {
    return result;
  }

  Fd fd(open(pstr(path), O_RDONLY | O_BINARY));
  if (!fd) {
    LOG(""Failed to open {}: {}"", path, strerror(errno));
    return tl::unexpected(strerror(errno));
  }

  if (pos != 0 && lseek(*fd, pos, SEEK_SET) != static_cast<off_t>(pos)) {
    return tl::unexpected(strerror(errno));
  }

  int64_t ret = 0;
  size_t bytes_read = 0;
  result.resize(count);

  while (true) {
    const size_t max_read = count - bytes_read;
    ret = read(*fd, &result[bytes_read], max_read);
    if (ret == 0 || (ret == -1 && errno != EINTR)) {
      break;
    }
    if (ret > 0) {
      bytes_read += ret;
      if (bytes_read == count) {
        break;
      }
    }
  }

  if (ret == -1) {
    LOG(""Failed to read {}: {}"", path, strerror(errno));
    return tl::unexpected(strerror(errno));
  }

  result.resize(bytes_read);
  return result;
}

template tl::expected<Bytes, std::string>
read_file_part(const fs::path& path, size_t pos, size_t count);

template tl::expected<std::string, std::string>
read_file_part(const fs::path& path, size_t pos, size_t count);

template tl::expected<std::vector<uint8_t>, std::string>
read_file_part(const fs::path& path, size_t pos, size_t count);

tl::expected<bool, std::error_code>
remove(const fs::path& path, LogFailure log_failure)
{
  auto result = fs::remove(path);
  if (result || log_failure == LogFailure::yes) {
    LOG(""Removing {}"", path);
    if (!result) {
      LOG(""Removal failed: {}"", result.error().message());
    }
  }
  return result;
}

tl::expected<bool, std::error_code>
remove_nfs_safe(const fs::path& path, LogFailure log_failure)
{
  // fs::remove isn't atomic if path is on an NFS share, so we rename to a
  // temporary file. We don't care if the temporary file is trashed, so it's
  // always safe to remove it first.
  auto tmp_path =
    path.parent_path()
    / FMT(""{}.ccache{}remove"", path.filename(), TemporaryFile::tmp_file_infix);

  auto rename_result = fs::rename(path, tmp_path);
  if (!rename_result) {
    // It's OK if it was removed in a race.
    if (rename_result.error().value() != ENOENT
        && rename_result.error().value() != ESTALE
        && log_failure == LogFailure::yes) {
      LOG(""Removing {} via {}"", path, tmp_path);
      LOG(""Renaming {} to {} failed: {}"",
          path,
          tmp_path,
          rename_result.error().message());
    }
    return tl::unexpected(rename_result.error());
  }

  auto remove_result = fs::remove(tmp_path);
  if (remove_result || log_failure == LogFailure::yes) {
    LOG(""Removing {} via {}"", path, tmp_path);
    if (!remove_result) {
      LOG(""Removal failed: {}"", remove_result.error().message());
    }
  }
  return remove_result;
}

void
set_timestamps(const fs::path& path,
               std::optional<TimePoint> mtime,
               std::optional<TimePoint> atime)
{
#ifdef HAVE_UTIMENSAT
  timespec atime_mtime[2];
  if (mtime) {
    atime_mtime[0] = (atime ? *atime : *mtime).to_timespec();
    atime_mtime[1] = mtime->to_timespec();
  }
  utimensat(AT_FDCWD, pstr(path), mtime ? atime_mtime : nullptr, 0);
#elif defined(HAVE_UTIMES)
  timeval atime_mtime[2];
  if (mtime) {
    atime_mtime[0].tv_sec = atime ? atime->sec() : mtime->sec();
    atime_mtime[0].tv_usec =
      (atime ? atime->nsec_decimal_part() : mtime->nsec_decimal_part()) / 1000;
    atime_mtime[1].tv_sec = mtime->sec();
    atime_mtime[1].tv_usec = mtime->nsec_decimal_part() / 1000;
  }
  utimes(pstr(path), mtime ? atime_mtime : nullptr);
#else
  utimbuf atime_mtime;
  if (mtime) {
    atime_mtime.actime = atime ? atime->sec() : mtime->sec();
    atime_mtime.modtime = mtime->sec();
    utime(pstr(path), &atime_mtime);
  } else {
    utime(pstr(path), nullptr);
  }
#endif
}

#ifdef HAVE_DIRENT_H

tl::expected<void, std::string>
traverse_directory(const fs::path& directory,
                   const TraverseDirectoryVisitor& visitor)
{
  DIR* dir = opendir(pstr(directory));
  if (!dir) {
    return tl::unexpected(
      FMT(""Failed to traverse {}: {}"", directory, strerror(errno)));
  }

  Finalizer dir_closer([&] { closedir(dir); });

  struct dirent* entry;
  while ((entry = readdir(dir))) {
    if (strcmp(entry->d_name, """") == 0 || strcmp(entry->d_name, ""."") == 0
        || strcmp(entry->d_name, "".."") == 0) {
      continue;
    }

    auto path = directory / entry->d_name;
    bool is_dir;
#  ifdef _DIRENT_HAVE_D_TYPE
    if (entry->d_type != DT_UNKNOWN) {
      is_dir = entry->d_type == DT_DIR;
    } else
#  endif
    {
      DirEntry dir_entry(path);
      if (!dir_entry) {
        if (dir_entry.error_number() == ENOENT
            || dir_entry.error_number() == ESTALE) {
          continue;
        }
        return tl::unexpected(FMT(
          ""Failed to lstat {}: {}"", path, strerror(dir_entry.error_number())));
      }
      is_dir = dir_entry.is_directory();
    }
    if (is_dir) {
      traverse_directory(path, visitor);
    } else {
      visitor(path);
    }
  }
  visitor(directory);

  return {};
}

#else // If not available, use the C++17 std::filesystem implementation.

tl::expected<void, std::string>
traverse_directory(const fs::path& directory,
                   const TraverseDirectoryVisitor& visitor)
{
  // Note: Intentionally not using std::filesystem::recursive_directory_iterator
  // since it visits directories in preorder.

  DirEntry dir_entry(directory);
  if (!dir_entry.is_directory()) {
    return tl::unexpected(
      FMT(""Failed to traverse {}: {}"",
          directory,
          dir_entry ? ""Not a directory"" : ""No such file or directory""));
  }

  try {
    for (const auto& entry : std::filesystem::directory_iterator(directory)) {
      if (entry.is_directory()) {
        traverse_directory(entry.path(), visitor);
      } else {
        visitor(entry.path());
      }
    }
    visitor(directory);
  } catch (const std::filesystem::filesystem_error& e) {
    return tl::unexpected(e.what());
  }

  return {};
}

#endif

tl::expected<void, std::string>
write_fd(int fd, const void* data, size_t size)
{
  int64_t written = 0;
  while (static_cast<size_t>(written) < size) {
    const auto count =
      write(fd, static_cast<const uint8_t*>(data) + written, size - written);
    if (count == -1) {
      if (errno != EAGAIN && errno != EINTR) {
        return tl::unexpected(strerror(errno));
      }
    } else {
      written += count;
    }
  }
  return {};
}

tl::expected<void, std::string>
write_file(const fs::path& path, std::string_view data, InPlace in_place)
{
  auto path_str = pstr(path);
  if (in_place == InPlace::no) {
    unlink(path_str);
  }
  Fd fd(open(path_str, O_WRONLY | O_CREAT | O_TRUNC | O_TEXT, 0666));
  if (!fd) {
    return tl::unexpected(strerror(errno));
  }
  return write_fd(*fd, data.data(), data.size());
}

tl::expected<void, std::string>
write_file(const fs::path& path,
           nonstd::span<const uint8_t> data,
           InPlace in_place)
{
  auto path_str = pstr(path);
  if (in_place == InPlace::no) {
    unlink(path_str);
  }
  Fd fd(open(path_str, O_WRONLY | O_CREAT | O_TRUNC | O_BINARY, 0666));
  if (!fd) {
    return tl::unexpected(strerror(errno));
  }
  return write_fd(*fd, data.data(), data.size());
}

} // namespace util
""","""// Copyright (C) 2021-2024 Joel Rosdahl and other contributors
//
// See doc/AUTHORS.adoc for a complete list of contributors.
//
// This program is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by the Free
// Software Foundation; either version 3 of the License, or (at your option)
// any later version.
//
// This program is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
// more details.
//
// You should have received a copy of the GNU General Public License along with
// this program; if not, write to the Free Software Foundation, Inc., 51
// Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA

#include ""file.hpp""

#include <util/Bytes.hpp>
#include <util/DirEntry.hpp>
#include <util/Fd.hpp>
#include <util/Finalizer.hpp>
#include <util/PathString.hpp>
#include <util/TemporaryFile.hpp>
#include <util/error.hpp>
#include <util/expected.hpp>
#include <util/file.hpp>
#include <util/filesystem.hpp>
#include <util/fmtmacros.hpp>
#include <util/logging.hpp>

#ifdef HAVE_UNISTD_H
#  include <unistd.h>
#endif

#ifdef HAVE_UTIMENSAT
#elif defined(HAVE_UTIMES)
#  include <sys/time.h>
#else
#  ifdef HAVE_UTIME_H
#    include <utime.h>
#  elif defined(HAVE_SYS_UTIME_H)
#    include <sys/utime.h>
#  endif
#endif

#include <fcntl.h>
#include <sys/stat.h>
#include <sys/types.h>

#ifdef HAVE_DIRENT_H
#  include <dirent.h>
#endif

#include <cerrno>
#include <cstring>
#include <fstream>
#include <locale>
#include <type_traits>
#include <vector>

namespace fs = util::filesystem;

using pstr = util::PathString;

namespace util {

tl::expected<void, std::string>
copy_file(const fs::path& src, const fs::path& dest, ViaTmpFile via_tmp_file)
{
  Fd src_fd(open(pstr(src), O_RDONLY | O_BINARY));
  if (!src_fd) {
    return tl::unexpected(
      FMT(""Failed to open {} for reading: {}"", src, strerror(errno)));
  }

  unlink(pstr(dest));

  Fd dest_fd;
  fs::path tmp_file;
  if (via_tmp_file == ViaTmpFile::yes) {
    auto temp_file = TemporaryFile::create(dest);
    if (!temp_file) {
      return tl::unexpected(temp_file.error());
    }
    dest_fd = std::move(temp_file->fd);
    tmp_file = std::move(temp_file->path);
  } else {
    dest_fd =
      Fd(open(pstr(dest), O_WRONLY | O_CREAT | O_TRUNC | O_BINARY, 0666));
    if (!dest_fd) {
      return tl::unexpected(
        FMT(""Failed to open {} for writing: {}"", dest, strerror(errno)));
    }
  }
  TRY(read_fd(*src_fd, [&](nonstd::span<const uint8_t> data) {
    write_fd(*dest_fd, data.data(), data.size());
  }));

  dest_fd.close();
  src_fd.close();

  if (via_tmp_file == ViaTmpFile::yes) {
    const auto result = fs::rename(tmp_file, dest);
    if (!result) {
      return tl::unexpected(FMT(""Failed to rename {} to {}: {}"",
                                tmp_file,
                                dest,
                                result.error().message()));
    }
  }

  return {};
}

void
create_cachedir_tag(const fs::path& dir)
{
  constexpr char cachedir_tag[] =
    ""Signature: 8a477f597d28d172789f06886806bc55\n""
    ""# This file is a cache directory tag created by ccache.\n""
    ""# For information about cache directory tags, see:\n""
    ""#\thttp://www.brynosaurus.com/cachedir/\n"";

  auto path = dir / ""CACHEDIR.TAG"";
  if (fs::exists(path)) {
    return;
  }
  const auto result = write_file(path, cachedir_tag);
  if (!result) {
    LOG(""Failed to create {}: {}"", path, result.error());
  }
}

tl::expected<void, std::string>
fallocate(int fd, size_t new_size)
{
#ifdef HAVE_POSIX_FALLOCATE
  const int posix_fallocate_err = posix_fallocate(fd, 0, new_size);
  if (posix_fallocate_err == 0) {
    return {};
  }
  if (posix_fallocate_err != EINVAL) {
    return tl::unexpected(strerror(posix_fallocate_err));
  }
  // The underlying filesystem does not support the operation so fall back to
  // lseek.
#endif
  off_t saved_pos = lseek(fd, 0, SEEK_END);
  off_t old_size = lseek(fd, 0, SEEK_END);
  if (old_size == -1) {
    int err = errno;
    lseek(fd, saved_pos, SEEK_SET);
    return tl::unexpected(strerror(err));
  }
  if (static_cast<size_t>(old_size) >= new_size) {
    lseek(fd, saved_pos, SEEK_SET);
    return {};
  }
  long bytes_to_write = new_size - old_size;

  void* buf = calloc(bytes_to_write, 1);
  if (!buf) {
    lseek(fd, saved_pos, SEEK_SET);
    return tl::unexpected(strerror(ENOMEM));
  }
  Finalizer buf_freer([&] { free(buf); });

  return write_fd(fd, buf, bytes_to_write)
    .and_then([&]() -> tl::expected<void, std::string> {
      lseek(fd, saved_pos, SEEK_SET);
      return {};
    });
}

void
set_cloexec_flag(int fd)
{
#ifndef _WIN32
  int flags = fcntl(fd, F_GETFD, 0);
  if (flags >= 0) {
    fcntl(fd, F_SETFD, flags | FD_CLOEXEC);
  }
#else
  (void)fd;
#endif
}

tl::expected<void, std::string>
read_fd(int fd, DataReceiver data_receiver)
{
  int64_t n;
  uint8_t buffer[CCACHE_READ_BUFFER_SIZE];
  while ((n = read(fd, buffer, sizeof(buffer))) != 0) {
    if (n == -1 && errno != EINTR) {
      break;
    }
    if (n > 0) {
      data_receiver({buffer, static_cast<size_t>(n)});
    }
  }
  if (n == -1) {
    return tl::unexpected(strerror(errno));
  }
  return {};
}

tl::expected<Bytes, std::string>
read_fd(int fd)
{
  Bytes output;
  return read_fd(fd,
                 [&](auto data) {
                   output.insert(output.end(), data.begin(), data.end());
                 })
    .transform([&] { return output; });
}

#ifdef _WIN32
static bool
has_utf16_le_bom(std::string_view text)
{
  return text.size() > 1
         && ((static_cast<uint8_t>(text[0]) == 0xff
              && static_cast<uint8_t>(text[1]) == 0xfe));
}
#endif

template<typename T>
tl::expected<T, std::string>
read_file(const fs::path& path, size_t size_hint)
{
  if (size_hint == 0) {
    DirEntry de(path);
    if (!de) {
      return tl::unexpected(strerror(errno));
    }
    size_hint = de.size();
  }

  const int open_flags = [] {
    if constexpr (std::is_same<T, std::string>::value) {
      return O_RDONLY | O_TEXT;
    } else {
      return O_RDONLY | O_BINARY;
    }
  }();
  Fd fd(open(pstr(path), open_flags));
  if (!fd) {
    return tl::unexpected(strerror(errno));
  }

  int64_t ret = 0;
  size_t pos = 0;
  T result;
  result.resize(std::max(size_t{1024}, size_hint + 1));

  while (true) {
    if (pos == result.size()) {
      result.resize(2 * result.size());
    }
    const size_t max_read = std::min(size_t{1024 * 1024}, result.size() - pos);
    ret = read(*fd, &result[pos], max_read);
    if (ret == 0 || (ret == -1 && errno != EINTR)) {
      break;
    }
    if (ret > 0) {
      pos += ret;
    }
  }

  if (ret == -1) {
    return tl::unexpected(strerror(errno));
  }

  result.resize(pos);

#ifdef _WIN32
  if constexpr (std::is_same<T, std::string>::value) {
    // Convert to UTF-8 if the content starts with a UTF-16 little-endian BOM.
    if (has_utf16_le_bom(result)) {
      result.erase(0, 2); // Remove BOM.
      if (result.empty()) {
        return result;
      }

      std::wstring result_as_u16((result.size() / 2) + 1, '\0');
      result_as_u16 = reinterpret_cast<const wchar_t*>(result.c_str());
      const int size = WideCharToMultiByte(CP_UTF8,
                                           WC_ERR_INVALID_CHARS,
                                           result_as_u16.c_str(),
                                           int(result_as_u16.size()),
                                           nullptr,
                                           0,
                                           nullptr,
                                           nullptr);
      if (size <= 0) {
        return tl::unexpected(
          FMT(""Failed to convert {} from UTF-16LE to UTF-8: {}"",
              path,
              util::win32_error_message(GetLastError())));
      }

      result = std::string(size, '\0');
      WideCharToMultiByte(CP_UTF8,
                          0,
                          result_as_u16.c_str(),
                          int(result_as_u16.size()),
                          &result.at(0),
                          size,
                          nullptr,
                          nullptr);
    }
  }
#endif

  return result;
}

template tl::expected<Bytes, std::string> read_file(const fs::path& path,
                                                    size_t size_hint);

template tl::expected<std::string, std::string> read_file(const fs::path& path,
                                                          size_t size_hint);

template tl::expected<std::vector<uint8_t>, std::string>
read_file(const fs::path& path, size_t size_hint);

template<typename T>
tl::expected<T, std::string>
read_file_part(const fs::path& path, size_t pos, size_t count)
{
  T result;
  if (count == 0) {
    return result;
  }

  Fd fd(open(pstr(path), O_RDONLY | O_BINARY));
  if (!fd) {
    LOG(""Failed to open {}: {}"", path, strerror(errno));
    return tl::unexpected(strerror(errno));
  }

  if (pos != 0 && lseek(*fd, pos, SEEK_SET) != static_cast<off_t>(pos)) {
    return tl::unexpected(strerror(errno));
  }

  int64_t ret = 0;
  size_t bytes_read = 0;
  result.resize(count);

  while (true) {
    const size_t max_read = count - bytes_read;
    ret = read(*fd, &result[bytes_read], max_read);
    if (ret == 0 || (ret == -1 && errno != EINTR)) {
      break;
    }
    if (ret > 0) {
      bytes_read += ret;
      if (bytes_read == count) {
        break;
      }
    }
  }

  if (ret == -1) {
    LOG(""Failed to read {}: {}"", path, strerror(errno));
    return tl::unexpected(strerror(errno));
  }

  result.resize(bytes_read);
  return result;
}

template tl::expected<Bytes, std::string>
read_file_part(const fs::path& path, size_t pos, size_t count);

template tl::expected<std::string, std::string>
read_file_part(const fs::path& path, size_t pos, size_t count);

template tl::expected<std::vector<uint8_t>, std::string>
read_file_part(const fs::path& path, size_t pos, size_t count);

tl::expected<bool, std::error_code>
remove(const fs::path& path, LogFailure log_failure)
{
  auto result = fs::remove(path);
  if (result || log_failure == LogFailure::yes) {
    LOG(""Removing {}"", path);
    if (!result) {
      LOG(""Removal failed: {}"", result.error().message());
    }
  }
  return result;
}

tl::expected<bool, std::error_code>
remove_nfs_safe(const fs::path& path, LogFailure log_failure)
{
  // fs::remove isn't atomic if path is on an NFS share, so we rename to a
  // temporary file. We don't care if the temporary file is trashed, so it's
  // always safe to remove it first.
  auto tmp_path =
    path.parent_path()
    / FMT(""{}.ccache{}remove"", path.filename(), TemporaryFile::tmp_file_infix);

  auto rename_result = fs::rename(path, tmp_path);
  if (!rename_result) {
    // It's OK if it was removed in a race.
    if (rename_result.error().value() != ENOENT
        && rename_result.error().value() != ESTALE
        && log_failure == LogFailure::yes) {
      LOG(""Removing {} via {}"", path, tmp_path);
      LOG(""Renaming {} to {} failed: {}"",
          path,
          tmp_path,
          rename_result.error().message());
    }
    return tl::unexpected(rename_result.error());
  }

  auto remove_result = fs::remove(tmp_path);
  if (remove_result || log_failure == LogFailure::yes) {
    LOG(""Removing {} via {}"", path, tmp_path);
    if (!remove_result) {
      LOG(""Removal failed: {}"", remove_result.error().message());
    }
  }
  return remove_result;
}

void
set_timestamps(const fs::path& path,
               std::optional<TimePoint> mtime,
               std::optional<TimePoint> atime)
{
#ifdef HAVE_UTIMENSAT
  timespec atime_mtime[2];
  if (mtime) {
    atime_mtime[0] = (atime ? *atime : *mtime).to_timespec();
    atime_mtime[1] = mtime->to_timespec();
  }
  utimensat(AT_FDCWD, pstr(path), mtime ? atime_mtime : nullptr, 0);
#elif defined(HAVE_UTIMES)
  timeval atime_mtime[2];
  if (mtime) {
    atime_mtime[0].tv_sec = atime ? atime->sec() : mtime->sec();
    atime_mtime[0].tv_usec =
      (atime ? atime->nsec_decimal_part() : mtime->nsec_decimal_part()) / 1000;
    atime_mtime[1].tv_sec = mtime->sec();
    atime_mtime[1].tv_usec = mtime->nsec_decimal_part() / 1000;
  }
  utimes(pstr(path), mtime ? atime_mtime : nullptr);
#else
  utimbuf atime_mtime;
  if (mtime) {
    atime_mtime.actime = atime ? atime->sec() : mtime->sec();
    atime_mtime.modtime = mtime->sec();
    utime(pstr(path), &atime_mtime);
  } else {
    utime(pstr(path), nullptr);
  }
#endif
}

#ifdef HAVE_DIRENT_H

tl::expected<void, std::string>
traverse_directory(const fs::path& directory,
                   const TraverseDirectoryVisitor& visitor)
{
  DIR* dir = opendir(pstr(directory));
  if (!dir) {
    return tl::unexpected(
      FMT(""Failed to traverse {}: {}"", directory, strerror(errno)));
  }

  Finalizer dir_closer([&] { closedir(dir); });

  struct dirent* entry;
  while ((entry = readdir(dir))) {
    if (strcmp(entry->d_name, """") == 0 || strcmp(entry->d_name, ""."") == 0
        || strcmp(entry->d_name, "".."") == 0) {
      continue;
    }

    auto path = directory / entry->d_name;
    bool is_dir;
#  ifdef _DIRENT_HAVE_D_TYPE
    if (entry->d_type != DT_UNKNOWN) {
      is_dir = entry->d_type == DT_DIR;
    } else
#  endif
    {
      DirEntry dir_entry(path);
      if (!dir_entry) {
        if (dir_entry.error_number() == ENOENT
            || dir_entry.error_number() == ESTALE) {
          continue;
        }
        return tl::unexpected(FMT(
          ""Failed to lstat {}: {}"", path, strerror(dir_entry.error_number())));
      }
      is_dir = dir_entry.is_directory();
    }
    if (is_dir) {
      traverse_directory(path, visitor);
    } else {
      visitor(path);
    }
  }
  visitor(directory);

  return {};
}

#else // If not available, use the C++17 std::filesystem implementation.

tl::expected<void, std::string>
traverse_directory(const fs::path& directory,
                   const TraverseDirectoryVisitor& visitor)
{
  // Note: Intentionally not using std::filesystem::recursive_directory_iterator
  // since it visits directories in preorder.

  DirEntry dir_entry(directory);
  if (!dir_entry.is_directory()) {
    return tl::unexpected(
      FMT(""Failed to traverse {}: {}"",
          directory,
          dir_entry ? ""Not a directory"" : ""No such file or directory""));
  }

  try {
    for (const auto& entry : std::filesystem::directory_iterator(directory)) {
      if (entry.is_directory()) {
        traverse_directory(entry.path(), visitor);
      } else {
        visitor(entry.path());
      }
    }
    visitor(directory);
  } catch (const std::filesystem::filesystem_error& e) {
    return tl::unexpected(e.what());
  }

  return {};
}

#endif

tl::expected<void, std::string>
write_fd(int fd, const void* data, size_t size)
{
  int64_t written = 0;
  while (static_cast<size_t>(written) < size) {
    const auto count =
      write(fd, static_cast<const uint8_t*>(data) + written, size - written);
    if (count == -1) {
      if (errno != EAGAIN && errno != EINTR) {
        return tl::unexpected(strerror(errno));
      }
    } else {
      written += count;
    }
  }
  return {};
}

tl::expected<void, std::string>
write_file(const fs::path& path, std::string_view data, InPlace in_place)
{
  auto path_str = pstr(path);
  if (in_place == InPlace::no) {
    unlink(path_str);
  }
  Fd fd(open(path_str, O_WRONLY | O_CREAT | O_TRUNC | O_TEXT, 0666));
  if (!fd) {
    return tl::unexpected(strerror(errno));
  }
  return write_fd(*fd, data.data(), data.size());
}

tl::expected<void, std::string>
write_file(const fs::path& path,
           nonstd::span<const uint8_t> data,
           InPlace in_place)
{
  auto path_str = pstr(path);
  if (in_place == InPlace::no) {
    unlink(path_str);
  }
  Fd fd(open(path_str, O_WRONLY | O_CREAT | O_TRUNC | O_BINARY, 0666));
  if (!fd) {
    return tl::unexpected(strerror(errno));
  }
  return write_fd(*fd, data.data(), data.size());
}

} // namespace util
""",util::read_file,[233:320]
