Project Name,Commit URL,Message,src_before,src,changed_method_name,loc
znc,https://github.com/znc/znc/commit/ec3895e9548cf14d72c85e7cd8a95ef723e2d1fd,"""speed things up a bit


git-svn-id: https://znc.svn.sourceforge.net/svnroot/znc/trunk@304 726aef4b-f618-498e-8847-2d620e286838""","""#include ""main.h""
#include ""User.h""
#include ""Nick.h""
#include ""Modules.h""
#include ""Chan.h""
#include ""Utils.h""
#include ""FileUtils.h""
#include <pwd.h>
#include <map>
#include <vector>


class CStickyChan : public CModule 
{
public:
	MODCONSTRUCTOR(CStickyChan) {}
	virtual ~CStickyChan() 
	{
	}

	virtual bool OnLoad(const CString& sArgs);

	virtual CString GetDescription() 
	{
		return ( ""configless sticky chans, keeps you there very stickily even"" );
	}
	
	virtual void OnModCommand( const CString& sCommand )
	{
		CString sCmdName = sCommand.Token(0);
		CString sChannel = sCommand.Token(1);
		sChannel.MakeLower();
		if ( ( sCmdName == ""stick"" ) && ( !sChannel.empty() ) )
		{
			SetNV( sChannel, sCommand.Token(2) );
			PutModule( ""Stuck "" + sChannel );
		}
		else if ( ( sCmdName == ""unstick"" ) && ( !sChannel.empty() ) )
		{
			MCString::iterator it = FindNV( sChannel );
			if ( it != EndNV() )
				DelNV( it );

			PutModule( ""UnStuck "" + sChannel );
		}	
		else
		{
			PutModule( ""USAGE: [un]stick #channel [key]"" );
		}
	}

	virtual void RunJob()
	{
		for( MCString::iterator it = BeginNV(); it != EndNV(); it++ )
		{
			if ( !m_pUser->FindChan( it->first ) )
			{
				CChan *pChan = new CChan( it->first, m_pUser );
				if ( !it->second.empty() )
					pChan->SetKey( it->second );
				m_pUser->AddChan( pChan );
				PutModule( ""Joining ["" + it->first + ""]"" );
			}
		}
	}
private:

};


static void RunTimer( CModule * pModule, CFPTimer *pTimer )
{
	((CStickyChan *)pModule)->RunJob();
}

bool CStickyChan::OnLoad(const CString& sArgs)
{
	AddTimer( RunTimer, ""StickyChanTimer"", 15 );
	return( true );
}

MODULEDEFS(CStickyChan)
""","""#include ""main.h""
#include ""User.h""
#include ""Nick.h""
#include ""Modules.h""
#include ""Chan.h""
#include ""Utils.h""
#include ""FileUtils.h""
#include <pwd.h>
#include <map>
#include <vector>


class CStickyChan : public CModule 
{
public:
	MODCONSTRUCTOR(CStickyChan) {}
	virtual ~CStickyChan() 
	{
	}

	virtual bool OnLoad(const CString& sArgs);

	virtual CString GetDescription() 
	{
		return ( ""configless sticky chans, keeps you there very stickily even"" );
	}
	
	virtual void OnModCommand( const CString& sCommand )
	{
		CString sCmdName = sCommand.Token(0);
		CString sChannel = sCommand.Token(1);
		sChannel.MakeLower();
		if ( ( sCmdName == ""stick"" ) && ( !sChannel.empty() ) )
		{
			SetNV( sChannel, sCommand.Token(2) );
			PutModule( ""Stuck "" + sChannel );
		}
		else if ( ( sCmdName == ""unstick"" ) && ( !sChannel.empty() ) )
		{
			MCString::iterator it = FindNV( sChannel );
			if ( it != EndNV() )
				DelNV( it );

			PutModule( ""UnStuck "" + sChannel );
		}	
		else
		{
			PutModule( ""USAGE: [un]stick #channel [key]"" );
		}
	}

	virtual void RunJob()
	{
		for( MCString::iterator it = BeginNV(); it != EndNV(); it++ )
		{
			if ( !m_pUser->FindChan( it->first ) )
			{
				CChan *pChan = new CChan( it->first, m_pUser );
				if ( !it->second.empty() )
					pChan->SetKey( it->second );
				m_pUser->AddChan( pChan );
				PutModule( ""Joining ["" + it->first + ""]"" );
				PutIRC( ""JOIN "" + it->first + ( it->second.empty() ? """" : it->second ) );
			}
		}
	}
private:

};


static void RunTimer( CModule * pModule, CFPTimer *pTimer )
{
	((CStickyChan *)pModule)->RunJob();
}

bool CStickyChan::OnLoad(const CString& sArgs)
{
	AddTimer( RunTimer, ""StickyChanTimer"", 15 );
	return( true );
}

MODULEDEFS(CStickyChan)
""",CStickyChan::RunJob,[52:66]
znc,https://github.com/znc/znc/commit/fa3b955468f737a2186f9f08d0692ffcf3ece45e,"""Added psycho's perform module


git-svn-id: https://znc.svn.sourceforge.net/svnroot/znc/trunk@771 726aef4b-f618-498e-8847-2d620e286838""","""NA""","""#include ""main.h""
#include ""User.h""
#include ""Nick.h""
#include ""Modules.h""
#include ""Chan.h""
#include ""Utils.h""
#include <pwd.h>
#include <map>
#include <vector>

class CPerform : public CModule
{
public:
	MODCONSTRUCTOR(CPerform)
	{
	}
	
	virtual ~CPerform()
	{
	}

	virtual bool OnLoad(const CString& sArgs)
	{
		GetNV(""Perform"").Split(""\n"", m_vPerform, false);
		
		return true;
	}

	virtual void OnModCommand( const CString& sCommand )
	{
		CString sCmdName = sCommand.Token(0).AsLower();
		if(sCmdName == ""add"")
		{
			CString sPerf = sCommand.Token(1, true);
			if(sPerf.Left(1) == ""/"")
				sPerf.LeftChomp();

			if(sPerf.Token(0).AsUpper() == ""MSG"") {
				sPerf = ""PRIVMSG "" + sPerf.Token(1, true);
			}

			if(sPerf.Token(0).AsUpper() == ""PRIVMSG"" ||
				sPerf.Token(0).AsUpper() == ""NOTICE"") {
				sPerf = sPerf.Token(0) + "" "" + sPerf.Token(1)
					+ "" :"" + sPerf.Token(2, true);
			}
			m_vPerform.push_back(sPerf);
			PutModule(""Added!"");
			Save();
		} else if(sCmdName == ""del"")
		{
			u_int iNum = atoi( sCommand.Token(1, true).c_str() );
			if ( iNum >= m_vPerform.size() )
			{
				PutModule( ""Illegal # Requested"");
				return;
			}
			else
			{
				m_vPerform.erase( m_vPerform.begin() + iNum );
				PutModule( ""Command Erased."");
			}
			Save();
		} else if(sCmdName == ""list"")
		{
			int i = 1;
			for(VCString::iterator it = m_vPerform.begin(); it != m_vPerform.end(); it++, i++)
			{
				PutModule(CString( i ) + "": "" + *it);
			}
			PutModule("" -- End of List"");
		} else if(sCmdName == ""save"")
		{
			if(Save())
				PutModule(""Saved!"");
			else
				PutModule(""Error"");
		}else
		{
			PutModule( ""Commands: add <command>, del <nr>, list, save"");
		}
	}

	virtual void OnIRCConnected()
	{
		for( VCString::iterator it = m_vPerform.begin();
			it != m_vPerform.end();  it++)
		{
			PutIRC(*it);
		}
	}

private:
	bool Save()
	{
		CString sBuffer = """";
		
		for(VCString::iterator it = m_vPerform.begin(); it != m_vPerform.end(); it++)
		{
			sBuffer += *it + ""\n"";
		}
		SetNV(""Perform"", sBuffer);
		
		return true;
	}

	VCString	m_vPerform;
};

MODULEDEFS(CPerform, ""Adds perform capabilities"")
""",,
znc,https://github.com/znc/znc/commit/a60270de810e6f37eecc216b531d7f0398d4eaa0,"""Remove save command for perform, add and del already save everything


git-svn-id: https://znc.svn.sourceforge.net/svnroot/znc/trunk@868 726aef4b-f618-498e-8847-2d620e286838""","""/*
 * Copyright (C) 2004-2007  See the AUTHORS file for details.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 as published
 * by the Free Software Foundation.
 */

#include ""main.h""
#include ""User.h""
#include ""Nick.h""
#include ""Modules.h""
#include ""Chan.h""
#include ""Utils.h""
#include <pwd.h>
#include <map>
#include <vector>

class CPerform : public CModule
{
public:
	MODCONSTRUCTOR(CPerform)
	{
	}
	
	virtual ~CPerform()
	{
	}

	virtual bool OnLoad(const CString& sArgs, CString& sMessage)
	{
		GetNV(""Perform"").Split(""\n"", m_vPerform, false);
		
		return true;
	}

	virtual void OnModCommand( const CString& sCommand )
	{
		CString sCmdName = sCommand.Token(0).AsLower();
		if(sCmdName == ""add"")
		{
			CString sPerf = sCommand.Token(1, true);
			if(sPerf.Left(1) == ""/"")
				sPerf.LeftChomp();

			if(sPerf.Token(0).CaseCmp(""MSG"") == 0) {
				sPerf = ""PRIVMSG "" + sPerf.Token(1, true);
			}

			if((sPerf.Token(0).CaseCmp(""PRIVMSG"") == 0 ||
				sPerf.Token(0).CaseCmp(""NOTICE"") == 0) &&
				sPerf.Token(2).Left(1) != "":"") {
				sPerf = sPerf.Token(0) + "" "" + sPerf.Token(1)
					+ "" :"" + sPerf.Token(2, true);
			}
			m_vPerform.push_back(sPerf);
			PutModule(""Added!"");
			Save();
		} else if(sCmdName == ""del"")
		{
			u_int iNum = atoi( sCommand.Token(1, true).c_str() );
			if ( iNum > m_vPerform.size() || iNum <= 0 )
			{
				PutModule( ""Illegal # Requested"");
				return;
			}
			else
			{
				m_vPerform.erase( m_vPerform.begin() + iNum - 1 );
				PutModule( ""Command Erased."");
			}
			Save();
		} else if(sCmdName == ""list"")
		{
			int i = 1;
			CString sExpanded;
			for(VCString::iterator it = m_vPerform.begin(); it != m_vPerform.end(); it++, i++)
			{
				sExpanded = GetUser()->ExpandString( *it );
				if(sExpanded != *it)
					PutModule(CString( i ) + "": "" + *it + "" ("" + sExpanded + "")"");
				else
					PutModule(CString( i ) + "": "" + *it);
			}
			PutModule("" -- End of List"");
		} else if(sCmdName == ""save"")
		{
			if(Save())
				PutModule(""Saved!"");
			else
				PutModule(""Error"");
		}else
		{
			PutModule( ""Commands: add <command>, del <nr>, list, save"");
		}
	}

	virtual void OnIRCConnected()
	{
		for( VCString::iterator it = m_vPerform.begin();
			it != m_vPerform.end();  it++)
		{
			PutIRC( GetUser()->ExpandString( *it ) );
		}
	}

private:
	bool Save()
	{
		CString sBuffer = """";
		
		for(VCString::iterator it = m_vPerform.begin(); it != m_vPerform.end(); it++)
		{
			sBuffer += *it + ""\n"";
		}
		SetNV(""Perform"", sBuffer);
		
		return true;
	}

	VCString	m_vPerform;
};

MODULEDEFS(CPerform, ""Adds perform capabilities"")
""","""/*
 * Copyright (C) 2004-2007  See the AUTHORS file for details.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 as published
 * by the Free Software Foundation.
 */

#include ""main.h""
#include ""User.h""
#include ""Nick.h""
#include ""Modules.h""
#include ""Chan.h""
#include ""Utils.h""
#include <pwd.h>
#include <map>
#include <vector>

class CPerform : public CModule
{
public:
	MODCONSTRUCTOR(CPerform)
	{
	}
	
	virtual ~CPerform()
	{
	}

	virtual bool OnLoad(const CString& sArgs, CString& sMessage)
	{
		GetNV(""Perform"").Split(""\n"", m_vPerform, false);
		
		return true;
	}

	virtual void OnModCommand( const CString& sCommand )
	{
		CString sCmdName = sCommand.Token(0).AsLower();
		if(sCmdName == ""add"")
		{
			CString sPerf = sCommand.Token(1, true);
			if(sPerf.Left(1) == ""/"")
				sPerf.LeftChomp();

			if(sPerf.Token(0).CaseCmp(""MSG"") == 0) {
				sPerf = ""PRIVMSG "" + sPerf.Token(1, true);
			}

			if((sPerf.Token(0).CaseCmp(""PRIVMSG"") == 0 ||
				sPerf.Token(0).CaseCmp(""NOTICE"") == 0) &&
				sPerf.Token(2).Left(1) != "":"") {
				sPerf = sPerf.Token(0) + "" "" + sPerf.Token(1)
					+ "" :"" + sPerf.Token(2, true);
			}
			m_vPerform.push_back(sPerf);
			PutModule(""Added!"");
			Save();
		} else if(sCmdName == ""del"")
		{
			u_int iNum = atoi( sCommand.Token(1, true).c_str() );
			if ( iNum > m_vPerform.size() || iNum <= 0 )
			{
				PutModule( ""Illegal # Requested"");
				return;
			}
			else
			{
				m_vPerform.erase( m_vPerform.begin() + iNum - 1 );
				PutModule( ""Command Erased."");
			}
			Save();
		} else if(sCmdName == ""list"")
		{
			int i = 1;
			CString sExpanded;
			for(VCString::iterator it = m_vPerform.begin(); it != m_vPerform.end(); it++, i++)
			{
				sExpanded = GetUser()->ExpandString( *it );
				if(sExpanded != *it)
					PutModule(CString( i ) + "": "" + *it + "" ("" + sExpanded + "")"");
				else
					PutModule(CString( i ) + "": "" + *it);
			}
			PutModule("" -- End of List"");
		}else
		{
			PutModule( ""Commands: add <command>, del <nr>, list"");
		}
	}

	virtual void OnIRCConnected()
	{
		for( VCString::iterator it = m_vPerform.begin();
			it != m_vPerform.end();  it++)
		{
			PutIRC( GetUser()->ExpandString( *it ) );
		}
	}

private:
	bool Save()
	{
		CString sBuffer = """";
		
		for(VCString::iterator it = m_vPerform.begin(); it != m_vPerform.end(); it++)
		{
			sBuffer += *it + ""\n"";
		}
		SetNV(""Perform"", sBuffer);
		
		return true;
	}

	VCString	m_vPerform;
};

MODULEDEFS(CPerform, ""Adds perform capabilities"")
""",CPerform::OnModCommand,[37:90]
znc,https://github.com/znc/znc/commit/4e6c6fea4a4acf53e3d09797e5addb3e3478c55a,"""Cleanup CUtils::GetLongIP()

The new version should be faster (no malloc with pseudo-memset) and it
certainly is a lot more readable.


git-svn-id: https://znc.svn.sourceforge.net/svnroot/znc/trunk@1051 726aef4b-f618-498e-8847-2d620e286838""","""/*
 * Copyright (C) 2004-2008  See the AUTHORS file for details.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 as published
 * by the Free Software Foundation.
 */

#include ""Utils.h""
#include ""MD5.h""
#include <errno.h>
#ifdef HAVE_LIBSSL
#include <openssl/ssl.h>
#endif /* HAVE_LIBSSL */
#include <sstream>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>

using std::stringstream;

bool CUtils::stdoutIsTTY;

CUtils::CUtils() {}
CUtils::~CUtils() {}

#ifdef __sun
char *strcasestr(const char *big, const char *little) {
	int len;

	if (!little || !big || !little[0]) {
		return (char *) big;
	}

	len = strlen(little);
	while (*big) {
		if (tolower(*big) == tolower(*little)) {
			if (strncasecmp(big, little, len) == 0) {
				return (char *) big;
			}
		}

		big++;
	}

	return NULL;
}
#endif /* __sun */

#ifdef HAVE_LIBSSL
void CUtils::GenerateCert(FILE *pOut, bool bEncPrivKey, const CString& sHost) {
	EVP_PKEY *pKey = NULL;
	X509 *pCert = NULL;
	X509_NAME *pName = NULL;
	int days = 365;

	u_int iSeed = time(NULL);
	int serial = (rand_r(&iSeed) % 9999);

	RSA *pRSA = RSA_generate_key(1024, 0x10001, NULL, NULL);
	if ((pKey = EVP_PKEY_new())) {
		if (!EVP_PKEY_assign_RSA(pKey, pRSA)) {
			EVP_PKEY_free(pKey);
			return;
		}

		PEM_write_RSAPrivateKey(pOut, pRSA, (bEncPrivKey ? EVP_des_ede3_cbc() : NULL), NULL, 0, NULL, NULL);

		if (!(pCert = X509_new())) {
			EVP_PKEY_free(pKey);
			return;
		}

		X509_set_version(pCert, 2);
		ASN1_INTEGER_set(X509_get_serialNumber(pCert), serial);
		X509_gmtime_adj(X509_get_notBefore(pCert), 0);
		X509_gmtime_adj(X509_get_notAfter(pCert), (long)60*60*24*days);
		X509_set_pubkey(pCert, pKey);

		pName = X509_get_subject_name(pCert);

		const char *pLogName = getenv(""LOGNAME"");
		const char *pHostName = NULL;

		if (!sHost.empty()) {
			pHostName = sHost.c_str();
		}

		if (!pHostName) {
			pHostName = getenv(""HOSTNAME"");
		}

		if (!pLogName) {
			pLogName = ""Unknown"";
		}

		if (!pHostName) {
			pHostName = ""unknown.com"";
		}

		CString sEmailAddr = pLogName;
		sEmailAddr += ""@"";
		sEmailAddr += pHostName;

		X509_NAME_add_entry_by_txt(pName, ""C"", MBSTRING_ASC, (unsigned char *)""US"", -1, -1, 0);
		X509_NAME_add_entry_by_txt(pName, ""ST"", MBSTRING_ASC, (unsigned char *)""SomeState"", -1, -1, 0);
		X509_NAME_add_entry_by_txt(pName, ""L"", MBSTRING_ASC, (unsigned char *)""SomeCity"", -1, -1, 0);
		X509_NAME_add_entry_by_txt(pName, ""O"", MBSTRING_ASC, (unsigned char *)""SomeCompany"", -1, -1, 0);
		X509_NAME_add_entry_by_txt(pName, ""OU"", MBSTRING_ASC, (unsigned char *)pLogName, -1, -1, 0);
		X509_NAME_add_entry_by_txt(pName, ""CN"", MBSTRING_ASC, (unsigned char *)pHostName, -1, -1, 0);
		X509_NAME_add_entry_by_txt(pName, ""emailAddress"", MBSTRING_ASC, (unsigned char *)sEmailAddr.c_str(), -1, -1, 0);

		X509_set_subject_name(pCert, pName);

		if (!X509_sign(pCert, pKey, EVP_md5())) {
			X509_free(pCert);
			EVP_PKEY_free(pKey);
			return;
		}

		PEM_write_X509(pOut, pCert);
		X509_free(pCert);
		EVP_PKEY_free(pKey);
	}
}
#endif /* HAVE_LIBSSL */

CString CUtils::GetIP(unsigned long addr) {
	char szBuf[16];
	memset((char*) szBuf, 0, 16);

	if (addr >= (1 << 24)) {
		unsigned long ip[4];
		ip[0] = addr >> 24 & 255;
		ip[1] = addr >> 16 & 255;
		ip[2] = addr >> 8  & 255;
		ip[3] = addr       & 255;
		sprintf(szBuf, ""%lu.%lu.%lu.%lu"", ip[0], ip[1], ip[2], ip[3]);
	}

	return szBuf;
}

unsigned long CUtils::GetLongIP(const CString& sIP) {
	register int i;
	char *addr = (char *) malloc(sIP.length() +1);
	char ip[4][4], n;

	strcpy(addr, sIP.c_str());

	for (i=0; i<4; ip[0][i]=ip[1][i]=ip[2][i]=ip[3][i]='\0', i++);

	if (sscanf(addr, ""%3[0-9].%3[0-9].%3[0-9].%3[0-9]%[^\n]"", ip[0], ip[1], ip[2], ip[3], &n) != 4) {
		free(addr);
		return 0;
	}

	free(addr);
	return (unsigned long) ((atoi(ip[0]) << 24) + (atoi(ip[1]) << 16) + (atoi(ip[2]) << 8) + atoi(ip[3]));
}

CString CUtils::GetHashPass() {
	while (true) {
		char* pass = CUtils::GetPass(""Enter Password"");
		char* pass1 = (char*) malloc(strlen(pass) +1);
		strcpy(pass1, pass);	// Make a copy of this since it is stored in a static buffer and will be overwritten when we fill pass2 below
		memset((char*) pass, 0, strlen(pass));	// null out our pass so it doesn't sit in memory
		char* pass2 = CUtils::GetPass(""Confirm Password"");
		int iLen = strlen(pass1);

		if (strcmp(pass1, pass2) != 0) {
			CUtils::PrintError(""The supplied passwords did not match"");
		} else if (!iLen) {
			CUtils::PrintError(""You can not use an empty password"");
		} else {
			CString sRet((const char*) CMD5(pass1, iLen));
			memset((char*) pass1, 0, iLen);	// null out our pass so it doesn't sit in memory
			memset((char*) pass2, 0, strlen(pass2));	// null out our pass so it doesn't sit in memory
			free(pass1);

			return sRet;
		}

		memset((char*) pass1, 0, iLen);	// null out our pass so it doesn't sit in memory
		memset((char*) pass2, 0, strlen(pass2));	// null out our pass so it doesn't sit in memory
		free(pass1);
	}

	return """";
}

char* CUtils::GetPass(const CString& sPrompt) {
	PrintPrompt(sPrompt);
	return getpass("""");
}

bool CUtils::GetBoolInput(const CString& sPrompt, bool bDefault) {
	return CUtils::GetBoolInput(sPrompt, &bDefault);
}

bool CUtils::GetBoolInput(const CString& sPrompt, bool *pbDefault) {
	CString sRet, sDefault;

	if (pbDefault) {
		sDefault = (*pbDefault) ? ""yes"" : ""no"";
	}

	GetInput(sPrompt, sRet, sDefault, ""yes/no"");

	if (sRet.CaseCmp(""yes"") == 0) {
		return true;
	} else if (sRet.CaseCmp(""no"") == 0) {
		return false;
	}

	return GetBoolInput(sPrompt, pbDefault);
}

bool CUtils::GetNumInput(const CString& sPrompt, unsigned int& uRet, unsigned int uMin, unsigned int uMax, unsigned int uDefault) {
	if (uMin > uMax) {
		return false;
	}

	CString sDefault = (uDefault != (unsigned int) ~0) ? CString(uDefault) : """";
	CString sNum, sHint;

	if (uMax != (unsigned int) ~0) {
		sHint = CString(uMin) + "" to "" + CString(uMax);
	} else if (uMin > 0) {
		sHint = CString(uMin) + "" and up"";
	}

	while (true) {
		GetInput(sPrompt, sNum, sDefault, sHint);
		if (sNum.empty()) {
			return false;
		}

		uRet = atoi(sNum.c_str());

		if ((uRet >= uMin && uRet <= uMax)) {
			break;
		}

		CUtils::PrintError(""Number must be "" + sHint);
	}

	return true;
}

bool CUtils::GetInput(const CString& sPrompt, CString& sRet, const CString& sDefault, const CString& sHint) {
	CString sExtra;
	CString sInput;
	sExtra += (!sHint.empty()) ? ("" ("" + sHint + "")"") : """";
	sExtra += (!sDefault.empty()) ? ("" ["" + sDefault + ""]"") : """";

	PrintPrompt(sPrompt + sExtra);
	char szBuf[1024];
	memset(szBuf, 0, 1024);
	fgets(szBuf, 1024, stdin);
	sInput = szBuf;

	if (sInput.Right(1) == ""\n"") {
		sInput.RightChomp();
	}

	if (sInput.empty()) {
		sRet = sDefault;
	} else {
		sRet = sInput;
	}

	return !sRet.empty();
}

void CUtils::PrintError(const CString& sMessage) {
	if (stdoutIsTTY)
		fprintf(stdout, ""\033[1m\033[34m[\033[31m ** \033[34m]\033[39m\033[22m %s\n"", sMessage.c_str());
	else
		fprintf(stdout, ""[ ** ] %s\n"", sMessage.c_str());
	fflush(stdout);
}

void CUtils::PrintPrompt(const CString& sMessage) {
	if (stdoutIsTTY)
		fprintf(stdout, ""\033[1m\033[34m[\033[33m ?? \033[34m]\033[39m\033[22m %s: "", sMessage.c_str());
	else
		fprintf(stdout, ""[ ?? ] %s: "", sMessage.c_str());
	fflush(stdout);
}

void CUtils::PrintMessage(const CString& sMessage, bool bStrong) {
	if (stdoutIsTTY) {
		if (bStrong)
			fprintf(stdout, ""\033[1m\033[34m[\033[33m ** \033[34m]\033[39m\033[22m \033[1m%s\033[22m\n"",
					sMessage.c_str());
		else
			fprintf(stdout, ""\033[1m\033[34m[\033[33m ** \033[34m]\033[39m\033[22m %s\n"",
					sMessage.c_str());
	} else
		fprintf(stdout, ""%s\n"", sMessage.c_str());

	fflush(stdout);
}

void CUtils::PrintAction(const CString& sMessage) {
	if (stdoutIsTTY)
		fprintf(stdout, ""\033[1m\033[34m[\033[32m    \033[34m]\033[39m\033[22m %s... "", sMessage.c_str());
	else
		fprintf(stdout, ""%s... "", sMessage.c_str());
	fflush(stdout);
}

void CUtils::PrintStatus(bool bSuccess, const CString& sMessage) {
	if (stdoutIsTTY) {
		if (!sMessage.empty()) {
			if (bSuccess) {
				fprintf(stdout, ""%s"", sMessage.c_str());
			} else {
				fprintf(stdout, ""\033[1m\033[34m[\033[31m %s \033[34m]""
						""\033[39m\033[22m"", sMessage.c_str());
			}
		}

		fprintf(stdout, ""\r"");

		if (bSuccess) {
			fprintf(stdout, ""\033[1m\033[34m[\033[32m ok \033[34m]\033[39m\033[22m\n"");
		} else {
			fprintf(stdout, ""\033[1m\033[34m[\033[31m !! \033[34m]\033[39m\033[22m\n"");
		}
	} else {
		if (bSuccess) {
			fprintf(stdout, ""%s\n"", sMessage.c_str());
		} else {
			if (!sMessage.empty()) {
				fprintf(stdout, ""[ %s ]"", sMessage.c_str());
			}

			fprintf(stdout, ""\n[ !! ]\n"");
		}
	}

	fflush(stdout);
}

CTable::CTable() {}
CTable::~CTable() {
	for (unsigned int a = 0; a < size(); a++) {
		delete (*this)[a];
	}

	clear();
}

bool CTable::AddColumn(const CString& sName) {
	for (unsigned int a = 0; a < m_vsHeaders.size(); a++) {
		if (m_vsHeaders[a].CaseCmp(sName) == 0) {
			return false;
		}
	}

	m_vsHeaders.push_back(sName);
	return true;
}

unsigned int CTable::AddRow() {
	push_back(new map<CString, CString>);
	return size() -1;
}

bool CTable::SetCell(const CString& sColumn, const CString& sValue, unsigned int uRowIdx) {
	if (uRowIdx == (unsigned int) ~0) {
		if (!size()) {
			return false;
		}

		uRowIdx = size() -1;
	}

	(*(*this)[uRowIdx])[sColumn] = sValue;
	return true;
}

bool CTable::GetLine(unsigned int uIdx, CString& sLine) {
	stringstream ssRet;

	if (!size()) {
		return false;
	}

	if (uIdx == 1) {
		m_msuWidths.clear();	// Clear out the width cache
		ssRet.fill(' ');
		ssRet << ""| "";

		for (unsigned int a = 0; a < m_vsHeaders.size(); a++) {
			ssRet.width(GetColumnWidth(a));
			ssRet << std::left << m_vsHeaders[a];
			ssRet << ((a == m_vsHeaders.size() -1) ? "" |"" : "" | "");
		}

		sLine = ssRet.str();
		return true;
	} else if ((uIdx == 0) || (uIdx == 2) || (uIdx == (size() +3))) {
		ssRet.fill('-');
		ssRet << ""+-"";

		for (unsigned int a = 0; a < m_vsHeaders.size(); a++) {
			ssRet.width(GetColumnWidth(a));
			ssRet << std::left << ""-"";
			ssRet << ((a == m_vsHeaders.size() -1) ? ""-+"" : ""-+-"");
		}

		sLine = ssRet.str();
		return true;
	} else {
		uIdx -= 3;

		if (uIdx < size()) {
			map<CString, CString>* pRow = (*this)[uIdx];
			ssRet.fill(' ');
			ssRet << ""| "";

			for (unsigned int c = 0; c < m_vsHeaders.size(); c++) {
				ssRet.width(GetColumnWidth(c));
				ssRet << std::left << (*pRow)[m_vsHeaders[c]];
				ssRet << ((c == m_vsHeaders.size() -1) ? "" |"" : "" | "");
			}

			sLine = ssRet.str();
			return true;
		}
	}

	return false;
}

/*
bool CTable::Output(std::ostream oOut) {
	stringstream ssSep;

	ssSep << ""-+-"";

	oOut << endl << ssSep.str() << endl;

	for (unsigned int b = 0; b < size(); b++) {
		map<CString, CString>* pRow = (*this)[b];

		oOut << "" | "";

		for (unsigned int c = 0; c < m_vsHeaders.size(); c++) {
			oOut.width(GetColumnWidth(c));
			oOut << (*pRow)[m_vsHeaders[c]];
			oOut << "" | "";
		}

		oOut << endl;
	}

	oOut << ssSep.str() << endl;
	return true;
}
*/

unsigned int CTable::GetColumnWidth(unsigned int uIdx) {
	if (uIdx >= m_vsHeaders.size()) {
		return 0;
	}

	const CString& sColName = m_vsHeaders[uIdx];
	unsigned int uRet = sColName.size();
	map<CString, unsigned int>::iterator it = m_msuWidths.find(sColName);

	if (it != m_msuWidths.end()) {
		return it->second;
	}

	for (unsigned int a = 0; a < size(); a++) {
		map<CString, CString>* pRow = (*this)[a];
		unsigned int uTmp = (*pRow)[m_vsHeaders[uIdx]].size();

		if (uTmp > uRet) {
			uRet = uTmp;
		}
	}

	return uRet;
}


#ifdef HAVE_LIBSSL
CBlowfish::CBlowfish(const CString & sPassword, int iEncrypt, const CString & sIvec) {
	m_iEncrypt = iEncrypt;
	m_ivec = (unsigned char *)calloc(sizeof(unsigned char), 8);
	m_num = 0;

	if (sIvec.length() >= 8) {
		memcpy(m_ivec, sIvec.data(), 8);
	}

	BF_set_key(&m_bkey, sPassword.length(), (unsigned char *)sPassword.data());
}

CBlowfish::~CBlowfish() {
	free(m_ivec);
}

//! output must be freed
unsigned char *CBlowfish::MD5(const unsigned char *input, u_int ilen) {
	unsigned char *output = (unsigned char *)malloc(MD5_DIGEST_LENGTH);
	::MD5(input, ilen, output);
	return output;
}

//! returns an md5 of the CString (not hex encoded)
CString CBlowfish::MD5(const CString & sInput, bool bHexEncode) {
	CString sRet;
	unsigned char *data = MD5((const unsigned char *)sInput.data(), sInput.length());

	if (!bHexEncode) {
		sRet.append((const char *)data, MD5_DIGEST_LENGTH);
	} else {
		for (int a = 0; a < MD5_DIGEST_LENGTH; a++) {
			sRet += g_HexDigits[data[a] >> 4];
			sRet += g_HexDigits[data[a] & 0xf];
		}
	}

	free(data);
	return sRet;
}

//! output must be the same size as input
void CBlowfish::Crypt(unsigned char *input, unsigned char *output, u_int ibytes) {
	BF_cfb64_encrypt(input, output, ibytes, &m_bkey, m_ivec, &m_num, m_iEncrypt);
}

//! must free result
unsigned char * CBlowfish::Crypt(unsigned char *input, u_int ibytes) {
	unsigned char *buff = (unsigned char *)malloc(ibytes);
	Crypt(input, buff, ibytes);
	return buff;
}

CString CBlowfish::Crypt(const CString & sData) {
	unsigned char *buff = Crypt((unsigned char *)sData.data(), sData.length());
	CString sOutput;
	sOutput.append((const char *)buff, sData.length());
	free(buff);
	return sOutput;
}

#endif // HAVE_LIBSSL

""","""/*
 * Copyright (C) 2004-2008  See the AUTHORS file for details.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 as published
 * by the Free Software Foundation.
 */

#include ""Utils.h""
#include ""MD5.h""
#include <errno.h>
#ifdef HAVE_LIBSSL
#include <openssl/ssl.h>
#endif /* HAVE_LIBSSL */
#include <sstream>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>

using std::stringstream;

bool CUtils::stdoutIsTTY;

CUtils::CUtils() {}
CUtils::~CUtils() {}

#ifdef __sun
char *strcasestr(const char *big, const char *little) {
	int len;

	if (!little || !big || !little[0]) {
		return (char *) big;
	}

	len = strlen(little);
	while (*big) {
		if (tolower(*big) == tolower(*little)) {
			if (strncasecmp(big, little, len) == 0) {
				return (char *) big;
			}
		}

		big++;
	}

	return NULL;
}
#endif /* __sun */

#ifdef HAVE_LIBSSL
void CUtils::GenerateCert(FILE *pOut, bool bEncPrivKey, const CString& sHost) {
	EVP_PKEY *pKey = NULL;
	X509 *pCert = NULL;
	X509_NAME *pName = NULL;
	int days = 365;

	u_int iSeed = time(NULL);
	int serial = (rand_r(&iSeed) % 9999);

	RSA *pRSA = RSA_generate_key(1024, 0x10001, NULL, NULL);
	if ((pKey = EVP_PKEY_new())) {
		if (!EVP_PKEY_assign_RSA(pKey, pRSA)) {
			EVP_PKEY_free(pKey);
			return;
		}

		PEM_write_RSAPrivateKey(pOut, pRSA, (bEncPrivKey ? EVP_des_ede3_cbc() : NULL), NULL, 0, NULL, NULL);

		if (!(pCert = X509_new())) {
			EVP_PKEY_free(pKey);
			return;
		}

		X509_set_version(pCert, 2);
		ASN1_INTEGER_set(X509_get_serialNumber(pCert), serial);
		X509_gmtime_adj(X509_get_notBefore(pCert), 0);
		X509_gmtime_adj(X509_get_notAfter(pCert), (long)60*60*24*days);
		X509_set_pubkey(pCert, pKey);

		pName = X509_get_subject_name(pCert);

		const char *pLogName = getenv(""LOGNAME"");
		const char *pHostName = NULL;

		if (!sHost.empty()) {
			pHostName = sHost.c_str();
		}

		if (!pHostName) {
			pHostName = getenv(""HOSTNAME"");
		}

		if (!pLogName) {
			pLogName = ""Unknown"";
		}

		if (!pHostName) {
			pHostName = ""unknown.com"";
		}

		CString sEmailAddr = pLogName;
		sEmailAddr += ""@"";
		sEmailAddr += pHostName;

		X509_NAME_add_entry_by_txt(pName, ""C"", MBSTRING_ASC, (unsigned char *)""US"", -1, -1, 0);
		X509_NAME_add_entry_by_txt(pName, ""ST"", MBSTRING_ASC, (unsigned char *)""SomeState"", -1, -1, 0);
		X509_NAME_add_entry_by_txt(pName, ""L"", MBSTRING_ASC, (unsigned char *)""SomeCity"", -1, -1, 0);
		X509_NAME_add_entry_by_txt(pName, ""O"", MBSTRING_ASC, (unsigned char *)""SomeCompany"", -1, -1, 0);
		X509_NAME_add_entry_by_txt(pName, ""OU"", MBSTRING_ASC, (unsigned char *)pLogName, -1, -1, 0);
		X509_NAME_add_entry_by_txt(pName, ""CN"", MBSTRING_ASC, (unsigned char *)pHostName, -1, -1, 0);
		X509_NAME_add_entry_by_txt(pName, ""emailAddress"", MBSTRING_ASC, (unsigned char *)sEmailAddr.c_str(), -1, -1, 0);

		X509_set_subject_name(pCert, pName);

		if (!X509_sign(pCert, pKey, EVP_md5())) {
			X509_free(pCert);
			EVP_PKEY_free(pKey);
			return;
		}

		PEM_write_X509(pOut, pCert);
		X509_free(pCert);
		EVP_PKEY_free(pKey);
	}
}
#endif /* HAVE_LIBSSL */

CString CUtils::GetIP(unsigned long addr) {
	char szBuf[16];
	memset((char*) szBuf, 0, 16);

	if (addr >= (1 << 24)) {
		unsigned long ip[4];
		ip[0] = addr >> 24 & 255;
		ip[1] = addr >> 16 & 255;
		ip[2] = addr >> 8  & 255;
		ip[3] = addr       & 255;
		sprintf(szBuf, ""%lu.%lu.%lu.%lu"", ip[0], ip[1], ip[2], ip[3]);
	}

	return szBuf;
}

unsigned long CUtils::GetLongIP(const CString& sIP) {
	unsigned long ret;
	char ip[4][4];
	int i;

	i = sscanf(sIP.c_str(), ""%3[0-9].%3[0-9].%3[0-9].%3[0-9]"",
			ip[0], ip[1], ip[2], ip[3]);
	if (i != 4)
		return 0;

	ret  = atoi(ip[0]) << 24;
	ret += atoi(ip[1]) << 16;
	ret += atoi(ip[2]) << 8;
	ret += atoi(ip[3]) << 0;

	return ret;
}

CString CUtils::GetHashPass() {
	while (true) {
		char* pass = CUtils::GetPass(""Enter Password"");
		char* pass1 = (char*) malloc(strlen(pass) +1);
		strcpy(pass1, pass);	// Make a copy of this since it is stored in a static buffer and will be overwritten when we fill pass2 below
		memset((char*) pass, 0, strlen(pass));	// null out our pass so it doesn't sit in memory
		char* pass2 = CUtils::GetPass(""Confirm Password"");
		int iLen = strlen(pass1);

		if (strcmp(pass1, pass2) != 0) {
			CUtils::PrintError(""The supplied passwords did not match"");
		} else if (!iLen) {
			CUtils::PrintError(""You can not use an empty password"");
		} else {
			CString sRet((const char*) CMD5(pass1, iLen));
			memset((char*) pass1, 0, iLen);	// null out our pass so it doesn't sit in memory
			memset((char*) pass2, 0, strlen(pass2));	// null out our pass so it doesn't sit in memory
			free(pass1);

			return sRet;
		}

		memset((char*) pass1, 0, iLen);	// null out our pass so it doesn't sit in memory
		memset((char*) pass2, 0, strlen(pass2));	// null out our pass so it doesn't sit in memory
		free(pass1);
	}

	return """";
}

char* CUtils::GetPass(const CString& sPrompt) {
	PrintPrompt(sPrompt);
	return getpass("""");
}

bool CUtils::GetBoolInput(const CString& sPrompt, bool bDefault) {
	return CUtils::GetBoolInput(sPrompt, &bDefault);
}

bool CUtils::GetBoolInput(const CString& sPrompt, bool *pbDefault) {
	CString sRet, sDefault;

	if (pbDefault) {
		sDefault = (*pbDefault) ? ""yes"" : ""no"";
	}

	GetInput(sPrompt, sRet, sDefault, ""yes/no"");

	if (sRet.CaseCmp(""yes"") == 0) {
		return true;
	} else if (sRet.CaseCmp(""no"") == 0) {
		return false;
	}

	return GetBoolInput(sPrompt, pbDefault);
}

bool CUtils::GetNumInput(const CString& sPrompt, unsigned int& uRet, unsigned int uMin, unsigned int uMax, unsigned int uDefault) {
	if (uMin > uMax) {
		return false;
	}

	CString sDefault = (uDefault != (unsigned int) ~0) ? CString(uDefault) : """";
	CString sNum, sHint;

	if (uMax != (unsigned int) ~0) {
		sHint = CString(uMin) + "" to "" + CString(uMax);
	} else if (uMin > 0) {
		sHint = CString(uMin) + "" and up"";
	}

	while (true) {
		GetInput(sPrompt, sNum, sDefault, sHint);
		if (sNum.empty()) {
			return false;
		}

		uRet = atoi(sNum.c_str());

		if ((uRet >= uMin && uRet <= uMax)) {
			break;
		}

		CUtils::PrintError(""Number must be "" + sHint);
	}

	return true;
}

bool CUtils::GetInput(const CString& sPrompt, CString& sRet, const CString& sDefault, const CString& sHint) {
	CString sExtra;
	CString sInput;
	sExtra += (!sHint.empty()) ? ("" ("" + sHint + "")"") : """";
	sExtra += (!sDefault.empty()) ? ("" ["" + sDefault + ""]"") : """";

	PrintPrompt(sPrompt + sExtra);
	char szBuf[1024];
	memset(szBuf, 0, 1024);
	fgets(szBuf, 1024, stdin);
	sInput = szBuf;

	if (sInput.Right(1) == ""\n"") {
		sInput.RightChomp();
	}

	if (sInput.empty()) {
		sRet = sDefault;
	} else {
		sRet = sInput;
	}

	return !sRet.empty();
}

void CUtils::PrintError(const CString& sMessage) {
	if (stdoutIsTTY)
		fprintf(stdout, ""\033[1m\033[34m[\033[31m ** \033[34m]\033[39m\033[22m %s\n"", sMessage.c_str());
	else
		fprintf(stdout, ""[ ** ] %s\n"", sMessage.c_str());
	fflush(stdout);
}

void CUtils::PrintPrompt(const CString& sMessage) {
	if (stdoutIsTTY)
		fprintf(stdout, ""\033[1m\033[34m[\033[33m ?? \033[34m]\033[39m\033[22m %s: "", sMessage.c_str());
	else
		fprintf(stdout, ""[ ?? ] %s: "", sMessage.c_str());
	fflush(stdout);
}

void CUtils::PrintMessage(const CString& sMessage, bool bStrong) {
	if (stdoutIsTTY) {
		if (bStrong)
			fprintf(stdout, ""\033[1m\033[34m[\033[33m ** \033[34m]\033[39m\033[22m \033[1m%s\033[22m\n"",
					sMessage.c_str());
		else
			fprintf(stdout, ""\033[1m\033[34m[\033[33m ** \033[34m]\033[39m\033[22m %s\n"",
					sMessage.c_str());
	} else
		fprintf(stdout, ""%s\n"", sMessage.c_str());

	fflush(stdout);
}

void CUtils::PrintAction(const CString& sMessage) {
	if (stdoutIsTTY)
		fprintf(stdout, ""\033[1m\033[34m[\033[32m    \033[34m]\033[39m\033[22m %s... "", sMessage.c_str());
	else
		fprintf(stdout, ""%s... "", sMessage.c_str());
	fflush(stdout);
}

void CUtils::PrintStatus(bool bSuccess, const CString& sMessage) {
	if (stdoutIsTTY) {
		if (!sMessage.empty()) {
			if (bSuccess) {
				fprintf(stdout, ""%s"", sMessage.c_str());
			} else {
				fprintf(stdout, ""\033[1m\033[34m[\033[31m %s \033[34m]""
						""\033[39m\033[22m"", sMessage.c_str());
			}
		}

		fprintf(stdout, ""\r"");

		if (bSuccess) {
			fprintf(stdout, ""\033[1m\033[34m[\033[32m ok \033[34m]\033[39m\033[22m\n"");
		} else {
			fprintf(stdout, ""\033[1m\033[34m[\033[31m !! \033[34m]\033[39m\033[22m\n"");
		}
	} else {
		if (bSuccess) {
			fprintf(stdout, ""%s\n"", sMessage.c_str());
		} else {
			if (!sMessage.empty()) {
				fprintf(stdout, ""[ %s ]"", sMessage.c_str());
			}

			fprintf(stdout, ""\n[ !! ]\n"");
		}
	}

	fflush(stdout);
}

CTable::CTable() {}
CTable::~CTable() {
	for (unsigned int a = 0; a < size(); a++) {
		delete (*this)[a];
	}

	clear();
}

bool CTable::AddColumn(const CString& sName) {
	for (unsigned int a = 0; a < m_vsHeaders.size(); a++) {
		if (m_vsHeaders[a].CaseCmp(sName) == 0) {
			return false;
		}
	}

	m_vsHeaders.push_back(sName);
	return true;
}

unsigned int CTable::AddRow() {
	push_back(new map<CString, CString>);
	return size() -1;
}

bool CTable::SetCell(const CString& sColumn, const CString& sValue, unsigned int uRowIdx) {
	if (uRowIdx == (unsigned int) ~0) {
		if (!size()) {
			return false;
		}

		uRowIdx = size() -1;
	}

	(*(*this)[uRowIdx])[sColumn] = sValue;
	return true;
}

bool CTable::GetLine(unsigned int uIdx, CString& sLine) {
	stringstream ssRet;

	if (!size()) {
		return false;
	}

	if (uIdx == 1) {
		m_msuWidths.clear();	// Clear out the width cache
		ssRet.fill(' ');
		ssRet << ""| "";

		for (unsigned int a = 0; a < m_vsHeaders.size(); a++) {
			ssRet.width(GetColumnWidth(a));
			ssRet << std::left << m_vsHeaders[a];
			ssRet << ((a == m_vsHeaders.size() -1) ? "" |"" : "" | "");
		}

		sLine = ssRet.str();
		return true;
	} else if ((uIdx == 0) || (uIdx == 2) || (uIdx == (size() +3))) {
		ssRet.fill('-');
		ssRet << ""+-"";

		for (unsigned int a = 0; a < m_vsHeaders.size(); a++) {
			ssRet.width(GetColumnWidth(a));
			ssRet << std::left << ""-"";
			ssRet << ((a == m_vsHeaders.size() -1) ? ""-+"" : ""-+-"");
		}

		sLine = ssRet.str();
		return true;
	} else {
		uIdx -= 3;

		if (uIdx < size()) {
			map<CString, CString>* pRow = (*this)[uIdx];
			ssRet.fill(' ');
			ssRet << ""| "";

			for (unsigned int c = 0; c < m_vsHeaders.size(); c++) {
				ssRet.width(GetColumnWidth(c));
				ssRet << std::left << (*pRow)[m_vsHeaders[c]];
				ssRet << ((c == m_vsHeaders.size() -1) ? "" |"" : "" | "");
			}

			sLine = ssRet.str();
			return true;
		}
	}

	return false;
}

/*
bool CTable::Output(std::ostream oOut) {
	stringstream ssSep;

	ssSep << ""-+-"";

	oOut << endl << ssSep.str() << endl;

	for (unsigned int b = 0; b < size(); b++) {
		map<CString, CString>* pRow = (*this)[b];

		oOut << "" | "";

		for (unsigned int c = 0; c < m_vsHeaders.size(); c++) {
			oOut.width(GetColumnWidth(c));
			oOut << (*pRow)[m_vsHeaders[c]];
			oOut << "" | "";
		}

		oOut << endl;
	}

	oOut << ssSep.str() << endl;
	return true;
}
*/

unsigned int CTable::GetColumnWidth(unsigned int uIdx) {
	if (uIdx >= m_vsHeaders.size()) {
		return 0;
	}

	const CString& sColName = m_vsHeaders[uIdx];
	unsigned int uRet = sColName.size();
	map<CString, unsigned int>::iterator it = m_msuWidths.find(sColName);

	if (it != m_msuWidths.end()) {
		return it->second;
	}

	for (unsigned int a = 0; a < size(); a++) {
		map<CString, CString>* pRow = (*this)[a];
		unsigned int uTmp = (*pRow)[m_vsHeaders[uIdx]].size();

		if (uTmp > uRet) {
			uRet = uTmp;
		}
	}

	return uRet;
}


#ifdef HAVE_LIBSSL
CBlowfish::CBlowfish(const CString & sPassword, int iEncrypt, const CString & sIvec) {
	m_iEncrypt = iEncrypt;
	m_ivec = (unsigned char *)calloc(sizeof(unsigned char), 8);
	m_num = 0;

	if (sIvec.length() >= 8) {
		memcpy(m_ivec, sIvec.data(), 8);
	}

	BF_set_key(&m_bkey, sPassword.length(), (unsigned char *)sPassword.data());
}

CBlowfish::~CBlowfish() {
	free(m_ivec);
}

//! output must be freed
unsigned char *CBlowfish::MD5(const unsigned char *input, u_int ilen) {
	unsigned char *output = (unsigned char *)malloc(MD5_DIGEST_LENGTH);
	::MD5(input, ilen, output);
	return output;
}

//! returns an md5 of the CString (not hex encoded)
CString CBlowfish::MD5(const CString & sInput, bool bHexEncode) {
	CString sRet;
	unsigned char *data = MD5((const unsigned char *)sInput.data(), sInput.length());

	if (!bHexEncode) {
		sRet.append((const char *)data, MD5_DIGEST_LENGTH);
	} else {
		for (int a = 0; a < MD5_DIGEST_LENGTH; a++) {
			sRet += g_HexDigits[data[a] >> 4];
			sRet += g_HexDigits[data[a] & 0xf];
		}
	}

	free(data);
	return sRet;
}

//! output must be the same size as input
void CBlowfish::Crypt(unsigned char *input, unsigned char *output, u_int ibytes) {
	BF_cfb64_encrypt(input, output, ibytes, &m_bkey, m_ivec, &m_num, m_iEncrypt);
}

//! must free result
unsigned char * CBlowfish::Crypt(unsigned char *input, u_int ibytes) {
	unsigned char *buff = (unsigned char *)malloc(ibytes);
	Crypt(input, buff, ibytes);
	return buff;
}

CString CBlowfish::Crypt(const CString & sData) {
	unsigned char *buff = Crypt((unsigned char *)sData.data(), sData.length());
	CString sOutput;
	sOutput.append((const char *)buff, sData.length());
	free(buff);
	return sOutput;
}

#endif // HAVE_LIBSSL

""",CUtils::GetLongIP,[144:160]
znc,https://github.com/znc/znc/commit/daef16a3ebfa34d3204e5503ce1191a52aaa3b37,"""Replace CString::Token() with a rewritten version

In my testing this saves between 29% and 97% (!) of CPU usage. Biggest speedup
happens with long tokens being returned.
This is because the old version uses std::string::operator+(char) to construct
the returned string, while the new one uses std::string::substr() only once.


git-svn-id: https://znc.svn.sourceforge.net/svnroot/znc/trunk@1065 726aef4b-f618-498e-8847-2d620e286838""","""/*
 * Copyright (C) 2004-2008  See the AUTHORS file for details.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 as published
 * by the Free Software Foundation.
 */

#include ""String.h""
#include ""FileUtils.h""
#include ""MD5.h""
#include ""Utils.h""
#include <sstream>

using std::stringstream;

const char* g_szHTMLescapes[256] = {
	""&#0;"", 0, 0, 0, 0, 0, 0, 0, 0, 0,               // 0-9
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                    // 10-19
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                    // 20-29
	0, 0, 0, 0, ""&quot;"", 0, 0, 0, ""&amp;"", ""&#39;"", // 30-39
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                    // 40-49
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                    // 50-59
	""&lt;"", 0, ""&gt;"", 0, 0, 0, 0, 0, 0, 0,          // 60-69
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                    // 70-79
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                    // 80-89
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                    // 90-99
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                    // 100-109
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                    // 110-119
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                    // 120-129
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                    // 130-139
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                    // 140-149
	0, 0, 0, ""&trade;"", 0, 0, 0, 0, 0, 0,            // 150-159
	""&nbsp;"",   // 160
	""&iexcl;"",  // 161
	""&cent;"",   // 162
	""&pound;"",  // 163
	""&curren;"", // 164
	""&yen;"",    // 165
	""&brvbar;"", // 166
	""&sect;"",   // 167
	""&uml;"",    // 168
	""&copy;"",   // 169
	""&ordf;"",   // 170
	""&laquo;"",  // 171
	""&not;"",    // 172
	""&shy;"",    // 173
	""&reg;"",    // 174
	""&macr;"",   // 175
	""&deg;"",    // 176
	""&plusmn;"", // 177
	""&sup2;"",   // 178
	""&sup3;"",   // 179
	""&acute;"",  // 180
	""&micro;"",  // 181
	""&para;"",   // 182
	""&middot;"", // 183
	""&cedil;"",  // 184
	""&sup1;"",   // 185
	""&ordm;"",   // 186
	""&raquo;"",  // 187
	""&frac14;"", // 188
	""&frac12;"", // 189
	""&frac34;"", // 190
	""&iquest;"", // 191
	""&Agrave;"", // 192
	""&Aacute;"", // 193
	""&Acirc;"",  // 194
	""&Atilde;"", // 195
	""&Auml;"",   // 196
	""&Aring;"",  // 197
	""&AElig;"",  // 198
	""&Ccedil;"", // 199
	""&Egrave;"", // 200
	""&Eacute;"", // 201
	""&Ecirc;"",  // 202
	""&Euml;"",   // 203
	""&Igrave;"", // 204
	""&Iacute;"", // 205
	""&Icirc;"",  // 206
	""&Iuml;"",   // 207
	""&ETH;"",    // 208
	""&Ntilde;"", // 209
	""&Ograve;"", // 210
	""&Oacute;"", // 211
	""&Ocirc;"",  // 212
	""&Otilde;"", // 213
	""&Ouml;"",   // 214
	""&times;"",  // 215
	""&Oslash;"", // 216
	""&Ugrave;"", // 217
	""&Uacute;"", // 218
	""&Ucirc;"",  // 219
	""&Uuml;"",   // 220
	""&Yacute;"", // 221
	""&THORN;"",  // 222
	""&szlig;"",  // 223
	""&agrave;"", // 224
	""&aacute;"", // 225
	""&acirc;"",  // 226
	""&atilde;"", // 227
	""&auml;"",   // 228
	""&aring;"",  // 229
	""&aelig;"",  // 230
	""&ccedil;"", // 231
	""&egrave;"", // 232
	""&eacute;"", // 233
	""&ecirc;"",  // 234
	""&euml;"",   // 235
	""&igrave;"", // 236
	""&iacute;"", // 237
	""&icirc;"",  // 238
	""&iuml;"",   // 239
	""&eth;"",    // 240
	""&ntilde;"", // 241
	""&ograve;"", // 242
	""&oacute;"", // 243
	""&ocirc;"",  // 244
	""&otilde;"", // 245
	""&ouml;"",   // 246
	""&divide;"", // 247
	""&oslash;"", // 248
	""&ugrave;"", // 249
	""&uacute;"", // 250
	""&ucirc;"",  // 251
	""&uuml;"",   // 252
	""&yacute;"", // 253
	""&thorn;"",  // 254
	""&yuml;"",   // 255
};

CString::CString(char c) : string() { stringstream s; s << c; *this = s.str(); }
CString::CString(unsigned char c) : string() { stringstream s; s << c; *this = s.str(); }
CString::CString(short i) : string() { stringstream s; s << i; *this = s.str(); }
CString::CString(unsigned short i) : string() { stringstream s; s << i; *this = s.str(); }
CString::CString(int i) : string() { stringstream s; s << i; *this = s.str(); }
CString::CString(unsigned int i) : string() { stringstream s; s << i; *this = s.str(); }
CString::CString(long i) : string() { stringstream s; s << i; *this = s.str(); }
CString::CString(unsigned long i) : string() { stringstream s; s << i; *this = s.str(); }
CString::CString(long long i) : string() { stringstream s; s << i; *this = s.str(); }
CString::CString(unsigned long long i) : string() { stringstream s; s << i; *this = s.str(); }
CString::CString(double i) : string() { stringstream s; s << i; *this = s.str(); }
CString::CString(float i) : string() { stringstream s; s << i; *this = s.str(); }

inline unsigned char* CString::strnchr(const unsigned char* src, unsigned char c, unsigned int iMaxBytes, unsigned char* pFill, unsigned int* piCount) const {
    for (unsigned int a = 0; a < iMaxBytes && *src; a++, src++) {
		if (pFill) {
			pFill[a] = *src;
		}

		if (*src == c) {
			if (pFill) {
				pFill[a +1] = 0;
			}

			if (piCount) {
				*piCount = a;
			}

			return (unsigned char*) src;
		}
	}

	if (pFill) {
		*pFill = 0;
	}

	if (piCount) {
		*piCount = 0;
	}

    return NULL;
}

int CString::CaseCmp(const CString& s, u_long uLen) const {
	if (uLen != CString::npos) {
		return strncasecmp(c_str(), s.c_str(), uLen);
	}
	return strcasecmp(c_str(), s.c_str());
}

int CString::StrCmp(const CString& s) const {
	return strcmp(c_str(), s.c_str());
}

bool CString::WildCmp(const CString& sWild, const CString& sString) {
	// Written by Jack Handy - jakkhandy@hotmail.com
	const char *wild = sWild.c_str(), *CString = sString.c_str();
	const char *cp = NULL, *mp = NULL;

	while ((*CString) && (*wild != '*')) {
		if ((*wild != *CString) && (*wild != '?')) {
			return false;
		}

		wild++;
		CString++;
	}

	while (*CString) {
		if (*wild == '*') {
			if (!*++wild) {
				return true;
			}

			mp = wild;
			cp = CString+1;
		} else if ((*wild == *CString) || (*wild == '?')) {
			wild++;
			CString++;
		} else {
			wild = mp;
			CString = cp++;
		}
	}

	while (*wild == '*') {
		wild++;
	}

	return (*wild == 0);
}

bool CString::WildCmp(const CString& sWild) const {
	return CString::WildCmp(sWild, *this);
}

CString& CString::MakeUpper() {
	for (unsigned int a = 0; a < length(); a++) {
		char& c = (*this)[a];
		c = toupper(c);
	}

	return *this;
}

CString& CString::MakeLower() {
	for (unsigned int a = 0; a < length(); a++) {
		char& c = (*this)[a];
		c = tolower(c);
	}

	return *this;
}

CString CString::AsUpper() const {
	CString sRet = *this;

	for (unsigned int a = 0; a < length(); a++) {
		char& c = sRet[a];
		c = toupper(c);
	}

	return sRet;
}

CString CString::AsLower() const {
	CString sRet = *this;

	for (unsigned int a = 0; a < length(); a++) {
		char& c = sRet[a];
		c = tolower(c);
	}

	return sRet;
}

CString::EEscape CString::ToEscape(const CString& sEsc) {
	if (sEsc.CaseCmp(""ASCII"") == 0) {
		return EASCII;
	} else if (sEsc.CaseCmp(""HTML"") == 0) {
		return EHTML;
	} else if (sEsc.CaseCmp(""URL"") == 0) {
		return EURL;
	} else if (sEsc.CaseCmp(""SQL"") == 0) {
		return ESQL;
	}

	return EASCII;
}

CString CString::Escape_n(EEscape eFrom, EEscape eTo) const {
	CString sRet;
	const char szHex[] = ""0123456789ABCDEF"";
	const unsigned char *pStart = (const unsigned char*) data();
	const unsigned char *p = (const unsigned char*) data();
	unsigned int iLength = length();
	sRet.reserve(iLength *3);
	unsigned int iMaxLen = (eFrom == EHTML) ? 20 : 0;
	unsigned char pTmp[iMaxLen +1];
	unsigned int iCounted = 0;

	for (unsigned int a = 0; a < iLength; a++, p = pStart + a) {
		unsigned char ch = 0;

		switch (eFrom) {
			case EHTML:
				if ((*p == '&') && (strnchr((unsigned char*) p, ';', iMaxLen, pTmp, &iCounted))) {
					if ((iCounted >= 3) && (pTmp[1] == '#')) {	// do XML and HTML &#97; &#x3c
						int base = 10;

						if ((pTmp[2] & 0xDF) == 'X') {
							base = 16;
						}

						char* endptr = NULL;
						unsigned int b = strtol((const char*) (pTmp +2 + (base == 16)), &endptr, base);

						if ((*endptr == ';') && (b <= 255)) { // incase they do something like &#7777777777;
							ch = b;
							a += iCounted;
							break;
						}
					}

					for (unsigned int c = 0; c < 256; c++) {
						if (g_szHTMLescapes[c] && strcmp(g_szHTMLescapes[c], (const char*) &pTmp) == 0) {
							ch = c;
							break;
						}
					}

					if (ch > 0) {
						a += iCounted;
					} else {
						ch = *p;	 // Not a valid escape, just record the &
					}
				} else {
					ch = *p;
				}
				break;
			case EASCII:
				ch = *p;
				break;
			case EURL:
				if (*p == '%' && (a +2) < iLength && isxdigit(*(p +1)) && isxdigit(*(p +2))) {
					p++;
					if (isdigit(*p)) {
						ch = (*p - '0') << 4;
					} else {
						ch = (tolower(*p) - 'a' +10) << 4;
					}

					p++;
					if (isdigit(*p)) {
						ch |= (*p - '0');
					} else {
						ch |= (tolower(*p) - 'a' +10);
					}

					a += 2;
				} else if (pStart[a] == '+') {
					ch = ' ';
				} else {
					ch = *p;
				}

				break;
			case ESQL:
				if (*p != '\\' || iLength < (a +1)) {
					ch = *p;
				} else {
					a++;
					p++;

					if (*p == 'n') {
						ch = '\n';
					} else if (*p == 'r') {
						ch = '\r';
					} else if (*p == '0') {
						ch = '\0';
					} else if (*p == 't') {
						ch = '\t';
					} else if (*p == 'b') {
						ch = '\b';
					} else {
						ch = *p;
					}
				}

				break;
		}

		switch (eTo) {
			case EHTML:
				if (g_szHTMLescapes[ch]) {
					sRet += g_szHTMLescapes[ch];
				} else {
					sRet += ch;
				}

				break;
			case EASCII:
				sRet += ch;
				break;
			case EURL:
				if (isalnum(ch) || ch == '_' || ch == '.' || ch == '-') {
					sRet += ch;
				} else if (ch == ' ') {
					sRet += '+';
				} else {
					sRet += '%';
					sRet += szHex[ch >> 4];
					sRet += szHex[ch & 0xf];
				}

				break;
			case ESQL:
				if (ch == '\0') { sRet += '\\'; sRet += '0';
				} else if (ch == '\n') { sRet += '\\'; sRet += 'n';
				} else if (ch == '\t') { sRet += '\\'; sRet += 't';
				} else if (ch == '\r') { sRet += '\\'; sRet += 'r';
				} else if (ch == '\b') { sRet += '\\'; sRet += 'b';
				} else if (ch == '\""') { sRet += '\\'; sRet += '\""';
				} else if (ch == '\'') { sRet += '\\'; sRet += '\'';
				} else if (ch == '\\') { sRet += '\\'; sRet += '\\';
				} else { sRet += ch; }

				break;
		}
	}

	sRet.reserve(0);
	return sRet;
}

CString CString::Escape_n(EEscape eTo) const {
	return Escape_n(EASCII, eTo);
}

CString& CString::Escape(EEscape eFrom, EEscape eTo) {
	return (*this = Escape_n(eFrom, eTo));
}

CString& CString::Escape(EEscape eTo) {
	return (*this = Escape_n(eTo));
}

CString CString::Replace_n(const CString& sReplace, const CString& sWith, const CString& sLeft, const CString& sRight, bool bRemoveDelims) const {
	CString sRet = *this;
	CString::Replace(sRet, sReplace, sWith, sLeft, sRight, bRemoveDelims);
	return sRet;
}

unsigned int CString::Replace(const CString& sReplace, const CString& sWith, const CString& sLeft, const CString& sRight, bool bRemoveDelims) {
	return CString::Replace(*this, sReplace, sWith, sLeft, sRight, bRemoveDelims);
}

unsigned int CString::Replace(CString& sStr, const CString& sReplace, const CString& sWith, const CString& sLeft, const CString& sRight, bool bRemoveDelims) {
	unsigned int uRet = 0;
	CString sCopy = sStr;
	sStr.clear();

	unsigned int uReplaceWidth = sReplace.length();
	unsigned int uLeftWidth = sLeft.length();
	unsigned int uRightWidth = sRight.length();
	const char* p = sCopy.c_str();
	bool bInside = false;

	while (*p) {
		if (!bInside && uLeftWidth && strncmp(p, sLeft.c_str(), uLeftWidth) == 0) {
			if (!bRemoveDelims) {
				sStr += sLeft;
			}

			p += uLeftWidth -1;
			bInside = true;
		} else if (bInside && uRightWidth && strncmp(p, sRight.c_str(), uRightWidth) == 0) {
			if (!bRemoveDelims) {
				sStr += sRight;
			}

			p += uRightWidth -1;
			bInside = false;
		} else if (!bInside && strncmp(p, sReplace.c_str(), uReplaceWidth) == 0) {
			sStr += sWith;
			p += uReplaceWidth -1;
			uRet++;
		} else {
			sStr.append(p, 1);
		}

		p++;
	}

	return uRet;
}

CString CString::Token(unsigned int uPos, bool bRest, const CString& sSep) const {
	string sRet;
	const char* p = c_str();
	unsigned int uSepLen = sSep.length();

	if (uSepLen) {
		uSepLen--;
	}

	while (*p) {
		if (uPos) {
			if (strncmp(p, sSep.c_str(), sSep.length()) == 0) {
				uPos--;
				p += uSepLen;
			}
		} else {
			if (strncmp(p, sSep.c_str(), sSep.length()) == 0) {
				if (!bRest) {
					return sRet;
				}
			}

			sRet += *p;
		}

		p++;
	}

	return sRet;
}

CString CString::Ellipsize(unsigned int uLen) const {
	if (uLen >= size()) {
		return *this;
	}

	string sRet;

	// @todo this looks suspect
	if (uLen < 4) {
		for (unsigned int a = 0; a < uLen; a++) {
			sRet += ""."";
		}

		return sRet;
	}

	sRet = substr(0, uLen -3) + ""..."";

	return sRet;
}

CString CString::Left(unsigned int uCount) const {
	uCount = (uCount > length()) ? length() : uCount;
	return substr(0, uCount);
}

CString CString::Right(unsigned int uCount) const {
	uCount = (uCount > length()) ? length() : uCount;
	return substr(length() - uCount, uCount);
}

unsigned int CString::URLSplit(MCString& msRet) const {
	msRet.clear();

	VCString vsPairs;
	Split(""&"", vsPairs);

	for (size_t a = 0; a < vsPairs.size(); a++) {
		const CString& sPair = vsPairs[a];

		msRet[sPair.Token(0, false, ""="").Escape(CString::EURL, CString::EASCII)] = sPair.Token(1, true, ""="").Escape(CString::EURL, CString::EASCII);
	}

	return msRet.size();
}

unsigned int CString::Split(const CString& sDelim, VCString& vsRet, bool bAllowEmpty, const CString& sLeft, const CString& sRight) const {
	vsRet.clear();

	if (empty()) {
		return 0;
	}

	CString sTmp;
	bool bInside = false;
	unsigned int uDelimLen = sDelim.length();
	unsigned int uLeftLen = sLeft.length();
	unsigned int uRightLen = sRight.length();
	const char* p = c_str();

	if (!bAllowEmpty) {
		while (strncasecmp(p, sDelim.c_str(), uDelimLen) == 0) {
			p += uDelimLen;
		}
	}

	while (*p) {
		if (uLeftLen && uRightLen && !bInside && strncasecmp(p, sLeft.c_str(), uLeftLen) == 0) {
			p += uLeftLen;
			bInside = true;
			continue;
		}

		if (uLeftLen && uRightLen && bInside && strncasecmp(p, sRight.c_str(), uRightLen) == 0) {
			p += uRightLen;
			bInside = false;
			continue;
		}

		if (uDelimLen && !bInside && strncasecmp(p, sDelim.c_str(), uDelimLen) == 0) {
			vsRet.push_back(sTmp);
			sTmp.clear();
			p += uDelimLen;

			if (!bAllowEmpty) {
				while (strncasecmp(p, sDelim.c_str(), uDelimLen) == 0) {
					p += uDelimLen;
				}
			}

			bInside = false;
			continue;
		} else {
			sTmp += *p;
		}

		p++;
	}

	if (!sTmp.empty()) {
		vsRet.push_back(sTmp);
	}

	return vsRet.size();

	/*vsRet.clear();
	CString sTmp = *this;

	while (sTmp.size()) {
		CString sTok = sTmp.Token(0, false, sDelim);
		CString sRest = sTmp.Token(1, true, sDelim);

		if (bAllowEmpty || !sTok.empty()) {
			vsRet.push_back(sTok);
		}

		if (bAllowEmpty && sRest.empty() && sTok.size() < sTmp.size()) {
			vsRet.push_back("""");
		}

		sTmp = sRest;
	}

	return vsRet.size();*/
}

unsigned int CString::Split(const CString& sDelim, SCString& ssRet, bool bAllowEmpty, const CString& sLeft, const CString& sRight) const {
	VCString vsTokens;

	Split(sDelim, vsTokens, bAllowEmpty, sLeft, sRight);

	ssRet.clear();

	for (size_t a = 0; a < vsTokens.size(); a++) {
		ssRet.insert(vsTokens[a]);
	}

	return ssRet.size();
}

CString CString::Format(const CString& sFormatStr, ...) {
	return """";
}

CString CString::RandomString(unsigned int uLength) {
	const char chars[] = ""abcdefghijklmnopqrstuvwxyz""
		""ABCDEFGHIJKLMNOPQRSTUVWXYZ""
		""0123456789!?.,:;/*-+_()"";
	// -1 because sizeof() includes the trailing '\0' byte
	const size_t len = sizeof(chars) / sizeof(chars[0]) - 1;
	size_t p;
	CString sRet;

	for (unsigned int a = 0; a < uLength; a++) {
		p = (size_t) (len * (rand() / (RAND_MAX + 1.0)));
		sRet += chars[p];
	}

	return sRet;
}

bool CString::Base64Encode(unsigned int uWrap) {
	CString sCopy(*this);
	return sCopy.Base64Encode(*this, uWrap);
}

unsigned long CString::Base64Decode() {
	CString sCopy(*this);
	return sCopy.Base64Decode(*this);
}

CString CString::Base64Encode_n(unsigned int uWrap) const {
	CString sRet;
	Base64Encode(sRet, uWrap);
	return sRet;
}

CString CString::Base64Decode_n() const {
	CString sRet;
	Base64Decode(sRet);
	return sRet;
}

bool CString::Base64Encode(CString& sRet, unsigned int uWrap) const {
	static char b64table[] = ""ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"";
	sRet.clear();
	size_t len = size();
	const unsigned char* input = (const unsigned char*) c_str();
	unsigned char *output, *p;
	size_t        i = 0, mod = len % 3, toalloc;
	toalloc = (len / 3) * 4 + (3 - mod) % 3 + 1 + 8;

	if (uWrap) {
		toalloc += len / 57;
		if (len % 57) {
			toalloc++;
		}
	}

	if (toalloc < len) {
		return 0;
	}

	//p = output = (unsigned char *)malloc(toalloc);
	p = output = new unsigned char [toalloc];

	if (!p) {
		return false;
	}

	while (i < len - mod) {
		*p++ = b64table[input[i++] >> 2];
		*p++ = b64table[((input[i - 1] << 4) | (input[i] >> 4)) & 0x3f];
		*p++ = b64table[((input[i] << 2) | (input[i + 1] >> 6)) & 0x3f];
		*p++ = b64table[input[i + 1] & 0x3f];
		i += 2;

		if (uWrap && !(i % 57)) {
			*p++ = '\n';
		}
	}

	if (!mod) {
		if (uWrap && i % 57) {
			*p++ = '\n';
		}
	} else {
		*p++ = b64table[input[i++] >> 2];
		*p++ = b64table[((input[i - 1] << 4) | (input[i] >> 4)) & 0x3f];
		if (mod == 1) {
			*p++ = '=';
		} else {
			*p++ = b64table[(input[i] << 2) & 0x3f];
		}

		*p++ = '=';

		if (uWrap) {
			*p++ = '\n';
		}
	}

	*p = 0;
	sRet = (char*) output;
	delete[] output;
	return true;
}

unsigned long CString::Base64Decode(CString& sRet) const {
	const char* in = c_str();
	char c, c1, *p;
	unsigned long i;
	unsigned long uLen = size();
	char* out = (char*) malloc(size() +1);

	for (i = 0, p = out; i < uLen; i++) {
		c = (char)base64_table[(unsigned char)in[i++]];
		c1 = (char)base64_table[(unsigned char)in[i++]];
		*p++ = (c << 2) | ((c1 >> 4) & 0x3);

		if (i < uLen) {
			if (in[i] == '=') {
				break;
			}
			c = (char)base64_table[(unsigned char)in[i]];
			*p++ = ((c1 << 4) & 0xf0) | ((c >> 2) & 0xf);
		}

		if (++i < uLen) {
			if (in[i] == '=') {
				break;
			}
			*p++ = ((c << 6) & 0xc0) | (char)base64_table[(unsigned char)in[i]];
		}
	}

	*p = '\0';
	unsigned long uRet = p - out;
	sRet.clear();
	sRet.append(out, uRet);
	free(out);

	return uRet;
}

CString CString::MD5() const {
	return (const char*) CMD5(*this);
}

#ifdef HAVE_LIBSSL
CString CString::Encrypt_n(const CString& sPass, const CString& sIvec) {
	CString sRet;
	sRet.Encrypt(sPass, sIvec);
	return sRet;
}

CString CString::Decrypt_n(const CString& sPass, const CString& sIvec) {
	CString sRet;
	sRet.Decrypt(sPass, sIvec);
	return sRet;
}

void CString::Encrypt(const CString& sPass, const CString& sIvec) {
	Crypt(sPass, true, sIvec);
}

void CString::Decrypt(const CString& sPass, const CString& sIvec) {
	Crypt(sPass, false, sIvec);
}

void CString::Crypt(const CString& sPass, bool bEncrypt, const CString& sIvec) {
	unsigned char szIvec[8] = {0,0,0,0,0,0,0,0};
	BF_KEY bKey;

	if (sIvec.length() >= 8) {
		memcpy(szIvec, sIvec.data(), 8);
	}

	BF_set_key(&bKey, sPass.length(), (unsigned char*) sPass.data());
	unsigned int uPad = (length() % 8);

	if (uPad) {
		uPad = 8 - uPad;
		append(uPad, '\0');
	}

	size_t uLen = length();
	unsigned char* szBuff = (unsigned char*) malloc(uLen);
	BF_cbc_encrypt((const unsigned char*) data(), szBuff, uLen, &bKey, szIvec, ((bEncrypt) ? BF_ENCRYPT : BF_DECRYPT));

	clear();
	append((const char*) szBuff, uLen);
	free(szBuff);
}
#endif	// HAVE_LIBSSL

CString CString::ToPercent(double d) {
	char szRet[32];
	snprintf(szRet, 32, ""%.02f%%"", d);
	return szRet;
}

CString CString::ToByteStr(unsigned long long d) {
	const unsigned long long KiB = 1024;
	const unsigned long long MiB = KiB * 1024;
	const unsigned long long GiB = MiB * 1024;
	const unsigned long long TiB = GiB * 1024;

	if (d > TiB) {
		return CString(d / (double) TiB) + "" TiB"";
	} else if (d > GiB) {
		return CString(d / (double) GiB) + "" GiB"";
	} else if (d > MiB) {
		return CString(d / (double) MiB) + "" MiB"";
	} else if (d > KiB) {
		return CString(d / (double) KiB) + "" KiB"";
	}

	return CString(d) + "" B"";
}

bool CString::ToBool() const { return (!Trim_n().Trim_n(""0"").empty() && Trim_n().CaseCmp(""false"") != 0); }
short CString::ToShort() const { return strtoul(this->c_str(), (char**) NULL, 10); }
unsigned short CString::ToUShort() const { return strtoul(this->c_str(), (char**) NULL, 10); }
unsigned int CString::ToUInt() const { return strtoul(this->c_str(), (char**) NULL, 10); }
int CString::ToInt() const { return strtoul(this->c_str(), (char**) NULL, 10); }
unsigned long CString::ToULong() const { return strtoul(c_str(), NULL, 10); }
unsigned long long CString::ToULongLong() const { return strtoull(c_str(), NULL, 10); }
long long CString::ToLongLong() const { return strtoll(c_str(), NULL, 10); }
double CString::ToDouble() const { return strtod(c_str(), NULL); }


bool CString::Trim(const CString& s) {
	bool bLeft = TrimLeft(s);
	return (TrimRight(s) || bLeft);
}

bool CString::TrimLeft(const CString& s) {
	bool bRet = false;

	while (length() && s.find(Left(1)) != CString::npos) {
		LeftChomp();
		bRet = true;
	}

	return bRet;
}

bool CString::TrimRight(const CString& s) {
	bool bRet = false;

	while (length() && s.find(Right(1)) != CString::npos) {
		RightChomp();
		bRet = true;
	}

	return bRet;
}

CString CString::Trim_n(const CString& s) const {
	CString sRet = *this;
	sRet.Trim(s);
	return sRet;
}

CString CString::TrimLeft_n(const CString& s) const {
	CString sRet = *this;
	sRet.TrimLeft(s);
	return sRet;
}

CString CString::TrimRight_n(const CString& s) const {
	CString sRet = *this;
	sRet.TrimRight(s);
	return sRet;
}

CString CString::LeftChomp_n(unsigned int uLen) const {
	CString sRet = *this;
	sRet.LeftChomp(uLen);
	return sRet;
}

CString CString::RightChomp_n(unsigned int uLen) const {
	CString sRet = *this;
	sRet.RightChomp(uLen);
	return sRet;
}

bool CString::LeftChomp(unsigned int uLen) {
	bool bRet = false;

	while ((uLen--) && (length())) {
		erase(0, 1);
		bRet = true;
	}

	return bRet;
}

bool CString::RightChomp(unsigned int uLen) {
	bool bRet = false;

	while ((uLen--) && (length())) {
		erase(length() -1);
		bRet = true;
	}

	return bRet;
}

//////////////// MCString ////////////////
int MCString::WriteToDisk(const CString& sPath, mode_t iMode) {
	if (this->empty())
		return MCS_SUCCESS;

	CFile cFile(sPath);
	if (!cFile.Open(O_WRONLY|O_CREAT|O_TRUNC, iMode)) {
		return MCS_EOPEN;
	}

	for (MCString::iterator it = this->begin(); it != this->end(); it++) {
		CString sKey = it->first;
		CString sValue = it->second;
		if (!WriteFilter(sKey, sValue)) {
			return MCS_EWRITEFIL;
		}

		if (sKey.empty()) {
			continue;
		}

		if (cFile.Write(Encode(sKey) + "" "" +  Encode(sValue) + ""\n"") <= 0) {
			return MCS_EWRITE;
		}
	}

	cFile.Close();

	return MCS_SUCCESS;
}

int MCString::ReadFromDisk(const CString& sPath, mode_t iMode) {
	clear();
	CFile cFile(sPath);
	if (!cFile.Open(O_RDONLY, iMode)) {
		return MCS_EOPEN;
	}

	CString sBuffer;

	while (cFile.ReadLine(sBuffer)) {
		sBuffer.Trim();
		CString sKey = sBuffer.Token(0);
		CString sValue = sBuffer.Token(1);
		Decode(sKey);
		Decode(sValue);

		if (!ReadFilter(sKey, sValue))
			return MCS_EREADFIL;

		(*this)[sKey] = sValue;
	}
	cFile.Close();

	return MCS_SUCCESS;
}


static const char hexdigits[] = ""0123456789abcdef"";

CString& MCString::Encode(CString& sValue) {
	CString sTmp;
	for (CString::iterator it = sValue.begin(); it != sValue.end(); it++) {
		if (isalnum(*it)) {
			sTmp += *it;
		} else {
			sTmp += ""%"";
			sTmp += hexdigits[*it >> 4];
			sTmp += hexdigits[*it & 0xf];
			sTmp += "";"";
		}
	}
	sValue = sTmp;
	return sValue;
}

CString& MCString::Decode(CString& sValue) {
	const char *pTmp = sValue.c_str();
	char *endptr;
	CString sTmp;

	while (*pTmp) {
		if (*pTmp != '%') {
			sTmp += *pTmp++;
		} else {
			char ch = (char) strtol(pTmp + 1, &endptr, 16);
			if (*endptr == ';') {
				sTmp += ch;
				pTmp = ++endptr;
			} else {
				sTmp += *pTmp++;
			}
		}
	}

	sValue = sTmp;
	return sValue;
}














""","""/*
 * Copyright (C) 2004-2008  See the AUTHORS file for details.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 as published
 * by the Free Software Foundation.
 */

#include ""String.h""
#include ""FileUtils.h""
#include ""MD5.h""
#include ""Utils.h""
#include <sstream>

using std::stringstream;

const char* g_szHTMLescapes[256] = {
	""&#0;"", 0, 0, 0, 0, 0, 0, 0, 0, 0,               // 0-9
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                    // 10-19
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                    // 20-29
	0, 0, 0, 0, ""&quot;"", 0, 0, 0, ""&amp;"", ""&#39;"", // 30-39
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                    // 40-49
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                    // 50-59
	""&lt;"", 0, ""&gt;"", 0, 0, 0, 0, 0, 0, 0,          // 60-69
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                    // 70-79
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                    // 80-89
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                    // 90-99
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                    // 100-109
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                    // 110-119
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                    // 120-129
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                    // 130-139
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                    // 140-149
	0, 0, 0, ""&trade;"", 0, 0, 0, 0, 0, 0,            // 150-159
	""&nbsp;"",   // 160
	""&iexcl;"",  // 161
	""&cent;"",   // 162
	""&pound;"",  // 163
	""&curren;"", // 164
	""&yen;"",    // 165
	""&brvbar;"", // 166
	""&sect;"",   // 167
	""&uml;"",    // 168
	""&copy;"",   // 169
	""&ordf;"",   // 170
	""&laquo;"",  // 171
	""&not;"",    // 172
	""&shy;"",    // 173
	""&reg;"",    // 174
	""&macr;"",   // 175
	""&deg;"",    // 176
	""&plusmn;"", // 177
	""&sup2;"",   // 178
	""&sup3;"",   // 179
	""&acute;"",  // 180
	""&micro;"",  // 181
	""&para;"",   // 182
	""&middot;"", // 183
	""&cedil;"",  // 184
	""&sup1;"",   // 185
	""&ordm;"",   // 186
	""&raquo;"",  // 187
	""&frac14;"", // 188
	""&frac12;"", // 189
	""&frac34;"", // 190
	""&iquest;"", // 191
	""&Agrave;"", // 192
	""&Aacute;"", // 193
	""&Acirc;"",  // 194
	""&Atilde;"", // 195
	""&Auml;"",   // 196
	""&Aring;"",  // 197
	""&AElig;"",  // 198
	""&Ccedil;"", // 199
	""&Egrave;"", // 200
	""&Eacute;"", // 201
	""&Ecirc;"",  // 202
	""&Euml;"",   // 203
	""&Igrave;"", // 204
	""&Iacute;"", // 205
	""&Icirc;"",  // 206
	""&Iuml;"",   // 207
	""&ETH;"",    // 208
	""&Ntilde;"", // 209
	""&Ograve;"", // 210
	""&Oacute;"", // 211
	""&Ocirc;"",  // 212
	""&Otilde;"", // 213
	""&Ouml;"",   // 214
	""&times;"",  // 215
	""&Oslash;"", // 216
	""&Ugrave;"", // 217
	""&Uacute;"", // 218
	""&Ucirc;"",  // 219
	""&Uuml;"",   // 220
	""&Yacute;"", // 221
	""&THORN;"",  // 222
	""&szlig;"",  // 223
	""&agrave;"", // 224
	""&aacute;"", // 225
	""&acirc;"",  // 226
	""&atilde;"", // 227
	""&auml;"",   // 228
	""&aring;"",  // 229
	""&aelig;"",  // 230
	""&ccedil;"", // 231
	""&egrave;"", // 232
	""&eacute;"", // 233
	""&ecirc;"",  // 234
	""&euml;"",   // 235
	""&igrave;"", // 236
	""&iacute;"", // 237
	""&icirc;"",  // 238
	""&iuml;"",   // 239
	""&eth;"",    // 240
	""&ntilde;"", // 241
	""&ograve;"", // 242
	""&oacute;"", // 243
	""&ocirc;"",  // 244
	""&otilde;"", // 245
	""&ouml;"",   // 246
	""&divide;"", // 247
	""&oslash;"", // 248
	""&ugrave;"", // 249
	""&uacute;"", // 250
	""&ucirc;"",  // 251
	""&uuml;"",   // 252
	""&yacute;"", // 253
	""&thorn;"",  // 254
	""&yuml;"",   // 255
};

CString::CString(char c) : string() { stringstream s; s << c; *this = s.str(); }
CString::CString(unsigned char c) : string() { stringstream s; s << c; *this = s.str(); }
CString::CString(short i) : string() { stringstream s; s << i; *this = s.str(); }
CString::CString(unsigned short i) : string() { stringstream s; s << i; *this = s.str(); }
CString::CString(int i) : string() { stringstream s; s << i; *this = s.str(); }
CString::CString(unsigned int i) : string() { stringstream s; s << i; *this = s.str(); }
CString::CString(long i) : string() { stringstream s; s << i; *this = s.str(); }
CString::CString(unsigned long i) : string() { stringstream s; s << i; *this = s.str(); }
CString::CString(long long i) : string() { stringstream s; s << i; *this = s.str(); }
CString::CString(unsigned long long i) : string() { stringstream s; s << i; *this = s.str(); }
CString::CString(double i) : string() { stringstream s; s << i; *this = s.str(); }
CString::CString(float i) : string() { stringstream s; s << i; *this = s.str(); }

inline unsigned char* CString::strnchr(const unsigned char* src, unsigned char c, unsigned int iMaxBytes, unsigned char* pFill, unsigned int* piCount) const {
    for (unsigned int a = 0; a < iMaxBytes && *src; a++, src++) {
		if (pFill) {
			pFill[a] = *src;
		}

		if (*src == c) {
			if (pFill) {
				pFill[a +1] = 0;
			}

			if (piCount) {
				*piCount = a;
			}

			return (unsigned char*) src;
		}
	}

	if (pFill) {
		*pFill = 0;
	}

	if (piCount) {
		*piCount = 0;
	}

    return NULL;
}

int CString::CaseCmp(const CString& s, u_long uLen) const {
	if (uLen != CString::npos) {
		return strncasecmp(c_str(), s.c_str(), uLen);
	}
	return strcasecmp(c_str(), s.c_str());
}

int CString::StrCmp(const CString& s) const {
	return strcmp(c_str(), s.c_str());
}

bool CString::WildCmp(const CString& sWild, const CString& sString) {
	// Written by Jack Handy - jakkhandy@hotmail.com
	const char *wild = sWild.c_str(), *CString = sString.c_str();
	const char *cp = NULL, *mp = NULL;

	while ((*CString) && (*wild != '*')) {
		if ((*wild != *CString) && (*wild != '?')) {
			return false;
		}

		wild++;
		CString++;
	}

	while (*CString) {
		if (*wild == '*') {
			if (!*++wild) {
				return true;
			}

			mp = wild;
			cp = CString+1;
		} else if ((*wild == *CString) || (*wild == '?')) {
			wild++;
			CString++;
		} else {
			wild = mp;
			CString = cp++;
		}
	}

	while (*wild == '*') {
		wild++;
	}

	return (*wild == 0);
}

bool CString::WildCmp(const CString& sWild) const {
	return CString::WildCmp(sWild, *this);
}

CString& CString::MakeUpper() {
	for (unsigned int a = 0; a < length(); a++) {
		char& c = (*this)[a];
		c = toupper(c);
	}

	return *this;
}

CString& CString::MakeLower() {
	for (unsigned int a = 0; a < length(); a++) {
		char& c = (*this)[a];
		c = tolower(c);
	}

	return *this;
}

CString CString::AsUpper() const {
	CString sRet = *this;

	for (unsigned int a = 0; a < length(); a++) {
		char& c = sRet[a];
		c = toupper(c);
	}

	return sRet;
}

CString CString::AsLower() const {
	CString sRet = *this;

	for (unsigned int a = 0; a < length(); a++) {
		char& c = sRet[a];
		c = tolower(c);
	}

	return sRet;
}

CString::EEscape CString::ToEscape(const CString& sEsc) {
	if (sEsc.CaseCmp(""ASCII"") == 0) {
		return EASCII;
	} else if (sEsc.CaseCmp(""HTML"") == 0) {
		return EHTML;
	} else if (sEsc.CaseCmp(""URL"") == 0) {
		return EURL;
	} else if (sEsc.CaseCmp(""SQL"") == 0) {
		return ESQL;
	}

	return EASCII;
}

CString CString::Escape_n(EEscape eFrom, EEscape eTo) const {
	CString sRet;
	const char szHex[] = ""0123456789ABCDEF"";
	const unsigned char *pStart = (const unsigned char*) data();
	const unsigned char *p = (const unsigned char*) data();
	unsigned int iLength = length();
	sRet.reserve(iLength *3);
	unsigned int iMaxLen = (eFrom == EHTML) ? 20 : 0;
	unsigned char pTmp[iMaxLen +1];
	unsigned int iCounted = 0;

	for (unsigned int a = 0; a < iLength; a++, p = pStart + a) {
		unsigned char ch = 0;

		switch (eFrom) {
			case EHTML:
				if ((*p == '&') && (strnchr((unsigned char*) p, ';', iMaxLen, pTmp, &iCounted))) {
					if ((iCounted >= 3) && (pTmp[1] == '#')) {	// do XML and HTML &#97; &#x3c
						int base = 10;

						if ((pTmp[2] & 0xDF) == 'X') {
							base = 16;
						}

						char* endptr = NULL;
						unsigned int b = strtol((const char*) (pTmp +2 + (base == 16)), &endptr, base);

						if ((*endptr == ';') && (b <= 255)) { // incase they do something like &#7777777777;
							ch = b;
							a += iCounted;
							break;
						}
					}

					for (unsigned int c = 0; c < 256; c++) {
						if (g_szHTMLescapes[c] && strcmp(g_szHTMLescapes[c], (const char*) &pTmp) == 0) {
							ch = c;
							break;
						}
					}

					if (ch > 0) {
						a += iCounted;
					} else {
						ch = *p;	 // Not a valid escape, just record the &
					}
				} else {
					ch = *p;
				}
				break;
			case EASCII:
				ch = *p;
				break;
			case EURL:
				if (*p == '%' && (a +2) < iLength && isxdigit(*(p +1)) && isxdigit(*(p +2))) {
					p++;
					if (isdigit(*p)) {
						ch = (*p - '0') << 4;
					} else {
						ch = (tolower(*p) - 'a' +10) << 4;
					}

					p++;
					if (isdigit(*p)) {
						ch |= (*p - '0');
					} else {
						ch |= (tolower(*p) - 'a' +10);
					}

					a += 2;
				} else if (pStart[a] == '+') {
					ch = ' ';
				} else {
					ch = *p;
				}

				break;
			case ESQL:
				if (*p != '\\' || iLength < (a +1)) {
					ch = *p;
				} else {
					a++;
					p++;

					if (*p == 'n') {
						ch = '\n';
					} else if (*p == 'r') {
						ch = '\r';
					} else if (*p == '0') {
						ch = '\0';
					} else if (*p == 't') {
						ch = '\t';
					} else if (*p == 'b') {
						ch = '\b';
					} else {
						ch = *p;
					}
				}

				break;
		}

		switch (eTo) {
			case EHTML:
				if (g_szHTMLescapes[ch]) {
					sRet += g_szHTMLescapes[ch];
				} else {
					sRet += ch;
				}

				break;
			case EASCII:
				sRet += ch;
				break;
			case EURL:
				if (isalnum(ch) || ch == '_' || ch == '.' || ch == '-') {
					sRet += ch;
				} else if (ch == ' ') {
					sRet += '+';
				} else {
					sRet += '%';
					sRet += szHex[ch >> 4];
					sRet += szHex[ch & 0xf];
				}

				break;
			case ESQL:
				if (ch == '\0') { sRet += '\\'; sRet += '0';
				} else if (ch == '\n') { sRet += '\\'; sRet += 'n';
				} else if (ch == '\t') { sRet += '\\'; sRet += 't';
				} else if (ch == '\r') { sRet += '\\'; sRet += 'r';
				} else if (ch == '\b') { sRet += '\\'; sRet += 'b';
				} else if (ch == '\""') { sRet += '\\'; sRet += '\""';
				} else if (ch == '\'') { sRet += '\\'; sRet += '\'';
				} else if (ch == '\\') { sRet += '\\'; sRet += '\\';
				} else { sRet += ch; }

				break;
		}
	}

	sRet.reserve(0);
	return sRet;
}

CString CString::Escape_n(EEscape eTo) const {
	return Escape_n(EASCII, eTo);
}

CString& CString::Escape(EEscape eFrom, EEscape eTo) {
	return (*this = Escape_n(eFrom, eTo));
}

CString& CString::Escape(EEscape eTo) {
	return (*this = Escape_n(eTo));
}

CString CString::Replace_n(const CString& sReplace, const CString& sWith, const CString& sLeft, const CString& sRight, bool bRemoveDelims) const {
	CString sRet = *this;
	CString::Replace(sRet, sReplace, sWith, sLeft, sRight, bRemoveDelims);
	return sRet;
}

unsigned int CString::Replace(const CString& sReplace, const CString& sWith, const CString& sLeft, const CString& sRight, bool bRemoveDelims) {
	return CString::Replace(*this, sReplace, sWith, sLeft, sRight, bRemoveDelims);
}

unsigned int CString::Replace(CString& sStr, const CString& sReplace, const CString& sWith, const CString& sLeft, const CString& sRight, bool bRemoveDelims) {
	unsigned int uRet = 0;
	CString sCopy = sStr;
	sStr.clear();

	unsigned int uReplaceWidth = sReplace.length();
	unsigned int uLeftWidth = sLeft.length();
	unsigned int uRightWidth = sRight.length();
	const char* p = sCopy.c_str();
	bool bInside = false;

	while (*p) {
		if (!bInside && uLeftWidth && strncmp(p, sLeft.c_str(), uLeftWidth) == 0) {
			if (!bRemoveDelims) {
				sStr += sLeft;
			}

			p += uLeftWidth -1;
			bInside = true;
		} else if (bInside && uRightWidth && strncmp(p, sRight.c_str(), uRightWidth) == 0) {
			if (!bRemoveDelims) {
				sStr += sRight;
			}

			p += uRightWidth -1;
			bInside = false;
		} else if (!bInside && strncmp(p, sReplace.c_str(), uReplaceWidth) == 0) {
			sStr += sWith;
			p += uReplaceWidth -1;
			uRet++;
		} else {
			sStr.append(p, 1);
		}

		p++;
	}

	return uRet;
}

CString CString::Token(unsigned int uPos, bool bRest, const CString& sSep) const {
	const char *sep_str = sSep.c_str();
	size_t sep_len = sSep.length();
	const char *str = c_str();
	size_t str_len = length();
	size_t start_pos = 0;
	size_t end_pos;

	// First, find the start of our token
	while (uPos != 0 && start_pos < str_len) {
		if (strncmp(&str[start_pos], sep_str, sep_len) == 0) {
			start_pos += sep_len;
			uPos--;
		} else {
			start_pos++;
		}
	}

	// String is over?
	if (start_pos >= str_len)
		return """";

	// If they want everything from here on, give it to them
	if (bRest) {
		return substr(start_pos);
	}

	// Now look for the end of the token they want
	end_pos = start_pos;
	while (end_pos < str_len) {
		if (strncmp(&str[end_pos], sep_str, sep_len) == 0)
			return substr(start_pos, end_pos - start_pos);

		end_pos++;
	}

	// They want the last token in the string, not something in between
	return substr(start_pos);
}

CString CString::Ellipsize(unsigned int uLen) const {
	if (uLen >= size()) {
		return *this;
	}

	string sRet;

	// @todo this looks suspect
	if (uLen < 4) {
		for (unsigned int a = 0; a < uLen; a++) {
			sRet += ""."";
		}

		return sRet;
	}

	sRet = substr(0, uLen -3) + ""..."";

	return sRet;
}

CString CString::Left(unsigned int uCount) const {
	uCount = (uCount > length()) ? length() : uCount;
	return substr(0, uCount);
}

CString CString::Right(unsigned int uCount) const {
	uCount = (uCount > length()) ? length() : uCount;
	return substr(length() - uCount, uCount);
}

unsigned int CString::URLSplit(MCString& msRet) const {
	msRet.clear();

	VCString vsPairs;
	Split(""&"", vsPairs);

	for (size_t a = 0; a < vsPairs.size(); a++) {
		const CString& sPair = vsPairs[a];

		msRet[sPair.Token(0, false, ""="").Escape(CString::EURL, CString::EASCII)] = sPair.Token(1, true, ""="").Escape(CString::EURL, CString::EASCII);
	}

	return msRet.size();
}

unsigned int CString::Split(const CString& sDelim, VCString& vsRet, bool bAllowEmpty, const CString& sLeft, const CString& sRight) const {
	vsRet.clear();

	if (empty()) {
		return 0;
	}

	CString sTmp;
	bool bInside = false;
	unsigned int uDelimLen = sDelim.length();
	unsigned int uLeftLen = sLeft.length();
	unsigned int uRightLen = sRight.length();
	const char* p = c_str();

	if (!bAllowEmpty) {
		while (strncasecmp(p, sDelim.c_str(), uDelimLen) == 0) {
			p += uDelimLen;
		}
	}

	while (*p) {
		if (uLeftLen && uRightLen && !bInside && strncasecmp(p, sLeft.c_str(), uLeftLen) == 0) {
			p += uLeftLen;
			bInside = true;
			continue;
		}

		if (uLeftLen && uRightLen && bInside && strncasecmp(p, sRight.c_str(), uRightLen) == 0) {
			p += uRightLen;
			bInside = false;
			continue;
		}

		if (uDelimLen && !bInside && strncasecmp(p, sDelim.c_str(), uDelimLen) == 0) {
			vsRet.push_back(sTmp);
			sTmp.clear();
			p += uDelimLen;

			if (!bAllowEmpty) {
				while (strncasecmp(p, sDelim.c_str(), uDelimLen) == 0) {
					p += uDelimLen;
				}
			}

			bInside = false;
			continue;
		} else {
			sTmp += *p;
		}

		p++;
	}

	if (!sTmp.empty()) {
		vsRet.push_back(sTmp);
	}

	return vsRet.size();

	/*vsRet.clear();
	CString sTmp = *this;

	while (sTmp.size()) {
		CString sTok = sTmp.Token(0, false, sDelim);
		CString sRest = sTmp.Token(1, true, sDelim);

		if (bAllowEmpty || !sTok.empty()) {
			vsRet.push_back(sTok);
		}

		if (bAllowEmpty && sRest.empty() && sTok.size() < sTmp.size()) {
			vsRet.push_back("""");
		}

		sTmp = sRest;
	}

	return vsRet.size();*/
}

unsigned int CString::Split(const CString& sDelim, SCString& ssRet, bool bAllowEmpty, const CString& sLeft, const CString& sRight) const {
	VCString vsTokens;

	Split(sDelim, vsTokens, bAllowEmpty, sLeft, sRight);

	ssRet.clear();

	for (size_t a = 0; a < vsTokens.size(); a++) {
		ssRet.insert(vsTokens[a]);
	}

	return ssRet.size();
}

CString CString::Format(const CString& sFormatStr, ...) {
	return """";
}

CString CString::RandomString(unsigned int uLength) {
	const char chars[] = ""abcdefghijklmnopqrstuvwxyz""
		""ABCDEFGHIJKLMNOPQRSTUVWXYZ""
		""0123456789!?.,:;/*-+_()"";
	// -1 because sizeof() includes the trailing '\0' byte
	const size_t len = sizeof(chars) / sizeof(chars[0]) - 1;
	size_t p;
	CString sRet;

	for (unsigned int a = 0; a < uLength; a++) {
		p = (size_t) (len * (rand() / (RAND_MAX + 1.0)));
		sRet += chars[p];
	}

	return sRet;
}

bool CString::Base64Encode(unsigned int uWrap) {
	CString sCopy(*this);
	return sCopy.Base64Encode(*this, uWrap);
}

unsigned long CString::Base64Decode() {
	CString sCopy(*this);
	return sCopy.Base64Decode(*this);
}

CString CString::Base64Encode_n(unsigned int uWrap) const {
	CString sRet;
	Base64Encode(sRet, uWrap);
	return sRet;
}

CString CString::Base64Decode_n() const {
	CString sRet;
	Base64Decode(sRet);
	return sRet;
}

bool CString::Base64Encode(CString& sRet, unsigned int uWrap) const {
	static char b64table[] = ""ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"";
	sRet.clear();
	size_t len = size();
	const unsigned char* input = (const unsigned char*) c_str();
	unsigned char *output, *p;
	size_t        i = 0, mod = len % 3, toalloc;
	toalloc = (len / 3) * 4 + (3 - mod) % 3 + 1 + 8;

	if (uWrap) {
		toalloc += len / 57;
		if (len % 57) {
			toalloc++;
		}
	}

	if (toalloc < len) {
		return 0;
	}

	//p = output = (unsigned char *)malloc(toalloc);
	p = output = new unsigned char [toalloc];

	if (!p) {
		return false;
	}

	while (i < len - mod) {
		*p++ = b64table[input[i++] >> 2];
		*p++ = b64table[((input[i - 1] << 4) | (input[i] >> 4)) & 0x3f];
		*p++ = b64table[((input[i] << 2) | (input[i + 1] >> 6)) & 0x3f];
		*p++ = b64table[input[i + 1] & 0x3f];
		i += 2;

		if (uWrap && !(i % 57)) {
			*p++ = '\n';
		}
	}

	if (!mod) {
		if (uWrap && i % 57) {
			*p++ = '\n';
		}
	} else {
		*p++ = b64table[input[i++] >> 2];
		*p++ = b64table[((input[i - 1] << 4) | (input[i] >> 4)) & 0x3f];
		if (mod == 1) {
			*p++ = '=';
		} else {
			*p++ = b64table[(input[i] << 2) & 0x3f];
		}

		*p++ = '=';

		if (uWrap) {
			*p++ = '\n';
		}
	}

	*p = 0;
	sRet = (char*) output;
	delete[] output;
	return true;
}

unsigned long CString::Base64Decode(CString& sRet) const {
	const char* in = c_str();
	char c, c1, *p;
	unsigned long i;
	unsigned long uLen = size();
	char* out = (char*) malloc(size() +1);

	for (i = 0, p = out; i < uLen; i++) {
		c = (char)base64_table[(unsigned char)in[i++]];
		c1 = (char)base64_table[(unsigned char)in[i++]];
		*p++ = (c << 2) | ((c1 >> 4) & 0x3);

		if (i < uLen) {
			if (in[i] == '=') {
				break;
			}
			c = (char)base64_table[(unsigned char)in[i]];
			*p++ = ((c1 << 4) & 0xf0) | ((c >> 2) & 0xf);
		}

		if (++i < uLen) {
			if (in[i] == '=') {
				break;
			}
			*p++ = ((c << 6) & 0xc0) | (char)base64_table[(unsigned char)in[i]];
		}
	}

	*p = '\0';
	unsigned long uRet = p - out;
	sRet.clear();
	sRet.append(out, uRet);
	free(out);

	return uRet;
}

CString CString::MD5() const {
	return (const char*) CMD5(*this);
}

#ifdef HAVE_LIBSSL
CString CString::Encrypt_n(const CString& sPass, const CString& sIvec) {
	CString sRet;
	sRet.Encrypt(sPass, sIvec);
	return sRet;
}

CString CString::Decrypt_n(const CString& sPass, const CString& sIvec) {
	CString sRet;
	sRet.Decrypt(sPass, sIvec);
	return sRet;
}

void CString::Encrypt(const CString& sPass, const CString& sIvec) {
	Crypt(sPass, true, sIvec);
}

void CString::Decrypt(const CString& sPass, const CString& sIvec) {
	Crypt(sPass, false, sIvec);
}

void CString::Crypt(const CString& sPass, bool bEncrypt, const CString& sIvec) {
	unsigned char szIvec[8] = {0,0,0,0,0,0,0,0};
	BF_KEY bKey;

	if (sIvec.length() >= 8) {
		memcpy(szIvec, sIvec.data(), 8);
	}

	BF_set_key(&bKey, sPass.length(), (unsigned char*) sPass.data());
	unsigned int uPad = (length() % 8);

	if (uPad) {
		uPad = 8 - uPad;
		append(uPad, '\0');
	}

	size_t uLen = length();
	unsigned char* szBuff = (unsigned char*) malloc(uLen);
	BF_cbc_encrypt((const unsigned char*) data(), szBuff, uLen, &bKey, szIvec, ((bEncrypt) ? BF_ENCRYPT : BF_DECRYPT));

	clear();
	append((const char*) szBuff, uLen);
	free(szBuff);
}
#endif	// HAVE_LIBSSL

CString CString::ToPercent(double d) {
	char szRet[32];
	snprintf(szRet, 32, ""%.02f%%"", d);
	return szRet;
}

CString CString::ToByteStr(unsigned long long d) {
	const unsigned long long KiB = 1024;
	const unsigned long long MiB = KiB * 1024;
	const unsigned long long GiB = MiB * 1024;
	const unsigned long long TiB = GiB * 1024;

	if (d > TiB) {
		return CString(d / (double) TiB) + "" TiB"";
	} else if (d > GiB) {
		return CString(d / (double) GiB) + "" GiB"";
	} else if (d > MiB) {
		return CString(d / (double) MiB) + "" MiB"";
	} else if (d > KiB) {
		return CString(d / (double) KiB) + "" KiB"";
	}

	return CString(d) + "" B"";
}

bool CString::ToBool() const { return (!Trim_n().Trim_n(""0"").empty() && Trim_n().CaseCmp(""false"") != 0); }
short CString::ToShort() const { return strtoul(this->c_str(), (char**) NULL, 10); }
unsigned short CString::ToUShort() const { return strtoul(this->c_str(), (char**) NULL, 10); }
unsigned int CString::ToUInt() const { return strtoul(this->c_str(), (char**) NULL, 10); }
int CString::ToInt() const { return strtoul(this->c_str(), (char**) NULL, 10); }
unsigned long CString::ToULong() const { return strtoul(c_str(), NULL, 10); }
unsigned long long CString::ToULongLong() const { return strtoull(c_str(), NULL, 10); }
long long CString::ToLongLong() const { return strtoll(c_str(), NULL, 10); }
double CString::ToDouble() const { return strtod(c_str(), NULL); }


bool CString::Trim(const CString& s) {
	bool bLeft = TrimLeft(s);
	return (TrimRight(s) || bLeft);
}

bool CString::TrimLeft(const CString& s) {
	bool bRet = false;

	while (length() && s.find(Left(1)) != CString::npos) {
		LeftChomp();
		bRet = true;
	}

	return bRet;
}

bool CString::TrimRight(const CString& s) {
	bool bRet = false;

	while (length() && s.find(Right(1)) != CString::npos) {
		RightChomp();
		bRet = true;
	}

	return bRet;
}

CString CString::Trim_n(const CString& s) const {
	CString sRet = *this;
	sRet.Trim(s);
	return sRet;
}

CString CString::TrimLeft_n(const CString& s) const {
	CString sRet = *this;
	sRet.TrimLeft(s);
	return sRet;
}

CString CString::TrimRight_n(const CString& s) const {
	CString sRet = *this;
	sRet.TrimRight(s);
	return sRet;
}

CString CString::LeftChomp_n(unsigned int uLen) const {
	CString sRet = *this;
	sRet.LeftChomp(uLen);
	return sRet;
}

CString CString::RightChomp_n(unsigned int uLen) const {
	CString sRet = *this;
	sRet.RightChomp(uLen);
	return sRet;
}

bool CString::LeftChomp(unsigned int uLen) {
	bool bRet = false;

	while ((uLen--) && (length())) {
		erase(0, 1);
		bRet = true;
	}

	return bRet;
}

bool CString::RightChomp(unsigned int uLen) {
	bool bRet = false;

	while ((uLen--) && (length())) {
		erase(length() -1);
		bRet = true;
	}

	return bRet;
}

//////////////// MCString ////////////////
int MCString::WriteToDisk(const CString& sPath, mode_t iMode) {
	if (this->empty())
		return MCS_SUCCESS;

	CFile cFile(sPath);
	if (!cFile.Open(O_WRONLY|O_CREAT|O_TRUNC, iMode)) {
		return MCS_EOPEN;
	}

	for (MCString::iterator it = this->begin(); it != this->end(); it++) {
		CString sKey = it->first;
		CString sValue = it->second;
		if (!WriteFilter(sKey, sValue)) {
			return MCS_EWRITEFIL;
		}

		if (sKey.empty()) {
			continue;
		}

		if (cFile.Write(Encode(sKey) + "" "" +  Encode(sValue) + ""\n"") <= 0) {
			return MCS_EWRITE;
		}
	}

	cFile.Close();

	return MCS_SUCCESS;
}

int MCString::ReadFromDisk(const CString& sPath, mode_t iMode) {
	clear();
	CFile cFile(sPath);
	if (!cFile.Open(O_RDONLY, iMode)) {
		return MCS_EOPEN;
	}

	CString sBuffer;

	while (cFile.ReadLine(sBuffer)) {
		sBuffer.Trim();
		CString sKey = sBuffer.Token(0);
		CString sValue = sBuffer.Token(1);
		Decode(sKey);
		Decode(sValue);

		if (!ReadFilter(sKey, sValue))
			return MCS_EREADFIL;

		(*this)[sKey] = sValue;
	}
	cFile.Close();

	return MCS_SUCCESS;
}


static const char hexdigits[] = ""0123456789abcdef"";

CString& MCString::Encode(CString& sValue) {
	CString sTmp;
	for (CString::iterator it = sValue.begin(); it != sValue.end(); it++) {
		if (isalnum(*it)) {
			sTmp += *it;
		} else {
			sTmp += ""%"";
			sTmp += hexdigits[*it >> 4];
			sTmp += hexdigits[*it & 0xf];
			sTmp += "";"";
		}
	}
	sValue = sTmp;
	return sValue;
}

CString& MCString::Decode(CString& sValue) {
	const char *pTmp = sValue.c_str();
	char *endptr;
	CString sTmp;

	while (*pTmp) {
		if (*pTmp != '%') {
			sTmp += *pTmp++;
		} else {
			char ch = (char) strtol(pTmp + 1, &endptr, 16);
			if (*endptr == ';') {
				sTmp += ch;
				pTmp = ++endptr;
			} else {
				sTmp += *pTmp++;
			}
		}
	}

	sValue = sTmp;
	return sValue;
}














""",CString::Token,[489:527]
znc,https://github.com/znc/znc/commit/3b0a4dc4b5f5aaa8ae40b3b902b468f5dbb7ff01,"""Config reading: Apply a small (unnoticeable) optimization

Trim() always removes all trailing and leading spaces and line endings from
that string, so there is no point in this main loop. It will always run once,
anyway.


git-svn-id: https://znc.svn.sourceforge.net/svnroot/znc/trunk@1124 726aef4b-f618-498e-8847-2d620e286838""","""/*
 * Copyright (C) 2004-2008  See the AUTHORS file for details.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 as published
 * by the Free Software Foundation.
 */

#include ""znc.h""
#include ""Chan.h""
#include ""IRCSock.h""
#include ""Server.h""
#include ""User.h""
#include <pwd.h>
#include <list>

namespace
{ // private namespace for local things
	struct CGlobalModuleConfigLine
	{
		CString	m_sName;
		CString	m_sValue;
		CUser	*m_pUser;
		CChan	*m_pChan;
	};
};

CZNC::CZNC() {
#ifdef _MODULES
	m_pModules = new CGlobalModules();
#endif
	m_pISpoofLockFile = NULL;
	m_uiConnectDelay = 30;
	SetISpoofFormat(""""); // Set ISpoofFormat to default
	m_uBytesRead = 0;
	m_uBytesWritten = 0;
	m_pConnectUserTimer = NULL;
	m_bNeedRehash = false;
	m_TimeStarted = time(NULL);
}

CZNC::~CZNC() {
	if (m_pISpoofLockFile)
		ReleaseISpoof();

#ifdef _MODULES
	m_pModules->UnloadAll();

	for (map<CString,CUser*>::iterator a = m_msUsers.begin(); a != m_msUsers.end(); a++) {
		a->second->GetModules().UnloadAll();
	}
#endif

	for (size_t b = 0; b < m_vpListeners.size(); b++) {
		delete m_vpListeners[b];
	}

	for (map<CString,CUser*>::iterator a = m_msUsers.begin(); a != m_msUsers.end(); a++) {
		a->second->SetBeingDeleted(true);
	}

	m_pConnectUserTimer = NULL;
	// This deletes m_pConnectUserTimer
	m_Manager.Cleanup();
	DeleteUsers();

#ifdef _MODULES
	delete m_pModules;
#endif

	DeletePidFile();
}

CString CZNC::GetVersion() {
	char szBuf[128];

	snprintf(szBuf, sizeof(szBuf), ""%1.3f""VERSION_EXTRA, VERSION);
	// If snprintf overflows (which I doubt), we want to be on the safe side
	szBuf[sizeof(szBuf) - 1] = '\0';

	return szBuf;
}

CString CZNC::GetTag(bool bIncludeVersion) {
	if (!bIncludeVersion) {
		return ""ZNC - http://znc.sourceforge.net"";
	}

	char szBuf[128];
	snprintf(szBuf, sizeof(szBuf), ""ZNC %1.3f""VERSION_EXTRA"" - http://znc.sourceforge.net"", VERSION);
	// If snprintf overflows (which I doubt), we want to be on the safe side
	szBuf[sizeof(szBuf) - 1] = '\0';

	return szBuf;
}

CString CZNC::GetUptime() {
	time_t now = time(NULL);
	return CString::ToTimeStr(now - TimeStarted());
}

bool CZNC::OnBoot() {
#ifdef _MODULES
	if (!GetModules().OnBoot()) {
		return false;
	}

	for (map<CString,CUser*>::iterator it = m_msUsers.begin(); it != m_msUsers.end(); it++) {
		if (!it->second->GetModules().OnBoot()) {
			return false;
		}
	}
#endif

	return true;
}

bool CZNC::ConnectUser(CUser *pUser) {
	CString sSockName = ""IRC::"" + pUser->GetUserName();
	// Don't use pUser->GetIRCSock(), as that only returns something if the
	// CIRCSock is already connected, not when it's still connecting!
	CIRCSock* pIRCSock = (CIRCSock*) m_Manager.FindSockByName(sSockName);

	if (m_pISpoofLockFile != NULL) {
		return false;
	}

	if (!pUser->GetIRCConnectEnabled())
		return false;

	if (pIRCSock || !pUser->HasServers())
		return false;

	if (pUser->ConnectPaused())
		return false;

	CServer* pServer = pUser->GetNextServer();

	if (!pServer)
		return false;

	if (!WriteISpoof(pUser)) {
		DEBUG_ONLY(cout << ""ISpoof could not be written"" << endl);
		pUser->PutStatus(""ISpoof could not be written, retrying..."");
		return true;
	}

	DEBUG_ONLY(cout << ""User ["" << pUser->GetUserName() << ""] is connecting to ["" << pServer->GetName() << "":"" << pServer->GetPort() << ""] ..."" << endl);
	pUser->PutStatus(""Attempting to connect to ["" + pServer->GetName() + "":"" + CString(pServer->GetPort()) + ""] ..."");

	pIRCSock = new CIRCSock(pUser);
	pIRCSock->SetPass(pServer->GetPass());

	bool bSSL = false;
#ifdef HAVE_LIBSSL
	if (pServer->IsSSL()) {
		bSSL = true;
	}
#endif

	if (!m_Manager.Connect(pServer->GetName(), pServer->GetPort(), sSockName, 120, bSSL, pUser->GetVHost(), pIRCSock)) {
		ReleaseISpoof();
		pUser->PutStatus(""Unable to connect. (Bad host?)"");
	}

	return true;
}

bool CZNC::HandleUserDeletion()
{
	map<CString, CUser*>::iterator it;
	map<CString, CUser*>::iterator end;

	if (m_msDelUsers.size() == 0)
		return false;

	end = m_msDelUsers.end();
	for (it = m_msDelUsers.begin(); it != end; it++) {
		CUser* pUser = it->second;
		pUser->SetBeingDeleted(true);

#ifdef _MODULES
		if (GetModules().OnDeleteUser(*pUser)) {
			pUser->SetBeingDeleted(false);
			continue;
		}
#endif
		m_msUsers.erase(pUser->GetUserName());

		CIRCSock* pIRCSock = pUser->GetIRCSock();

		if (pIRCSock) {
			m_Manager.DelSockByAddr(pIRCSock);
		}

		pUser->DelClients();
#ifdef _MODULES
		pUser->DelModules();
#endif
		AddBytesRead(pUser->BytesRead());
		AddBytesWritten(pUser->BytesWritten());
		delete pUser;
	}

	m_msDelUsers.clear();
	RestartConnectUser();

	return true;
}

int CZNC::Loop() {
	while (true) {
		CString sError;
		map<CString, CUser*>::iterator it;
		map<CString, CUser*>::iterator end;

		if (GetNeedRehash()) {
			SetNeedRehash(false);

			if (RehashConfig(sError)) {
				Broadcast(""Rehashing succeeded"", true);
			} else {
				Broadcast(""Rehashing failed: "" + sError, true);
				Broadcast(""ZNC is in some possibly inconsistent state!"", true);
			}
		}

		// Check for users that need to be deleted
		if (HandleUserDeletion()) {
			// Also remove those user(s) from the config file
			WriteConfig();
		}

		// Csocket wants micro seconds
		// 500 msec to 600 sec
		m_Manager.DynamicSelectLoop(500 * 1000, 600 * 1000 * 1000);
	}

	return 0;
}

bool CZNC::WriteISpoof(CUser* pUser) {
	if (m_pISpoofLockFile != NULL)
		return false;

	if (!m_sISpoofFile.empty()) {
		m_pISpoofLockFile = new CLockFile;
		if (!m_pISpoofLockFile->TryExLock(m_sISpoofFile, true)) {
			delete m_pISpoofLockFile;
			m_pISpoofLockFile = NULL;
			return false;
		}

		CFile File(m_pISpoofLockFile->GetFD(), m_pISpoofLockFile->GetFileName());

		char buf[1024];
		memset((char*) buf, 0, 1024);
		File.Read(buf, 1023);
		m_sOrigISpoof = buf;

		if (!File.Seek(0) || !File.Truncate()) {
			delete m_pISpoofLockFile;
			m_pISpoofLockFile = NULL;
			return false;
		}

		CString sData = m_sISpoofFormat.Token(0, false, ""%"") + pUser->GetIdent() + m_sISpoofFormat.Token(1, true, ""%"");
		File.Write(sData + ""\n"");
	}
	return true;
}

void CZNC::ReleaseISpoof() {
	if (m_pISpoofLockFile == NULL)
		return;

	if (!m_sISpoofFile.empty()) {
		CFile File(m_pISpoofLockFile->GetFD(), m_pISpoofLockFile->GetFileName());

		if (File.Seek(0) && File.Truncate()) {
			File.Write(m_sOrigISpoof);
		}

		m_sOrigISpoof = """";
	}

	delete m_pISpoofLockFile;
	m_pISpoofLockFile = NULL;
}

bool CZNC::WritePidFile(int iPid) {
	if (!m_sPidFile.empty()) {
		CString sFile;

		// absolute path or relative to the data dir?
		if (m_sPidFile[0] != '/')
			sFile = GetZNCPath() + ""/"" + m_sPidFile;
		else
			sFile = m_sPidFile;

		CFile File(sFile);
		CUtils::PrintAction(""Writing pid file ["" + sFile + ""]"");

		if (File.Open(O_WRONLY | O_TRUNC | O_CREAT)) {
			File.Write(CString(iPid) + ""\n"");
			File.Close();
			CUtils::PrintStatus(true);
			return true;
		}

		CUtils::PrintStatus(false);
	}

	return false;
}

bool CZNC::DeletePidFile() {
	if (!m_sPidFile.empty()) {
		CString sFile;
		// absolute path or relative to the data dir?
		if (m_sPidFile[0] != '/')
			sFile = GetZNCPath() + ""/"" + m_sPidFile;
		else
			sFile = m_sPidFile;

		CFile File(sFile);
		CUtils::PrintAction(""Deleting pid file ["" + sFile + ""]"");
		if (File.Delete()) {
			CUtils::PrintStatus(true);
			return true;
		}
		CUtils::PrintStatus(false);
	}
	return false;
}

bool CZNC::WritePemFile(bool bEncPem) {
#ifndef HAVE_LIBSSL
	CUtils::PrintError(""ZNC was not compiled with ssl support."");
	return false;
#else
	CString sPemFile = GetPemLocation();
	const char* pHostName = getenv(""HOSTNAME"");
	CString sHost;

	if (pHostName) {
		sHost = pHostName;
	}

	if (CFile::Exists(sPemFile)) {
		CUtils::PrintError(""Pem file ["" + sPemFile + ""] already exists"");
		return false;
	}

	while (!CUtils::GetInput(""hostname of your shell"", sHost, sHost, ""including the '.com' portion"")) ;

	CUtils::PrintAction(""Writing Pem file ["" + sPemFile + ""]"");
	FILE *f = fopen(sPemFile.c_str(), ""w"");

	if (!f) {
		CUtils::PrintStatus(false, ""Unable to open"");
		return false;
	}

	CUtils::GenerateCert(f, bEncPem, sHost);
	fclose(f);

	CUtils::PrintStatus(true);
	return true;
#endif
}

void CZNC::DeleteUsers() {
	for (map<CString,CUser*>::iterator a = m_msUsers.begin(); a != m_msUsers.end(); a++) {
		a->second->SetBeingDeleted(true);
		delete a->second;
	}

	m_msUsers.clear();
	DisableConnectUser();
}

CUser* CZNC::GetUser(const CString& sUser) {
	// Todo: make this case insensitive
	map<CString,CUser*>::iterator it = m_msUsers.find(sUser);
	return (it == m_msUsers.end()) ? NULL : it->second;
}

Csock* CZNC::FindSockByName(const CString& sSockName) {
	return m_Manager.FindSockByName(sSockName);
}

bool CZNC::IsHostAllowed(const CString& sHostMask) {
	for (map<CString,CUser*>::iterator a = m_msUsers.begin(); a != m_msUsers.end(); a++) {
		if (a->second->IsHostAllowed(sHostMask)) {
			return true;
		}
	}

	return false;
}

void CZNC::InitDirs(const CString& sArgvPath, const CString& sDataDir) {
	char buf[PATH_MAX];
	char *home;

	if (getcwd(buf, PATH_MAX) == NULL) {
		CUtils::PrintError(""getcwd() failed, can't read my current dir"");
		exit(-1);
	}

	// If the bin was not ran from the current directory, we need to add that dir onto our cwd
	CString::size_type uPos = sArgvPath.rfind('/');
	m_sCurPath = (uPos == CString::npos) ? CString(buf) : CDir::ChangeDir(buf, sArgvPath.substr(0, uPos), """");

	// Try to set the user's home dir, default to binpath on failure
	home = getenv(""HOME"");

	m_sHomePath.clear();
	if (home) {
		m_sHomePath = home;
	}

	if (m_sHomePath.empty()) {
		struct passwd* pUserInfo = getpwuid(getuid());

		if (pUserInfo) {
			m_sHomePath = pUserInfo->pw_dir;
		}
	}

	if (m_sHomePath.empty()) {
		m_sHomePath = m_sCurPath;
	}

	if (sDataDir.empty()) {
	    m_sZNCPath = m_sHomePath + ""/.znc"";
	} else {
	    m_sZNCPath = sDataDir;
	}

	// Other dirs that we use
	m_sConfPath = m_sZNCPath + ""/configs"";
	m_sModPath = m_sZNCPath + ""/modules"";
	m_sUserPath = m_sZNCPath + ""/users"";
}


CString CZNC::ExpandConfigPath(const CString& sConfigFile) {
	CString sRetPath;

	if (sConfigFile.empty()) {
		sRetPath = GetConfPath() + ""/znc.conf"";
	} else {
		if (sConfigFile.Left(2) == ""./"" || sConfigFile.Left(3) == ""../"") {
			sRetPath = GetCurPath() + ""/"" + sConfigFile;
		} else if (sConfigFile.Left(1) != ""/"") {
			sRetPath = GetConfPath() + ""/"" + sConfigFile;
		} else {
			sRetPath = sConfigFile;
		}
	}

	return sRetPath;
}

bool CZNC::BackupConfig() const {
	CString sBackup = GetConfigFile() + ""-backup"";

	// Create a new backup overwriting an old one we might have
	if (CFile::Copy(m_sConfigFile, sBackup, true))
		return true;

	// Don't abort if no config file exists
	if (!CFile::Exists(m_sConfigFile))
		// No backup because we got nothing to backup
		return true;

	return false;
}

bool CZNC::WriteConfig() {
	CFile File(GetConfigFile());

	if (!BackupConfig()) {
		return false;
	}

	if (m_sConfigFile.empty() || !File.Open(O_WRONLY | O_CREAT | O_TRUNC, 0600)) {
		return false;
	}

	for (size_t l = 0; l < m_vpListeners.size(); l++) {
		CListener* pListener = m_vpListeners[l];
		CString sHostPortion = pListener->GetBindHost();

		if (!sHostPortion.empty()) {
			sHostPortion += "" "";
		}

		CString s6 = (pListener->IsIPV6()) ? ""6"" : "" "";

		File.Write(""Listen"" + s6 + ""      = "" + sHostPortion + CString((pListener->IsSSL()) ? ""+"" : """") + CString(pListener->GetPort()) + ""\n"");
	}

	File.Write(""ConnectDelay = "" + CString(m_uiConnectDelay) + ""\n"");

	if (!m_sISpoofFile.empty()) {
		File.Write(""ISpoofFile   = "" + m_sISpoofFile + ""\n"");
		if (!m_sISpoofFormat.empty()) { File.Write(""ISpoofFormat = "" + m_sISpoofFormat + ""\n""); }
	}

	if (!m_sPidFile.empty()) { File.Write(""PidFile      = "" + m_sPidFile + ""\n""); }
	if (!m_sStatusPrefix.empty()) { File.Write(""StatusPrefix = "" + m_sStatusPrefix + ""\n""); }

	for (unsigned int m = 0; m < m_vsMotd.size(); m++) {
		File.Write(""Motd         = "" + m_vsMotd[m] + ""\n"");
	}

	for (unsigned int v = 0; v < m_vsVHosts.size(); v++) {
		File.Write(""VHost        = "" + m_vsVHosts[v] + ""\n"");
	}

#ifdef _MODULES
	CGlobalModules& Mods = GetModules();

	for (unsigned int a = 0; a < Mods.size(); a++) {
		CString sArgs = Mods[a]->GetArgs();

		if (!sArgs.empty()) {
			sArgs = "" "" + sArgs;
		}

		File.Write(""LoadModule   = "" + Mods[a]->GetModName() + sArgs + ""\n"");
	}
#endif

	for (map<CString,CUser*>::iterator it = m_msUsers.begin(); it != m_msUsers.end(); it++) {
		CString sErr;

		if (!it->second->IsValid(sErr)) {
			DEBUG_ONLY(cerr << ""** Error writing config for user ["" << it->first << ""] ["" << sErr << ""]"" << endl);
			continue;
		}

		File.Write(""\n"");

		if (!it->second->WriteConfig(File)) {
			DEBUG_ONLY(cerr << ""** Error writing config for user ["" << it->first << ""]"" << endl);
		}
	}

	File.Close();

	return true;
}

bool CZNC::WriteNewConfig(const CString& sConfig) {
	CString sConfigFile = ExpandConfigPath((sConfig.empty()) ? ""znc.conf"" : sConfig);
	CString sAnswer, sUser;
	vector<CString> vsLines;

	if (CFile::Exists(sConfigFile)) {
		if (!m_LockFile.TryExLock(sConfigFile)) {
			CUtils::PrintError(""ZNC is currently running on this config."");
			return false;
		}

		if (!CUtils::GetBoolInput(""This config already exists.  Would you like to overwrite it?"", false)) {
			m_LockFile.UnLock();
			return false;
		}
	}

	CUtils::PrintMessage(""Writing new config ["" + sConfigFile + ""]"");

	CUtils::PrintMessage("""");
	CUtils::PrintMessage(""First lets start with some global settings..."");
	CUtils::PrintMessage("""");

	// Listen
	unsigned int uListenPort = 0;
	while (!CUtils::GetNumInput(""What port would you like ZNC to listen on?"", uListenPort, 1, 65535)) ;

	CString sSSL;
#ifdef HAVE_LIBSSL
	if (CUtils::GetBoolInput(""Would you like ZNC to listen using SSL?"", false)) {
		sSSL = ""+"";
	}
#endif

	CString s6 = "" "";
#ifdef HAVE_IPV6
	if (CUtils::GetBoolInput(""Would you like ZNC to listen using ipv6?"", false)) {
		s6 = ""6"";
	}
#endif

	CString sListenHost;
	CUtils::GetInput(""Listen Host"", sListenHost, """", ""Blank for all ips"");

	if (!sListenHost.empty()) {
		sListenHost += "" "";
	}

	vsLines.push_back(""Listen"" + s6 + ""    = "" + sListenHost + sSSL + CString(uListenPort));
	// !Listen

#ifdef _MODULES
	set<CModInfo> ssGlobalMods;
	GetModules().GetAvailableMods(ssGlobalMods, true);

	if (ssGlobalMods.size()) {
		CUtils::PrintMessage("""");
		CUtils::PrintMessage(""-- Global Modules --"");
		CUtils::PrintMessage("""");

		if (CUtils::GetBoolInput(""Do you want to load any global modules?"")) {
			CTable Table;
			Table.AddColumn(""Name"");
			Table.AddColumn(""Description"");
			set<CModInfo>::iterator it;

			for (it = ssGlobalMods.begin(); it != ssGlobalMods.end(); it++) {
				const CModInfo& Info = *it;
				Table.AddRow();
				Table.SetCell(""Name"", Info.GetName());
				Table.SetCell(""Description"", Info.GetDescription().Ellipsize(128));
			}

			unsigned int uTableIdx = 0; CString sLine;
			while (Table.GetLine(uTableIdx++, sLine)) {
				CUtils::PrintMessage(sLine);
			}

			CUtils::PrintMessage("""");

			for (it = ssGlobalMods.begin(); it != ssGlobalMods.end(); it++) {
				const CModInfo& Info = *it;
				CString sName = Info.GetName();

				if (sName.Right(3).CaseCmp("".so"") == 0) {
					sName.RightChomp(3);
				}

				if (CUtils::GetBoolInput(""Load global module <\033[1m"" + sName + ""\033[22m>?"", false)) {
					vsLines.push_back(""LoadModule = "" + sName);
				}
			}
		}
	}
#endif

	// User
	CUtils::PrintMessage("""");
	CUtils::PrintMessage(""Now we need to setup a user..."");
	CUtils::PrintMessage("""");

	bool bFirstUser = true;

	do {
		vsLines.push_back("""");
		CString sNick;
		do {
			CUtils::GetInput(""Username"", sUser, """", ""AlphaNumeric"");
		} while (!CUser::IsValidUserName(sUser));

		vsLines.push_back(""<User "" + sUser + "">"");
		sAnswer = CUtils::GetHashPass();
		vsLines.push_back(""\tPass       = "" + sAnswer + "" -"");

		if (CUtils::GetBoolInput(""Would you like this user to be an admin?"", bFirstUser)) {
			vsLines.push_back(""\tAdmin      = true"");
		} else {
			vsLines.push_back(""\tAdmin      = false"");
		}

		CUtils::GetInput(""Nick"", sNick, CUser::MakeCleanUserName(sUser));
		vsLines.push_back(""\tNick       = "" + sNick);
		CUtils::GetInput(""Alt Nick"", sAnswer, sNick + ""_"");
		if (!sAnswer.empty()) {
			vsLines.push_back(""\tAltNick    = "" + sAnswer);
		}
		CUtils::GetInput(""Ident"", sAnswer, sNick);
		vsLines.push_back(""\tIdent      = "" + sAnswer);
		CUtils::GetInput(""Real Name"", sAnswer, ""Got ZNC?"");
		vsLines.push_back(""\tRealName   = "" + sAnswer);
		CUtils::GetInput(""VHost"", sAnswer, """", ""optional"");
		if (!sAnswer.empty()) {
			vsLines.push_back(""\tVHost      = "" + sAnswer);
		}
		// todo: Possibly add motd

		if (CUtils::GetBoolInput(""Would you like ZNC to keep trying for your primary nick?"", false)) {
			vsLines.push_back(""\tKeepNick   = true"");
		} else {
			vsLines.push_back(""\tKeepNick   = false"");
		}

		unsigned int uBufferCount = 0;

		CUtils::GetNumInput(""Number of lines to buffer per channel"", uBufferCount, 0, ~0, 50);
		if (uBufferCount) {
			vsLines.push_back(""\tBuffer     = "" + CString(uBufferCount));
		}
		if (CUtils::GetBoolInput(""Would you like to keep buffers after replay?"", false)) {
			vsLines.push_back(""\tKeepBuffer = true"");
		} else {
			vsLines.push_back(""\tKeepBuffer = false"");
		}

		CUtils::GetInput(""Default channel modes"", sAnswer, ""+stn"");
		if (!sAnswer.empty()) {
			vsLines.push_back(""\tChanModes  = "" + sAnswer);
		}

#ifdef _MODULES
		set<CModInfo> ssUserMods;
		GetModules().GetAvailableMods(ssUserMods);

		if (ssUserMods.size()) {
			vsLines.push_back("""");
			CUtils::PrintMessage("""");
			CUtils::PrintMessage(""-- User Modules --"");
			CUtils::PrintMessage("""");

			if (CUtils::GetBoolInput(""Do you want to automatically load any user modules for this user?"")) {
				CTable Table;
				Table.AddColumn(""Name"");
				Table.AddColumn(""Description"");
				set<CModInfo>::iterator it;

				for (it = ssUserMods.begin(); it != ssUserMods.end(); it++) {
					const CModInfo& Info = *it;
					Table.AddRow();
					Table.SetCell(""Name"", Info.GetName());
					Table.SetCell(""Description"", Info.GetDescription().Ellipsize(128));
				}

				unsigned int uTableIdx = 0; CString sLine;
				while (Table.GetLine(uTableIdx++, sLine)) {
					CUtils::PrintMessage(sLine);
				}

				CUtils::PrintMessage("""");

				for (it = ssUserMods.begin(); it != ssUserMods.end(); it++) {
					const CModInfo& Info = *it;
					CString sName = Info.GetName();

					if (CUtils::GetBoolInput(""Load "" + CString((Info.IsSystem()) ? ""system"" : ""local"") + "" module <\033[1m"" + sName + ""\033[22m>?"", false)) {
						vsLines.push_back(""\tLoadModule = "" + sName);
					}
				}
			}
		}
#endif

		vsLines.push_back("""");
		CUtils::PrintMessage("""");
		CUtils::PrintMessage(""-- IRC Servers --"");
		CUtils::PrintMessage("""");

		do {
			CString sHost, sPass;
			bool bSSL = false;
			unsigned int uServerPort = 0;

			while (!CUtils::GetInput(""IRC server"", sHost, """", ""host only"") || !CServer::IsValidHostName(sHost)) ;
			while (!CUtils::GetNumInput(""["" + sHost + ""] Port"", uServerPort, 1, 65535, 6667)) ;
			CUtils::GetInput(""["" + sHost + ""] Password (probably empty)"", sPass);

#ifdef HAVE_LIBSSL
			bSSL = CUtils::GetBoolInput(""Does this server use SSL? (probably no)"", false);
#endif

			vsLines.push_back(""\tServer     = "" + sHost + ((bSSL) ? "" +"" : "" "") + CString(uServerPort) + "" "" + sPass);
		} while (CUtils::GetBoolInput(""Would you like to add another server?"", false));

		vsLines.push_back("""");
		CUtils::PrintMessage("""");
		CUtils::PrintMessage(""-- Channels --"");
		CUtils::PrintMessage("""");

		CString sArg = ""a"";
		CString sPost = "" for ZNC to automatically join?"";
		bool bDefault = true;

		while (CUtils::GetBoolInput(""Would you like to add "" + sArg + "" channel"" + sPost, bDefault)) {
			while (!CUtils::GetInput(""Channel name"", sAnswer)) ;
			vsLines.push_back(""\t<Chan "" + sAnswer + "">"");
			vsLines.push_back(""\t</Chan>"");
			sArg = ""another"";
			sPost = ""?"";
			bDefault = false;
		}

		vsLines.push_back(""</User>"");

		CUtils::PrintMessage("""");
		bFirstUser = false;
	} while (CUtils::GetBoolInput(""Would you like to setup another user?"", false));
	// !User

	CUtils::PrintAction(""Writing config ["" + sConfigFile + ""]"");
	CFile File(sConfigFile);

	bool bFileOpen = false;

	if (File.Open(O_WRONLY | O_CREAT | O_TRUNC, 0600)) {
		bFileOpen = true;
	} else {
		CUtils::PrintStatus(false, ""Unable to open file"");
		CUtils::GetInput(""Alternate location"", sConfigFile, ""/tmp/"" + sConfig);

		if (!CFile::Exists(sConfigFile) || CUtils::GetBoolInput(""Would you like to overwrite the existing alt file"", false)) {
			CUtils::PrintAction(""Writing to alt location ["" + sConfigFile + ""]"");
			File.SetFileName(sConfigFile);

			if (File.Open(O_WRONLY | O_CREAT | O_TRUNC, 0600)) {
				bFileOpen = true;
			} else {
				CUtils::PrintStatus(false, ""Unable to open alt file"");
			}
		}
	}

	if (!bFileOpen) {
		CUtils::PrintMessage("""");
		CUtils::PrintMessage(""Printing new config to stdout since we were unable to open a file"");
		CUtils::PrintMessage("""");
		cout << endl << ""----------------------------------------------------------------------------"" << endl << endl;
	}

	for (unsigned int a = 0; a < vsLines.size(); a++) {
		if (bFileOpen) {
			File.Write(vsLines[a] + ""\n"");
		} else {
			cout << vsLines[a] << endl;
		}
	}

	if (bFileOpen) {
		File.Close();

		CUtils::PrintStatus(true);
	} else {
		cout << endl << ""----------------------------------------------------------------------------"" << endl << endl;
	}

	CUtils::PrintMessage("""");
	CUtils::PrintMessage(""To connect to this znc you need to connect to it as your irc server"", true);
	CUtils::PrintMessage(""using the port that you supplied.  You have to supply your login info"", true);
	CUtils::PrintMessage(""as the irc server password like so.. user:pass."", true);
	CUtils::PrintMessage("""");
	CUtils::PrintMessage(""Try something like this in your IRC client..."", true);
	CUtils::PrintMessage(""/server <znc_server_ip> "" + CString(uListenPort) + "" "" + sUser + "":<pass>"", true);
	CUtils::PrintMessage("""");

	m_LockFile.UnLock();
	return CUtils::GetBoolInput(""Launch znc now?"", true);
}

bool CZNC::ParseConfig(const CString& sConfig)
{
	CString s;

	m_sConfigFile = ExpandConfigPath(sConfig);

	return DoRehash(s);
}

bool CZNC::RehashConfig(CString& sError)
{
#ifdef _MODULES
	GetModules().OnPreRehash();
	for (map<CString, CUser*>::iterator itb = m_msUsers.begin();
			itb != m_msUsers.end(); itb++) {
		itb->second->GetModules().OnPreRehash();
	}
#endif

	// This clears m_msDelUsers
	HandleUserDeletion();

	// Mark all users as going-to-be deleted
	m_msDelUsers = m_msUsers;
	m_msUsers.clear();

	// Make sure that timer doesn't have a stale iterator
	DisableConnectUser();

	if (DoRehash(sError)) {
#ifdef _MODULES
		GetModules().OnPostRehash();
		for (map<CString, CUser*>::iterator it = m_msUsers.begin();
				it != m_msUsers.end(); it++) {
			it->second->GetModules().OnPostRehash();
		}
#endif

		return true;
	}

	// Rehashing failed, try to recover
	CString s;
	while (m_msDelUsers.size()) {
		AddUser(m_msDelUsers.begin()->second, s);
		m_msDelUsers.erase(m_msDelUsers.begin());
	}

	// Make sure that users that want to connect do so
	RestartConnectUser();

	return false;
}

bool CZNC::DoRehash(CString& sError)
{
	sError.clear();

	CUtils::PrintAction(""Opening Config ["" + m_sConfigFile + ""]"");

	if (!CFile::Exists(m_sConfigFile)) {
		sError = ""No such file"";
		CUtils::PrintStatus(false, sError);
		CUtils::PrintMessage(""Restart znc with the --makeconf option if you wish to create this config."");
		return false;
	}

	if (!CFile::IsReg(m_sConfigFile)) {
		sError = ""Not a file"";
		CUtils::PrintStatus(false, sError);
		return false;
	}

	if (!m_LockFile.Open(m_sConfigFile)) {
		sError = ""Can not open config file"";
		CUtils::PrintStatus(false, sError);
		return false;
	}

	if (!m_LockFile.TryExLock()) {
		sError = ""ZNC is already running on this config."";
		CUtils::PrintStatus(false, sError);
		return false;
	}

	CFile File(m_LockFile.GetFD(), m_sConfigFile);

	// This fd is re-used for rehashing, so we must seek back to the beginning!
	if (!File.Seek(0)) {
		sError = ""Could not seek to the beginning of the config."";
		CUtils::PrintStatus(false, sError);
		return false;
	}

	CUtils::PrintStatus(true);

	m_vsVHosts.clear();
	m_vsMotd.clear();

	// Delete all listeners
	while (m_vpListeners.size()) {
		delete m_vpListeners[0];
		m_vpListeners.erase(m_vpListeners.begin());
	}

	// Make sure that timer doesn't have a stale iterator
	DisableConnectUser();

	CString sLine;
	bool bCommented = false;	// support for /**/ style comments
	CUser* pUser = NULL;	// Used to keep track of which user block we are in
	CUser* pRealUser = NULL;	// If we rehash a user, this is the real one
	CChan* pChan = NULL;	// Used to keep track of which chan block we are in
	unsigned int uLineNum = 0;
#ifdef _MODULES
	MCString msModules;	// Modules are queued for later loading
#endif

	std::list<CGlobalModuleConfigLine> lGlobalModuleConfigLine;

	while (File.ReadLine(sLine)) {
		uLineNum++;

		while ((sLine.Right(1) == ""\r"") || (sLine.Right(1) == ""\n"")) {
			sLine.Trim();
		}

		if ((sLine.empty()) || (sLine[0] == '#') || (sLine.Left(2) == ""//"")) {
			continue;
		}

		if (sLine.Left(2) == ""/*"") {
			if (sLine.Right(2) != ""*/"") {
				bCommented = true;
			}

			continue;
		}

		if (bCommented) {
			if (sLine.Right(2) == ""*/"") {
				bCommented = false;
			}

			continue;
		}

		if ((sLine.Left(1) == ""<"") && (sLine.Right(1) == "">"")) {
			sLine.LeftChomp();
			sLine.RightChomp();
			sLine.Trim();

			CString sTag = sLine.substr(0, sLine.find_first_of("" \t\r\n""));
			CString sValue = (sTag.size() < sLine.size()) ? sLine.substr(sTag.size() +1) : """";

			sTag.Trim();
			sValue.Trim();

			if (sLine.Left(1) == ""/"") {
				sTag = sTag.substr(1);

				if (pUser) {
					if (pChan) {
						if (sTag.CaseCmp(""Chan"") == 0) {
							// Save the channel name, because AddChan
							// deletes the CChannel*, if adding fails
							sError = pChan->GetName();
							if (!pUser->AddChan(pChan)) {
								sError = ""Channel ["" + sError + ""] defined more than once"";
								CUtils::PrintError(sError);
								return false;
							}
							sError.clear();
							pChan = NULL;
							continue;
						}
					} else if (sTag.CaseCmp(""User"") == 0) {
						CString sErr;

						if (pRealUser) {
							if (!pRealUser->Clone(*pUser, sErr)
									|| !AddUser(pRealUser, sErr)) {
								sError = ""Invalid user ["" + pUser->GetUserName() + ""] "" + sErr;
								DEBUG_ONLY(cout << ""CUser::Clone() failed in rehash"" << endl);
							}
							pUser->SetBeingDeleted(true);
							delete pUser;
							pUser = NULL;
						} else if (!AddUser(pUser, sErr)) {
							sError = ""Invalid user ["" + pUser->GetUserName() + ""] "" + sErr;
						}

						if (!sError.empty()) {
							CUtils::PrintError(sError);
							if (pUser) {
								pUser->SetBeingDeleted(true);
								delete pUser;
								pUser = NULL;
							}
							return false;
						}

						pUser = NULL;
						pRealUser = NULL;
						continue;
					}
				}
			} else if (sTag.CaseCmp(""User"") == 0) {
				if (pUser) {
					sError = ""You may not nest <User> tags inside of other <User> tags."";
					CUtils::PrintError(sError);
					return false;
				}

				if (sValue.empty()) {
					sError = ""You must supply a username in the <User> tag."";
					CUtils::PrintError(sError);
					return false;
				}

				if (m_msUsers.find(sValue) != m_msUsers.end()) {
					sError = ""User ["" + sValue + ""] defined more than once."";
					CUtils::PrintError(sError);
					return false;
				}

				CUtils::PrintMessage(""Loading user ["" + sValue + ""]"");

				// Either create a CUser* or use an existing one
				map<CString, CUser*>::iterator it = m_msDelUsers.find(sValue);

				if (it != m_msDelUsers.end()) {
					pRealUser = it->second;
					m_msDelUsers.erase(it);
				} else
					pRealUser = NULL;

				pUser = new CUser(sValue);

				if (!m_sStatusPrefix.empty()) {
					if (!pUser->SetStatusPrefix(m_sStatusPrefix)) {
						sError = ""Invalid StatusPrefix ["" + m_sStatusPrefix + ""] Must be 1-5 chars, no spaces."";
						CUtils::PrintError(sError);
						return false;
					}
				}

				continue;
			} else if (sTag.CaseCmp(""Chan"") == 0) {
				if (!pUser) {
					sError = ""<Chan> tags must be nested inside of a <User> tag."";
					CUtils::PrintError(sError);
					return false;
				}

				if (pChan) {
					sError = ""You may not nest <Chan> tags inside of other <Chan> tags."";
					CUtils::PrintError(sError);
					return false;
				}

				pChan = new CChan(sValue, pUser, true);
				continue;
			}
		}

		// If we have a regular line, figure out where it goes
		CString sName = sLine.Token(0, false, ""="");
		CString sValue = sLine.Token(1, true, ""="");
		sName.Trim();
		sValue.Trim();

		if ((!sName.empty()) && (!sValue.empty())) {
			if (pUser) {
				if (pChan) {
					if (sName.CaseCmp(""Buffer"") == 0) {
						pChan->SetBufferCount(strtoul(sValue.c_str(), NULL, 10));
						continue;
					} else if (sName.CaseCmp(""KeepBuffer"") == 0) {
						pChan->SetKeepBuffer((sValue.CaseCmp(""true"") == 0));
						continue;
					} else if (sName.CaseCmp(""Detached"") == 0) {
						pChan->SetDetached((sValue.CaseCmp(""true"") == 0));
						continue;
					} else if (sName.CaseCmp(""AutoCycle"") == 0) {
						pChan->SetAutoCycle((sValue.CaseCmp(""true"") == 0));
						continue;
					} else if (sName.CaseCmp(""Key"") == 0) {
						pChan->SetKey(sValue);
						continue;
					} else if (sName.CaseCmp(""Modes"") == 0) {
						pChan->SetDefaultModes(sValue);
						continue;
					}
				} else {
					if (sName.CaseCmp(""Buffer"") == 0) {
						pUser->SetBufferCount(strtoul(sValue.c_str(), NULL, 10));
						continue;
					} else if (sName.CaseCmp(""KeepBuffer"") == 0) {
						pUser->SetKeepBuffer((sValue.CaseCmp(""true"") == 0));
						continue;
					} else if (sName.CaseCmp(""AutoCycle"") == 0) {
						pUser->SetAutoCycle((sValue.CaseCmp(""true"") == 0));
						continue;
					} else if (sName.CaseCmp(""Nick"") == 0) {
						pUser->SetNick(sValue);
						continue;
					} else if (sName.CaseCmp(""CTCPReply"") == 0) {
						pUser->AddCTCPReply(sValue.Token(0), sValue.Token(1, true));
						continue;
					} else if (sName.CaseCmp(""QuitMsg"") == 0) {
						pUser->SetQuitMsg(sValue);
						continue;
					} else if (sName.CaseCmp(""AltNick"") == 0) {
						pUser->SetAltNick(sValue);
						continue;
					} else if (sName.CaseCmp(""AwaySuffix"") == 0) {
						CUtils::PrintMessage(""WARNING: AwaySuffix has been depricated, instead try -> LoadModule = awaynick %nick%_"" + sValue);
						continue;
					} else if (sName.CaseCmp(""Pass"") == 0) {
						if (sValue.Right(1) == ""-"") {
							sValue.RightChomp();
							sValue.Trim();
							pUser->SetPass(sValue, true);
						} else {
							pUser->SetPass(sValue, false);
						}

						continue;
					} else if (sName.CaseCmp(""MultiClients"") == 0) {
						pUser->SetMultiClients(sValue.CaseCmp(""true"") == 0);
						continue;
					} else if (sName.CaseCmp(""BounceDCCs"") == 0) {
						pUser->SetBounceDCCs(sValue.CaseCmp(""true"") == 0);
						continue;
					} else if (sName.CaseCmp(""Ident"") == 0) {
						pUser->SetIdent(sValue);
						continue;
					} else if (sName.CaseCmp(""DenyLoadMod"") == 0) {
						pUser->SetDenyLoadMod((sValue.CaseCmp(""TRUE"") == 0));
						continue;
					} else if (sName.CaseCmp(""Admin"") == 0) {
						pUser->SetAdmin((sValue.CaseCmp(""TRUE"") == 0));
						continue;
					} else if (sName.CaseCmp(""DenySetVHost"") == 0) {
						pUser->SetDenySetVHost((sValue.CaseCmp(""TRUE"") == 0));
						continue;
					} else if (sName.CaseCmp(""StatusPrefix"") == 0) {
						if (!pUser->SetStatusPrefix(sValue)) {
							sError = ""Invalid StatusPrefix ["" + sValue + ""] Must be 1-5 chars, no spaces."";
							CUtils::PrintError(sError);
							return false;
						}
						continue;
					} else if (sName.CaseCmp(""DCCLookupMethod"") == 0) {
						pUser->SetUseClientIP((sValue.CaseCmp(""Client"") == 0));
						continue;
					} else if (sName.CaseCmp(""RealName"") == 0) {
						pUser->SetRealName(sValue);
						continue;
					} else if (sName.CaseCmp(""KeepNick"") == 0) {
						pUser->SetKeepNick((sValue.CaseCmp(""true"") == 0));
						continue;
					} else if (sName.CaseCmp(""ChanModes"") == 0) {
						pUser->SetDefaultChanModes(sValue);
						continue;
					} else if (sName.CaseCmp(""VHost"") == 0) {
						pUser->SetVHost(sValue);
						continue;
					} else if (sName.CaseCmp(""Allow"") == 0) {
						pUser->AddAllowedHost(sValue);
						continue;
					} else if (sName.CaseCmp(""Server"") == 0) {
						CUtils::PrintAction(""Adding Server ["" + sValue + ""]"");
						CUtils::PrintStatus(pUser->AddServer(sValue));
						continue;
					} else if (sName.CaseCmp(""Chan"") == 0) {
						pUser->AddChan(sValue, true);
						continue;
					} else if (sName.CaseCmp(""TimestampFormat"") == 0) {
						pUser->SetTimestampFormat(sValue);
						continue;
					} else if (sName.CaseCmp(""AppendTimestamp"") == 0) {
						pUser->SetTimestampAppend(sValue.ToBool());
						continue;
					} else if (sName.CaseCmp(""PrependTimestamp"") == 0) {
						pUser->SetTimestampPrepend(sValue.ToBool());
						continue;
					} else if (sName.CaseCmp(""Timestamp"") == 0) {
						if (sValue.Trim_n().CaseCmp(""true"") != 0) {
							if (sValue.Trim_n().CaseCmp(""append"") == 0) {
								pUser->SetTimestampAppend(true);
								pUser->SetTimestampPrepend(false);
							} else if (sValue.Trim_n().CaseCmp(""prepend"") == 0) {
								pUser->SetTimestampAppend(false);
								pUser->SetTimestampPrepend(true);
							} else if (sValue.Trim_n().CaseCmp(""false"") == 0) {
								pUser->SetTimestampAppend(false);
								pUser->SetTimestampPrepend(false);
							} else {
								pUser->SetTimestampFormat(sValue);
							}
						}
						continue;
					} else if (sName.CaseCmp(""TimezoneOffset"") == 0) {
						pUser->SetTimezoneOffset(sValue.ToDouble()); // there is no ToFloat()
						continue;
					} else if (sName.CaseCmp(""JoinTries"") == 0) {
						pUser->SetJoinTries(sValue.ToUInt());
						continue;
					} else if (sName.CaseCmp(""LoadModule"") == 0) {
						CString sModName = sValue.Token(0);
						CUtils::PrintAction(""Loading Module ["" + sModName + ""]"");
#ifdef _MODULES
						CString sModRet;
						CString sArgs = sValue.Token(1, true);

						try {
							bool bModRet = pUser->GetModules().LoadModule(sModName, sArgs, pUser, sModRet);

							// If the module was loaded, sModRet contains
							// ""Loaded Module [name] ..."" and we strip away this beginning.
							if (bModRet)
								sModRet = sModRet.Token(1, true, sModName + ""] "");

							CUtils::PrintStatus(bModRet, sModRet);
							if (!bModRet) {
								sError = sModRet;
								return false;
							}
						} catch (CException e) {
							sError = ""Caught exception while loading ["" + sModName + ""]"";
							CUtils::PrintStatus(false, sModRet);
							return false;
						}
#else
						sError = ""Modules are not enabled."";
						CUtils::PrintStatus(false, sError);
#endif
						continue;
					}
				}
			} else {
				if (sName.CaseCmp(""Listen"") == 0 || sName.CaseCmp(""ListenPort"") == 0 || sName.CaseCmp(""Listen6"") == 0) {
					bool bSSL = false;
					bool bIPV6 = (sName.CaseCmp(""Listen6"") == 0);
					CString sPort;

					CString sBindHost;

					if (!bIPV6) {
						sValue.Replace("":"", "" "");
					}

					if (sValue.find("" "") != CString::npos) {
						sBindHost = sValue.Token(0, false, "" "");
						sPort = sValue.Token(1, true, "" "");
					} else {
						sPort = sValue;
					}

					if (sPort.Left(1) == ""+"") {
						sPort.LeftChomp();
						bSSL = true;
					}

					CString sHostComment;

					if (!sBindHost.empty()) {
						sHostComment = "" on host ["" + sBindHost + ""]"";
					}

					CString sIPV6Comment;

					if (bIPV6) {
						sIPV6Comment = "" using ipv6"";
					}

					unsigned short uPort = strtol(sPort.c_str(), NULL, 10);
					CUtils::PrintAction(""Binding to port ["" + CString((bSSL) ? ""+"" : """") + CString(uPort) + ""]"" + sHostComment + sIPV6Comment);

#ifndef HAVE_IPV6
					if (bIPV6) {
						sError = ""IPV6 is not enabled"";
						CUtils::PrintStatus(false, sError);
						return false;
					}
#endif

#ifndef HAVE_LIBSSL
					if (bSSL) {
						sError = ""SSL is not enabled"";
						CUtils::PrintStatus(false, sError);
						return false;
					}
#else
					CString sPemFile = GetPemLocation();

					if (bSSL && !CFile::Exists(sPemFile)) {
						sError = ""Unable to locate pem file: ["" + sPemFile + ""]"";
						CUtils::PrintStatus(false, sError);

						// If stdin is e.g. /dev/null and we call GetBoolInput(),
						// we are stuck in an endless loop!
						if (isatty(0) && CUtils::GetBoolInput(""Would you like to create a new pem file?"", true)) {
							sError.clear();
							WritePemFile();
						} else {
							return false;
						}

						CUtils::PrintAction(""Binding to port [+"" + CString(uPort) + ""]"" + sHostComment + sIPV6Comment);
					}
#endif
					if (!uPort) {
						sError = ""Invalid port"";
						CUtils::PrintStatus(false, sError);
						return false;
					}

					CListener* pListener = new CListener(uPort, sBindHost, bSSL, bIPV6);

					if (!pListener->Listen()) {
						sError = ""Unable to bind"";
						CUtils::PrintStatus(false, sError);
						delete pListener;
						return false;
					}

					m_vpListeners.push_back(pListener);
					CUtils::PrintStatus(true);

					continue;
				} else if (sName.CaseCmp(""LoadModule"") == 0) {
#ifdef _MODULES
					CString sModName = sValue.Token(0);
					CString sArgs = sValue.Token(1, true);

					if (msModules.find(sModName) != msModules.end()) {
						sError = ""Module ["" + sModName +
							""] already loaded"";
						CUtils::PrintError(sError);
						return false;
					}
					msModules[sModName] = sArgs;
#else
					CUtils::PrintError(""Modules are not enabled."");
#endif
					continue;
				} else if (sName.CaseCmp(""ISpoofFormat"") == 0) {
					m_sISpoofFormat = sValue;
					continue;
				} else if (sName.CaseCmp(""ISpoofFile"") == 0) {
					if (sValue.Left(2) == ""~/"") {
						sValue.LeftChomp(2);
						sValue = GetHomePath() + ""/"" + sValue;
					}
					m_sISpoofFile = sValue;
					continue;
				} else if (sName.CaseCmp(""MOTD"") == 0) {
					AddMotd(sValue);
					continue;
				} else if (sName.CaseCmp(""VHost"") == 0) {
					AddVHost(sValue);
					continue;
				} else if (sName.CaseCmp(""PidFile"") == 0) {
					m_sPidFile = sValue;
					continue;
				} else if (sName.CaseCmp(""StatusPrefix"") == 0) {
					m_sStatusPrefix = sValue;
					continue;
				} else if (sName.CaseCmp(""ConnectDelay"") == 0) {
					m_uiConnectDelay = sValue.ToUInt();
					continue;
				}
			}

		}

		if (sName.CaseCmp(""GM:"", 3) == 0)
		{ // GM: prefix is a pass through to config lines for global modules
			CGlobalModuleConfigLine cTmp;
			cTmp.m_sName = sName.substr(3, CString::npos);
			cTmp.m_sValue = sValue;
			cTmp.m_pChan = pChan;
			cTmp.m_pUser = pUser;
			lGlobalModuleConfigLine.push_back(cTmp);
		}
		else
		{
			sError = ""Unhandled line "" + CString(uLineNum) + "" in config: ["" + sLine + ""]"";
			CUtils::PrintError(sError);
			return false;
		}
	}

#ifdef _MODULES
	// First step: Load and reload new modules or modules with new arguments
	for (MCString::iterator it = msModules.begin(); it != msModules.end(); it++) {
		CString sModName = it->first;
		CString sArgs = it->second;
		CString sModRet;
		CModule *pOldMod;

		pOldMod = GetModules().FindModule(sModName);
		if (!pOldMod) {
			CUtils::PrintAction(""Loading Global Module ["" + sModName + ""]"");

			try {
				bool bModRet = GetModules().LoadModule(sModName, sArgs, NULL, sModRet);

				// If the module was loaded, sModRet contains
				// ""Loaded Module [name] ..."" and we strip away this beginning.
				if (bModRet)
					sModRet = sModRet.Token(1, true, sModName + ""] "");

				CUtils::PrintStatus(bModRet, sModRet);
				if (!bModRet) {
					sError = sModRet;
					return false;
				}
			} catch (CException e) {
				sError = ""Caught an exception while loading ["" + sModName + ""]"";
				CUtils::PrintStatus(false, sModRet);
				return false;
			}
		} else if (pOldMod->GetArgs() != sArgs) {
			CUtils::PrintAction(""Reloading Global Module ["" + sModName + ""]"");

			try {
				bool bModRet = GetModules().ReloadModule(sModName, sArgs, NULL, sModRet);

				// If the module was loaded, sModRet contains
				// ""Loaded Module [name] ..."" and we strip away this beginning.
				if (bModRet)
					sModRet = sModRet.Token(1, true, sModName + ""] "");

				CUtils::PrintStatus(bModRet, sModRet);
				if (!bModRet) {
					sError = sModRet;
					return false;
				}
			} catch (CException e) {
				sError = ""Caught an exception while reloading ["" + sModName + ""]"";
				CUtils::PrintStatus(false, sModRet);
				return false;
			}
		} else
			CUtils::PrintMessage(""Module ["" + sModName + ""] already loaded."");
	}

	// Second step: Unload modules which are no longer in the config
	set<CString> ssUnload;
	for (size_t i = 0; i < GetModules().size(); i++) {
		CModule *pCurMod = GetModules()[i];

		if (msModules.find(pCurMod->GetModName()) == msModules.end())
			ssUnload.insert(pCurMod->GetModName());
	}

	for (set<CString>::iterator it = ssUnload.begin(); it != ssUnload.end(); it++) {
		if (GetModules().UnloadModule(*it))
			CUtils::PrintMessage(""Unloaded Global Module ["" + *it + ""]"");
		else
			CUtils::PrintMessage(""Could not unload ["" + *it + ""]"");
	}

	// last step, throw unhandled config items at global config
	for (std::list<CGlobalModuleConfigLine>::iterator it = lGlobalModuleConfigLine.begin(); it != lGlobalModuleConfigLine.end(); it++)
	{
		if ((pChan && pChan == it->m_pChan) || (pUser && pUser == it->m_pUser))
			continue; // skip unclosed user or chan
		if (!GetModules().OnConfigLine(it->m_sName, it->m_sValue, it->m_pUser, it->m_pChan))
		{
			CUtils::PrintMessage(""unhandled global module config line [GM:"" + it->m_sName + ""] = ["" + it->m_sValue + ""]"");
		}
	}
#endif

	if (pChan) {
		// TODO last <Chan> not closed
		delete pChan;
	}

	if (pUser) {
		// TODO last <User> not closed
		delete pUser;
	}

	File.Close();

	if (m_msUsers.size() == 0) {
		sError = ""You must define at least one user in your config."";
		CUtils::PrintError(sError);
		return false;
	}

	if (m_vpListeners.size() == 0) {
		sError = ""You must supply at least one Listen port in your config."";
		CUtils::PrintError(sError);
		return false;
	}

	// Make sure that users that want to connect do so
	RestartConnectUser();

	return true;
}

void CZNC::ClearVHosts() {
	m_vsVHosts.clear();
}

bool CZNC::AddVHost(const CString& sHost) {
	if (sHost.empty()) {
		return false;
	}

	for (unsigned int a = 0; a < m_vsVHosts.size(); a++) {
		if (m_vsVHosts[a].CaseCmp(sHost) == 0) {
			return false;
		}
	}

	m_vsVHosts.push_back(sHost);
	return true;
}

bool CZNC::RemVHost(const CString& sHost) {
	// @todo
	return true;
}

void CZNC::Broadcast(const CString& sMessage, bool bAdminOnly,
		CUser* pSkipUser, CClient *pSkipClient) {
	for (map<CString,CUser*>::iterator a = m_msUsers.begin(); a != m_msUsers.end(); a++) {
		if (bAdminOnly && !a->second->IsAdmin())
			continue;

		if (a->second != pSkipUser) {
			CString sMsg = sMessage;

			MODULECALL(OnBroadcast(sMsg), a->second, NULL, continue);
			a->second->PutStatusNotice(""*** "" + sMsg, NULL, pSkipClient);
		}
	}
}

bool CZNC::FindModPath(const CString& sModule, CString& sModPath,
		CString& sDataPath) const {
	CString sMod = sModule;
	CString sDir = sMod;
	if (sModule.find(""."") == CString::npos)
		sMod += "".so"";

	sDataPath = GetCurPath() + ""/modules/"";
	sModPath = sDataPath + sMod;

	if (!CFile::Exists(sModPath)) {
		sDataPath = GetModPath() + ""/"";
		sModPath = sDataPath + sMod;

		if (!CFile::Exists(sModPath)) {
			sDataPath = _DATADIR_ + CString(""/"");
			sModPath = _MODDIR_ + CString(""/"") + sMod;

			if (!CFile::Exists(sModPath)) {
				return false;
			}
		}
	}

	sDataPath += sDir;

	return true;
}

CUser* CZNC::FindUser(const CString& sUsername) {
	map<CString,CUser*>::iterator it = m_msUsers.find(sUsername);

	if (it != m_msUsers.end()) {
		return it->second;
	}

	return NULL;
}

bool CZNC::DeleteUser(const CString& sUsername) {
	CUser* pUser = FindUser(sUsername);

	if (!pUser) {
		return false;
	}

	m_msDelUsers[pUser->GetUserName()] = pUser;
	return true;
}

bool CZNC::AddUser(CUser* pUser, CString& sErrorRet) {
	if (pUser->IsValid(sErrorRet)) {
		m_msUsers[pUser->GetUserName()] = pUser;
		return true;
	}

	DEBUG_ONLY(cout << ""Invalid user ["" << pUser->GetUserName() << ""] - ["" << sErrorRet << ""]"" << endl);
	return false;
}

CZNC& CZNC::Get() {
	static CZNC* pZNC = new CZNC;
	return *pZNC;
}

void CZNC::UpdateTrafficStats() {
	CSockManager* p = &m_Manager;
	for (unsigned int a = 0; a < p->size(); a++) {
		if ((*p)[a]->GetSockName().Left(5) == ""IRC::"") {
			CIRCSock *i = (CIRCSock *)(*p)[a];
			i->GetUser()->AddBytesRead((*p)[a]->GetBytesRead());
			(*p)[a]->ResetBytesRead();
			i->GetUser()->AddBytesWritten((*p)[a]->GetBytesWritten());
			(*p)[a]->ResetBytesWritten();
		} else if ((*p)[a]->GetSockName().Left(5) == ""USR::"") {
			CClient *c = (CClient *)(*p)[a];
			c->GetUser()->AddBytesRead((*p)[a]->GetBytesRead());
			(*p)[a]->ResetBytesRead();
			c->GetUser()->AddBytesWritten((*p)[a]->GetBytesWritten());
			(*p)[a]->ResetBytesWritten();
		}
	}
}

void CZNC::AuthUser(CSmartPtr<CAuthBase> AuthClass) {
#ifdef _MODULES
	// TODO unless the auth module calls it, CUser::IsHostAllowed() is not honoured
	if (GetModules().OnLoginAttempt(AuthClass)) {
		return;
	}
#endif

	CUser* pUser = GetUser(AuthClass->GetUsername());

	if (!pUser || !pUser->CheckPass(AuthClass->GetPassword())) {
		if (pUser) {
			pUser->PutStatus(""Another client attempted to login as you, with a bad password."");
		}

		AuthClass->RefuseLogin(""Invalid Password"");
		return;
	}

	CString sHost = AuthClass->GetRemoteIP();

	if (!pUser->IsHostAllowed(sHost)) {
		AuthClass->RefuseLogin(""Your host ["" + sHost + ""] is not allowed"");
		return;
	}

	AuthClass->AcceptLogin(*pUser);
}

class CConnectUserTimer : public CCron {
public:
	CConnectUserTimer(int iSecs) : CCron() {
		SetName(""Connect users"");
		Start(iSecs);
		m_itUserIter = CZNC::Get().GetUserMap().begin();
	}
	virtual ~CConnectUserTimer() {}

protected:
	virtual void RunJob() {
		unsigned int uiUserCount;
		map<CString,CUser*>::const_iterator end;
		bool bUsersLeft = false;

		uiUserCount = CZNC::Get().GetUserMap().size();
		end = CZNC::Get().GetUserMap().end();

		// Try to connect each user, if this doesnt work, abort
		for (unsigned int i = 0; i < uiUserCount; i++) {
			if (m_itUserIter == end) {
				m_itUserIter = CZNC::Get().GetUserMap().begin();
			}

			CUser* pUser = m_itUserIter->second;

			m_itUserIter++;

			// Is this user disconnected and does he want to connect?
			if (pUser->GetIRCSock() == NULL && pUser->GetIRCConnectEnabled())
				bUsersLeft = true;

			if (CZNC::Get().ConnectUser(pUser))
				// Wait until next time timer fires
				return;
		}

		if (bUsersLeft == false)
			CZNC::Get().DisableConnectUser();
	}

private:
	map<CString,CUser*>::const_iterator	m_itUserIter;
};

void CZNC::EnableConnectUser() {
	if (m_pConnectUserTimer != NULL)
		return;

	m_pConnectUserTimer = new CConnectUserTimer(m_uiConnectDelay);
	GetManager().AddCron(m_pConnectUserTimer);
}

void CZNC::DisableConnectUser() {
	if (m_pConnectUserTimer == NULL)
		return;

	// This will kill the cron
	m_pConnectUserTimer->Stop();
	m_pConnectUserTimer = NULL;
}

void CZNC::RestartConnectUser() {
	DisableConnectUser();

	map<CString, CUser*>::iterator end = m_msUsers.end();
	for (map<CString,CUser*>::iterator it = m_msUsers.begin(); it != end; it++) {
		// If there is a user without irc socket we need the timer
		if (it->second->GetIRCSock() == NULL) {
			EnableConnectUser();
			return;
		}
	}
}
""","""/*
 * Copyright (C) 2004-2008  See the AUTHORS file for details.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 as published
 * by the Free Software Foundation.
 */

#include ""znc.h""
#include ""Chan.h""
#include ""IRCSock.h""
#include ""Server.h""
#include ""User.h""
#include <pwd.h>
#include <list>

namespace
{ // private namespace for local things
	struct CGlobalModuleConfigLine
	{
		CString	m_sName;
		CString	m_sValue;
		CUser	*m_pUser;
		CChan	*m_pChan;
	};
};

CZNC::CZNC() {
#ifdef _MODULES
	m_pModules = new CGlobalModules();
#endif
	m_pISpoofLockFile = NULL;
	m_uiConnectDelay = 30;
	SetISpoofFormat(""""); // Set ISpoofFormat to default
	m_uBytesRead = 0;
	m_uBytesWritten = 0;
	m_pConnectUserTimer = NULL;
	m_bNeedRehash = false;
	m_TimeStarted = time(NULL);
}

CZNC::~CZNC() {
	if (m_pISpoofLockFile)
		ReleaseISpoof();

#ifdef _MODULES
	m_pModules->UnloadAll();

	for (map<CString,CUser*>::iterator a = m_msUsers.begin(); a != m_msUsers.end(); a++) {
		a->second->GetModules().UnloadAll();
	}
#endif

	for (size_t b = 0; b < m_vpListeners.size(); b++) {
		delete m_vpListeners[b];
	}

	for (map<CString,CUser*>::iterator a = m_msUsers.begin(); a != m_msUsers.end(); a++) {
		a->second->SetBeingDeleted(true);
	}

	m_pConnectUserTimer = NULL;
	// This deletes m_pConnectUserTimer
	m_Manager.Cleanup();
	DeleteUsers();

#ifdef _MODULES
	delete m_pModules;
#endif

	DeletePidFile();
}

CString CZNC::GetVersion() {
	char szBuf[128];

	snprintf(szBuf, sizeof(szBuf), ""%1.3f""VERSION_EXTRA, VERSION);
	// If snprintf overflows (which I doubt), we want to be on the safe side
	szBuf[sizeof(szBuf) - 1] = '\0';

	return szBuf;
}

CString CZNC::GetTag(bool bIncludeVersion) {
	if (!bIncludeVersion) {
		return ""ZNC - http://znc.sourceforge.net"";
	}

	char szBuf[128];
	snprintf(szBuf, sizeof(szBuf), ""ZNC %1.3f""VERSION_EXTRA"" - http://znc.sourceforge.net"", VERSION);
	// If snprintf overflows (which I doubt), we want to be on the safe side
	szBuf[sizeof(szBuf) - 1] = '\0';

	return szBuf;
}

CString CZNC::GetUptime() {
	time_t now = time(NULL);
	return CString::ToTimeStr(now - TimeStarted());
}

bool CZNC::OnBoot() {
#ifdef _MODULES
	if (!GetModules().OnBoot()) {
		return false;
	}

	for (map<CString,CUser*>::iterator it = m_msUsers.begin(); it != m_msUsers.end(); it++) {
		if (!it->second->GetModules().OnBoot()) {
			return false;
		}
	}
#endif

	return true;
}

bool CZNC::ConnectUser(CUser *pUser) {
	CString sSockName = ""IRC::"" + pUser->GetUserName();
	// Don't use pUser->GetIRCSock(), as that only returns something if the
	// CIRCSock is already connected, not when it's still connecting!
	CIRCSock* pIRCSock = (CIRCSock*) m_Manager.FindSockByName(sSockName);

	if (m_pISpoofLockFile != NULL) {
		return false;
	}

	if (!pUser->GetIRCConnectEnabled())
		return false;

	if (pIRCSock || !pUser->HasServers())
		return false;

	if (pUser->ConnectPaused())
		return false;

	CServer* pServer = pUser->GetNextServer();

	if (!pServer)
		return false;

	if (!WriteISpoof(pUser)) {
		DEBUG_ONLY(cout << ""ISpoof could not be written"" << endl);
		pUser->PutStatus(""ISpoof could not be written, retrying..."");
		return true;
	}

	DEBUG_ONLY(cout << ""User ["" << pUser->GetUserName() << ""] is connecting to ["" << pServer->GetName() << "":"" << pServer->GetPort() << ""] ..."" << endl);
	pUser->PutStatus(""Attempting to connect to ["" + pServer->GetName() + "":"" + CString(pServer->GetPort()) + ""] ..."");

	pIRCSock = new CIRCSock(pUser);
	pIRCSock->SetPass(pServer->GetPass());

	bool bSSL = false;
#ifdef HAVE_LIBSSL
	if (pServer->IsSSL()) {
		bSSL = true;
	}
#endif

	if (!m_Manager.Connect(pServer->GetName(), pServer->GetPort(), sSockName, 120, bSSL, pUser->GetVHost(), pIRCSock)) {
		ReleaseISpoof();
		pUser->PutStatus(""Unable to connect. (Bad host?)"");
	}

	return true;
}

bool CZNC::HandleUserDeletion()
{
	map<CString, CUser*>::iterator it;
	map<CString, CUser*>::iterator end;

	if (m_msDelUsers.size() == 0)
		return false;

	end = m_msDelUsers.end();
	for (it = m_msDelUsers.begin(); it != end; it++) {
		CUser* pUser = it->second;
		pUser->SetBeingDeleted(true);

#ifdef _MODULES
		if (GetModules().OnDeleteUser(*pUser)) {
			pUser->SetBeingDeleted(false);
			continue;
		}
#endif
		m_msUsers.erase(pUser->GetUserName());

		CIRCSock* pIRCSock = pUser->GetIRCSock();

		if (pIRCSock) {
			m_Manager.DelSockByAddr(pIRCSock);
		}

		pUser->DelClients();
#ifdef _MODULES
		pUser->DelModules();
#endif
		AddBytesRead(pUser->BytesRead());
		AddBytesWritten(pUser->BytesWritten());
		delete pUser;
	}

	m_msDelUsers.clear();
	RestartConnectUser();

	return true;
}

int CZNC::Loop() {
	while (true) {
		CString sError;
		map<CString, CUser*>::iterator it;
		map<CString, CUser*>::iterator end;

		if (GetNeedRehash()) {
			SetNeedRehash(false);

			if (RehashConfig(sError)) {
				Broadcast(""Rehashing succeeded"", true);
			} else {
				Broadcast(""Rehashing failed: "" + sError, true);
				Broadcast(""ZNC is in some possibly inconsistent state!"", true);
			}
		}

		// Check for users that need to be deleted
		if (HandleUserDeletion()) {
			// Also remove those user(s) from the config file
			WriteConfig();
		}

		// Csocket wants micro seconds
		// 500 msec to 600 sec
		m_Manager.DynamicSelectLoop(500 * 1000, 600 * 1000 * 1000);
	}

	return 0;
}

bool CZNC::WriteISpoof(CUser* pUser) {
	if (m_pISpoofLockFile != NULL)
		return false;

	if (!m_sISpoofFile.empty()) {
		m_pISpoofLockFile = new CLockFile;
		if (!m_pISpoofLockFile->TryExLock(m_sISpoofFile, true)) {
			delete m_pISpoofLockFile;
			m_pISpoofLockFile = NULL;
			return false;
		}

		CFile File(m_pISpoofLockFile->GetFD(), m_pISpoofLockFile->GetFileName());

		char buf[1024];
		memset((char*) buf, 0, 1024);
		File.Read(buf, 1023);
		m_sOrigISpoof = buf;

		if (!File.Seek(0) || !File.Truncate()) {
			delete m_pISpoofLockFile;
			m_pISpoofLockFile = NULL;
			return false;
		}

		CString sData = m_sISpoofFormat.Token(0, false, ""%"") + pUser->GetIdent() + m_sISpoofFormat.Token(1, true, ""%"");
		File.Write(sData + ""\n"");
	}
	return true;
}

void CZNC::ReleaseISpoof() {
	if (m_pISpoofLockFile == NULL)
		return;

	if (!m_sISpoofFile.empty()) {
		CFile File(m_pISpoofLockFile->GetFD(), m_pISpoofLockFile->GetFileName());

		if (File.Seek(0) && File.Truncate()) {
			File.Write(m_sOrigISpoof);
		}

		m_sOrigISpoof = """";
	}

	delete m_pISpoofLockFile;
	m_pISpoofLockFile = NULL;
}

bool CZNC::WritePidFile(int iPid) {
	if (!m_sPidFile.empty()) {
		CString sFile;

		// absolute path or relative to the data dir?
		if (m_sPidFile[0] != '/')
			sFile = GetZNCPath() + ""/"" + m_sPidFile;
		else
			sFile = m_sPidFile;

		CFile File(sFile);
		CUtils::PrintAction(""Writing pid file ["" + sFile + ""]"");

		if (File.Open(O_WRONLY | O_TRUNC | O_CREAT)) {
			File.Write(CString(iPid) + ""\n"");
			File.Close();
			CUtils::PrintStatus(true);
			return true;
		}

		CUtils::PrintStatus(false);
	}

	return false;
}

bool CZNC::DeletePidFile() {
	if (!m_sPidFile.empty()) {
		CString sFile;
		// absolute path or relative to the data dir?
		if (m_sPidFile[0] != '/')
			sFile = GetZNCPath() + ""/"" + m_sPidFile;
		else
			sFile = m_sPidFile;

		CFile File(sFile);
		CUtils::PrintAction(""Deleting pid file ["" + sFile + ""]"");
		if (File.Delete()) {
			CUtils::PrintStatus(true);
			return true;
		}
		CUtils::PrintStatus(false);
	}
	return false;
}

bool CZNC::WritePemFile(bool bEncPem) {
#ifndef HAVE_LIBSSL
	CUtils::PrintError(""ZNC was not compiled with ssl support."");
	return false;
#else
	CString sPemFile = GetPemLocation();
	const char* pHostName = getenv(""HOSTNAME"");
	CString sHost;

	if (pHostName) {
		sHost = pHostName;
	}

	if (CFile::Exists(sPemFile)) {
		CUtils::PrintError(""Pem file ["" + sPemFile + ""] already exists"");
		return false;
	}

	while (!CUtils::GetInput(""hostname of your shell"", sHost, sHost, ""including the '.com' portion"")) ;

	CUtils::PrintAction(""Writing Pem file ["" + sPemFile + ""]"");
	FILE *f = fopen(sPemFile.c_str(), ""w"");

	if (!f) {
		CUtils::PrintStatus(false, ""Unable to open"");
		return false;
	}

	CUtils::GenerateCert(f, bEncPem, sHost);
	fclose(f);

	CUtils::PrintStatus(true);
	return true;
#endif
}

void CZNC::DeleteUsers() {
	for (map<CString,CUser*>::iterator a = m_msUsers.begin(); a != m_msUsers.end(); a++) {
		a->second->SetBeingDeleted(true);
		delete a->second;
	}

	m_msUsers.clear();
	DisableConnectUser();
}

CUser* CZNC::GetUser(const CString& sUser) {
	// Todo: make this case insensitive
	map<CString,CUser*>::iterator it = m_msUsers.find(sUser);
	return (it == m_msUsers.end()) ? NULL : it->second;
}

Csock* CZNC::FindSockByName(const CString& sSockName) {
	return m_Manager.FindSockByName(sSockName);
}

bool CZNC::IsHostAllowed(const CString& sHostMask) {
	for (map<CString,CUser*>::iterator a = m_msUsers.begin(); a != m_msUsers.end(); a++) {
		if (a->second->IsHostAllowed(sHostMask)) {
			return true;
		}
	}

	return false;
}

void CZNC::InitDirs(const CString& sArgvPath, const CString& sDataDir) {
	char buf[PATH_MAX];
	char *home;

	if (getcwd(buf, PATH_MAX) == NULL) {
		CUtils::PrintError(""getcwd() failed, can't read my current dir"");
		exit(-1);
	}

	// If the bin was not ran from the current directory, we need to add that dir onto our cwd
	CString::size_type uPos = sArgvPath.rfind('/');
	m_sCurPath = (uPos == CString::npos) ? CString(buf) : CDir::ChangeDir(buf, sArgvPath.substr(0, uPos), """");

	// Try to set the user's home dir, default to binpath on failure
	home = getenv(""HOME"");

	m_sHomePath.clear();
	if (home) {
		m_sHomePath = home;
	}

	if (m_sHomePath.empty()) {
		struct passwd* pUserInfo = getpwuid(getuid());

		if (pUserInfo) {
			m_sHomePath = pUserInfo->pw_dir;
		}
	}

	if (m_sHomePath.empty()) {
		m_sHomePath = m_sCurPath;
	}

	if (sDataDir.empty()) {
	    m_sZNCPath = m_sHomePath + ""/.znc"";
	} else {
	    m_sZNCPath = sDataDir;
	}

	// Other dirs that we use
	m_sConfPath = m_sZNCPath + ""/configs"";
	m_sModPath = m_sZNCPath + ""/modules"";
	m_sUserPath = m_sZNCPath + ""/users"";
}


CString CZNC::ExpandConfigPath(const CString& sConfigFile) {
	CString sRetPath;

	if (sConfigFile.empty()) {
		sRetPath = GetConfPath() + ""/znc.conf"";
	} else {
		if (sConfigFile.Left(2) == ""./"" || sConfigFile.Left(3) == ""../"") {
			sRetPath = GetCurPath() + ""/"" + sConfigFile;
		} else if (sConfigFile.Left(1) != ""/"") {
			sRetPath = GetConfPath() + ""/"" + sConfigFile;
		} else {
			sRetPath = sConfigFile;
		}
	}

	return sRetPath;
}

bool CZNC::BackupConfig() const {
	CString sBackup = GetConfigFile() + ""-backup"";

	// Create a new backup overwriting an old one we might have
	if (CFile::Copy(m_sConfigFile, sBackup, true))
		return true;

	// Don't abort if no config file exists
	if (!CFile::Exists(m_sConfigFile))
		// No backup because we got nothing to backup
		return true;

	return false;
}

bool CZNC::WriteConfig() {
	CFile File(GetConfigFile());

	if (!BackupConfig()) {
		return false;
	}

	if (m_sConfigFile.empty() || !File.Open(O_WRONLY | O_CREAT | O_TRUNC, 0600)) {
		return false;
	}

	for (size_t l = 0; l < m_vpListeners.size(); l++) {
		CListener* pListener = m_vpListeners[l];
		CString sHostPortion = pListener->GetBindHost();

		if (!sHostPortion.empty()) {
			sHostPortion += "" "";
		}

		CString s6 = (pListener->IsIPV6()) ? ""6"" : "" "";

		File.Write(""Listen"" + s6 + ""      = "" + sHostPortion + CString((pListener->IsSSL()) ? ""+"" : """") + CString(pListener->GetPort()) + ""\n"");
	}

	File.Write(""ConnectDelay = "" + CString(m_uiConnectDelay) + ""\n"");

	if (!m_sISpoofFile.empty()) {
		File.Write(""ISpoofFile   = "" + m_sISpoofFile + ""\n"");
		if (!m_sISpoofFormat.empty()) { File.Write(""ISpoofFormat = "" + m_sISpoofFormat + ""\n""); }
	}

	if (!m_sPidFile.empty()) { File.Write(""PidFile      = "" + m_sPidFile + ""\n""); }
	if (!m_sStatusPrefix.empty()) { File.Write(""StatusPrefix = "" + m_sStatusPrefix + ""\n""); }

	for (unsigned int m = 0; m < m_vsMotd.size(); m++) {
		File.Write(""Motd         = "" + m_vsMotd[m] + ""\n"");
	}

	for (unsigned int v = 0; v < m_vsVHosts.size(); v++) {
		File.Write(""VHost        = "" + m_vsVHosts[v] + ""\n"");
	}

#ifdef _MODULES
	CGlobalModules& Mods = GetModules();

	for (unsigned int a = 0; a < Mods.size(); a++) {
		CString sArgs = Mods[a]->GetArgs();

		if (!sArgs.empty()) {
			sArgs = "" "" + sArgs;
		}

		File.Write(""LoadModule   = "" + Mods[a]->GetModName() + sArgs + ""\n"");
	}
#endif

	for (map<CString,CUser*>::iterator it = m_msUsers.begin(); it != m_msUsers.end(); it++) {
		CString sErr;

		if (!it->second->IsValid(sErr)) {
			DEBUG_ONLY(cerr << ""** Error writing config for user ["" << it->first << ""] ["" << sErr << ""]"" << endl);
			continue;
		}

		File.Write(""\n"");

		if (!it->second->WriteConfig(File)) {
			DEBUG_ONLY(cerr << ""** Error writing config for user ["" << it->first << ""]"" << endl);
		}
	}

	File.Close();

	return true;
}

bool CZNC::WriteNewConfig(const CString& sConfig) {
	CString sConfigFile = ExpandConfigPath((sConfig.empty()) ? ""znc.conf"" : sConfig);
	CString sAnswer, sUser;
	vector<CString> vsLines;

	if (CFile::Exists(sConfigFile)) {
		if (!m_LockFile.TryExLock(sConfigFile)) {
			CUtils::PrintError(""ZNC is currently running on this config."");
			return false;
		}

		if (!CUtils::GetBoolInput(""This config already exists.  Would you like to overwrite it?"", false)) {
			m_LockFile.UnLock();
			return false;
		}
	}

	CUtils::PrintMessage(""Writing new config ["" + sConfigFile + ""]"");

	CUtils::PrintMessage("""");
	CUtils::PrintMessage(""First lets start with some global settings..."");
	CUtils::PrintMessage("""");

	// Listen
	unsigned int uListenPort = 0;
	while (!CUtils::GetNumInput(""What port would you like ZNC to listen on?"", uListenPort, 1, 65535)) ;

	CString sSSL;
#ifdef HAVE_LIBSSL
	if (CUtils::GetBoolInput(""Would you like ZNC to listen using SSL?"", false)) {
		sSSL = ""+"";
	}
#endif

	CString s6 = "" "";
#ifdef HAVE_IPV6
	if (CUtils::GetBoolInput(""Would you like ZNC to listen using ipv6?"", false)) {
		s6 = ""6"";
	}
#endif

	CString sListenHost;
	CUtils::GetInput(""Listen Host"", sListenHost, """", ""Blank for all ips"");

	if (!sListenHost.empty()) {
		sListenHost += "" "";
	}

	vsLines.push_back(""Listen"" + s6 + ""    = "" + sListenHost + sSSL + CString(uListenPort));
	// !Listen

#ifdef _MODULES
	set<CModInfo> ssGlobalMods;
	GetModules().GetAvailableMods(ssGlobalMods, true);

	if (ssGlobalMods.size()) {
		CUtils::PrintMessage("""");
		CUtils::PrintMessage(""-- Global Modules --"");
		CUtils::PrintMessage("""");

		if (CUtils::GetBoolInput(""Do you want to load any global modules?"")) {
			CTable Table;
			Table.AddColumn(""Name"");
			Table.AddColumn(""Description"");
			set<CModInfo>::iterator it;

			for (it = ssGlobalMods.begin(); it != ssGlobalMods.end(); it++) {
				const CModInfo& Info = *it;
				Table.AddRow();
				Table.SetCell(""Name"", Info.GetName());
				Table.SetCell(""Description"", Info.GetDescription().Ellipsize(128));
			}

			unsigned int uTableIdx = 0; CString sLine;
			while (Table.GetLine(uTableIdx++, sLine)) {
				CUtils::PrintMessage(sLine);
			}

			CUtils::PrintMessage("""");

			for (it = ssGlobalMods.begin(); it != ssGlobalMods.end(); it++) {
				const CModInfo& Info = *it;
				CString sName = Info.GetName();

				if (sName.Right(3).CaseCmp("".so"") == 0) {
					sName.RightChomp(3);
				}

				if (CUtils::GetBoolInput(""Load global module <\033[1m"" + sName + ""\033[22m>?"", false)) {
					vsLines.push_back(""LoadModule = "" + sName);
				}
			}
		}
	}
#endif

	// User
	CUtils::PrintMessage("""");
	CUtils::PrintMessage(""Now we need to setup a user..."");
	CUtils::PrintMessage("""");

	bool bFirstUser = true;

	do {
		vsLines.push_back("""");
		CString sNick;
		do {
			CUtils::GetInput(""Username"", sUser, """", ""AlphaNumeric"");
		} while (!CUser::IsValidUserName(sUser));

		vsLines.push_back(""<User "" + sUser + "">"");
		sAnswer = CUtils::GetHashPass();
		vsLines.push_back(""\tPass       = "" + sAnswer + "" -"");

		if (CUtils::GetBoolInput(""Would you like this user to be an admin?"", bFirstUser)) {
			vsLines.push_back(""\tAdmin      = true"");
		} else {
			vsLines.push_back(""\tAdmin      = false"");
		}

		CUtils::GetInput(""Nick"", sNick, CUser::MakeCleanUserName(sUser));
		vsLines.push_back(""\tNick       = "" + sNick);
		CUtils::GetInput(""Alt Nick"", sAnswer, sNick + ""_"");
		if (!sAnswer.empty()) {
			vsLines.push_back(""\tAltNick    = "" + sAnswer);
		}
		CUtils::GetInput(""Ident"", sAnswer, sNick);
		vsLines.push_back(""\tIdent      = "" + sAnswer);
		CUtils::GetInput(""Real Name"", sAnswer, ""Got ZNC?"");
		vsLines.push_back(""\tRealName   = "" + sAnswer);
		CUtils::GetInput(""VHost"", sAnswer, """", ""optional"");
		if (!sAnswer.empty()) {
			vsLines.push_back(""\tVHost      = "" + sAnswer);
		}
		// todo: Possibly add motd

		if (CUtils::GetBoolInput(""Would you like ZNC to keep trying for your primary nick?"", false)) {
			vsLines.push_back(""\tKeepNick   = true"");
		} else {
			vsLines.push_back(""\tKeepNick   = false"");
		}

		unsigned int uBufferCount = 0;

		CUtils::GetNumInput(""Number of lines to buffer per channel"", uBufferCount, 0, ~0, 50);
		if (uBufferCount) {
			vsLines.push_back(""\tBuffer     = "" + CString(uBufferCount));
		}
		if (CUtils::GetBoolInput(""Would you like to keep buffers after replay?"", false)) {
			vsLines.push_back(""\tKeepBuffer = true"");
		} else {
			vsLines.push_back(""\tKeepBuffer = false"");
		}

		CUtils::GetInput(""Default channel modes"", sAnswer, ""+stn"");
		if (!sAnswer.empty()) {
			vsLines.push_back(""\tChanModes  = "" + sAnswer);
		}

#ifdef _MODULES
		set<CModInfo> ssUserMods;
		GetModules().GetAvailableMods(ssUserMods);

		if (ssUserMods.size()) {
			vsLines.push_back("""");
			CUtils::PrintMessage("""");
			CUtils::PrintMessage(""-- User Modules --"");
			CUtils::PrintMessage("""");

			if (CUtils::GetBoolInput(""Do you want to automatically load any user modules for this user?"")) {
				CTable Table;
				Table.AddColumn(""Name"");
				Table.AddColumn(""Description"");
				set<CModInfo>::iterator it;

				for (it = ssUserMods.begin(); it != ssUserMods.end(); it++) {
					const CModInfo& Info = *it;
					Table.AddRow();
					Table.SetCell(""Name"", Info.GetName());
					Table.SetCell(""Description"", Info.GetDescription().Ellipsize(128));
				}

				unsigned int uTableIdx = 0; CString sLine;
				while (Table.GetLine(uTableIdx++, sLine)) {
					CUtils::PrintMessage(sLine);
				}

				CUtils::PrintMessage("""");

				for (it = ssUserMods.begin(); it != ssUserMods.end(); it++) {
					const CModInfo& Info = *it;
					CString sName = Info.GetName();

					if (CUtils::GetBoolInput(""Load "" + CString((Info.IsSystem()) ? ""system"" : ""local"") + "" module <\033[1m"" + sName + ""\033[22m>?"", false)) {
						vsLines.push_back(""\tLoadModule = "" + sName);
					}
				}
			}
		}
#endif

		vsLines.push_back("""");
		CUtils::PrintMessage("""");
		CUtils::PrintMessage(""-- IRC Servers --"");
		CUtils::PrintMessage("""");

		do {
			CString sHost, sPass;
			bool bSSL = false;
			unsigned int uServerPort = 0;

			while (!CUtils::GetInput(""IRC server"", sHost, """", ""host only"") || !CServer::IsValidHostName(sHost)) ;
			while (!CUtils::GetNumInput(""["" + sHost + ""] Port"", uServerPort, 1, 65535, 6667)) ;
			CUtils::GetInput(""["" + sHost + ""] Password (probably empty)"", sPass);

#ifdef HAVE_LIBSSL
			bSSL = CUtils::GetBoolInput(""Does this server use SSL? (probably no)"", false);
#endif

			vsLines.push_back(""\tServer     = "" + sHost + ((bSSL) ? "" +"" : "" "") + CString(uServerPort) + "" "" + sPass);
		} while (CUtils::GetBoolInput(""Would you like to add another server?"", false));

		vsLines.push_back("""");
		CUtils::PrintMessage("""");
		CUtils::PrintMessage(""-- Channels --"");
		CUtils::PrintMessage("""");

		CString sArg = ""a"";
		CString sPost = "" for ZNC to automatically join?"";
		bool bDefault = true;

		while (CUtils::GetBoolInput(""Would you like to add "" + sArg + "" channel"" + sPost, bDefault)) {
			while (!CUtils::GetInput(""Channel name"", sAnswer)) ;
			vsLines.push_back(""\t<Chan "" + sAnswer + "">"");
			vsLines.push_back(""\t</Chan>"");
			sArg = ""another"";
			sPost = ""?"";
			bDefault = false;
		}

		vsLines.push_back(""</User>"");

		CUtils::PrintMessage("""");
		bFirstUser = false;
	} while (CUtils::GetBoolInput(""Would you like to setup another user?"", false));
	// !User

	CUtils::PrintAction(""Writing config ["" + sConfigFile + ""]"");
	CFile File(sConfigFile);

	bool bFileOpen = false;

	if (File.Open(O_WRONLY | O_CREAT | O_TRUNC, 0600)) {
		bFileOpen = true;
	} else {
		CUtils::PrintStatus(false, ""Unable to open file"");
		CUtils::GetInput(""Alternate location"", sConfigFile, ""/tmp/"" + sConfig);

		if (!CFile::Exists(sConfigFile) || CUtils::GetBoolInput(""Would you like to overwrite the existing alt file"", false)) {
			CUtils::PrintAction(""Writing to alt location ["" + sConfigFile + ""]"");
			File.SetFileName(sConfigFile);

			if (File.Open(O_WRONLY | O_CREAT | O_TRUNC, 0600)) {
				bFileOpen = true;
			} else {
				CUtils::PrintStatus(false, ""Unable to open alt file"");
			}
		}
	}

	if (!bFileOpen) {
		CUtils::PrintMessage("""");
		CUtils::PrintMessage(""Printing new config to stdout since we were unable to open a file"");
		CUtils::PrintMessage("""");
		cout << endl << ""----------------------------------------------------------------------------"" << endl << endl;
	}

	for (unsigned int a = 0; a < vsLines.size(); a++) {
		if (bFileOpen) {
			File.Write(vsLines[a] + ""\n"");
		} else {
			cout << vsLines[a] << endl;
		}
	}

	if (bFileOpen) {
		File.Close();

		CUtils::PrintStatus(true);
	} else {
		cout << endl << ""----------------------------------------------------------------------------"" << endl << endl;
	}

	CUtils::PrintMessage("""");
	CUtils::PrintMessage(""To connect to this znc you need to connect to it as your irc server"", true);
	CUtils::PrintMessage(""using the port that you supplied.  You have to supply your login info"", true);
	CUtils::PrintMessage(""as the irc server password like so.. user:pass."", true);
	CUtils::PrintMessage("""");
	CUtils::PrintMessage(""Try something like this in your IRC client..."", true);
	CUtils::PrintMessage(""/server <znc_server_ip> "" + CString(uListenPort) + "" "" + sUser + "":<pass>"", true);
	CUtils::PrintMessage("""");

	m_LockFile.UnLock();
	return CUtils::GetBoolInput(""Launch znc now?"", true);
}

bool CZNC::ParseConfig(const CString& sConfig)
{
	CString s;

	m_sConfigFile = ExpandConfigPath(sConfig);

	return DoRehash(s);
}

bool CZNC::RehashConfig(CString& sError)
{
#ifdef _MODULES
	GetModules().OnPreRehash();
	for (map<CString, CUser*>::iterator itb = m_msUsers.begin();
			itb != m_msUsers.end(); itb++) {
		itb->second->GetModules().OnPreRehash();
	}
#endif

	// This clears m_msDelUsers
	HandleUserDeletion();

	// Mark all users as going-to-be deleted
	m_msDelUsers = m_msUsers;
	m_msUsers.clear();

	// Make sure that timer doesn't have a stale iterator
	DisableConnectUser();

	if (DoRehash(sError)) {
#ifdef _MODULES
		GetModules().OnPostRehash();
		for (map<CString, CUser*>::iterator it = m_msUsers.begin();
				it != m_msUsers.end(); it++) {
			it->second->GetModules().OnPostRehash();
		}
#endif

		return true;
	}

	// Rehashing failed, try to recover
	CString s;
	while (m_msDelUsers.size()) {
		AddUser(m_msDelUsers.begin()->second, s);
		m_msDelUsers.erase(m_msDelUsers.begin());
	}

	// Make sure that users that want to connect do so
	RestartConnectUser();

	return false;
}

bool CZNC::DoRehash(CString& sError)
{
	sError.clear();

	CUtils::PrintAction(""Opening Config ["" + m_sConfigFile + ""]"");

	if (!CFile::Exists(m_sConfigFile)) {
		sError = ""No such file"";
		CUtils::PrintStatus(false, sError);
		CUtils::PrintMessage(""Restart znc with the --makeconf option if you wish to create this config."");
		return false;
	}

	if (!CFile::IsReg(m_sConfigFile)) {
		sError = ""Not a file"";
		CUtils::PrintStatus(false, sError);
		return false;
	}

	if (!m_LockFile.Open(m_sConfigFile)) {
		sError = ""Can not open config file"";
		CUtils::PrintStatus(false, sError);
		return false;
	}

	if (!m_LockFile.TryExLock()) {
		sError = ""ZNC is already running on this config."";
		CUtils::PrintStatus(false, sError);
		return false;
	}

	CFile File(m_LockFile.GetFD(), m_sConfigFile);

	// This fd is re-used for rehashing, so we must seek back to the beginning!
	if (!File.Seek(0)) {
		sError = ""Could not seek to the beginning of the config."";
		CUtils::PrintStatus(false, sError);
		return false;
	}

	CUtils::PrintStatus(true);

	m_vsVHosts.clear();
	m_vsMotd.clear();

	// Delete all listeners
	while (m_vpListeners.size()) {
		delete m_vpListeners[0];
		m_vpListeners.erase(m_vpListeners.begin());
	}

	// Make sure that timer doesn't have a stale iterator
	DisableConnectUser();

	CString sLine;
	bool bCommented = false;	// support for /**/ style comments
	CUser* pUser = NULL;	// Used to keep track of which user block we are in
	CUser* pRealUser = NULL;	// If we rehash a user, this is the real one
	CChan* pChan = NULL;	// Used to keep track of which chan block we are in
	unsigned int uLineNum = 0;
#ifdef _MODULES
	MCString msModules;	// Modules are queued for later loading
#endif

	std::list<CGlobalModuleConfigLine> lGlobalModuleConfigLine;

	while (File.ReadLine(sLine)) {
		uLineNum++;

		// Remove all leading / trailing spaces and line endings
		sLine.Trim();

		if ((sLine.empty()) || (sLine[0] == '#') || (sLine.Left(2) == ""//"")) {
			continue;
		}

		if (sLine.Left(2) == ""/*"") {
			if (sLine.Right(2) != ""*/"") {
				bCommented = true;
			}

			continue;
		}

		if (bCommented) {
			if (sLine.Right(2) == ""*/"") {
				bCommented = false;
			}

			continue;
		}

		if ((sLine.Left(1) == ""<"") && (sLine.Right(1) == "">"")) {
			sLine.LeftChomp();
			sLine.RightChomp();
			sLine.Trim();

			CString sTag = sLine.substr(0, sLine.find_first_of("" \t\r\n""));
			CString sValue = (sTag.size() < sLine.size()) ? sLine.substr(sTag.size() +1) : """";

			sTag.Trim();
			sValue.Trim();

			if (sLine.Left(1) == ""/"") {
				sTag = sTag.substr(1);

				if (pUser) {
					if (pChan) {
						if (sTag.CaseCmp(""Chan"") == 0) {
							// Save the channel name, because AddChan
							// deletes the CChannel*, if adding fails
							sError = pChan->GetName();
							if (!pUser->AddChan(pChan)) {
								sError = ""Channel ["" + sError + ""] defined more than once"";
								CUtils::PrintError(sError);
								return false;
							}
							sError.clear();
							pChan = NULL;
							continue;
						}
					} else if (sTag.CaseCmp(""User"") == 0) {
						CString sErr;

						if (pRealUser) {
							if (!pRealUser->Clone(*pUser, sErr)
									|| !AddUser(pRealUser, sErr)) {
								sError = ""Invalid user ["" + pUser->GetUserName() + ""] "" + sErr;
								DEBUG_ONLY(cout << ""CUser::Clone() failed in rehash"" << endl);
							}
							pUser->SetBeingDeleted(true);
							delete pUser;
							pUser = NULL;
						} else if (!AddUser(pUser, sErr)) {
							sError = ""Invalid user ["" + pUser->GetUserName() + ""] "" + sErr;
						}

						if (!sError.empty()) {
							CUtils::PrintError(sError);
							if (pUser) {
								pUser->SetBeingDeleted(true);
								delete pUser;
								pUser = NULL;
							}
							return false;
						}

						pUser = NULL;
						pRealUser = NULL;
						continue;
					}
				}
			} else if (sTag.CaseCmp(""User"") == 0) {
				if (pUser) {
					sError = ""You may not nest <User> tags inside of other <User> tags."";
					CUtils::PrintError(sError);
					return false;
				}

				if (sValue.empty()) {
					sError = ""You must supply a username in the <User> tag."";
					CUtils::PrintError(sError);
					return false;
				}

				if (m_msUsers.find(sValue) != m_msUsers.end()) {
					sError = ""User ["" + sValue + ""] defined more than once."";
					CUtils::PrintError(sError);
					return false;
				}

				CUtils::PrintMessage(""Loading user ["" + sValue + ""]"");

				// Either create a CUser* or use an existing one
				map<CString, CUser*>::iterator it = m_msDelUsers.find(sValue);

				if (it != m_msDelUsers.end()) {
					pRealUser = it->second;
					m_msDelUsers.erase(it);
				} else
					pRealUser = NULL;

				pUser = new CUser(sValue);

				if (!m_sStatusPrefix.empty()) {
					if (!pUser->SetStatusPrefix(m_sStatusPrefix)) {
						sError = ""Invalid StatusPrefix ["" + m_sStatusPrefix + ""] Must be 1-5 chars, no spaces."";
						CUtils::PrintError(sError);
						return false;
					}
				}

				continue;
			} else if (sTag.CaseCmp(""Chan"") == 0) {
				if (!pUser) {
					sError = ""<Chan> tags must be nested inside of a <User> tag."";
					CUtils::PrintError(sError);
					return false;
				}

				if (pChan) {
					sError = ""You may not nest <Chan> tags inside of other <Chan> tags."";
					CUtils::PrintError(sError);
					return false;
				}

				pChan = new CChan(sValue, pUser, true);
				continue;
			}
		}

		// If we have a regular line, figure out where it goes
		CString sName = sLine.Token(0, false, ""="");
		CString sValue = sLine.Token(1, true, ""="");
		sName.Trim();
		sValue.Trim();

		if ((!sName.empty()) && (!sValue.empty())) {
			if (pUser) {
				if (pChan) {
					if (sName.CaseCmp(""Buffer"") == 0) {
						pChan->SetBufferCount(strtoul(sValue.c_str(), NULL, 10));
						continue;
					} else if (sName.CaseCmp(""KeepBuffer"") == 0) {
						pChan->SetKeepBuffer((sValue.CaseCmp(""true"") == 0));
						continue;
					} else if (sName.CaseCmp(""Detached"") == 0) {
						pChan->SetDetached((sValue.CaseCmp(""true"") == 0));
						continue;
					} else if (sName.CaseCmp(""AutoCycle"") == 0) {
						pChan->SetAutoCycle((sValue.CaseCmp(""true"") == 0));
						continue;
					} else if (sName.CaseCmp(""Key"") == 0) {
						pChan->SetKey(sValue);
						continue;
					} else if (sName.CaseCmp(""Modes"") == 0) {
						pChan->SetDefaultModes(sValue);
						continue;
					}
				} else {
					if (sName.CaseCmp(""Buffer"") == 0) {
						pUser->SetBufferCount(strtoul(sValue.c_str(), NULL, 10));
						continue;
					} else if (sName.CaseCmp(""KeepBuffer"") == 0) {
						pUser->SetKeepBuffer((sValue.CaseCmp(""true"") == 0));
						continue;
					} else if (sName.CaseCmp(""AutoCycle"") == 0) {
						pUser->SetAutoCycle((sValue.CaseCmp(""true"") == 0));
						continue;
					} else if (sName.CaseCmp(""Nick"") == 0) {
						pUser->SetNick(sValue);
						continue;
					} else if (sName.CaseCmp(""CTCPReply"") == 0) {
						pUser->AddCTCPReply(sValue.Token(0), sValue.Token(1, true));
						continue;
					} else if (sName.CaseCmp(""QuitMsg"") == 0) {
						pUser->SetQuitMsg(sValue);
						continue;
					} else if (sName.CaseCmp(""AltNick"") == 0) {
						pUser->SetAltNick(sValue);
						continue;
					} else if (sName.CaseCmp(""AwaySuffix"") == 0) {
						CUtils::PrintMessage(""WARNING: AwaySuffix has been depricated, instead try -> LoadModule = awaynick %nick%_"" + sValue);
						continue;
					} else if (sName.CaseCmp(""Pass"") == 0) {
						if (sValue.Right(1) == ""-"") {
							sValue.RightChomp();
							sValue.Trim();
							pUser->SetPass(sValue, true);
						} else {
							pUser->SetPass(sValue, false);
						}

						continue;
					} else if (sName.CaseCmp(""MultiClients"") == 0) {
						pUser->SetMultiClients(sValue.CaseCmp(""true"") == 0);
						continue;
					} else if (sName.CaseCmp(""BounceDCCs"") == 0) {
						pUser->SetBounceDCCs(sValue.CaseCmp(""true"") == 0);
						continue;
					} else if (sName.CaseCmp(""Ident"") == 0) {
						pUser->SetIdent(sValue);
						continue;
					} else if (sName.CaseCmp(""DenyLoadMod"") == 0) {
						pUser->SetDenyLoadMod((sValue.CaseCmp(""TRUE"") == 0));
						continue;
					} else if (sName.CaseCmp(""Admin"") == 0) {
						pUser->SetAdmin((sValue.CaseCmp(""TRUE"") == 0));
						continue;
					} else if (sName.CaseCmp(""DenySetVHost"") == 0) {
						pUser->SetDenySetVHost((sValue.CaseCmp(""TRUE"") == 0));
						continue;
					} else if (sName.CaseCmp(""StatusPrefix"") == 0) {
						if (!pUser->SetStatusPrefix(sValue)) {
							sError = ""Invalid StatusPrefix ["" + sValue + ""] Must be 1-5 chars, no spaces."";
							CUtils::PrintError(sError);
							return false;
						}
						continue;
					} else if (sName.CaseCmp(""DCCLookupMethod"") == 0) {
						pUser->SetUseClientIP((sValue.CaseCmp(""Client"") == 0));
						continue;
					} else if (sName.CaseCmp(""RealName"") == 0) {
						pUser->SetRealName(sValue);
						continue;
					} else if (sName.CaseCmp(""KeepNick"") == 0) {
						pUser->SetKeepNick((sValue.CaseCmp(""true"") == 0));
						continue;
					} else if (sName.CaseCmp(""ChanModes"") == 0) {
						pUser->SetDefaultChanModes(sValue);
						continue;
					} else if (sName.CaseCmp(""VHost"") == 0) {
						pUser->SetVHost(sValue);
						continue;
					} else if (sName.CaseCmp(""Allow"") == 0) {
						pUser->AddAllowedHost(sValue);
						continue;
					} else if (sName.CaseCmp(""Server"") == 0) {
						CUtils::PrintAction(""Adding Server ["" + sValue + ""]"");
						CUtils::PrintStatus(pUser->AddServer(sValue));
						continue;
					} else if (sName.CaseCmp(""Chan"") == 0) {
						pUser->AddChan(sValue, true);
						continue;
					} else if (sName.CaseCmp(""TimestampFormat"") == 0) {
						pUser->SetTimestampFormat(sValue);
						continue;
					} else if (sName.CaseCmp(""AppendTimestamp"") == 0) {
						pUser->SetTimestampAppend(sValue.ToBool());
						continue;
					} else if (sName.CaseCmp(""PrependTimestamp"") == 0) {
						pUser->SetTimestampPrepend(sValue.ToBool());
						continue;
					} else if (sName.CaseCmp(""Timestamp"") == 0) {
						if (sValue.Trim_n().CaseCmp(""true"") != 0) {
							if (sValue.Trim_n().CaseCmp(""append"") == 0) {
								pUser->SetTimestampAppend(true);
								pUser->SetTimestampPrepend(false);
							} else if (sValue.Trim_n().CaseCmp(""prepend"") == 0) {
								pUser->SetTimestampAppend(false);
								pUser->SetTimestampPrepend(true);
							} else if (sValue.Trim_n().CaseCmp(""false"") == 0) {
								pUser->SetTimestampAppend(false);
								pUser->SetTimestampPrepend(false);
							} else {
								pUser->SetTimestampFormat(sValue);
							}
						}
						continue;
					} else if (sName.CaseCmp(""TimezoneOffset"") == 0) {
						pUser->SetTimezoneOffset(sValue.ToDouble()); // there is no ToFloat()
						continue;
					} else if (sName.CaseCmp(""JoinTries"") == 0) {
						pUser->SetJoinTries(sValue.ToUInt());
						continue;
					} else if (sName.CaseCmp(""LoadModule"") == 0) {
						CString sModName = sValue.Token(0);
						CUtils::PrintAction(""Loading Module ["" + sModName + ""]"");
#ifdef _MODULES
						CString sModRet;
						CString sArgs = sValue.Token(1, true);

						try {
							bool bModRet = pUser->GetModules().LoadModule(sModName, sArgs, pUser, sModRet);

							// If the module was loaded, sModRet contains
							// ""Loaded Module [name] ..."" and we strip away this beginning.
							if (bModRet)
								sModRet = sModRet.Token(1, true, sModName + ""] "");

							CUtils::PrintStatus(bModRet, sModRet);
							if (!bModRet) {
								sError = sModRet;
								return false;
							}
						} catch (CException e) {
							sError = ""Caught exception while loading ["" + sModName + ""]"";
							CUtils::PrintStatus(false, sModRet);
							return false;
						}
#else
						sError = ""Modules are not enabled."";
						CUtils::PrintStatus(false, sError);
#endif
						continue;
					}
				}
			} else {
				if (sName.CaseCmp(""Listen"") == 0 || sName.CaseCmp(""ListenPort"") == 0 || sName.CaseCmp(""Listen6"") == 0) {
					bool bSSL = false;
					bool bIPV6 = (sName.CaseCmp(""Listen6"") == 0);
					CString sPort;

					CString sBindHost;

					if (!bIPV6) {
						sValue.Replace("":"", "" "");
					}

					if (sValue.find("" "") != CString::npos) {
						sBindHost = sValue.Token(0, false, "" "");
						sPort = sValue.Token(1, true, "" "");
					} else {
						sPort = sValue;
					}

					if (sPort.Left(1) == ""+"") {
						sPort.LeftChomp();
						bSSL = true;
					}

					CString sHostComment;

					if (!sBindHost.empty()) {
						sHostComment = "" on host ["" + sBindHost + ""]"";
					}

					CString sIPV6Comment;

					if (bIPV6) {
						sIPV6Comment = "" using ipv6"";
					}

					unsigned short uPort = strtol(sPort.c_str(), NULL, 10);
					CUtils::PrintAction(""Binding to port ["" + CString((bSSL) ? ""+"" : """") + CString(uPort) + ""]"" + sHostComment + sIPV6Comment);

#ifndef HAVE_IPV6
					if (bIPV6) {
						sError = ""IPV6 is not enabled"";
						CUtils::PrintStatus(false, sError);
						return false;
					}
#endif

#ifndef HAVE_LIBSSL
					if (bSSL) {
						sError = ""SSL is not enabled"";
						CUtils::PrintStatus(false, sError);
						return false;
					}
#else
					CString sPemFile = GetPemLocation();

					if (bSSL && !CFile::Exists(sPemFile)) {
						sError = ""Unable to locate pem file: ["" + sPemFile + ""]"";
						CUtils::PrintStatus(false, sError);

						// If stdin is e.g. /dev/null and we call GetBoolInput(),
						// we are stuck in an endless loop!
						if (isatty(0) && CUtils::GetBoolInput(""Would you like to create a new pem file?"", true)) {
							sError.clear();
							WritePemFile();
						} else {
							return false;
						}

						CUtils::PrintAction(""Binding to port [+"" + CString(uPort) + ""]"" + sHostComment + sIPV6Comment);
					}
#endif
					if (!uPort) {
						sError = ""Invalid port"";
						CUtils::PrintStatus(false, sError);
						return false;
					}

					CListener* pListener = new CListener(uPort, sBindHost, bSSL, bIPV6);

					if (!pListener->Listen()) {
						sError = ""Unable to bind"";
						CUtils::PrintStatus(false, sError);
						delete pListener;
						return false;
					}

					m_vpListeners.push_back(pListener);
					CUtils::PrintStatus(true);

					continue;
				} else if (sName.CaseCmp(""LoadModule"") == 0) {
#ifdef _MODULES
					CString sModName = sValue.Token(0);
					CString sArgs = sValue.Token(1, true);

					if (msModules.find(sModName) != msModules.end()) {
						sError = ""Module ["" + sModName +
							""] already loaded"";
						CUtils::PrintError(sError);
						return false;
					}
					msModules[sModName] = sArgs;
#else
					CUtils::PrintError(""Modules are not enabled."");
#endif
					continue;
				} else if (sName.CaseCmp(""ISpoofFormat"") == 0) {
					m_sISpoofFormat = sValue;
					continue;
				} else if (sName.CaseCmp(""ISpoofFile"") == 0) {
					if (sValue.Left(2) == ""~/"") {
						sValue.LeftChomp(2);
						sValue = GetHomePath() + ""/"" + sValue;
					}
					m_sISpoofFile = sValue;
					continue;
				} else if (sName.CaseCmp(""MOTD"") == 0) {
					AddMotd(sValue);
					continue;
				} else if (sName.CaseCmp(""VHost"") == 0) {
					AddVHost(sValue);
					continue;
				} else if (sName.CaseCmp(""PidFile"") == 0) {
					m_sPidFile = sValue;
					continue;
				} else if (sName.CaseCmp(""StatusPrefix"") == 0) {
					m_sStatusPrefix = sValue;
					continue;
				} else if (sName.CaseCmp(""ConnectDelay"") == 0) {
					m_uiConnectDelay = sValue.ToUInt();
					continue;
				}
			}

		}

		if (sName.CaseCmp(""GM:"", 3) == 0)
		{ // GM: prefix is a pass through to config lines for global modules
			CGlobalModuleConfigLine cTmp;
			cTmp.m_sName = sName.substr(3, CString::npos);
			cTmp.m_sValue = sValue;
			cTmp.m_pChan = pChan;
			cTmp.m_pUser = pUser;
			lGlobalModuleConfigLine.push_back(cTmp);
		}
		else
		{
			sError = ""Unhandled line "" + CString(uLineNum) + "" in config: ["" + sLine + ""]"";
			CUtils::PrintError(sError);
			return false;
		}
	}

#ifdef _MODULES
	// First step: Load and reload new modules or modules with new arguments
	for (MCString::iterator it = msModules.begin(); it != msModules.end(); it++) {
		CString sModName = it->first;
		CString sArgs = it->second;
		CString sModRet;
		CModule *pOldMod;

		pOldMod = GetModules().FindModule(sModName);
		if (!pOldMod) {
			CUtils::PrintAction(""Loading Global Module ["" + sModName + ""]"");

			try {
				bool bModRet = GetModules().LoadModule(sModName, sArgs, NULL, sModRet);

				// If the module was loaded, sModRet contains
				// ""Loaded Module [name] ..."" and we strip away this beginning.
				if (bModRet)
					sModRet = sModRet.Token(1, true, sModName + ""] "");

				CUtils::PrintStatus(bModRet, sModRet);
				if (!bModRet) {
					sError = sModRet;
					return false;
				}
			} catch (CException e) {
				sError = ""Caught an exception while loading ["" + sModName + ""]"";
				CUtils::PrintStatus(false, sModRet);
				return false;
			}
		} else if (pOldMod->GetArgs() != sArgs) {
			CUtils::PrintAction(""Reloading Global Module ["" + sModName + ""]"");

			try {
				bool bModRet = GetModules().ReloadModule(sModName, sArgs, NULL, sModRet);

				// If the module was loaded, sModRet contains
				// ""Loaded Module [name] ..."" and we strip away this beginning.
				if (bModRet)
					sModRet = sModRet.Token(1, true, sModName + ""] "");

				CUtils::PrintStatus(bModRet, sModRet);
				if (!bModRet) {
					sError = sModRet;
					return false;
				}
			} catch (CException e) {
				sError = ""Caught an exception while reloading ["" + sModName + ""]"";
				CUtils::PrintStatus(false, sModRet);
				return false;
			}
		} else
			CUtils::PrintMessage(""Module ["" + sModName + ""] already loaded."");
	}

	// Second step: Unload modules which are no longer in the config
	set<CString> ssUnload;
	for (size_t i = 0; i < GetModules().size(); i++) {
		CModule *pCurMod = GetModules()[i];

		if (msModules.find(pCurMod->GetModName()) == msModules.end())
			ssUnload.insert(pCurMod->GetModName());
	}

	for (set<CString>::iterator it = ssUnload.begin(); it != ssUnload.end(); it++) {
		if (GetModules().UnloadModule(*it))
			CUtils::PrintMessage(""Unloaded Global Module ["" + *it + ""]"");
		else
			CUtils::PrintMessage(""Could not unload ["" + *it + ""]"");
	}

	// last step, throw unhandled config items at global config
	for (std::list<CGlobalModuleConfigLine>::iterator it = lGlobalModuleConfigLine.begin(); it != lGlobalModuleConfigLine.end(); it++)
	{
		if ((pChan && pChan == it->m_pChan) || (pUser && pUser == it->m_pUser))
			continue; // skip unclosed user or chan
		if (!GetModules().OnConfigLine(it->m_sName, it->m_sValue, it->m_pUser, it->m_pChan))
		{
			CUtils::PrintMessage(""unhandled global module config line [GM:"" + it->m_sName + ""] = ["" + it->m_sValue + ""]"");
		}
	}
#endif

	if (pChan) {
		// TODO last <Chan> not closed
		delete pChan;
	}

	if (pUser) {
		// TODO last <User> not closed
		delete pUser;
	}

	File.Close();

	if (m_msUsers.size() == 0) {
		sError = ""You must define at least one user in your config."";
		CUtils::PrintError(sError);
		return false;
	}

	if (m_vpListeners.size() == 0) {
		sError = ""You must supply at least one Listen port in your config."";
		CUtils::PrintError(sError);
		return false;
	}

	// Make sure that users that want to connect do so
	RestartConnectUser();

	return true;
}

void CZNC::ClearVHosts() {
	m_vsVHosts.clear();
}

bool CZNC::AddVHost(const CString& sHost) {
	if (sHost.empty()) {
		return false;
	}

	for (unsigned int a = 0; a < m_vsVHosts.size(); a++) {
		if (m_vsVHosts[a].CaseCmp(sHost) == 0) {
			return false;
		}
	}

	m_vsVHosts.push_back(sHost);
	return true;
}

bool CZNC::RemVHost(const CString& sHost) {
	// @todo
	return true;
}

void CZNC::Broadcast(const CString& sMessage, bool bAdminOnly,
		CUser* pSkipUser, CClient *pSkipClient) {
	for (map<CString,CUser*>::iterator a = m_msUsers.begin(); a != m_msUsers.end(); a++) {
		if (bAdminOnly && !a->second->IsAdmin())
			continue;

		if (a->second != pSkipUser) {
			CString sMsg = sMessage;

			MODULECALL(OnBroadcast(sMsg), a->second, NULL, continue);
			a->second->PutStatusNotice(""*** "" + sMsg, NULL, pSkipClient);
		}
	}
}

bool CZNC::FindModPath(const CString& sModule, CString& sModPath,
		CString& sDataPath) const {
	CString sMod = sModule;
	CString sDir = sMod;
	if (sModule.find(""."") == CString::npos)
		sMod += "".so"";

	sDataPath = GetCurPath() + ""/modules/"";
	sModPath = sDataPath + sMod;

	if (!CFile::Exists(sModPath)) {
		sDataPath = GetModPath() + ""/"";
		sModPath = sDataPath + sMod;

		if (!CFile::Exists(sModPath)) {
			sDataPath = _DATADIR_ + CString(""/"");
			sModPath = _MODDIR_ + CString(""/"") + sMod;

			if (!CFile::Exists(sModPath)) {
				return false;
			}
		}
	}

	sDataPath += sDir;

	return true;
}

CUser* CZNC::FindUser(const CString& sUsername) {
	map<CString,CUser*>::iterator it = m_msUsers.find(sUsername);

	if (it != m_msUsers.end()) {
		return it->second;
	}

	return NULL;
}

bool CZNC::DeleteUser(const CString& sUsername) {
	CUser* pUser = FindUser(sUsername);

	if (!pUser) {
		return false;
	}

	m_msDelUsers[pUser->GetUserName()] = pUser;
	return true;
}

bool CZNC::AddUser(CUser* pUser, CString& sErrorRet) {
	if (pUser->IsValid(sErrorRet)) {
		m_msUsers[pUser->GetUserName()] = pUser;
		return true;
	}

	DEBUG_ONLY(cout << ""Invalid user ["" << pUser->GetUserName() << ""] - ["" << sErrorRet << ""]"" << endl);
	return false;
}

CZNC& CZNC::Get() {
	static CZNC* pZNC = new CZNC;
	return *pZNC;
}

void CZNC::UpdateTrafficStats() {
	CSockManager* p = &m_Manager;
	for (unsigned int a = 0; a < p->size(); a++) {
		if ((*p)[a]->GetSockName().Left(5) == ""IRC::"") {
			CIRCSock *i = (CIRCSock *)(*p)[a];
			i->GetUser()->AddBytesRead((*p)[a]->GetBytesRead());
			(*p)[a]->ResetBytesRead();
			i->GetUser()->AddBytesWritten((*p)[a]->GetBytesWritten());
			(*p)[a]->ResetBytesWritten();
		} else if ((*p)[a]->GetSockName().Left(5) == ""USR::"") {
			CClient *c = (CClient *)(*p)[a];
			c->GetUser()->AddBytesRead((*p)[a]->GetBytesRead());
			(*p)[a]->ResetBytesRead();
			c->GetUser()->AddBytesWritten((*p)[a]->GetBytesWritten());
			(*p)[a]->ResetBytesWritten();
		}
	}
}

void CZNC::AuthUser(CSmartPtr<CAuthBase> AuthClass) {
#ifdef _MODULES
	// TODO unless the auth module calls it, CUser::IsHostAllowed() is not honoured
	if (GetModules().OnLoginAttempt(AuthClass)) {
		return;
	}
#endif

	CUser* pUser = GetUser(AuthClass->GetUsername());

	if (!pUser || !pUser->CheckPass(AuthClass->GetPassword())) {
		if (pUser) {
			pUser->PutStatus(""Another client attempted to login as you, with a bad password."");
		}

		AuthClass->RefuseLogin(""Invalid Password"");
		return;
	}

	CString sHost = AuthClass->GetRemoteIP();

	if (!pUser->IsHostAllowed(sHost)) {
		AuthClass->RefuseLogin(""Your host ["" + sHost + ""] is not allowed"");
		return;
	}

	AuthClass->AcceptLogin(*pUser);
}

class CConnectUserTimer : public CCron {
public:
	CConnectUserTimer(int iSecs) : CCron() {
		SetName(""Connect users"");
		Start(iSecs);
		m_itUserIter = CZNC::Get().GetUserMap().begin();
	}
	virtual ~CConnectUserTimer() {}

protected:
	virtual void RunJob() {
		unsigned int uiUserCount;
		map<CString,CUser*>::const_iterator end;
		bool bUsersLeft = false;

		uiUserCount = CZNC::Get().GetUserMap().size();
		end = CZNC::Get().GetUserMap().end();

		// Try to connect each user, if this doesnt work, abort
		for (unsigned int i = 0; i < uiUserCount; i++) {
			if (m_itUserIter == end) {
				m_itUserIter = CZNC::Get().GetUserMap().begin();
			}

			CUser* pUser = m_itUserIter->second;

			m_itUserIter++;

			// Is this user disconnected and does he want to connect?
			if (pUser->GetIRCSock() == NULL && pUser->GetIRCConnectEnabled())
				bUsersLeft = true;

			if (CZNC::Get().ConnectUser(pUser))
				// Wait until next time timer fires
				return;
		}

		if (bUsersLeft == false)
			CZNC::Get().DisableConnectUser();
	}

private:
	map<CString,CUser*>::const_iterator	m_itUserIter;
};

void CZNC::EnableConnectUser() {
	if (m_pConnectUserTimer != NULL)
		return;

	m_pConnectUserTimer = new CConnectUserTimer(m_uiConnectDelay);
	GetManager().AddCron(m_pConnectUserTimer);
}

void CZNC::DisableConnectUser() {
	if (m_pConnectUserTimer == NULL)
		return;

	// This will kill the cron
	m_pConnectUserTimer->Stop();
	m_pConnectUserTimer = NULL;
}

void CZNC::RestartConnectUser() {
	DisableConnectUser();

	map<CString, CUser*>::iterator end = m_msUsers.end();
	for (map<CString,CUser*>::iterator it = m_msUsers.begin(); it != end; it++) {
		// If there is a user without irc socket we need the timer
		if (it->second->GetIRCSock() == NULL) {
			EnableConnectUser();
			return;
		}
	}
}
""",CZNC::DoRehash,[918:1570]
znc,https://github.com/znc/znc/commit/ef31d6e2396139d7789f6c06689518a1eed5efaa,"""Connect and reconnect faster to IRC

The first reconnect now happens when the timer is created which is
possibly thanks to latest Csocket.


git-svn-id: https://znc.svn.sourceforge.net/svnroot/znc/trunk@1161 726aef4b-f618-498e-8847-2d620e286838""","""/*
 * Copyright (C) 2004-2008  See the AUTHORS file for details.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 as published
 * by the Free Software Foundation.
 */

#include ""znc.h""
#include ""Chan.h""
#include ""IRCSock.h""
#include ""Server.h""
#include ""User.h""
#include <pwd.h>
#include <list>

namespace
{ // private namespace for local things
	struct CGlobalModuleConfigLine
	{
		CString	m_sName;
		CString	m_sValue;
		CUser	*m_pUser;
		CChan	*m_pChan;
	};
};

CZNC::CZNC() {
#ifdef _MODULES
	m_pModules = new CGlobalModules();
#endif
	m_pISpoofLockFile = NULL;
	m_uiConnectDelay = 30;
	SetISpoofFormat(""""); // Set ISpoofFormat to default
	m_uBytesRead = 0;
	m_uBytesWritten = 0;
	m_pConnectUserTimer = NULL;
	m_bNeedRehash = false;
	m_TimeStarted = time(NULL);
}

CZNC::~CZNC() {
	if (m_pISpoofLockFile)
		ReleaseISpoof();

#ifdef _MODULES
	m_pModules->UnloadAll();

	for (map<CString,CUser*>::iterator a = m_msUsers.begin(); a != m_msUsers.end(); a++) {
		a->second->GetModules().UnloadAll();
	}
#endif

	for (size_t b = 0; b < m_vpListeners.size(); b++) {
		delete m_vpListeners[b];
	}

	for (map<CString,CUser*>::iterator a = m_msUsers.begin(); a != m_msUsers.end(); a++) {
		a->second->SetBeingDeleted(true);
	}

	m_pConnectUserTimer = NULL;
	// This deletes m_pConnectUserTimer
	m_Manager.Cleanup();
	DeleteUsers();

#ifdef _MODULES
	delete m_pModules;
#endif

	DeletePidFile();
}

CString CZNC::GetVersion() {
	char szBuf[128];

	snprintf(szBuf, sizeof(szBuf), ""%1.3f""VERSION_EXTRA, VERSION);
	// If snprintf overflows (which I doubt), we want to be on the safe side
	szBuf[sizeof(szBuf) - 1] = '\0';

	return szBuf;
}

CString CZNC::GetTag(bool bIncludeVersion) {
	if (!bIncludeVersion) {
		return ""ZNC - http://znc.sourceforge.net"";
	}

	char szBuf[128];
	snprintf(szBuf, sizeof(szBuf), ""ZNC %1.3f""VERSION_EXTRA"" - http://znc.sourceforge.net"", VERSION);
	// If snprintf overflows (which I doubt), we want to be on the safe side
	szBuf[sizeof(szBuf) - 1] = '\0';

	return szBuf;
}

CString CZNC::GetUptime() const {
	time_t now = time(NULL);
	return CString::ToTimeStr(now - TimeStarted());
}

bool CZNC::OnBoot() {
#ifdef _MODULES
	if (!GetModules().OnBoot()) {
		return false;
	}

	for (map<CString,CUser*>::iterator it = m_msUsers.begin(); it != m_msUsers.end(); it++) {
		if (!it->second->GetModules().OnBoot()) {
			return false;
		}
	}
#endif

	return true;
}

bool CZNC::ConnectUser(CUser *pUser) {
	CString sSockName = ""IRC::"" + pUser->GetUserName();
	// Don't use pUser->GetIRCSock(), as that only returns something if the
	// CIRCSock is already connected, not when it's still connecting!
	CIRCSock* pIRCSock = (CIRCSock*) m_Manager.FindSockByName(sSockName);

	if (m_pISpoofLockFile != NULL) {
		return false;
	}

	if (!pUser->GetIRCConnectEnabled())
		return false;

	if (pIRCSock || !pUser->HasServers())
		return false;

	if (pUser->ConnectPaused())
		return false;

	CServer* pServer = pUser->GetNextServer();

	if (!pServer)
		return false;

	if (!WriteISpoof(pUser)) {
		DEBUG_ONLY(cout << ""ISpoof could not be written"" << endl);
		pUser->PutStatus(""ISpoof could not be written, retrying..."");
		return true;
	}

	DEBUG_ONLY(cout << ""User ["" << pUser->GetUserName() << ""] is connecting to ["" << pServer->GetName() << "":"" << pServer->GetPort() << ""] ..."" << endl);
	pUser->PutStatus(""Attempting to connect to ["" + pServer->GetName() + "":"" + CString(pServer->GetPort()) + ""] ..."");

	pIRCSock = new CIRCSock(pUser);
	pIRCSock->SetPass(pServer->GetPass());

	bool bSSL = false;
#ifdef HAVE_LIBSSL
	if (pServer->IsSSL()) {
		bSSL = true;
	}
#endif

	if (!m_Manager.Connect(pServer->GetName(), pServer->GetPort(), sSockName, 120, bSSL, pUser->GetVHost(), pIRCSock)) {
		ReleaseISpoof();
		pUser->PutStatus(""Unable to connect. (Bad host?)"");
	}

	return true;
}

bool CZNC::HandleUserDeletion()
{
	map<CString, CUser*>::iterator it;
	map<CString, CUser*>::iterator end;

	if (m_msDelUsers.size() == 0)
		return false;

	end = m_msDelUsers.end();
	for (it = m_msDelUsers.begin(); it != end; it++) {
		CUser* pUser = it->second;
		pUser->SetBeingDeleted(true);

#ifdef _MODULES
		if (GetModules().OnDeleteUser(*pUser)) {
			pUser->SetBeingDeleted(false);
			continue;
		}
#endif
		m_msUsers.erase(pUser->GetUserName());

		CIRCSock* pIRCSock = pUser->GetIRCSock();

		if (pIRCSock) {
			m_Manager.DelSockByAddr(pIRCSock);
		}

		pUser->DelClients();
#ifdef _MODULES
		pUser->DelModules();
#endif
		AddBytesRead(pUser->BytesRead());
		AddBytesWritten(pUser->BytesWritten());
		delete pUser;
	}

	m_msDelUsers.clear();

	return true;
}

int CZNC::Loop() {
	while (true) {
		CString sError;
		map<CString, CUser*>::iterator it;
		map<CString, CUser*>::iterator end;

		if (GetNeedRehash()) {
			SetNeedRehash(false);

			if (RehashConfig(sError)) {
				Broadcast(""Rehashing succeeded"", true);
			} else {
				Broadcast(""Rehashing failed: "" + sError, true);
				Broadcast(""ZNC is in some possibly inconsistent state!"", true);
			}
		}

		// Check for users that need to be deleted
		if (HandleUserDeletion()) {
			// Also remove those user(s) from the config file
			WriteConfig();
		}

		// Csocket wants micro seconds
		// 500 msec to 600 sec
		m_Manager.DynamicSelectLoop(500 * 1000, 600 * 1000 * 1000);
	}

	return 0;
}

bool CZNC::WriteISpoof(CUser* pUser) {
	if (m_pISpoofLockFile != NULL)
		return false;

	if (!m_sISpoofFile.empty()) {
		m_pISpoofLockFile = new CLockFile;
		if (!m_pISpoofLockFile->TryExLock(m_sISpoofFile, true)) {
			delete m_pISpoofLockFile;
			m_pISpoofLockFile = NULL;
			return false;
		}

		CFile File(m_pISpoofLockFile->GetFD(), m_pISpoofLockFile->GetFileName());

		char buf[1024];
		memset((char*) buf, 0, 1024);
		File.Read(buf, 1023);
		m_sOrigISpoof = buf;

		if (!File.Seek(0) || !File.Truncate()) {
			delete m_pISpoofLockFile;
			m_pISpoofLockFile = NULL;
			return false;
		}

		CString sData = m_sISpoofFormat.Token(0, false, ""%"") + pUser->GetIdent() + m_sISpoofFormat.Token(1, true, ""%"");
		File.Write(sData + ""\n"");
	}
	return true;
}

void CZNC::ReleaseISpoof() {
	if (m_pISpoofLockFile == NULL)
		return;

	if (!m_sISpoofFile.empty()) {
		CFile File(m_pISpoofLockFile->GetFD(), m_pISpoofLockFile->GetFileName());

		if (File.Seek(0) && File.Truncate()) {
			File.Write(m_sOrigISpoof);
		}

		m_sOrigISpoof = """";
	}

	delete m_pISpoofLockFile;
	m_pISpoofLockFile = NULL;
}

bool CZNC::WritePidFile(int iPid) {
	if (!m_sPidFile.empty()) {
		CString sFile;

		// absolute path or relative to the data dir?
		if (m_sPidFile[0] != '/')
			sFile = GetZNCPath() + ""/"" + m_sPidFile;
		else
			sFile = m_sPidFile;

		CFile File(sFile);
		CUtils::PrintAction(""Writing pid file ["" + sFile + ""]"");

		if (File.Open(O_WRONLY | O_TRUNC | O_CREAT)) {
			File.Write(CString(iPid) + ""\n"");
			File.Close();
			CUtils::PrintStatus(true);
			return true;
		}

		CUtils::PrintStatus(false);
	}

	return false;
}

bool CZNC::DeletePidFile() {
	if (!m_sPidFile.empty()) {
		CString sFile;
		// absolute path or relative to the data dir?
		if (m_sPidFile[0] != '/')
			sFile = GetZNCPath() + ""/"" + m_sPidFile;
		else
			sFile = m_sPidFile;

		CFile File(sFile);
		CUtils::PrintAction(""Deleting pid file ["" + sFile + ""]"");
		if (File.Delete()) {
			CUtils::PrintStatus(true);
			return true;
		}
		CUtils::PrintStatus(false);
	}
	return false;
}

bool CZNC::WritePemFile(bool bEncPem) {
#ifndef HAVE_LIBSSL
	CUtils::PrintError(""ZNC was not compiled with ssl support."");
	return false;
#else
	CString sPemFile = GetPemLocation();
	const char* pHostName = getenv(""HOSTNAME"");
	CString sHost;

	if (pHostName) {
		sHost = pHostName;
	}

	if (CFile::Exists(sPemFile)) {
		CUtils::PrintError(""Pem file ["" + sPemFile + ""] already exists"");
		return false;
	}

	while (!CUtils::GetInput(""hostname of your shell"", sHost, sHost, ""including the '.com' portion"")) ;

	CUtils::PrintAction(""Writing Pem file ["" + sPemFile + ""]"");
	FILE *f = fopen(sPemFile.c_str(), ""w"");

	if (!f) {
		CUtils::PrintStatus(false, ""Unable to open"");
		return false;
	}

	CUtils::GenerateCert(f, bEncPem, sHost);
	fclose(f);

	CUtils::PrintStatus(true);
	return true;
#endif
}

void CZNC::DeleteUsers() {
	for (map<CString,CUser*>::iterator a = m_msUsers.begin(); a != m_msUsers.end(); a++) {
		a->second->SetBeingDeleted(true);
		delete a->second;
	}

	m_msUsers.clear();
	DisableConnectUser();
}

CUser* CZNC::GetUser(const CString& sUser) {
	// Todo: make this case insensitive
	map<CString,CUser*>::iterator it = m_msUsers.find(sUser);
	return (it == m_msUsers.end()) ? NULL : it->second;
}

Csock* CZNC::FindSockByName(const CString& sSockName) {
	return m_Manager.FindSockByName(sSockName);
}

bool CZNC::IsHostAllowed(const CString& sHostMask) const {
	for (map<CString,CUser*>::const_iterator a = m_msUsers.begin(); a != m_msUsers.end(); a++) {
		if (a->second->IsHostAllowed(sHostMask)) {
			return true;
		}
	}

	return false;
}

void CZNC::InitDirs(const CString& sArgvPath, const CString& sDataDir) {
	char buf[PATH_MAX];
	char *home;

	if (getcwd(buf, PATH_MAX) == NULL) {
		CUtils::PrintError(""getcwd() failed, can't read my current dir"");
		exit(-1);
	}

	// If the bin was not ran from the current directory, we need to add that dir onto our cwd
	CString::size_type uPos = sArgvPath.rfind('/');
	m_sCurPath = (uPos == CString::npos) ? CString(buf) : CDir::ChangeDir(buf, sArgvPath.substr(0, uPos), """");

	// Try to set the user's home dir, default to binpath on failure
	home = getenv(""HOME"");

	m_sHomePath.clear();
	if (home) {
		m_sHomePath = home;
	}

	if (m_sHomePath.empty()) {
		struct passwd* pUserInfo = getpwuid(getuid());

		if (pUserInfo) {
			m_sHomePath = pUserInfo->pw_dir;
		}
	}

	if (m_sHomePath.empty()) {
		m_sHomePath = m_sCurPath;
	}

	if (sDataDir.empty()) {
	    m_sZNCPath = m_sHomePath + ""/.znc"";
	} else {
	    m_sZNCPath = sDataDir;
	}

	// Other dirs that we use
	m_sConfPath = m_sZNCPath + ""/configs"";
	m_sModPath = m_sZNCPath + ""/modules"";
	m_sUserPath = m_sZNCPath + ""/users"";
}


CString CZNC::ExpandConfigPath(const CString& sConfigFile) {
	CString sRetPath;

	if (sConfigFile.empty()) {
		sRetPath = GetConfPath() + ""/znc.conf"";
	} else {
		if (sConfigFile.Left(2) == ""./"" || sConfigFile.Left(3) == ""../"") {
			sRetPath = GetCurPath() + ""/"" + sConfigFile;
		} else if (sConfigFile.Left(1) != ""/"") {
			sRetPath = GetConfPath() + ""/"" + sConfigFile;
		} else {
			sRetPath = sConfigFile;
		}
	}

	return sRetPath;
}

bool CZNC::BackupConfig() const {
	CString sBackup = GetConfigFile() + ""-backup"";

	// Create a new backup overwriting an old one we might have
	if (CFile::Copy(m_sConfigFile, sBackup, true))
		return true;

	// Don't abort if no config file exists
	if (!CFile::Exists(m_sConfigFile))
		// No backup because we got nothing to backup
		return true;

	return false;
}

bool CZNC::WriteConfig() {
	CFile File(GetConfigFile());

	if (!BackupConfig()) {
		return false;
	}

	if (m_sConfigFile.empty() || !File.Open(O_WRONLY | O_CREAT | O_TRUNC, 0600)) {
		return false;
	}

	for (size_t l = 0; l < m_vpListeners.size(); l++) {
		CListener* pListener = m_vpListeners[l];
		CString sHostPortion = pListener->GetBindHost();

		if (!sHostPortion.empty()) {
			sHostPortion += "" "";
		}

		CString s6 = (pListener->IsIPV6()) ? ""6"" : "" "";

		File.Write(""Listen"" + s6 + ""      = "" + sHostPortion + CString((pListener->IsSSL()) ? ""+"" : """") + CString(pListener->GetPort()) + ""\n"");
	}

	File.Write(""ConnectDelay = "" + CString(m_uiConnectDelay) + ""\n"");

	if (!m_sISpoofFile.empty()) {
		File.Write(""ISpoofFile   = "" + m_sISpoofFile + ""\n"");
		if (!m_sISpoofFormat.empty()) { File.Write(""ISpoofFormat = "" + m_sISpoofFormat + ""\n""); }
	}

	if (!m_sPidFile.empty()) { File.Write(""PidFile      = "" + m_sPidFile + ""\n""); }
	if (!m_sStatusPrefix.empty()) { File.Write(""StatusPrefix = "" + m_sStatusPrefix + ""\n""); }

	for (unsigned int m = 0; m < m_vsMotd.size(); m++) {
		File.Write(""Motd         = "" + m_vsMotd[m] + ""\n"");
	}

	for (unsigned int v = 0; v < m_vsVHosts.size(); v++) {
		File.Write(""VHost        = "" + m_vsVHosts[v] + ""\n"");
	}

#ifdef _MODULES
	CGlobalModules& Mods = GetModules();

	for (unsigned int a = 0; a < Mods.size(); a++) {
		CString sArgs = Mods[a]->GetArgs();

		if (!sArgs.empty()) {
			sArgs = "" "" + sArgs;
		}

		File.Write(""LoadModule   = "" + Mods[a]->GetModName() + sArgs + ""\n"");
	}
#endif

	for (map<CString,CUser*>::iterator it = m_msUsers.begin(); it != m_msUsers.end(); it++) {
		CString sErr;

		if (!it->second->IsValid(sErr)) {
			DEBUG_ONLY(cerr << ""** Error writing config for user ["" << it->first << ""] ["" << sErr << ""]"" << endl);
			continue;
		}

		File.Write(""\n"");

		if (!it->second->WriteConfig(File)) {
			DEBUG_ONLY(cerr << ""** Error writing config for user ["" << it->first << ""]"" << endl);
		}
	}

	File.Close();

	return true;
}

bool CZNC::WriteNewConfig(const CString& sConfig) {
	CString sConfigFile = ExpandConfigPath((sConfig.empty()) ? ""znc.conf"" : sConfig);
	CString sAnswer, sUser;
	vector<CString> vsLines;

	if (CFile::Exists(sConfigFile)) {
		if (!m_LockFile.TryExLock(sConfigFile)) {
			CUtils::PrintError(""ZNC is currently running on this config."");
			return false;
		}

		if (!CUtils::GetBoolInput(""This config already exists.  Would you like to overwrite it?"", false)) {
			m_LockFile.UnLock();
			return false;
		}
	}

	CUtils::PrintMessage(""Writing new config ["" + sConfigFile + ""]"");

	CUtils::PrintMessage("""");
	CUtils::PrintMessage(""First lets start with some global settings..."");
	CUtils::PrintMessage("""");

	// Listen
	unsigned int uListenPort = 0;
	while (!CUtils::GetNumInput(""What port would you like ZNC to listen on?"", uListenPort, 1, 65535)) ;

	CString sSSL;
#ifdef HAVE_LIBSSL
	if (CUtils::GetBoolInput(""Would you like ZNC to listen using SSL?"", false)) {
		sSSL = ""+"";
	}
#endif

	CString s6 = "" "";
#ifdef HAVE_IPV6
	if (CUtils::GetBoolInput(""Would you like ZNC to listen using ipv6?"", false)) {
		s6 = ""6"";
	}
#endif

	CString sListenHost;
	CUtils::GetInput(""Listen Host"", sListenHost, """", ""Blank for all ips"");

	if (!sListenHost.empty()) {
		sListenHost += "" "";
	}

	vsLines.push_back(""Listen"" + s6 + ""    = "" + sListenHost + sSSL + CString(uListenPort));
	// !Listen

#ifdef _MODULES
	set<CModInfo> ssGlobalMods;
	GetModules().GetAvailableMods(ssGlobalMods, true);

	if (ssGlobalMods.size()) {
		CUtils::PrintMessage("""");
		CUtils::PrintMessage(""-- Global Modules --"");
		CUtils::PrintMessage("""");

		if (CUtils::GetBoolInput(""Do you want to load any global modules?"")) {
			CTable Table;
			Table.AddColumn(""Name"");
			Table.AddColumn(""Description"");
			set<CModInfo>::iterator it;

			for (it = ssGlobalMods.begin(); it != ssGlobalMods.end(); it++) {
				const CModInfo& Info = *it;
				Table.AddRow();
				Table.SetCell(""Name"", Info.GetName());
				Table.SetCell(""Description"", Info.GetDescription().Ellipsize(128));
			}

			unsigned int uTableIdx = 0; CString sLine;
			while (Table.GetLine(uTableIdx++, sLine)) {
				CUtils::PrintMessage(sLine);
			}

			CUtils::PrintMessage("""");

			for (it = ssGlobalMods.begin(); it != ssGlobalMods.end(); it++) {
				const CModInfo& Info = *it;
				CString sName = Info.GetName();

				if (sName.Right(3).CaseCmp("".so"") == 0) {
					sName.RightChomp(3);
				}

				if (CUtils::GetBoolInput(""Load global module <\033[1m"" + sName + ""\033[22m>?"", false)) {
					vsLines.push_back(""LoadModule = "" + sName);
				}
			}
		}
	}
#endif

	// User
	CUtils::PrintMessage("""");
	CUtils::PrintMessage(""Now we need to setup a user..."");
	CUtils::PrintMessage("""");

	bool bFirstUser = true;

	do {
		vsLines.push_back("""");
		CString sNick;
		do {
			CUtils::GetInput(""Username"", sUser, """", ""AlphaNumeric"");
		} while (!CUser::IsValidUserName(sUser));

		vsLines.push_back(""<User "" + sUser + "">"");
		CString sSalt;
		sAnswer = CUtils::GetSaltedHashPass(sSalt);
		vsLines.push_back(""\tPass       = md5#"" + sAnswer + ""#"" + sSalt + ""#"");

		if (CUtils::GetBoolInput(""Would you like this user to be an admin?"", bFirstUser)) {
			vsLines.push_back(""\tAdmin      = true"");
		} else {
			vsLines.push_back(""\tAdmin      = false"");
		}

		CUtils::GetInput(""Nick"", sNick, CUser::MakeCleanUserName(sUser));
		vsLines.push_back(""\tNick       = "" + sNick);
		CUtils::GetInput(""Alt Nick"", sAnswer, sNick + ""_"");
		if (!sAnswer.empty()) {
			vsLines.push_back(""\tAltNick    = "" + sAnswer);
		}
		CUtils::GetInput(""Ident"", sAnswer, sNick);
		vsLines.push_back(""\tIdent      = "" + sAnswer);
		CUtils::GetInput(""Real Name"", sAnswer, ""Got ZNC?"");
		vsLines.push_back(""\tRealName   = "" + sAnswer);
		CUtils::GetInput(""VHost"", sAnswer, """", ""optional"");
		if (!sAnswer.empty()) {
			vsLines.push_back(""\tVHost      = "" + sAnswer);
		}
		// todo: Possibly add motd

		unsigned int uBufferCount = 0;

		CUtils::GetNumInput(""Number of lines to buffer per channel"", uBufferCount, 0, ~0, 50);
		if (uBufferCount) {
			vsLines.push_back(""\tBuffer     = "" + CString(uBufferCount));
		}
		if (CUtils::GetBoolInput(""Would you like to keep buffers after replay?"", false)) {
			vsLines.push_back(""\tKeepBuffer = true"");
		} else {
			vsLines.push_back(""\tKeepBuffer = false"");
		}

		CUtils::GetInput(""Default channel modes"", sAnswer, ""+stn"");
		if (!sAnswer.empty()) {
			vsLines.push_back(""\tChanModes  = "" + sAnswer);
		}

#ifdef _MODULES
		set<CModInfo> ssUserMods;
		GetModules().GetAvailableMods(ssUserMods);

		if (ssUserMods.size()) {
			vsLines.push_back("""");
			CUtils::PrintMessage("""");
			CUtils::PrintMessage(""-- User Modules --"");
			CUtils::PrintMessage("""");

			if (CUtils::GetBoolInput(""Do you want to automatically load any user modules for this user?"")) {
				CTable Table;
				Table.AddColumn(""Name"");
				Table.AddColumn(""Description"");
				set<CModInfo>::iterator it;

				for (it = ssUserMods.begin(); it != ssUserMods.end(); it++) {
					const CModInfo& Info = *it;
					Table.AddRow();
					Table.SetCell(""Name"", Info.GetName());
					Table.SetCell(""Description"", Info.GetDescription().Ellipsize(128));
				}

				unsigned int uTableIdx = 0; CString sLine;
				while (Table.GetLine(uTableIdx++, sLine)) {
					CUtils::PrintMessage(sLine);
				}

				CUtils::PrintMessage("""");

				for (it = ssUserMods.begin(); it != ssUserMods.end(); it++) {
					const CModInfo& Info = *it;
					CString sName = Info.GetName();

					if (CUtils::GetBoolInput(""Load "" + CString((Info.IsSystem()) ? ""system"" : ""local"") + "" module <\033[1m"" + sName + ""\033[22m>?"", false)) {
						vsLines.push_back(""\tLoadModule = "" + sName);
					}
				}
			}
		}
#endif

		vsLines.push_back("""");
		CUtils::PrintMessage("""");
		CUtils::PrintMessage(""-- IRC Servers --"");
		CUtils::PrintMessage("""");

		do {
			CString sHost, sPass;
			bool bSSL = false;
			unsigned int uServerPort = 0;

			while (!CUtils::GetInput(""IRC server"", sHost, """", ""host only"") || !CServer::IsValidHostName(sHost)) ;
			while (!CUtils::GetNumInput(""["" + sHost + ""] Port"", uServerPort, 1, 65535, 6667)) ;
			CUtils::GetInput(""["" + sHost + ""] Password (probably empty)"", sPass);

#ifdef HAVE_LIBSSL
			bSSL = CUtils::GetBoolInput(""Does this server use SSL? (probably no)"", false);
#endif

			vsLines.push_back(""\tServer     = "" + sHost + ((bSSL) ? "" +"" : "" "") + CString(uServerPort) + "" "" + sPass);
		} while (CUtils::GetBoolInput(""Would you like to add another server?"", false));

		vsLines.push_back("""");
		CUtils::PrintMessage("""");
		CUtils::PrintMessage(""-- Channels --"");
		CUtils::PrintMessage("""");

		CString sArg = ""a"";
		CString sPost = "" for ZNC to automatically join?"";
		bool bDefault = true;

		while (CUtils::GetBoolInput(""Would you like to add "" + sArg + "" channel"" + sPost, bDefault)) {
			while (!CUtils::GetInput(""Channel name"", sAnswer)) ;
			vsLines.push_back(""\t<Chan "" + sAnswer + "">"");
			vsLines.push_back(""\t</Chan>"");
			sArg = ""another"";
			sPost = ""?"";
			bDefault = false;
		}

		vsLines.push_back(""</User>"");

		CUtils::PrintMessage("""");
		bFirstUser = false;
	} while (CUtils::GetBoolInput(""Would you like to setup another user?"", false));
	// !User

	CUtils::PrintAction(""Writing config ["" + sConfigFile + ""]"");
	CFile File(sConfigFile);

	bool bFileOpen = false;

	if (File.Open(O_WRONLY | O_CREAT | O_TRUNC, 0600)) {
		bFileOpen = true;
	} else {
		CUtils::PrintStatus(false, ""Unable to open file"");
		CUtils::GetInput(""Alternate location"", sConfigFile, ""/tmp/"" + sConfig);

		if (!CFile::Exists(sConfigFile) || CUtils::GetBoolInput(""Would you like to overwrite the existing alt file"", false)) {
			CUtils::PrintAction(""Writing to alt location ["" + sConfigFile + ""]"");
			File.SetFileName(sConfigFile);

			if (File.Open(O_WRONLY | O_CREAT | O_TRUNC, 0600)) {
				bFileOpen = true;
			} else {
				CUtils::PrintStatus(false, ""Unable to open alt file"");
			}
		}
	}

	if (!bFileOpen) {
		CUtils::PrintMessage("""");
		CUtils::PrintMessage(""Printing new config to stdout since we were unable to open a file"");
		CUtils::PrintMessage("""");
		cout << endl << ""----------------------------------------------------------------------------"" << endl << endl;
	}

	for (unsigned int a = 0; a < vsLines.size(); a++) {
		if (bFileOpen) {
			File.Write(vsLines[a] + ""\n"");
		} else {
			cout << vsLines[a] << endl;
		}
	}

	if (bFileOpen) {
		File.Close();

		CUtils::PrintStatus(true);
	} else {
		cout << endl << ""----------------------------------------------------------------------------"" << endl << endl;
	}

	CUtils::PrintMessage("""");
	CUtils::PrintMessage(""To connect to this znc you need to connect to it as your irc server"", true);
	CUtils::PrintMessage(""using the port that you supplied.  You have to supply your login info"", true);
	CUtils::PrintMessage(""as the irc server password like so.. user:pass."", true);
	CUtils::PrintMessage("""");
	CUtils::PrintMessage(""Try something like this in your IRC client..."", true);
	CUtils::PrintMessage(""/server <znc_server_ip> "" + CString(uListenPort) + "" "" + sUser + "":<pass>"", true);
	CUtils::PrintMessage("""");

	m_LockFile.UnLock();
	return CUtils::GetBoolInput(""Launch znc now?"", true);
}

bool CZNC::ParseConfig(const CString& sConfig)
{
	CString s;

	m_sConfigFile = ExpandConfigPath(sConfig);

	return DoRehash(s);
}

bool CZNC::RehashConfig(CString& sError)
{
#ifdef _MODULES
	GetModules().OnPreRehash();
	for (map<CString, CUser*>::iterator itb = m_msUsers.begin();
			itb != m_msUsers.end(); itb++) {
		itb->second->GetModules().OnPreRehash();
	}
#endif

	// This clears m_msDelUsers
	HandleUserDeletion();

	// Mark all users as going-to-be deleted
	m_msDelUsers = m_msUsers;
	m_msUsers.clear();

	if (DoRehash(sError)) {
#ifdef _MODULES
		GetModules().OnPostRehash();
		for (map<CString, CUser*>::iterator it = m_msUsers.begin();
				it != m_msUsers.end(); it++) {
			it->second->GetModules().OnPostRehash();
		}
#endif

		return true;
	}

	// Rehashing failed, try to recover
	CString s;
	while (m_msDelUsers.size()) {
		AddUser(m_msDelUsers.begin()->second, s);
		m_msDelUsers.erase(m_msDelUsers.begin());
	}

	return false;
}

bool CZNC::DoRehash(CString& sError)
{
	sError.clear();

	CUtils::PrintAction(""Opening Config ["" + m_sConfigFile + ""]"");

	if (!CFile::Exists(m_sConfigFile)) {
		sError = ""No such file"";
		CUtils::PrintStatus(false, sError);
		CUtils::PrintMessage(""Restart znc with the --makeconf option if you wish to create this config."");
		return false;
	}

	if (!CFile::IsReg(m_sConfigFile)) {
		sError = ""Not a file"";
		CUtils::PrintStatus(false, sError);
		return false;
	}

	if (!m_LockFile.Open(m_sConfigFile)) {
		sError = ""Can not open config file"";
		CUtils::PrintStatus(false, sError);
		return false;
	}

	if (!m_LockFile.TryExLock()) {
		sError = ""ZNC is already running on this config."";
		CUtils::PrintStatus(false, sError);
		return false;
	}

	CFile File(m_LockFile.GetFD(), m_sConfigFile);

	// This fd is re-used for rehashing, so we must seek back to the beginning!
	if (!File.Seek(0)) {
		sError = ""Could not seek to the beginning of the config."";
		CUtils::PrintStatus(false, sError);
		return false;
	}

	CUtils::PrintStatus(true);

	m_vsVHosts.clear();
	m_vsMotd.clear();

	// Delete all listeners
	while (m_vpListeners.size()) {
		delete m_vpListeners[0];
		m_vpListeners.erase(m_vpListeners.begin());
	}

	CString sLine;
	bool bCommented = false;	// support for /**/ style comments
	CUser* pUser = NULL;	// Used to keep track of which user block we are in
	CUser* pRealUser = NULL;	// If we rehash a user, this is the real one
	CChan* pChan = NULL;	// Used to keep track of which chan block we are in
	unsigned int uLineNum = 0;
#ifdef _MODULES
	MCString msModules;	// Modules are queued for later loading
#endif

	std::list<CGlobalModuleConfigLine> lGlobalModuleConfigLine;

	while (File.ReadLine(sLine)) {
		uLineNum++;

		// Remove all leading / trailing spaces and line endings
		sLine.Trim();

		if ((sLine.empty()) || (sLine[0] == '#') || (sLine.Left(2) == ""//"")) {
			continue;
		}

		if (sLine.Left(2) == ""/*"") {
			if (sLine.Right(2) != ""*/"") {
				bCommented = true;
			}

			continue;
		}

		if (bCommented) {
			if (sLine.Right(2) == ""*/"") {
				bCommented = false;
			}

			continue;
		}

		if ((sLine.Left(1) == ""<"") && (sLine.Right(1) == "">"")) {
			sLine.LeftChomp();
			sLine.RightChomp();
			sLine.Trim();

			CString sTag = sLine.substr(0, sLine.find_first_of("" \t\r\n""));
			CString sValue = (sTag.size() < sLine.size()) ? sLine.substr(sTag.size() +1) : """";

			sTag.Trim();
			sValue.Trim();

			if (sLine.Left(1) == ""/"") {
				sTag = sTag.substr(1);

				if (pUser) {
					if (pChan) {
						if (sTag.CaseCmp(""Chan"") == 0) {
							// Save the channel name, because AddChan
							// deletes the CChannel*, if adding fails
							sError = pChan->GetName();
							if (!pUser->AddChan(pChan)) {
								sError = ""Channel ["" + sError + ""] defined more than once"";
								CUtils::PrintError(sError);
								return false;
							}
							sError.clear();
							pChan = NULL;
							continue;
						}
					} else if (sTag.CaseCmp(""User"") == 0) {
						CString sErr;

						if (pRealUser) {
							if (!pRealUser->Clone(*pUser, sErr)
									|| !AddUser(pRealUser, sErr)) {
								sError = ""Invalid user ["" + pUser->GetUserName() + ""] "" + sErr;
								DEBUG_ONLY(cout << ""CUser::Clone() failed in rehash"" << endl);
							}
							pUser->SetBeingDeleted(true);
							delete pUser;
							pUser = NULL;
						} else if (!AddUser(pUser, sErr)) {
							sError = ""Invalid user ["" + pUser->GetUserName() + ""] "" + sErr;
						}

						if (!sError.empty()) {
							CUtils::PrintError(sError);
							if (pUser) {
								pUser->SetBeingDeleted(true);
								delete pUser;
								pUser = NULL;
							}
							return false;
						}

						pUser = NULL;
						pRealUser = NULL;
						continue;
					}
				}
			} else if (sTag.CaseCmp(""User"") == 0) {
				if (pUser) {
					sError = ""You may not nest <User> tags inside of other <User> tags."";
					CUtils::PrintError(sError);
					return false;
				}

				if (sValue.empty()) {
					sError = ""You must supply a username in the <User> tag."";
					CUtils::PrintError(sError);
					return false;
				}

				if (m_msUsers.find(sValue) != m_msUsers.end()) {
					sError = ""User ["" + sValue + ""] defined more than once."";
					CUtils::PrintError(sError);
					return false;
				}

				CUtils::PrintMessage(""Loading user ["" + sValue + ""]"");

				// Either create a CUser* or use an existing one
				map<CString, CUser*>::iterator it = m_msDelUsers.find(sValue);

				if (it != m_msDelUsers.end()) {
					pRealUser = it->second;
					m_msDelUsers.erase(it);
				} else
					pRealUser = NULL;

				pUser = new CUser(sValue);

				if (!m_sStatusPrefix.empty()) {
					if (!pUser->SetStatusPrefix(m_sStatusPrefix)) {
						sError = ""Invalid StatusPrefix ["" + m_sStatusPrefix + ""] Must be 1-5 chars, no spaces."";
						CUtils::PrintError(sError);
						return false;
					}
				}

				continue;
			} else if (sTag.CaseCmp(""Chan"") == 0) {
				if (!pUser) {
					sError = ""<Chan> tags must be nested inside of a <User> tag."";
					CUtils::PrintError(sError);
					return false;
				}

				if (pChan) {
					sError = ""You may not nest <Chan> tags inside of other <Chan> tags."";
					CUtils::PrintError(sError);
					return false;
				}

				pChan = new CChan(sValue, pUser, true);
				continue;
			}
		}

		// If we have a regular line, figure out where it goes
		CString sName = sLine.Token(0, false, ""="");
		CString sValue = sLine.Token(1, true, ""="");
		sName.Trim();
		sValue.Trim();

		if ((!sName.empty()) && (!sValue.empty())) {
			if (pUser) {
				if (pChan) {
					if (sName.CaseCmp(""Buffer"") == 0) {
						pChan->SetBufferCount(strtoul(sValue.c_str(), NULL, 10));
						continue;
					} else if (sName.CaseCmp(""KeepBuffer"") == 0) {
						pChan->SetKeepBuffer((sValue.CaseCmp(""true"") == 0));
						continue;
					} else if (sName.CaseCmp(""Detached"") == 0) {
						pChan->SetDetached((sValue.CaseCmp(""true"") == 0));
						continue;
					} else if (sName.CaseCmp(""AutoCycle"") == 0) {
						pChan->SetAutoCycle((sValue.CaseCmp(""true"") == 0));
						continue;
					} else if (sName.CaseCmp(""Key"") == 0) {
						pChan->SetKey(sValue);
						continue;
					} else if (sName.CaseCmp(""Modes"") == 0) {
						pChan->SetDefaultModes(sValue);
						continue;
					}
				} else {
					if (sName.CaseCmp(""Buffer"") == 0) {
						pUser->SetBufferCount(strtoul(sValue.c_str(), NULL, 10));
						continue;
					} else if (sName.CaseCmp(""KeepBuffer"") == 0) {
						pUser->SetKeepBuffer((sValue.CaseCmp(""true"") == 0));
						continue;
					} else if (sName.CaseCmp(""AutoCycle"") == 0) {
						pUser->SetAutoCycle((sValue.CaseCmp(""true"") == 0));
						continue;
					} else if (sName.CaseCmp(""Nick"") == 0) {
						pUser->SetNick(sValue);
						continue;
					} else if (sName.CaseCmp(""CTCPReply"") == 0) {
						pUser->AddCTCPReply(sValue.Token(0), sValue.Token(1, true));
						continue;
					} else if (sName.CaseCmp(""QuitMsg"") == 0) {
						pUser->SetQuitMsg(sValue);
						continue;
					} else if (sName.CaseCmp(""AltNick"") == 0) {
						pUser->SetAltNick(sValue);
						continue;
					} else if (sName.CaseCmp(""AwaySuffix"") == 0) {
						CUtils::PrintMessage(""WARNING: AwaySuffix has been depricated, instead try -> LoadModule = awaynick %nick%_"" + sValue);
						continue;
					} else if (sName.CaseCmp(""Pass"") == 0) {
						// There are different formats for this available:
						// Pass = <plain text>
						// Pass = <md5 hash> -
						// Pass = plain#<plain text>
						// Pass = md5#<md5 hash>
						// Pass = md5#<salted md5 hash>#<salt>#
						// The last one is the md5 hash of 'password' + 'salt'
						if (sValue.Right(1) == ""-"") {
							sValue.RightChomp();
							sValue.Trim();
							pUser->SetPass(sValue, true);
						} else {
							CString sMethod = sValue.Token(0, false, ""#"");
							CString sPass = sValue.Token(1, true, ""#"");
							if (sMethod == ""md5"") {
								CString sSalt = sPass.Token(1, false, ""#"");
								sPass = sPass.Token(0, false, ""#"");
								pUser->SetPass(sPass, true, sSalt);
							} else if (sMethod == ""plain"") {
								pUser->SetPass(sPass, false);
							} else {
								pUser->SetPass(sValue, false);
							}
						}

						continue;
					} else if (sName.CaseCmp(""MultiClients"") == 0) {
						pUser->SetMultiClients(sValue.CaseCmp(""true"") == 0);
						continue;
					} else if (sName.CaseCmp(""BounceDCCs"") == 0) {
						pUser->SetBounceDCCs(sValue.CaseCmp(""true"") == 0);
						continue;
					} else if (sName.CaseCmp(""Ident"") == 0) {
						pUser->SetIdent(sValue);
						continue;
					} else if (sName.CaseCmp(""DenyLoadMod"") == 0) {
						pUser->SetDenyLoadMod((sValue.CaseCmp(""TRUE"") == 0));
						continue;
					} else if (sName.CaseCmp(""Admin"") == 0) {
						pUser->SetAdmin((sValue.CaseCmp(""TRUE"") == 0));
						continue;
					} else if (sName.CaseCmp(""DenySetVHost"") == 0) {
						pUser->SetDenySetVHost((sValue.CaseCmp(""TRUE"") == 0));
						continue;
					} else if (sName.CaseCmp(""StatusPrefix"") == 0) {
						if (!pUser->SetStatusPrefix(sValue)) {
							sError = ""Invalid StatusPrefix ["" + sValue + ""] Must be 1-5 chars, no spaces."";
							CUtils::PrintError(sError);
							return false;
						}
						continue;
					} else if (sName.CaseCmp(""DCCLookupMethod"") == 0) {
						pUser->SetUseClientIP((sValue.CaseCmp(""Client"") == 0));
						continue;
					} else if (sName.CaseCmp(""RealName"") == 0) {
						pUser->SetRealName(sValue);
						continue;
					} else if (sName.CaseCmp(""KeepNick"") == 0) {
						if (sValue.CaseCmp(""true"") == 0) {
							CUtils::PrintError(""WARNING: KeepNick has been deprecated, instead try -> LoadModule = keepnick"");
						}
						continue;
					} else if (sName.CaseCmp(""ChanModes"") == 0) {
						pUser->SetDefaultChanModes(sValue);
						continue;
					} else if (sName.CaseCmp(""VHost"") == 0) {
						pUser->SetVHost(sValue);
						continue;
					} else if (sName.CaseCmp(""Allow"") == 0) {
						pUser->AddAllowedHost(sValue);
						continue;
					} else if (sName.CaseCmp(""Server"") == 0) {
						CUtils::PrintAction(""Adding Server ["" + sValue + ""]"");
						CUtils::PrintStatus(pUser->AddServer(sValue));
						continue;
					} else if (sName.CaseCmp(""Chan"") == 0) {
						pUser->AddChan(sValue, true);
						continue;
					} else if (sName.CaseCmp(""TimestampFormat"") == 0) {
						pUser->SetTimestampFormat(sValue);
						continue;
					} else if (sName.CaseCmp(""AppendTimestamp"") == 0) {
						pUser->SetTimestampAppend(sValue.ToBool());
						continue;
					} else if (sName.CaseCmp(""PrependTimestamp"") == 0) {
						pUser->SetTimestampPrepend(sValue.ToBool());
						continue;
					} else if (sName.CaseCmp(""Timestamp"") == 0) {
						if (sValue.Trim_n().CaseCmp(""true"") != 0) {
							if (sValue.Trim_n().CaseCmp(""append"") == 0) {
								pUser->SetTimestampAppend(true);
								pUser->SetTimestampPrepend(false);
							} else if (sValue.Trim_n().CaseCmp(""prepend"") == 0) {
								pUser->SetTimestampAppend(false);
								pUser->SetTimestampPrepend(true);
							} else if (sValue.Trim_n().CaseCmp(""false"") == 0) {
								pUser->SetTimestampAppend(false);
								pUser->SetTimestampPrepend(false);
							} else {
								pUser->SetTimestampFormat(sValue);
							}
						}
						continue;
					} else if (sName.CaseCmp(""TimezoneOffset"") == 0) {
						pUser->SetTimezoneOffset(sValue.ToDouble()); // there is no ToFloat()
						continue;
					} else if (sName.CaseCmp(""JoinTries"") == 0) {
						pUser->SetJoinTries(sValue.ToUInt());
						continue;
					} else if (sName.CaseCmp(""LoadModule"") == 0) {
						CString sModName = sValue.Token(0);
						CUtils::PrintAction(""Loading Module ["" + sModName + ""]"");
#ifdef _MODULES
						CString sModRet;
						CString sArgs = sValue.Token(1, true);

						bool bModRet = pUser->GetModules().LoadModule(sModName, sArgs, pUser, sModRet);

						// If the module was loaded, sModRet contains
						// ""Loaded Module [name] ..."" and we strip away this beginning.
						if (bModRet)
							sModRet = sModRet.Token(1, true, sModName + ""] "");

						CUtils::PrintStatus(bModRet, sModRet);
						if (!bModRet) {
							sError = sModRet;
							return false;
						}
#else
						sError = ""Modules are not enabled."";
						CUtils::PrintStatus(false, sError);
#endif
						continue;
					}
				}
			} else {
				if (sName.CaseCmp(""Listen"") == 0 || sName.CaseCmp(""ListenPort"") == 0 || sName.CaseCmp(""Listen6"") == 0) {
					bool bSSL = false;
					bool bIPV6 = (sName.CaseCmp(""Listen6"") == 0);
					CString sPort;

					CString sBindHost;

					if (!bIPV6) {
						sValue.Replace("":"", "" "");
					}

					if (sValue.find("" "") != CString::npos) {
						sBindHost = sValue.Token(0, false, "" "");
						sPort = sValue.Token(1, true, "" "");
					} else {
						sPort = sValue;
					}

					if (sPort.Left(1) == ""+"") {
						sPort.LeftChomp();
						bSSL = true;
					}

					CString sHostComment;

					if (!sBindHost.empty()) {
						sHostComment = "" on host ["" + sBindHost + ""]"";
					}

					CString sIPV6Comment;

					if (bIPV6) {
						sIPV6Comment = "" using ipv6"";
					}

					unsigned short uPort = strtol(sPort.c_str(), NULL, 10);
					CUtils::PrintAction(""Binding to port ["" + CString((bSSL) ? ""+"" : """") + CString(uPort) + ""]"" + sHostComment + sIPV6Comment);

#ifndef HAVE_IPV6
					if (bIPV6) {
						sError = ""IPV6 is not enabled"";
						CUtils::PrintStatus(false, sError);
						return false;
					}
#endif

#ifndef HAVE_LIBSSL
					if (bSSL) {
						sError = ""SSL is not enabled"";
						CUtils::PrintStatus(false, sError);
						return false;
					}
#else
					CString sPemFile = GetPemLocation();

					if (bSSL && !CFile::Exists(sPemFile)) {
						sError = ""Unable to locate pem file: ["" + sPemFile + ""]"";
						CUtils::PrintStatus(false, sError);

						// If stdin is e.g. /dev/null and we call GetBoolInput(),
						// we are stuck in an endless loop!
						if (isatty(0) && CUtils::GetBoolInput(""Would you like to create a new pem file?"", true)) {
							sError.clear();
							WritePemFile();
						} else {
							return false;
						}

						CUtils::PrintAction(""Binding to port [+"" + CString(uPort) + ""]"" + sHostComment + sIPV6Comment);
					}
#endif
					if (!uPort) {
						sError = ""Invalid port"";
						CUtils::PrintStatus(false, sError);
						return false;
					}

					CListener* pListener = new CListener(uPort, sBindHost, bSSL, bIPV6);

					if (!pListener->Listen()) {
						sError = ""Unable to bind"";
						CUtils::PrintStatus(false, sError);
						delete pListener;
						return false;
					}

					m_vpListeners.push_back(pListener);
					CUtils::PrintStatus(true);

					continue;
				} else if (sName.CaseCmp(""LoadModule"") == 0) {
#ifdef _MODULES
					CString sModName = sValue.Token(0);
					CString sArgs = sValue.Token(1, true);

					if (msModules.find(sModName) != msModules.end()) {
						sError = ""Module ["" + sModName +
							""] already loaded"";
						CUtils::PrintError(sError);
						return false;
					}
					msModules[sModName] = sArgs;
#else
					CUtils::PrintError(""Modules are not enabled."");
#endif
					continue;
				} else if (sName.CaseCmp(""ISpoofFormat"") == 0) {
					m_sISpoofFormat = sValue;
					continue;
				} else if (sName.CaseCmp(""ISpoofFile"") == 0) {
					if (sValue.Left(2) == ""~/"") {
						sValue.LeftChomp(2);
						sValue = GetHomePath() + ""/"" + sValue;
					}
					m_sISpoofFile = sValue;
					continue;
				} else if (sName.CaseCmp(""MOTD"") == 0) {
					AddMotd(sValue);
					continue;
				} else if (sName.CaseCmp(""VHost"") == 0) {
					AddVHost(sValue);
					continue;
				} else if (sName.CaseCmp(""PidFile"") == 0) {
					m_sPidFile = sValue;
					continue;
				} else if (sName.CaseCmp(""StatusPrefix"") == 0) {
					m_sStatusPrefix = sValue;
					continue;
				} else if (sName.CaseCmp(""ConnectDelay"") == 0) {
					m_uiConnectDelay = sValue.ToUInt();
					continue;
				}
			}

		}

		if (sName.CaseCmp(""GM:"", 3) == 0)
		{ // GM: prefix is a pass through to config lines for global modules
			CGlobalModuleConfigLine cTmp;
			cTmp.m_sName = sName.substr(3, CString::npos);
			cTmp.m_sValue = sValue;
			cTmp.m_pChan = pChan;
			cTmp.m_pUser = pUser;
			lGlobalModuleConfigLine.push_back(cTmp);
		}
		else
		{
			sError = ""Unhandled line "" + CString(uLineNum) + "" in config: ["" + sLine + ""]"";
			CUtils::PrintError(sError);
			return false;
		}
	}

#ifdef _MODULES
	// First step: Load and reload new modules or modules with new arguments
	for (MCString::iterator it = msModules.begin(); it != msModules.end(); it++) {
		CString sModName = it->first;
		CString sArgs = it->second;
		CString sModRet;
		CModule *pOldMod;

		pOldMod = GetModules().FindModule(sModName);
		if (!pOldMod) {
			CUtils::PrintAction(""Loading Global Module ["" + sModName + ""]"");

			bool bModRet = GetModules().LoadModule(sModName, sArgs, NULL, sModRet);

			// If the module was loaded, sModRet contains
			// ""Loaded Module [name] ..."" and we strip away this beginning.
			if (bModRet)
				sModRet = sModRet.Token(1, true, sModName + ""] "");

			CUtils::PrintStatus(bModRet, sModRet);
			if (!bModRet) {
				sError = sModRet;
				return false;
			}
		} else if (pOldMod->GetArgs() != sArgs) {
			CUtils::PrintAction(""Reloading Global Module ["" + sModName + ""]"");

			bool bModRet = GetModules().ReloadModule(sModName, sArgs, NULL, sModRet);

			// If the module was loaded, sModRet contains
			// ""Loaded Module [name] ..."" and we strip away this beginning.
			if (bModRet)
				sModRet = sModRet.Token(1, true, sModName + ""] "");

			CUtils::PrintStatus(bModRet, sModRet);
			if (!bModRet) {
				sError = sModRet;
				return false;
			}
		} else
			CUtils::PrintMessage(""Module ["" + sModName + ""] already loaded."");
	}

	// Second step: Unload modules which are no longer in the config
	set<CString> ssUnload;
	for (size_t i = 0; i < GetModules().size(); i++) {
		CModule *pCurMod = GetModules()[i];

		if (msModules.find(pCurMod->GetModName()) == msModules.end())
			ssUnload.insert(pCurMod->GetModName());
	}

	for (set<CString>::iterator it = ssUnload.begin(); it != ssUnload.end(); it++) {
		if (GetModules().UnloadModule(*it))
			CUtils::PrintMessage(""Unloaded Global Module ["" + *it + ""]"");
		else
			CUtils::PrintMessage(""Could not unload ["" + *it + ""]"");
	}

	// last step, throw unhandled config items at global config
	for (std::list<CGlobalModuleConfigLine>::iterator it = lGlobalModuleConfigLine.begin(); it != lGlobalModuleConfigLine.end(); it++)
	{
		if ((pChan && pChan == it->m_pChan) || (pUser && pUser == it->m_pUser))
			continue; // skip unclosed user or chan
		if (!GetModules().OnConfigLine(it->m_sName, it->m_sValue, it->m_pUser, it->m_pChan))
		{
			CUtils::PrintMessage(""unhandled global module config line [GM:"" + it->m_sName + ""] = ["" + it->m_sValue + ""]"");
		}
	}
#endif

	if (pChan) {
		// TODO last <Chan> not closed
		delete pChan;
	}

	if (pUser) {
		// TODO last <User> not closed
		delete pUser;
	}

	File.Close();

	if (m_msUsers.size() == 0) {
		sError = ""You must define at least one user in your config."";
		CUtils::PrintError(sError);
		return false;
	}

	if (m_vpListeners.size() == 0) {
		sError = ""You must supply at least one Listen port in your config."";
		CUtils::PrintError(sError);
		return false;
	}

	// Make sure that users that want to connect do so
	EnableConnectUser();

	return true;
}

void CZNC::ClearVHosts() {
	m_vsVHosts.clear();
}

bool CZNC::AddVHost(const CString& sHost) {
	if (sHost.empty()) {
		return false;
	}

	for (unsigned int a = 0; a < m_vsVHosts.size(); a++) {
		if (m_vsVHosts[a].CaseCmp(sHost) == 0) {
			return false;
		}
	}

	m_vsVHosts.push_back(sHost);
	return true;
}

bool CZNC::RemVHost(const CString& sHost) {
	// @todo
	return true;
}

void CZNC::Broadcast(const CString& sMessage, bool bAdminOnly,
		CUser* pSkipUser, CClient *pSkipClient) {
	for (map<CString,CUser*>::iterator a = m_msUsers.begin(); a != m_msUsers.end(); a++) {
		if (bAdminOnly && !a->second->IsAdmin())
			continue;

		if (a->second != pSkipUser) {
			CString sMsg = sMessage;

			MODULECALL(OnBroadcast(sMsg), a->second, NULL, continue);
			a->second->PutStatusNotice(""*** "" + sMsg, NULL, pSkipClient);
		}
	}
}

bool CZNC::FindModPath(const CString& sModule, CString& sModPath,
		CString& sDataPath) const {
	CString sMod = sModule;
	CString sDir = sMod;
	if (sModule.find(""."") == CString::npos)
		sMod += "".so"";

	sDataPath = GetCurPath() + ""/modules/"";
	sModPath = sDataPath + sMod;

	if (!CFile::Exists(sModPath)) {
		sDataPath = GetModPath() + ""/"";
		sModPath = sDataPath + sMod;

		if (!CFile::Exists(sModPath)) {
			sDataPath = _DATADIR_ + CString(""/"");
			sModPath = _MODDIR_ + CString(""/"") + sMod;

			if (!CFile::Exists(sModPath)) {
				return false;
			}
		}
	}

	sDataPath += sDir;

	return true;
}

CUser* CZNC::FindUser(const CString& sUsername) {
	map<CString,CUser*>::iterator it = m_msUsers.find(sUsername);

	if (it != m_msUsers.end()) {
		return it->second;
	}

	return NULL;
}

bool CZNC::DeleteUser(const CString& sUsername) {
	CUser* pUser = FindUser(sUsername);

	if (!pUser) {
		return false;
	}

	m_msDelUsers[pUser->GetUserName()] = pUser;
	return true;
}

bool CZNC::AddUser(CUser* pUser, CString& sErrorRet) {
	if (pUser->IsValid(sErrorRet)) {
		m_msUsers[pUser->GetUserName()] = pUser;
		return true;
	}

	DEBUG_ONLY(cout << ""Invalid user ["" << pUser->GetUserName() << ""] - ["" << sErrorRet << ""]"" << endl);
	return false;
}

CZNC& CZNC::Get() {
	static CZNC* pZNC = new CZNC;
	return *pZNC;
}

void CZNC::UpdateTrafficStats() {
	CSockManager* p = &m_Manager;
	for (unsigned int a = 0; a < p->size(); a++) {
		if ((*p)[a]->GetSockName().Left(5) == ""IRC::"") {
			CIRCSock *i = (CIRCSock *)(*p)[a];
			i->GetUser()->AddBytesRead((*p)[a]->GetBytesRead());
			(*p)[a]->ResetBytesRead();
			i->GetUser()->AddBytesWritten((*p)[a]->GetBytesWritten());
			(*p)[a]->ResetBytesWritten();
		} else if ((*p)[a]->GetSockName().Left(5) == ""USR::"") {
			CClient *c = (CClient *)(*p)[a];
			c->GetUser()->AddBytesRead((*p)[a]->GetBytesRead());
			(*p)[a]->ResetBytesRead();
			c->GetUser()->AddBytesWritten((*p)[a]->GetBytesWritten());
			(*p)[a]->ResetBytesWritten();
		}
	}
}

void CZNC::AuthUser(CSmartPtr<CAuthBase> AuthClass) {
#ifdef _MODULES
	// TODO unless the auth module calls it, CUser::IsHostAllowed() is not honoured
	if (GetModules().OnLoginAttempt(AuthClass)) {
		return;
	}
#endif

	CUser* pUser = GetUser(AuthClass->GetUsername());

	if (!pUser || !pUser->CheckPass(AuthClass->GetPassword())) {
		if (pUser) {
			pUser->PutStatus(""Another client attempted to login as you, with a bad password."");
		}

		AuthClass->RefuseLogin(""Invalid Password"");
		return;
	}

	CString sHost = AuthClass->GetRemoteIP();

	if (!pUser->IsHostAllowed(sHost)) {
		AuthClass->RefuseLogin(""Your host ["" + sHost + ""] is not allowed"");
		return;
	}

	AuthClass->AcceptLogin(*pUser);
}

class CConnectUserTimer : public CCron {
public:
	CConnectUserTimer(int iSecs) : CCron() {
		SetName(""Connect users"");
		Start(iSecs);
		m_uiPosNextUser = 0;
	}
	virtual ~CConnectUserTimer() {}

protected:
	virtual void RunJob() {
		unsigned int uiUserCount;
		bool bUsersLeft = false;
		const map<CString,CUser*>& mUsers = CZNC::Get().GetUserMap();
		map<CString,CUser*>::const_iterator it = mUsers.begin();

		uiUserCount = CZNC::Get().GetUserMap().size();

		if (m_uiPosNextUser >= uiUserCount) {
			m_uiPosNextUser = 0;
		}

		for (unsigned int i = 0; i < m_uiPosNextUser; i++) {
			it++;
		}

		// Try to connect each user, if this doesnt work, abort
		for (unsigned int i = 0; i < uiUserCount; i++) {
			if (it == mUsers.end())
				it = mUsers.begin();

			CUser* pUser = it->second;
			it++;
			m_uiPosNextUser = (m_uiPosNextUser + 1) % uiUserCount;

			// Is this user disconnected and does he want to connect?
			if (pUser->GetIRCSock() == NULL && pUser->GetIRCConnectEnabled()) {
				// The timer runs until it once didn't find any users to connect
				bUsersLeft = true;

				DEBUG_ONLY(cout << ""Connecting user ["" << pUser->GetUserName()
						<< ""]"" << endl);

				if (CZNC::Get().ConnectUser(pUser))
					// User connecting, wait until next time timer fires
					return;
			}
		}

		if (bUsersLeft == false) {
			DEBUG_ONLY(cout << ""ConnectUserTimer done"" << endl);
			CZNC::Get().DisableConnectUser();
		}
	}

private:
	size_t	m_uiPosNextUser;
};

void CZNC::EnableConnectUser() {
	if (m_pConnectUserTimer != NULL)
		return;

	m_pConnectUserTimer = new CConnectUserTimer(m_uiConnectDelay);
	GetManager().AddCron(m_pConnectUserTimer);
}

void CZNC::DisableConnectUser() {
	if (m_pConnectUserTimer == NULL)
		return;

	// This will kill the cron
	m_pConnectUserTimer->Stop();
	m_pConnectUserTimer = NULL;
}
""","""/*
 * Copyright (C) 2004-2008  See the AUTHORS file for details.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 as published
 * by the Free Software Foundation.
 */

#include ""znc.h""
#include ""Chan.h""
#include ""IRCSock.h""
#include ""Server.h""
#include ""User.h""
#include <pwd.h>
#include <list>

namespace
{ // private namespace for local things
	struct CGlobalModuleConfigLine
	{
		CString	m_sName;
		CString	m_sValue;
		CUser	*m_pUser;
		CChan	*m_pChan;
	};
};

CZNC::CZNC() {
#ifdef _MODULES
	m_pModules = new CGlobalModules();
#endif
	m_pISpoofLockFile = NULL;
	m_uiConnectDelay = 30;
	SetISpoofFormat(""""); // Set ISpoofFormat to default
	m_uBytesRead = 0;
	m_uBytesWritten = 0;
	m_pConnectUserTimer = NULL;
	m_bNeedRehash = false;
	m_TimeStarted = time(NULL);
}

CZNC::~CZNC() {
	if (m_pISpoofLockFile)
		ReleaseISpoof();

#ifdef _MODULES
	m_pModules->UnloadAll();

	for (map<CString,CUser*>::iterator a = m_msUsers.begin(); a != m_msUsers.end(); a++) {
		a->second->GetModules().UnloadAll();
	}
#endif

	for (size_t b = 0; b < m_vpListeners.size(); b++) {
		delete m_vpListeners[b];
	}

	for (map<CString,CUser*>::iterator a = m_msUsers.begin(); a != m_msUsers.end(); a++) {
		a->second->SetBeingDeleted(true);
	}

	m_pConnectUserTimer = NULL;
	// This deletes m_pConnectUserTimer
	m_Manager.Cleanup();
	DeleteUsers();

#ifdef _MODULES
	delete m_pModules;
#endif

	DeletePidFile();
}

CString CZNC::GetVersion() {
	char szBuf[128];

	snprintf(szBuf, sizeof(szBuf), ""%1.3f""VERSION_EXTRA, VERSION);
	// If snprintf overflows (which I doubt), we want to be on the safe side
	szBuf[sizeof(szBuf) - 1] = '\0';

	return szBuf;
}

CString CZNC::GetTag(bool bIncludeVersion) {
	if (!bIncludeVersion) {
		return ""ZNC - http://znc.sourceforge.net"";
	}

	char szBuf[128];
	snprintf(szBuf, sizeof(szBuf), ""ZNC %1.3f""VERSION_EXTRA"" - http://znc.sourceforge.net"", VERSION);
	// If snprintf overflows (which I doubt), we want to be on the safe side
	szBuf[sizeof(szBuf) - 1] = '\0';

	return szBuf;
}

CString CZNC::GetUptime() const {
	time_t now = time(NULL);
	return CString::ToTimeStr(now - TimeStarted());
}

bool CZNC::OnBoot() {
#ifdef _MODULES
	if (!GetModules().OnBoot()) {
		return false;
	}

	for (map<CString,CUser*>::iterator it = m_msUsers.begin(); it != m_msUsers.end(); it++) {
		if (!it->second->GetModules().OnBoot()) {
			return false;
		}
	}
#endif

	return true;
}

bool CZNC::ConnectUser(CUser *pUser) {
	CString sSockName = ""IRC::"" + pUser->GetUserName();
	// Don't use pUser->GetIRCSock(), as that only returns something if the
	// CIRCSock is already connected, not when it's still connecting!
	CIRCSock* pIRCSock = (CIRCSock*) m_Manager.FindSockByName(sSockName);

	if (m_pISpoofLockFile != NULL) {
		return false;
	}

	if (!pUser->GetIRCConnectEnabled())
		return false;

	if (pIRCSock || !pUser->HasServers())
		return false;

	if (pUser->ConnectPaused())
		return false;

	CServer* pServer = pUser->GetNextServer();

	if (!pServer)
		return false;

	if (!WriteISpoof(pUser)) {
		DEBUG_ONLY(cout << ""ISpoof could not be written"" << endl);
		pUser->PutStatus(""ISpoof could not be written, retrying..."");
		return true;
	}

	DEBUG_ONLY(cout << ""User ["" << pUser->GetUserName() << ""] is connecting to ["" << pServer->GetName() << "":"" << pServer->GetPort() << ""] ..."" << endl);
	pUser->PutStatus(""Attempting to connect to ["" + pServer->GetName() + "":"" + CString(pServer->GetPort()) + ""] ..."");

	pIRCSock = new CIRCSock(pUser);
	pIRCSock->SetPass(pServer->GetPass());

	bool bSSL = false;
#ifdef HAVE_LIBSSL
	if (pServer->IsSSL()) {
		bSSL = true;
	}
#endif

	if (!m_Manager.Connect(pServer->GetName(), pServer->GetPort(), sSockName, 120, bSSL, pUser->GetVHost(), pIRCSock)) {
		ReleaseISpoof();
		pUser->PutStatus(""Unable to connect. (Bad host?)"");
	}

	return true;
}

bool CZNC::HandleUserDeletion()
{
	map<CString, CUser*>::iterator it;
	map<CString, CUser*>::iterator end;

	if (m_msDelUsers.size() == 0)
		return false;

	end = m_msDelUsers.end();
	for (it = m_msDelUsers.begin(); it != end; it++) {
		CUser* pUser = it->second;
		pUser->SetBeingDeleted(true);

#ifdef _MODULES
		if (GetModules().OnDeleteUser(*pUser)) {
			pUser->SetBeingDeleted(false);
			continue;
		}
#endif
		m_msUsers.erase(pUser->GetUserName());

		CIRCSock* pIRCSock = pUser->GetIRCSock();

		if (pIRCSock) {
			m_Manager.DelSockByAddr(pIRCSock);
		}

		pUser->DelClients();
#ifdef _MODULES
		pUser->DelModules();
#endif
		AddBytesRead(pUser->BytesRead());
		AddBytesWritten(pUser->BytesWritten());
		delete pUser;
	}

	m_msDelUsers.clear();

	return true;
}

int CZNC::Loop() {
	while (true) {
		CString sError;
		map<CString, CUser*>::iterator it;
		map<CString, CUser*>::iterator end;

		if (GetNeedRehash()) {
			SetNeedRehash(false);

			if (RehashConfig(sError)) {
				Broadcast(""Rehashing succeeded"", true);
			} else {
				Broadcast(""Rehashing failed: "" + sError, true);
				Broadcast(""ZNC is in some possibly inconsistent state!"", true);
			}
		}

		// Check for users that need to be deleted
		if (HandleUserDeletion()) {
			// Also remove those user(s) from the config file
			WriteConfig();
		}

		// Csocket wants micro seconds
		// 500 msec to 600 sec
		m_Manager.DynamicSelectLoop(500 * 1000, 600 * 1000 * 1000);
	}

	return 0;
}

bool CZNC::WriteISpoof(CUser* pUser) {
	if (m_pISpoofLockFile != NULL)
		return false;

	if (!m_sISpoofFile.empty()) {
		m_pISpoofLockFile = new CLockFile;
		if (!m_pISpoofLockFile->TryExLock(m_sISpoofFile, true)) {
			delete m_pISpoofLockFile;
			m_pISpoofLockFile = NULL;
			return false;
		}

		CFile File(m_pISpoofLockFile->GetFD(), m_pISpoofLockFile->GetFileName());

		char buf[1024];
		memset((char*) buf, 0, 1024);
		File.Read(buf, 1023);
		m_sOrigISpoof = buf;

		if (!File.Seek(0) || !File.Truncate()) {
			delete m_pISpoofLockFile;
			m_pISpoofLockFile = NULL;
			return false;
		}

		CString sData = m_sISpoofFormat.Token(0, false, ""%"") + pUser->GetIdent() + m_sISpoofFormat.Token(1, true, ""%"");
		File.Write(sData + ""\n"");
	}
	return true;
}

void CZNC::ReleaseISpoof() {
	if (m_pISpoofLockFile == NULL)
		return;

	if (!m_sISpoofFile.empty()) {
		CFile File(m_pISpoofLockFile->GetFD(), m_pISpoofLockFile->GetFileName());

		if (File.Seek(0) && File.Truncate()) {
			File.Write(m_sOrigISpoof);
		}

		m_sOrigISpoof = """";
	}

	delete m_pISpoofLockFile;
	m_pISpoofLockFile = NULL;
}

bool CZNC::WritePidFile(int iPid) {
	if (!m_sPidFile.empty()) {
		CString sFile;

		// absolute path or relative to the data dir?
		if (m_sPidFile[0] != '/')
			sFile = GetZNCPath() + ""/"" + m_sPidFile;
		else
			sFile = m_sPidFile;

		CFile File(sFile);
		CUtils::PrintAction(""Writing pid file ["" + sFile + ""]"");

		if (File.Open(O_WRONLY | O_TRUNC | O_CREAT)) {
			File.Write(CString(iPid) + ""\n"");
			File.Close();
			CUtils::PrintStatus(true);
			return true;
		}

		CUtils::PrintStatus(false);
	}

	return false;
}

bool CZNC::DeletePidFile() {
	if (!m_sPidFile.empty()) {
		CString sFile;
		// absolute path or relative to the data dir?
		if (m_sPidFile[0] != '/')
			sFile = GetZNCPath() + ""/"" + m_sPidFile;
		else
			sFile = m_sPidFile;

		CFile File(sFile);
		CUtils::PrintAction(""Deleting pid file ["" + sFile + ""]"");
		if (File.Delete()) {
			CUtils::PrintStatus(true);
			return true;
		}
		CUtils::PrintStatus(false);
	}
	return false;
}

bool CZNC::WritePemFile(bool bEncPem) {
#ifndef HAVE_LIBSSL
	CUtils::PrintError(""ZNC was not compiled with ssl support."");
	return false;
#else
	CString sPemFile = GetPemLocation();
	const char* pHostName = getenv(""HOSTNAME"");
	CString sHost;

	if (pHostName) {
		sHost = pHostName;
	}

	if (CFile::Exists(sPemFile)) {
		CUtils::PrintError(""Pem file ["" + sPemFile + ""] already exists"");
		return false;
	}

	while (!CUtils::GetInput(""hostname of your shell"", sHost, sHost, ""including the '.com' portion"")) ;

	CUtils::PrintAction(""Writing Pem file ["" + sPemFile + ""]"");
	FILE *f = fopen(sPemFile.c_str(), ""w"");

	if (!f) {
		CUtils::PrintStatus(false, ""Unable to open"");
		return false;
	}

	CUtils::GenerateCert(f, bEncPem, sHost);
	fclose(f);

	CUtils::PrintStatus(true);
	return true;
#endif
}

void CZNC::DeleteUsers() {
	for (map<CString,CUser*>::iterator a = m_msUsers.begin(); a != m_msUsers.end(); a++) {
		a->second->SetBeingDeleted(true);
		delete a->second;
	}

	m_msUsers.clear();
	DisableConnectUser();
}

CUser* CZNC::GetUser(const CString& sUser) {
	// Todo: make this case insensitive
	map<CString,CUser*>::iterator it = m_msUsers.find(sUser);
	return (it == m_msUsers.end()) ? NULL : it->second;
}

Csock* CZNC::FindSockByName(const CString& sSockName) {
	return m_Manager.FindSockByName(sSockName);
}

bool CZNC::IsHostAllowed(const CString& sHostMask) const {
	for (map<CString,CUser*>::const_iterator a = m_msUsers.begin(); a != m_msUsers.end(); a++) {
		if (a->second->IsHostAllowed(sHostMask)) {
			return true;
		}
	}

	return false;
}

void CZNC::InitDirs(const CString& sArgvPath, const CString& sDataDir) {
	char buf[PATH_MAX];
	char *home;

	if (getcwd(buf, PATH_MAX) == NULL) {
		CUtils::PrintError(""getcwd() failed, can't read my current dir"");
		exit(-1);
	}

	// If the bin was not ran from the current directory, we need to add that dir onto our cwd
	CString::size_type uPos = sArgvPath.rfind('/');
	m_sCurPath = (uPos == CString::npos) ? CString(buf) : CDir::ChangeDir(buf, sArgvPath.substr(0, uPos), """");

	// Try to set the user's home dir, default to binpath on failure
	home = getenv(""HOME"");

	m_sHomePath.clear();
	if (home) {
		m_sHomePath = home;
	}

	if (m_sHomePath.empty()) {
		struct passwd* pUserInfo = getpwuid(getuid());

		if (pUserInfo) {
			m_sHomePath = pUserInfo->pw_dir;
		}
	}

	if (m_sHomePath.empty()) {
		m_sHomePath = m_sCurPath;
	}

	if (sDataDir.empty()) {
	    m_sZNCPath = m_sHomePath + ""/.znc"";
	} else {
	    m_sZNCPath = sDataDir;
	}

	// Other dirs that we use
	m_sConfPath = m_sZNCPath + ""/configs"";
	m_sModPath = m_sZNCPath + ""/modules"";
	m_sUserPath = m_sZNCPath + ""/users"";
}


CString CZNC::ExpandConfigPath(const CString& sConfigFile) {
	CString sRetPath;

	if (sConfigFile.empty()) {
		sRetPath = GetConfPath() + ""/znc.conf"";
	} else {
		if (sConfigFile.Left(2) == ""./"" || sConfigFile.Left(3) == ""../"") {
			sRetPath = GetCurPath() + ""/"" + sConfigFile;
		} else if (sConfigFile.Left(1) != ""/"") {
			sRetPath = GetConfPath() + ""/"" + sConfigFile;
		} else {
			sRetPath = sConfigFile;
		}
	}

	return sRetPath;
}

bool CZNC::BackupConfig() const {
	CString sBackup = GetConfigFile() + ""-backup"";

	// Create a new backup overwriting an old one we might have
	if (CFile::Copy(m_sConfigFile, sBackup, true))
		return true;

	// Don't abort if no config file exists
	if (!CFile::Exists(m_sConfigFile))
		// No backup because we got nothing to backup
		return true;

	return false;
}

bool CZNC::WriteConfig() {
	CFile File(GetConfigFile());

	if (!BackupConfig()) {
		return false;
	}

	if (m_sConfigFile.empty() || !File.Open(O_WRONLY | O_CREAT | O_TRUNC, 0600)) {
		return false;
	}

	for (size_t l = 0; l < m_vpListeners.size(); l++) {
		CListener* pListener = m_vpListeners[l];
		CString sHostPortion = pListener->GetBindHost();

		if (!sHostPortion.empty()) {
			sHostPortion += "" "";
		}

		CString s6 = (pListener->IsIPV6()) ? ""6"" : "" "";

		File.Write(""Listen"" + s6 + ""      = "" + sHostPortion + CString((pListener->IsSSL()) ? ""+"" : """") + CString(pListener->GetPort()) + ""\n"");
	}

	File.Write(""ConnectDelay = "" + CString(m_uiConnectDelay) + ""\n"");

	if (!m_sISpoofFile.empty()) {
		File.Write(""ISpoofFile   = "" + m_sISpoofFile + ""\n"");
		if (!m_sISpoofFormat.empty()) { File.Write(""ISpoofFormat = "" + m_sISpoofFormat + ""\n""); }
	}

	if (!m_sPidFile.empty()) { File.Write(""PidFile      = "" + m_sPidFile + ""\n""); }
	if (!m_sStatusPrefix.empty()) { File.Write(""StatusPrefix = "" + m_sStatusPrefix + ""\n""); }

	for (unsigned int m = 0; m < m_vsMotd.size(); m++) {
		File.Write(""Motd         = "" + m_vsMotd[m] + ""\n"");
	}

	for (unsigned int v = 0; v < m_vsVHosts.size(); v++) {
		File.Write(""VHost        = "" + m_vsVHosts[v] + ""\n"");
	}

#ifdef _MODULES
	CGlobalModules& Mods = GetModules();

	for (unsigned int a = 0; a < Mods.size(); a++) {
		CString sArgs = Mods[a]->GetArgs();

		if (!sArgs.empty()) {
			sArgs = "" "" + sArgs;
		}

		File.Write(""LoadModule   = "" + Mods[a]->GetModName() + sArgs + ""\n"");
	}
#endif

	for (map<CString,CUser*>::iterator it = m_msUsers.begin(); it != m_msUsers.end(); it++) {
		CString sErr;

		if (!it->second->IsValid(sErr)) {
			DEBUG_ONLY(cerr << ""** Error writing config for user ["" << it->first << ""] ["" << sErr << ""]"" << endl);
			continue;
		}

		File.Write(""\n"");

		if (!it->second->WriteConfig(File)) {
			DEBUG_ONLY(cerr << ""** Error writing config for user ["" << it->first << ""]"" << endl);
		}
	}

	File.Close();

	return true;
}

bool CZNC::WriteNewConfig(const CString& sConfig) {
	CString sConfigFile = ExpandConfigPath((sConfig.empty()) ? ""znc.conf"" : sConfig);
	CString sAnswer, sUser;
	vector<CString> vsLines;

	if (CFile::Exists(sConfigFile)) {
		if (!m_LockFile.TryExLock(sConfigFile)) {
			CUtils::PrintError(""ZNC is currently running on this config."");
			return false;
		}

		if (!CUtils::GetBoolInput(""This config already exists.  Would you like to overwrite it?"", false)) {
			m_LockFile.UnLock();
			return false;
		}
	}

	CUtils::PrintMessage(""Writing new config ["" + sConfigFile + ""]"");

	CUtils::PrintMessage("""");
	CUtils::PrintMessage(""First lets start with some global settings..."");
	CUtils::PrintMessage("""");

	// Listen
	unsigned int uListenPort = 0;
	while (!CUtils::GetNumInput(""What port would you like ZNC to listen on?"", uListenPort, 1, 65535)) ;

	CString sSSL;
#ifdef HAVE_LIBSSL
	if (CUtils::GetBoolInput(""Would you like ZNC to listen using SSL?"", false)) {
		sSSL = ""+"";
	}
#endif

	CString s6 = "" "";
#ifdef HAVE_IPV6
	if (CUtils::GetBoolInput(""Would you like ZNC to listen using ipv6?"", false)) {
		s6 = ""6"";
	}
#endif

	CString sListenHost;
	CUtils::GetInput(""Listen Host"", sListenHost, """", ""Blank for all ips"");

	if (!sListenHost.empty()) {
		sListenHost += "" "";
	}

	vsLines.push_back(""Listen"" + s6 + ""    = "" + sListenHost + sSSL + CString(uListenPort));
	// !Listen

#ifdef _MODULES
	set<CModInfo> ssGlobalMods;
	GetModules().GetAvailableMods(ssGlobalMods, true);

	if (ssGlobalMods.size()) {
		CUtils::PrintMessage("""");
		CUtils::PrintMessage(""-- Global Modules --"");
		CUtils::PrintMessage("""");

		if (CUtils::GetBoolInput(""Do you want to load any global modules?"")) {
			CTable Table;
			Table.AddColumn(""Name"");
			Table.AddColumn(""Description"");
			set<CModInfo>::iterator it;

			for (it = ssGlobalMods.begin(); it != ssGlobalMods.end(); it++) {
				const CModInfo& Info = *it;
				Table.AddRow();
				Table.SetCell(""Name"", Info.GetName());
				Table.SetCell(""Description"", Info.GetDescription().Ellipsize(128));
			}

			unsigned int uTableIdx = 0; CString sLine;
			while (Table.GetLine(uTableIdx++, sLine)) {
				CUtils::PrintMessage(sLine);
			}

			CUtils::PrintMessage("""");

			for (it = ssGlobalMods.begin(); it != ssGlobalMods.end(); it++) {
				const CModInfo& Info = *it;
				CString sName = Info.GetName();

				if (sName.Right(3).CaseCmp("".so"") == 0) {
					sName.RightChomp(3);
				}

				if (CUtils::GetBoolInput(""Load global module <\033[1m"" + sName + ""\033[22m>?"", false)) {
					vsLines.push_back(""LoadModule = "" + sName);
				}
			}
		}
	}
#endif

	// User
	CUtils::PrintMessage("""");
	CUtils::PrintMessage(""Now we need to setup a user..."");
	CUtils::PrintMessage("""");

	bool bFirstUser = true;

	do {
		vsLines.push_back("""");
		CString sNick;
		do {
			CUtils::GetInput(""Username"", sUser, """", ""AlphaNumeric"");
		} while (!CUser::IsValidUserName(sUser));

		vsLines.push_back(""<User "" + sUser + "">"");
		CString sSalt;
		sAnswer = CUtils::GetSaltedHashPass(sSalt);
		vsLines.push_back(""\tPass       = md5#"" + sAnswer + ""#"" + sSalt + ""#"");

		if (CUtils::GetBoolInput(""Would you like this user to be an admin?"", bFirstUser)) {
			vsLines.push_back(""\tAdmin      = true"");
		} else {
			vsLines.push_back(""\tAdmin      = false"");
		}

		CUtils::GetInput(""Nick"", sNick, CUser::MakeCleanUserName(sUser));
		vsLines.push_back(""\tNick       = "" + sNick);
		CUtils::GetInput(""Alt Nick"", sAnswer, sNick + ""_"");
		if (!sAnswer.empty()) {
			vsLines.push_back(""\tAltNick    = "" + sAnswer);
		}
		CUtils::GetInput(""Ident"", sAnswer, sNick);
		vsLines.push_back(""\tIdent      = "" + sAnswer);
		CUtils::GetInput(""Real Name"", sAnswer, ""Got ZNC?"");
		vsLines.push_back(""\tRealName   = "" + sAnswer);
		CUtils::GetInput(""VHost"", sAnswer, """", ""optional"");
		if (!sAnswer.empty()) {
			vsLines.push_back(""\tVHost      = "" + sAnswer);
		}
		// todo: Possibly add motd

		unsigned int uBufferCount = 0;

		CUtils::GetNumInput(""Number of lines to buffer per channel"", uBufferCount, 0, ~0, 50);
		if (uBufferCount) {
			vsLines.push_back(""\tBuffer     = "" + CString(uBufferCount));
		}
		if (CUtils::GetBoolInput(""Would you like to keep buffers after replay?"", false)) {
			vsLines.push_back(""\tKeepBuffer = true"");
		} else {
			vsLines.push_back(""\tKeepBuffer = false"");
		}

		CUtils::GetInput(""Default channel modes"", sAnswer, ""+stn"");
		if (!sAnswer.empty()) {
			vsLines.push_back(""\tChanModes  = "" + sAnswer);
		}

#ifdef _MODULES
		set<CModInfo> ssUserMods;
		GetModules().GetAvailableMods(ssUserMods);

		if (ssUserMods.size()) {
			vsLines.push_back("""");
			CUtils::PrintMessage("""");
			CUtils::PrintMessage(""-- User Modules --"");
			CUtils::PrintMessage("""");

			if (CUtils::GetBoolInput(""Do you want to automatically load any user modules for this user?"")) {
				CTable Table;
				Table.AddColumn(""Name"");
				Table.AddColumn(""Description"");
				set<CModInfo>::iterator it;

				for (it = ssUserMods.begin(); it != ssUserMods.end(); it++) {
					const CModInfo& Info = *it;
					Table.AddRow();
					Table.SetCell(""Name"", Info.GetName());
					Table.SetCell(""Description"", Info.GetDescription().Ellipsize(128));
				}

				unsigned int uTableIdx = 0; CString sLine;
				while (Table.GetLine(uTableIdx++, sLine)) {
					CUtils::PrintMessage(sLine);
				}

				CUtils::PrintMessage("""");

				for (it = ssUserMods.begin(); it != ssUserMods.end(); it++) {
					const CModInfo& Info = *it;
					CString sName = Info.GetName();

					if (CUtils::GetBoolInput(""Load "" + CString((Info.IsSystem()) ? ""system"" : ""local"") + "" module <\033[1m"" + sName + ""\033[22m>?"", false)) {
						vsLines.push_back(""\tLoadModule = "" + sName);
					}
				}
			}
		}
#endif

		vsLines.push_back("""");
		CUtils::PrintMessage("""");
		CUtils::PrintMessage(""-- IRC Servers --"");
		CUtils::PrintMessage("""");

		do {
			CString sHost, sPass;
			bool bSSL = false;
			unsigned int uServerPort = 0;

			while (!CUtils::GetInput(""IRC server"", sHost, """", ""host only"") || !CServer::IsValidHostName(sHost)) ;
			while (!CUtils::GetNumInput(""["" + sHost + ""] Port"", uServerPort, 1, 65535, 6667)) ;
			CUtils::GetInput(""["" + sHost + ""] Password (probably empty)"", sPass);

#ifdef HAVE_LIBSSL
			bSSL = CUtils::GetBoolInput(""Does this server use SSL? (probably no)"", false);
#endif

			vsLines.push_back(""\tServer     = "" + sHost + ((bSSL) ? "" +"" : "" "") + CString(uServerPort) + "" "" + sPass);
		} while (CUtils::GetBoolInput(""Would you like to add another server?"", false));

		vsLines.push_back("""");
		CUtils::PrintMessage("""");
		CUtils::PrintMessage(""-- Channels --"");
		CUtils::PrintMessage("""");

		CString sArg = ""a"";
		CString sPost = "" for ZNC to automatically join?"";
		bool bDefault = true;

		while (CUtils::GetBoolInput(""Would you like to add "" + sArg + "" channel"" + sPost, bDefault)) {
			while (!CUtils::GetInput(""Channel name"", sAnswer)) ;
			vsLines.push_back(""\t<Chan "" + sAnswer + "">"");
			vsLines.push_back(""\t</Chan>"");
			sArg = ""another"";
			sPost = ""?"";
			bDefault = false;
		}

		vsLines.push_back(""</User>"");

		CUtils::PrintMessage("""");
		bFirstUser = false;
	} while (CUtils::GetBoolInput(""Would you like to setup another user?"", false));
	// !User

	CUtils::PrintAction(""Writing config ["" + sConfigFile + ""]"");
	CFile File(sConfigFile);

	bool bFileOpen = false;

	if (File.Open(O_WRONLY | O_CREAT | O_TRUNC, 0600)) {
		bFileOpen = true;
	} else {
		CUtils::PrintStatus(false, ""Unable to open file"");
		CUtils::GetInput(""Alternate location"", sConfigFile, ""/tmp/"" + sConfig);

		if (!CFile::Exists(sConfigFile) || CUtils::GetBoolInput(""Would you like to overwrite the existing alt file"", false)) {
			CUtils::PrintAction(""Writing to alt location ["" + sConfigFile + ""]"");
			File.SetFileName(sConfigFile);

			if (File.Open(O_WRONLY | O_CREAT | O_TRUNC, 0600)) {
				bFileOpen = true;
			} else {
				CUtils::PrintStatus(false, ""Unable to open alt file"");
			}
		}
	}

	if (!bFileOpen) {
		CUtils::PrintMessage("""");
		CUtils::PrintMessage(""Printing new config to stdout since we were unable to open a file"");
		CUtils::PrintMessage("""");
		cout << endl << ""----------------------------------------------------------------------------"" << endl << endl;
	}

	for (unsigned int a = 0; a < vsLines.size(); a++) {
		if (bFileOpen) {
			File.Write(vsLines[a] + ""\n"");
		} else {
			cout << vsLines[a] << endl;
		}
	}

	if (bFileOpen) {
		File.Close();

		CUtils::PrintStatus(true);
	} else {
		cout << endl << ""----------------------------------------------------------------------------"" << endl << endl;
	}

	CUtils::PrintMessage("""");
	CUtils::PrintMessage(""To connect to this znc you need to connect to it as your irc server"", true);
	CUtils::PrintMessage(""using the port that you supplied.  You have to supply your login info"", true);
	CUtils::PrintMessage(""as the irc server password like so.. user:pass."", true);
	CUtils::PrintMessage("""");
	CUtils::PrintMessage(""Try something like this in your IRC client..."", true);
	CUtils::PrintMessage(""/server <znc_server_ip> "" + CString(uListenPort) + "" "" + sUser + "":<pass>"", true);
	CUtils::PrintMessage("""");

	m_LockFile.UnLock();
	return CUtils::GetBoolInput(""Launch znc now?"", true);
}

bool CZNC::ParseConfig(const CString& sConfig)
{
	CString s;

	m_sConfigFile = ExpandConfigPath(sConfig);

	return DoRehash(s);
}

bool CZNC::RehashConfig(CString& sError)
{
#ifdef _MODULES
	GetModules().OnPreRehash();
	for (map<CString, CUser*>::iterator itb = m_msUsers.begin();
			itb != m_msUsers.end(); itb++) {
		itb->second->GetModules().OnPreRehash();
	}
#endif

	// This clears m_msDelUsers
	HandleUserDeletion();

	// Mark all users as going-to-be deleted
	m_msDelUsers = m_msUsers;
	m_msUsers.clear();

	if (DoRehash(sError)) {
#ifdef _MODULES
		GetModules().OnPostRehash();
		for (map<CString, CUser*>::iterator it = m_msUsers.begin();
				it != m_msUsers.end(); it++) {
			it->second->GetModules().OnPostRehash();
		}
#endif

		return true;
	}

	// Rehashing failed, try to recover
	CString s;
	while (m_msDelUsers.size()) {
		AddUser(m_msDelUsers.begin()->second, s);
		m_msDelUsers.erase(m_msDelUsers.begin());
	}

	return false;
}

bool CZNC::DoRehash(CString& sError)
{
	sError.clear();

	CUtils::PrintAction(""Opening Config ["" + m_sConfigFile + ""]"");

	if (!CFile::Exists(m_sConfigFile)) {
		sError = ""No such file"";
		CUtils::PrintStatus(false, sError);
		CUtils::PrintMessage(""Restart znc with the --makeconf option if you wish to create this config."");
		return false;
	}

	if (!CFile::IsReg(m_sConfigFile)) {
		sError = ""Not a file"";
		CUtils::PrintStatus(false, sError);
		return false;
	}

	if (!m_LockFile.Open(m_sConfigFile)) {
		sError = ""Can not open config file"";
		CUtils::PrintStatus(false, sError);
		return false;
	}

	if (!m_LockFile.TryExLock()) {
		sError = ""ZNC is already running on this config."";
		CUtils::PrintStatus(false, sError);
		return false;
	}

	CFile File(m_LockFile.GetFD(), m_sConfigFile);

	// This fd is re-used for rehashing, so we must seek back to the beginning!
	if (!File.Seek(0)) {
		sError = ""Could not seek to the beginning of the config."";
		CUtils::PrintStatus(false, sError);
		return false;
	}

	CUtils::PrintStatus(true);

	m_vsVHosts.clear();
	m_vsMotd.clear();

	// Delete all listeners
	while (m_vpListeners.size()) {
		delete m_vpListeners[0];
		m_vpListeners.erase(m_vpListeners.begin());
	}

	CString sLine;
	bool bCommented = false;	// support for /**/ style comments
	CUser* pUser = NULL;	// Used to keep track of which user block we are in
	CUser* pRealUser = NULL;	// If we rehash a user, this is the real one
	CChan* pChan = NULL;	// Used to keep track of which chan block we are in
	unsigned int uLineNum = 0;
#ifdef _MODULES
	MCString msModules;	// Modules are queued for later loading
#endif

	std::list<CGlobalModuleConfigLine> lGlobalModuleConfigLine;

	while (File.ReadLine(sLine)) {
		uLineNum++;

		// Remove all leading / trailing spaces and line endings
		sLine.Trim();

		if ((sLine.empty()) || (sLine[0] == '#') || (sLine.Left(2) == ""//"")) {
			continue;
		}

		if (sLine.Left(2) == ""/*"") {
			if (sLine.Right(2) != ""*/"") {
				bCommented = true;
			}

			continue;
		}

		if (bCommented) {
			if (sLine.Right(2) == ""*/"") {
				bCommented = false;
			}

			continue;
		}

		if ((sLine.Left(1) == ""<"") && (sLine.Right(1) == "">"")) {
			sLine.LeftChomp();
			sLine.RightChomp();
			sLine.Trim();

			CString sTag = sLine.substr(0, sLine.find_first_of("" \t\r\n""));
			CString sValue = (sTag.size() < sLine.size()) ? sLine.substr(sTag.size() +1) : """";

			sTag.Trim();
			sValue.Trim();

			if (sLine.Left(1) == ""/"") {
				sTag = sTag.substr(1);

				if (pUser) {
					if (pChan) {
						if (sTag.CaseCmp(""Chan"") == 0) {
							// Save the channel name, because AddChan
							// deletes the CChannel*, if adding fails
							sError = pChan->GetName();
							if (!pUser->AddChan(pChan)) {
								sError = ""Channel ["" + sError + ""] defined more than once"";
								CUtils::PrintError(sError);
								return false;
							}
							sError.clear();
							pChan = NULL;
							continue;
						}
					} else if (sTag.CaseCmp(""User"") == 0) {
						CString sErr;

						if (pRealUser) {
							if (!pRealUser->Clone(*pUser, sErr)
									|| !AddUser(pRealUser, sErr)) {
								sError = ""Invalid user ["" + pUser->GetUserName() + ""] "" + sErr;
								DEBUG_ONLY(cout << ""CUser::Clone() failed in rehash"" << endl);
							}
							pUser->SetBeingDeleted(true);
							delete pUser;
							pUser = NULL;
						} else if (!AddUser(pUser, sErr)) {
							sError = ""Invalid user ["" + pUser->GetUserName() + ""] "" + sErr;
						}

						if (!sError.empty()) {
							CUtils::PrintError(sError);
							if (pUser) {
								pUser->SetBeingDeleted(true);
								delete pUser;
								pUser = NULL;
							}
							return false;
						}

						pUser = NULL;
						pRealUser = NULL;
						continue;
					}
				}
			} else if (sTag.CaseCmp(""User"") == 0) {
				if (pUser) {
					sError = ""You may not nest <User> tags inside of other <User> tags."";
					CUtils::PrintError(sError);
					return false;
				}

				if (sValue.empty()) {
					sError = ""You must supply a username in the <User> tag."";
					CUtils::PrintError(sError);
					return false;
				}

				if (m_msUsers.find(sValue) != m_msUsers.end()) {
					sError = ""User ["" + sValue + ""] defined more than once."";
					CUtils::PrintError(sError);
					return false;
				}

				CUtils::PrintMessage(""Loading user ["" + sValue + ""]"");

				// Either create a CUser* or use an existing one
				map<CString, CUser*>::iterator it = m_msDelUsers.find(sValue);

				if (it != m_msDelUsers.end()) {
					pRealUser = it->second;
					m_msDelUsers.erase(it);
				} else
					pRealUser = NULL;

				pUser = new CUser(sValue);

				if (!m_sStatusPrefix.empty()) {
					if (!pUser->SetStatusPrefix(m_sStatusPrefix)) {
						sError = ""Invalid StatusPrefix ["" + m_sStatusPrefix + ""] Must be 1-5 chars, no spaces."";
						CUtils::PrintError(sError);
						return false;
					}
				}

				continue;
			} else if (sTag.CaseCmp(""Chan"") == 0) {
				if (!pUser) {
					sError = ""<Chan> tags must be nested inside of a <User> tag."";
					CUtils::PrintError(sError);
					return false;
				}

				if (pChan) {
					sError = ""You may not nest <Chan> tags inside of other <Chan> tags."";
					CUtils::PrintError(sError);
					return false;
				}

				pChan = new CChan(sValue, pUser, true);
				continue;
			}
		}

		// If we have a regular line, figure out where it goes
		CString sName = sLine.Token(0, false, ""="");
		CString sValue = sLine.Token(1, true, ""="");
		sName.Trim();
		sValue.Trim();

		if ((!sName.empty()) && (!sValue.empty())) {
			if (pUser) {
				if (pChan) {
					if (sName.CaseCmp(""Buffer"") == 0) {
						pChan->SetBufferCount(strtoul(sValue.c_str(), NULL, 10));
						continue;
					} else if (sName.CaseCmp(""KeepBuffer"") == 0) {
						pChan->SetKeepBuffer((sValue.CaseCmp(""true"") == 0));
						continue;
					} else if (sName.CaseCmp(""Detached"") == 0) {
						pChan->SetDetached((sValue.CaseCmp(""true"") == 0));
						continue;
					} else if (sName.CaseCmp(""AutoCycle"") == 0) {
						pChan->SetAutoCycle((sValue.CaseCmp(""true"") == 0));
						continue;
					} else if (sName.CaseCmp(""Key"") == 0) {
						pChan->SetKey(sValue);
						continue;
					} else if (sName.CaseCmp(""Modes"") == 0) {
						pChan->SetDefaultModes(sValue);
						continue;
					}
				} else {
					if (sName.CaseCmp(""Buffer"") == 0) {
						pUser->SetBufferCount(strtoul(sValue.c_str(), NULL, 10));
						continue;
					} else if (sName.CaseCmp(""KeepBuffer"") == 0) {
						pUser->SetKeepBuffer((sValue.CaseCmp(""true"") == 0));
						continue;
					} else if (sName.CaseCmp(""AutoCycle"") == 0) {
						pUser->SetAutoCycle((sValue.CaseCmp(""true"") == 0));
						continue;
					} else if (sName.CaseCmp(""Nick"") == 0) {
						pUser->SetNick(sValue);
						continue;
					} else if (sName.CaseCmp(""CTCPReply"") == 0) {
						pUser->AddCTCPReply(sValue.Token(0), sValue.Token(1, true));
						continue;
					} else if (sName.CaseCmp(""QuitMsg"") == 0) {
						pUser->SetQuitMsg(sValue);
						continue;
					} else if (sName.CaseCmp(""AltNick"") == 0) {
						pUser->SetAltNick(sValue);
						continue;
					} else if (sName.CaseCmp(""AwaySuffix"") == 0) {
						CUtils::PrintMessage(""WARNING: AwaySuffix has been depricated, instead try -> LoadModule = awaynick %nick%_"" + sValue);
						continue;
					} else if (sName.CaseCmp(""Pass"") == 0) {
						// There are different formats for this available:
						// Pass = <plain text>
						// Pass = <md5 hash> -
						// Pass = plain#<plain text>
						// Pass = md5#<md5 hash>
						// Pass = md5#<salted md5 hash>#<salt>#
						// The last one is the md5 hash of 'password' + 'salt'
						if (sValue.Right(1) == ""-"") {
							sValue.RightChomp();
							sValue.Trim();
							pUser->SetPass(sValue, true);
						} else {
							CString sMethod = sValue.Token(0, false, ""#"");
							CString sPass = sValue.Token(1, true, ""#"");
							if (sMethod == ""md5"") {
								CString sSalt = sPass.Token(1, false, ""#"");
								sPass = sPass.Token(0, false, ""#"");
								pUser->SetPass(sPass, true, sSalt);
							} else if (sMethod == ""plain"") {
								pUser->SetPass(sPass, false);
							} else {
								pUser->SetPass(sValue, false);
							}
						}

						continue;
					} else if (sName.CaseCmp(""MultiClients"") == 0) {
						pUser->SetMultiClients(sValue.CaseCmp(""true"") == 0);
						continue;
					} else if (sName.CaseCmp(""BounceDCCs"") == 0) {
						pUser->SetBounceDCCs(sValue.CaseCmp(""true"") == 0);
						continue;
					} else if (sName.CaseCmp(""Ident"") == 0) {
						pUser->SetIdent(sValue);
						continue;
					} else if (sName.CaseCmp(""DenyLoadMod"") == 0) {
						pUser->SetDenyLoadMod((sValue.CaseCmp(""TRUE"") == 0));
						continue;
					} else if (sName.CaseCmp(""Admin"") == 0) {
						pUser->SetAdmin((sValue.CaseCmp(""TRUE"") == 0));
						continue;
					} else if (sName.CaseCmp(""DenySetVHost"") == 0) {
						pUser->SetDenySetVHost((sValue.CaseCmp(""TRUE"") == 0));
						continue;
					} else if (sName.CaseCmp(""StatusPrefix"") == 0) {
						if (!pUser->SetStatusPrefix(sValue)) {
							sError = ""Invalid StatusPrefix ["" + sValue + ""] Must be 1-5 chars, no spaces."";
							CUtils::PrintError(sError);
							return false;
						}
						continue;
					} else if (sName.CaseCmp(""DCCLookupMethod"") == 0) {
						pUser->SetUseClientIP((sValue.CaseCmp(""Client"") == 0));
						continue;
					} else if (sName.CaseCmp(""RealName"") == 0) {
						pUser->SetRealName(sValue);
						continue;
					} else if (sName.CaseCmp(""KeepNick"") == 0) {
						if (sValue.CaseCmp(""true"") == 0) {
							CUtils::PrintError(""WARNING: KeepNick has been deprecated, instead try -> LoadModule = keepnick"");
						}
						continue;
					} else if (sName.CaseCmp(""ChanModes"") == 0) {
						pUser->SetDefaultChanModes(sValue);
						continue;
					} else if (sName.CaseCmp(""VHost"") == 0) {
						pUser->SetVHost(sValue);
						continue;
					} else if (sName.CaseCmp(""Allow"") == 0) {
						pUser->AddAllowedHost(sValue);
						continue;
					} else if (sName.CaseCmp(""Server"") == 0) {
						CUtils::PrintAction(""Adding Server ["" + sValue + ""]"");
						CUtils::PrintStatus(pUser->AddServer(sValue));
						continue;
					} else if (sName.CaseCmp(""Chan"") == 0) {
						pUser->AddChan(sValue, true);
						continue;
					} else if (sName.CaseCmp(""TimestampFormat"") == 0) {
						pUser->SetTimestampFormat(sValue);
						continue;
					} else if (sName.CaseCmp(""AppendTimestamp"") == 0) {
						pUser->SetTimestampAppend(sValue.ToBool());
						continue;
					} else if (sName.CaseCmp(""PrependTimestamp"") == 0) {
						pUser->SetTimestampPrepend(sValue.ToBool());
						continue;
					} else if (sName.CaseCmp(""Timestamp"") == 0) {
						if (sValue.Trim_n().CaseCmp(""true"") != 0) {
							if (sValue.Trim_n().CaseCmp(""append"") == 0) {
								pUser->SetTimestampAppend(true);
								pUser->SetTimestampPrepend(false);
							} else if (sValue.Trim_n().CaseCmp(""prepend"") == 0) {
								pUser->SetTimestampAppend(false);
								pUser->SetTimestampPrepend(true);
							} else if (sValue.Trim_n().CaseCmp(""false"") == 0) {
								pUser->SetTimestampAppend(false);
								pUser->SetTimestampPrepend(false);
							} else {
								pUser->SetTimestampFormat(sValue);
							}
						}
						continue;
					} else if (sName.CaseCmp(""TimezoneOffset"") == 0) {
						pUser->SetTimezoneOffset(sValue.ToDouble()); // there is no ToFloat()
						continue;
					} else if (sName.CaseCmp(""JoinTries"") == 0) {
						pUser->SetJoinTries(sValue.ToUInt());
						continue;
					} else if (sName.CaseCmp(""LoadModule"") == 0) {
						CString sModName = sValue.Token(0);
						CUtils::PrintAction(""Loading Module ["" + sModName + ""]"");
#ifdef _MODULES
						CString sModRet;
						CString sArgs = sValue.Token(1, true);

						bool bModRet = pUser->GetModules().LoadModule(sModName, sArgs, pUser, sModRet);

						// If the module was loaded, sModRet contains
						// ""Loaded Module [name] ..."" and we strip away this beginning.
						if (bModRet)
							sModRet = sModRet.Token(1, true, sModName + ""] "");

						CUtils::PrintStatus(bModRet, sModRet);
						if (!bModRet) {
							sError = sModRet;
							return false;
						}
#else
						sError = ""Modules are not enabled."";
						CUtils::PrintStatus(false, sError);
#endif
						continue;
					}
				}
			} else {
				if (sName.CaseCmp(""Listen"") == 0 || sName.CaseCmp(""ListenPort"") == 0 || sName.CaseCmp(""Listen6"") == 0) {
					bool bSSL = false;
					bool bIPV6 = (sName.CaseCmp(""Listen6"") == 0);
					CString sPort;

					CString sBindHost;

					if (!bIPV6) {
						sValue.Replace("":"", "" "");
					}

					if (sValue.find("" "") != CString::npos) {
						sBindHost = sValue.Token(0, false, "" "");
						sPort = sValue.Token(1, true, "" "");
					} else {
						sPort = sValue;
					}

					if (sPort.Left(1) == ""+"") {
						sPort.LeftChomp();
						bSSL = true;
					}

					CString sHostComment;

					if (!sBindHost.empty()) {
						sHostComment = "" on host ["" + sBindHost + ""]"";
					}

					CString sIPV6Comment;

					if (bIPV6) {
						sIPV6Comment = "" using ipv6"";
					}

					unsigned short uPort = strtol(sPort.c_str(), NULL, 10);
					CUtils::PrintAction(""Binding to port ["" + CString((bSSL) ? ""+"" : """") + CString(uPort) + ""]"" + sHostComment + sIPV6Comment);

#ifndef HAVE_IPV6
					if (bIPV6) {
						sError = ""IPV6 is not enabled"";
						CUtils::PrintStatus(false, sError);
						return false;
					}
#endif

#ifndef HAVE_LIBSSL
					if (bSSL) {
						sError = ""SSL is not enabled"";
						CUtils::PrintStatus(false, sError);
						return false;
					}
#else
					CString sPemFile = GetPemLocation();

					if (bSSL && !CFile::Exists(sPemFile)) {
						sError = ""Unable to locate pem file: ["" + sPemFile + ""]"";
						CUtils::PrintStatus(false, sError);

						// If stdin is e.g. /dev/null and we call GetBoolInput(),
						// we are stuck in an endless loop!
						if (isatty(0) && CUtils::GetBoolInput(""Would you like to create a new pem file?"", true)) {
							sError.clear();
							WritePemFile();
						} else {
							return false;
						}

						CUtils::PrintAction(""Binding to port [+"" + CString(uPort) + ""]"" + sHostComment + sIPV6Comment);
					}
#endif
					if (!uPort) {
						sError = ""Invalid port"";
						CUtils::PrintStatus(false, sError);
						return false;
					}

					CListener* pListener = new CListener(uPort, sBindHost, bSSL, bIPV6);

					if (!pListener->Listen()) {
						sError = ""Unable to bind"";
						CUtils::PrintStatus(false, sError);
						delete pListener;
						return false;
					}

					m_vpListeners.push_back(pListener);
					CUtils::PrintStatus(true);

					continue;
				} else if (sName.CaseCmp(""LoadModule"") == 0) {
#ifdef _MODULES
					CString sModName = sValue.Token(0);
					CString sArgs = sValue.Token(1, true);

					if (msModules.find(sModName) != msModules.end()) {
						sError = ""Module ["" + sModName +
							""] already loaded"";
						CUtils::PrintError(sError);
						return false;
					}
					msModules[sModName] = sArgs;
#else
					CUtils::PrintError(""Modules are not enabled."");
#endif
					continue;
				} else if (sName.CaseCmp(""ISpoofFormat"") == 0) {
					m_sISpoofFormat = sValue;
					continue;
				} else if (sName.CaseCmp(""ISpoofFile"") == 0) {
					if (sValue.Left(2) == ""~/"") {
						sValue.LeftChomp(2);
						sValue = GetHomePath() + ""/"" + sValue;
					}
					m_sISpoofFile = sValue;
					continue;
				} else if (sName.CaseCmp(""MOTD"") == 0) {
					AddMotd(sValue);
					continue;
				} else if (sName.CaseCmp(""VHost"") == 0) {
					AddVHost(sValue);
					continue;
				} else if (sName.CaseCmp(""PidFile"") == 0) {
					m_sPidFile = sValue;
					continue;
				} else if (sName.CaseCmp(""StatusPrefix"") == 0) {
					m_sStatusPrefix = sValue;
					continue;
				} else if (sName.CaseCmp(""ConnectDelay"") == 0) {
					m_uiConnectDelay = sValue.ToUInt();
					continue;
				}
			}

		}

		if (sName.CaseCmp(""GM:"", 3) == 0)
		{ // GM: prefix is a pass through to config lines for global modules
			CGlobalModuleConfigLine cTmp;
			cTmp.m_sName = sName.substr(3, CString::npos);
			cTmp.m_sValue = sValue;
			cTmp.m_pChan = pChan;
			cTmp.m_pUser = pUser;
			lGlobalModuleConfigLine.push_back(cTmp);
		}
		else
		{
			sError = ""Unhandled line "" + CString(uLineNum) + "" in config: ["" + sLine + ""]"";
			CUtils::PrintError(sError);
			return false;
		}
	}

#ifdef _MODULES
	// First step: Load and reload new modules or modules with new arguments
	for (MCString::iterator it = msModules.begin(); it != msModules.end(); it++) {
		CString sModName = it->first;
		CString sArgs = it->second;
		CString sModRet;
		CModule *pOldMod;

		pOldMod = GetModules().FindModule(sModName);
		if (!pOldMod) {
			CUtils::PrintAction(""Loading Global Module ["" + sModName + ""]"");

			bool bModRet = GetModules().LoadModule(sModName, sArgs, NULL, sModRet);

			// If the module was loaded, sModRet contains
			// ""Loaded Module [name] ..."" and we strip away this beginning.
			if (bModRet)
				sModRet = sModRet.Token(1, true, sModName + ""] "");

			CUtils::PrintStatus(bModRet, sModRet);
			if (!bModRet) {
				sError = sModRet;
				return false;
			}
		} else if (pOldMod->GetArgs() != sArgs) {
			CUtils::PrintAction(""Reloading Global Module ["" + sModName + ""]"");

			bool bModRet = GetModules().ReloadModule(sModName, sArgs, NULL, sModRet);

			// If the module was loaded, sModRet contains
			// ""Loaded Module [name] ..."" and we strip away this beginning.
			if (bModRet)
				sModRet = sModRet.Token(1, true, sModName + ""] "");

			CUtils::PrintStatus(bModRet, sModRet);
			if (!bModRet) {
				sError = sModRet;
				return false;
			}
		} else
			CUtils::PrintMessage(""Module ["" + sModName + ""] already loaded."");
	}

	// Second step: Unload modules which are no longer in the config
	set<CString> ssUnload;
	for (size_t i = 0; i < GetModules().size(); i++) {
		CModule *pCurMod = GetModules()[i];

		if (msModules.find(pCurMod->GetModName()) == msModules.end())
			ssUnload.insert(pCurMod->GetModName());
	}

	for (set<CString>::iterator it = ssUnload.begin(); it != ssUnload.end(); it++) {
		if (GetModules().UnloadModule(*it))
			CUtils::PrintMessage(""Unloaded Global Module ["" + *it + ""]"");
		else
			CUtils::PrintMessage(""Could not unload ["" + *it + ""]"");
	}

	// last step, throw unhandled config items at global config
	for (std::list<CGlobalModuleConfigLine>::iterator it = lGlobalModuleConfigLine.begin(); it != lGlobalModuleConfigLine.end(); it++)
	{
		if ((pChan && pChan == it->m_pChan) || (pUser && pUser == it->m_pUser))
			continue; // skip unclosed user or chan
		if (!GetModules().OnConfigLine(it->m_sName, it->m_sValue, it->m_pUser, it->m_pChan))
		{
			CUtils::PrintMessage(""unhandled global module config line [GM:"" + it->m_sName + ""] = ["" + it->m_sValue + ""]"");
		}
	}
#endif

	if (pChan) {
		// TODO last <Chan> not closed
		delete pChan;
	}

	if (pUser) {
		// TODO last <User> not closed
		delete pUser;
	}

	File.Close();

	if (m_msUsers.size() == 0) {
		sError = ""You must define at least one user in your config."";
		CUtils::PrintError(sError);
		return false;
	}

	if (m_vpListeners.size() == 0) {
		sError = ""You must supply at least one Listen port in your config."";
		CUtils::PrintError(sError);
		return false;
	}

	// Make sure that users that want to connect do so
	EnableConnectUser();

	return true;
}

void CZNC::ClearVHosts() {
	m_vsVHosts.clear();
}

bool CZNC::AddVHost(const CString& sHost) {
	if (sHost.empty()) {
		return false;
	}

	for (unsigned int a = 0; a < m_vsVHosts.size(); a++) {
		if (m_vsVHosts[a].CaseCmp(sHost) == 0) {
			return false;
		}
	}

	m_vsVHosts.push_back(sHost);
	return true;
}

bool CZNC::RemVHost(const CString& sHost) {
	// @todo
	return true;
}

void CZNC::Broadcast(const CString& sMessage, bool bAdminOnly,
		CUser* pSkipUser, CClient *pSkipClient) {
	for (map<CString,CUser*>::iterator a = m_msUsers.begin(); a != m_msUsers.end(); a++) {
		if (bAdminOnly && !a->second->IsAdmin())
			continue;

		if (a->second != pSkipUser) {
			CString sMsg = sMessage;

			MODULECALL(OnBroadcast(sMsg), a->second, NULL, continue);
			a->second->PutStatusNotice(""*** "" + sMsg, NULL, pSkipClient);
		}
	}
}

bool CZNC::FindModPath(const CString& sModule, CString& sModPath,
		CString& sDataPath) const {
	CString sMod = sModule;
	CString sDir = sMod;
	if (sModule.find(""."") == CString::npos)
		sMod += "".so"";

	sDataPath = GetCurPath() + ""/modules/"";
	sModPath = sDataPath + sMod;

	if (!CFile::Exists(sModPath)) {
		sDataPath = GetModPath() + ""/"";
		sModPath = sDataPath + sMod;

		if (!CFile::Exists(sModPath)) {
			sDataPath = _DATADIR_ + CString(""/"");
			sModPath = _MODDIR_ + CString(""/"") + sMod;

			if (!CFile::Exists(sModPath)) {
				return false;
			}
		}
	}

	sDataPath += sDir;

	return true;
}

CUser* CZNC::FindUser(const CString& sUsername) {
	map<CString,CUser*>::iterator it = m_msUsers.find(sUsername);

	if (it != m_msUsers.end()) {
		return it->second;
	}

	return NULL;
}

bool CZNC::DeleteUser(const CString& sUsername) {
	CUser* pUser = FindUser(sUsername);

	if (!pUser) {
		return false;
	}

	m_msDelUsers[pUser->GetUserName()] = pUser;
	return true;
}

bool CZNC::AddUser(CUser* pUser, CString& sErrorRet) {
	if (pUser->IsValid(sErrorRet)) {
		m_msUsers[pUser->GetUserName()] = pUser;
		return true;
	}

	DEBUG_ONLY(cout << ""Invalid user ["" << pUser->GetUserName() << ""] - ["" << sErrorRet << ""]"" << endl);
	return false;
}

CZNC& CZNC::Get() {
	static CZNC* pZNC = new CZNC;
	return *pZNC;
}

void CZNC::UpdateTrafficStats() {
	CSockManager* p = &m_Manager;
	for (unsigned int a = 0; a < p->size(); a++) {
		if ((*p)[a]->GetSockName().Left(5) == ""IRC::"") {
			CIRCSock *i = (CIRCSock *)(*p)[a];
			i->GetUser()->AddBytesRead((*p)[a]->GetBytesRead());
			(*p)[a]->ResetBytesRead();
			i->GetUser()->AddBytesWritten((*p)[a]->GetBytesWritten());
			(*p)[a]->ResetBytesWritten();
		} else if ((*p)[a]->GetSockName().Left(5) == ""USR::"") {
			CClient *c = (CClient *)(*p)[a];
			c->GetUser()->AddBytesRead((*p)[a]->GetBytesRead());
			(*p)[a]->ResetBytesRead();
			c->GetUser()->AddBytesWritten((*p)[a]->GetBytesWritten());
			(*p)[a]->ResetBytesWritten();
		}
	}
}

void CZNC::AuthUser(CSmartPtr<CAuthBase> AuthClass) {
#ifdef _MODULES
	// TODO unless the auth module calls it, CUser::IsHostAllowed() is not honoured
	if (GetModules().OnLoginAttempt(AuthClass)) {
		return;
	}
#endif

	CUser* pUser = GetUser(AuthClass->GetUsername());

	if (!pUser || !pUser->CheckPass(AuthClass->GetPassword())) {
		if (pUser) {
			pUser->PutStatus(""Another client attempted to login as you, with a bad password."");
		}

		AuthClass->RefuseLogin(""Invalid Password"");
		return;
	}

	CString sHost = AuthClass->GetRemoteIP();

	if (!pUser->IsHostAllowed(sHost)) {
		AuthClass->RefuseLogin(""Your host ["" + sHost + ""] is not allowed"");
		return;
	}

	AuthClass->AcceptLogin(*pUser);
}

class CConnectUserTimer : public CCron {
public:
	CConnectUserTimer(int iSecs) : CCron() {
		SetName(""Connect users"");
		Start(iSecs);
		m_uiPosNextUser = 0;
		// Don't wait iSecs seconds for first timer run
		m_bRunOnNextCall = true;
	}
	virtual ~CConnectUserTimer() {}

protected:
	virtual void RunJob() {
		unsigned int uiUserCount;
		bool bUsersLeft = false;
		const map<CString,CUser*>& mUsers = CZNC::Get().GetUserMap();
		map<CString,CUser*>::const_iterator it = mUsers.begin();

		uiUserCount = CZNC::Get().GetUserMap().size();

		if (m_uiPosNextUser >= uiUserCount) {
			m_uiPosNextUser = 0;
		}

		for (unsigned int i = 0; i < m_uiPosNextUser; i++) {
			it++;
		}

		// Try to connect each user, if this doesnt work, abort
		for (unsigned int i = 0; i < uiUserCount; i++) {
			if (it == mUsers.end())
				it = mUsers.begin();

			CUser* pUser = it->second;
			it++;
			m_uiPosNextUser = (m_uiPosNextUser + 1) % uiUserCount;

			// Is this user disconnected and does he want to connect?
			if (pUser->GetIRCSock() == NULL && pUser->GetIRCConnectEnabled()) {
				// The timer runs until it once didn't find any users to connect
				bUsersLeft = true;

				DEBUG_ONLY(cout << ""Connecting user ["" << pUser->GetUserName()
						<< ""]"" << endl);

				if (CZNC::Get().ConnectUser(pUser))
					// User connecting, wait until next time timer fires
					return;
			}
		}

		if (bUsersLeft == false) {
			DEBUG_ONLY(cout << ""ConnectUserTimer done"" << endl);
			CZNC::Get().DisableConnectUser();
		}
	}

private:
	size_t	m_uiPosNextUser;
};

void CZNC::EnableConnectUser() {
	if (m_pConnectUserTimer != NULL)
		return;

	m_pConnectUserTimer = new CConnectUserTimer(m_uiConnectDelay);
	GetManager().AddCron(m_pConnectUserTimer);
}

void CZNC::DisableConnectUser() {
	if (m_pConnectUserTimer == NULL)
		return;

	// This will kill the cron
	m_pConnectUserTimer->Stop();
	m_pConnectUserTimer = NULL;
}
""",CConnectUserTimer::CConnectUserTimer,[1712:1718]
znc,https://github.com/znc/znc/commit/0e403e318e791ddb91d81cff25095e4c97c9236e,"""Small optimization to starting the connect user timer

Now the connect user timer is only started when the user which was disconnected
from IRC wants to reconnect, not always.


git-svn-id: https://znc.svn.sourceforge.net/svnroot/znc/trunk@1213 726aef4b-f618-498e-8847-2d620e286838""","""/*
 * Copyright (C) 2004-2008  See the AUTHORS file for details.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 as published
 * by the Free Software Foundation.
 */

#include ""User.h""
#include ""Chan.h""
#include ""DCCSock.h""
#include ""IRCSock.h""
#include ""Server.h""
#include ""Timers.h""
#include ""znc.h""

CUser::CUser(const CString& sUserName) {
	m_pIRCSock = NULL;
	m_fTimezoneOffset = 0;
	m_uConnectTime = 0;
	SetUserName(sUserName);
	m_sNick = m_sCleanUserName;
	m_sIdent = m_sCleanUserName;
	m_sRealName = sUserName;
	m_uServerIdx = 0;
	m_uBytesRead = 0;
	m_uBytesWritten = 0;
#ifdef _MODULES
	m_pModules = new CModules;
#endif
	m_RawBuffer.SetLineCount(100);		// This should be more than enough raws, especially since we are buffering the MOTD separately
	m_MotdBuffer.SetLineCount(200);		// This should be more than enough motd lines
	m_bMultiClients = true;
	m_bBounceDCCs = true;
	m_bPassHashed = false;
	m_bUseClientIP = false;
	m_bDenyLoadMod = false;
	m_bAdmin= false;
	m_bDenySetVHost= false;
	m_sStatusPrefix = ""*"";
	m_sChanPrefixes = """";
	m_uBufferCount = 50;
	m_uMaxJoinTries = 0;
	m_uMaxJoins = 5;
	m_bKeepBuffer = false;
	m_bBeingDeleted = false;
	m_sTimestampFormat = ""[%H:%M:%S]"";
	m_bAppendTimestamp = false;
	m_bPrependTimestamp = true;
	m_bIRCConnectEnabled = true;
	m_pJoinTimer = new CJoinTimer(this);
	m_pMiscTimer = new CMiscTimer(this);
	CZNC::Get().GetManager().AddCron(m_pJoinTimer);
	CZNC::Get().GetManager().AddCron(m_pMiscTimer);
	m_sUserPath = CZNC::Get().GetUserPath() + ""/"" + sUserName;
	m_sDLPath = GetUserPath() + ""/downloads"";
}

CUser::~CUser() {
	DelClients();

#ifdef _MODULES
	DelModules();
#endif

	DelServers();

	for (unsigned int b = 0; b < m_vChans.size(); b++) {
		delete m_vChans[b];
	}

	CZNC::Get().GetManager().DelCronByAddr(m_pJoinTimer);
	CZNC::Get().GetManager().DelCronByAddr(m_pMiscTimer);
}

#ifdef _MODULES
void CUser::DelModules() {
	if (m_pModules) {
		delete m_pModules;
		m_pModules = NULL;
	}
}
#endif

void CUser::DelClients() {
	for (unsigned int c = 0; c < m_vClients.size(); c++) {
		CClient* pClient = m_vClients[c];
		CZNC::Get().GetManager().DelSockByAddr(pClient);
	}

	m_vClients.clear();
}

void CUser::DelServers()
{
	for (unsigned int a = 0; a < m_vServers.size(); a++) {
		delete m_vServers[a];
	}

	m_vServers.clear();
}

void CUser::IRCConnected(CIRCSock* pIRCSock) {
	m_pIRCSock = pIRCSock;

	for (unsigned int a = 0; a < m_vClients.size(); a++) {
		m_vClients[a]->IRCConnected(pIRCSock);
	}
}

void CUser::IRCDisconnected() {
	m_pIRCSock = NULL;

	for (unsigned int a = 0; a < m_vClients.size(); a++) {
		m_vClients[a]->IRCDisconnected();
	}

	SetIRCServer("""");

	// Get the reconnect going
	CZNC::Get().EnableConnectUser();
}

CString CUser::ExpandString(const CString& sStr) const {
	CString sRet;
	return ExpandString(sStr, sRet);
}

CString& CUser::ExpandString(const CString& sStr, CString& sRet) const {
	// offset is in hours, so * 60 * 60 gets us seconds
	time_t iUserTime = time(NULL) + (time_t)(m_fTimezoneOffset * 60 * 60);
	char *szTime = ctime(&iUserTime);
	CString sTime;

	if (szTime) {
		sTime = szTime;
		// ctime() adds a trailing newline
		sTime.Trim();
	}

	sRet = sStr;
	sRet.Replace(""%user%"", GetUserName());
	sRet.Replace(""%defnick%"", GetNick());
	sRet.Replace(""%nick%"", GetCurNick());
	sRet.Replace(""%altnick%"", GetAltNick());
	sRet.Replace(""%ident%"", GetIdent());
	sRet.Replace(""%realname%"", GetRealName());
	sRet.Replace(""%vhost%"", GetVHost());
	sRet.Replace(""%version%"", CZNC::GetVersion());
	sRet.Replace(""%time%"", sTime);
	sRet.Replace(""%uptime%"", CZNC::Get().GetUptime());
	// The following lines do not exist. You must be on DrUgS!
	sRet.Replace(""%znc%"", ""All your IRC are belong to ZNC"");
	// Chosen by fair zocchihedron dice roll by SilverLeo
	sRet.Replace(""%rand%"", ""42"");

	return sRet;
}

CString CUser::AddTimestamp(const CString& sStr) const {
	CString sRet;
	return AddTimestamp(sStr, sRet);
}

CString& CUser::AddTimestamp(const CString& sStr, CString& sRet) const {
	char szTimestamp[1024];
	time_t tm;

	if (GetTimestampFormat().empty() || (!m_bAppendTimestamp && !m_bPrependTimestamp)) {
		sRet = sStr;
	} else {
		time(&tm);
		tm += (time_t)(m_fTimezoneOffset * 60 * 60); // offset is in hours
		strftime(szTimestamp, sizeof(szTimestamp) / sizeof(char), GetTimestampFormat().c_str(), localtime(&tm));

		sRet = sStr;
		if (m_bPrependTimestamp) {
			sRet = szTimestamp;
			sRet += "" "" + sStr;
		}
		if (m_bAppendTimestamp) {
			sRet += "" "";
			sRet += szTimestamp;
		}
	}
	return sRet;
}

void CUser::BounceAllClients() {
	for (unsigned int a = 0; a < m_vClients.size(); a++) {
		m_vClients[a]->BouncedOff();
	}

	m_vClients.clear();
}

void CUser::UserConnected(CClient* pClient) {
	if (!MultiClients()) {
		BounceAllClients();
	}

	PutStatus(""Another client authenticated as your user, use the 'ListClients' command to see all clients"");
	m_vClients.push_back(pClient);

	if (m_RawBuffer.IsEmpty()) {
		pClient->PutClient("":irc.znc.in 001 "" + pClient->GetNick() + "" :- Welcome to ZNC -"");
	} else {
		unsigned int uIdx = 0;
		CString sLine;

		while (m_RawBuffer.GetLine(GetIRCNick().GetNick(), sLine, uIdx++)) {
			pClient->PutClient(sLine);
		}
	}

	// Send the cached MOTD
	if (m_MotdBuffer.IsEmpty()) {
		PutIRC(""MOTD"");
	} else {
		unsigned int uIdx = 0;
		CString sLine;

		while (m_MotdBuffer.GetLine(GetIRCNick().GetNick(), sLine, uIdx++)) {
			pClient->PutClient(sLine);
		}
	}

	if (GetIRCSock() != NULL) {
		CString sUserMode("""");
		const set<unsigned char>& scUserModes = GetIRCSock()->GetUserModes();
		for (set<unsigned char>::iterator it = scUserModes.begin();
				it != scUserModes.end(); it++) {
			sUserMode += *it;
		}
		if (!sUserMode.empty()) {
			pClient->PutClient("":"" + GetIRCNick().GetNick() + "" MODE "" + GetIRCNick().GetNick() + "" :+"" + sUserMode);
		}
	}

	const vector<CChan*>& vChans = GetChans();
	for (unsigned int a = 0; a < vChans.size(); a++) {
		if ((vChans[a]->IsOn()) && (!vChans[a]->IsDetached())) {
			vChans[a]->JoinUser(true, """", pClient);
		}
	}

	CString sBufLine;
	while (m_QueryBuffer.GetNextLine(GetIRCNick().GetNick(), sBufLine)) {
		pClient->PutClient(sBufLine);
	}

	// Tell them why they won't connect
	if (!GetIRCConnectEnabled())
		pClient->PutStatus(""You are currently disconnected from IRC. ""
				""Use 'connect' to reconnect."");
}

void CUser::UserDisconnected(CClient* pClient) {
	for (unsigned int a = 0; a < m_vClients.size(); a++) {
		if (m_vClients[a] == pClient) {
			m_vClients.erase(m_vClients.begin() + a);
			break;
		}
	}
}

bool CUser::Clone(const CUser& User, CString& sErrorRet, bool bCloneChans) {
	unsigned int a = 0;
	sErrorRet.clear();

	if (!User.IsValid(sErrorRet, true)) {
		return false;
	}

	if (GetUserName() != User.GetUserName()) {
		if (CZNC::Get().FindUser(User.GetUserName())) {
			sErrorRet = ""New username already exists"";
			return false;
		}

		SetUserName(User.GetUserName());
	}

	if (!User.GetPass().empty()) {
		SetPass(User.GetPass(), User.IsPassHashed(), User.GetPassSalt());
	}

	SetNick(User.GetNick(false));
	SetAltNick(User.GetAltNick(false));
	SetIdent(User.GetIdent(false));
	SetRealName(User.GetRealName());
	SetStatusPrefix(User.GetStatusPrefix());
	SetVHost(User.GetVHost());
	SetQuitMsg(User.GetQuitMsg());
	SetDefaultChanModes(User.GetDefaultChanModes());
	SetBufferCount(User.GetBufferCount());
	SetJoinTries(User.JoinTries());
	SetMaxJoins(User.MaxJoins());

	// Allowed Hosts
	m_ssAllowedHosts.clear();
	const set<CString>& ssHosts = User.GetAllowedHosts();
	for (set<CString>::const_iterator it = ssHosts.begin(); it != ssHosts.end(); it++) {
		AddAllowedHost(*it);
	}

	for (a = 0; a < m_vClients.size(); a++) {
		CClient* pSock = m_vClients[a];

		if (!IsHostAllowed(pSock->GetRemoteIP())) {
			pSock->PutStatusNotice(""You are being disconnected because your IP is no longer allowed to connect to this user"");
			pSock->Close();
		}
	}

	// !Allowed Hosts

#ifdef _MODULES
	// Modules
	set<CString> ssUnloadMods;
	CModules& vCurMods = GetModules();
	const CModules& vNewMods = User.GetModules();

	for (a = 0; a < vNewMods.size(); a++) {
		CString sModRet;
		CModule* pNewMod = vNewMods[a];
		CModule* pCurMod = vCurMods.FindModule(pNewMod->GetModName());

		if (!pCurMod) {
			vCurMods.LoadModule(pNewMod->GetModName(), pNewMod->GetArgs(), this, sModRet);
		} else if (pNewMod->GetArgs() != pCurMod->GetArgs()) {
			vCurMods.ReloadModule(pNewMod->GetModName(), pNewMod->GetArgs(), this, sModRet);
		}
	}

	for (a = 0; a < vCurMods.size(); a++) {
		CModule* pCurMod = vCurMods[a];
		CModule* pNewMod = vNewMods.FindModule(pCurMod->GetModName());

		if (!pNewMod) {
			ssUnloadMods.insert(pCurMod->GetModName());
		}
	}

	for (set<CString>::iterator it = ssUnloadMods.begin(); it != ssUnloadMods.end(); it++) {
		vCurMods.UnloadModule(*it);
	}
	// !Modules
#endif // !_MODULES

	// Servers
	const vector<CServer*>& vServers = User.GetServers();
	CString sServer;
	CServer* pCurServ = GetCurrentServer();

	if (pCurServ) {
		sServer = pCurServ->GetName();
	}

	DelServers();

	for (a = 0; a < vServers.size(); a++) {
		CServer* pServer = vServers[a];
		AddServer(pServer->GetName(), pServer->GetPort(), pServer->GetPass(), pServer->IsSSL());
	}

	for (a = 0; a < m_vServers.size(); a++) {
		if (sServer.CaseCmp(m_vServers[a]->GetName()) == 0) {
			m_uServerIdx = a +1;
			break;
		}

		if (a == m_vServers.size() -1) {
			m_uServerIdx = m_vServers.size();
			CIRCSock* pSock = GetIRCSock();

			if (pSock) {
				PutStatus(""Jumping servers because this server is no longer in the list"");
				pSock->Quit();
			}
		}
	}
	// !Servers

	// Chans
	const vector<CChan*>& vChans = User.GetChans();
	for (a = 0; a < vChans.size(); a++) {
		CChan* pNewChan = vChans[a];
		CChan* pChan = FindChan(pNewChan->GetName());

		if (pChan) {
			pChan->SetInConfig(pNewChan->InConfig());
		} else {
			AddChan(pNewChan->GetName(), pNewChan->InConfig());
		}
	}

	for (a = 0; a < m_vChans.size(); a++) {
		CChan* pChan = m_vChans[a];
		CChan* pNewChan = User.FindChan(pChan->GetName());

		if (!pNewChan) {
			pChan->SetInConfig(false);
		} else {
			if (bCloneChans)
				pChan->Clone(*pNewChan);
		}
	}
	// !Chans

	// CTCP Replies
	m_mssCTCPReplies.clear();
	const MCString& msReplies = User.GetCTCPReplies();
	for (MCString::const_iterator it = msReplies.begin(); it != msReplies.end(); it++) {
		AddCTCPReply(it->first, it->second);
	}
	// !CTCP Replies

	// Flags
	SetKeepBuffer(User.KeepBuffer());
	SetMultiClients(User.MultiClients());
	SetBounceDCCs(User.BounceDCCs());
	SetUseClientIP(User.UseClientIP());
	SetDenyLoadMod(User.DenyLoadMod());
	SetAdmin(User.IsAdmin());
	SetDenySetVHost(User.DenySetVHost());
	SetTimestampAppend(User.GetTimestampAppend());
	SetTimestampPrepend(User.GetTimestampPrepend());
	SetTimestampFormat(User.GetTimestampFormat());
	SetTimezoneOffset(User.GetTimezoneOffset());
	// !Flags

	return true;
}

const set<CString>& CUser::GetAllowedHosts() const { return m_ssAllowedHosts; }
bool CUser::AddAllowedHost(const CString& sHostMask) {
	if (sHostMask.empty() || m_ssAllowedHosts.find(sHostMask) != m_ssAllowedHosts.end()) {
		return false;
	}

	m_ssAllowedHosts.insert(sHostMask);
	return true;
}

bool CUser::IsHostAllowed(const CString& sHostMask) const {
	if (m_ssAllowedHosts.empty()) {
		return true;
	}

	for (set<CString>::iterator a = m_ssAllowedHosts.begin(); a != m_ssAllowedHosts.end(); a++) {
		if (sHostMask.WildCmp(*a)) {
			return true;
		}
	}

	return false;
}

const CString& CUser::GetTimestampFormat() const { return m_sTimestampFormat; }
bool CUser::GetTimestampAppend() const { return m_bAppendTimestamp; }
bool CUser::GetTimestampPrepend() const { return m_bPrependTimestamp; }

bool CUser::IsValidUserName(const CString& sUserName) {
	const char* p = sUserName.c_str();

	if (sUserName.empty()) {
		return false;
	}

	if ((*p < 'a' || *p > 'z') && (*p < 'A' || *p > 'Z')) {
		return false;
	}

	while (*p) {
		if (*p != '@' && *p != '.' && *p != '-' && *p != '_' && !isalnum(*p)) {
			return false;
		}

		*p++;
	}

	return true;
}

bool CUser::IsValid(CString& sErrMsg, bool bSkipPass) const {
	sErrMsg.clear();

	if (!bSkipPass && m_sPass.empty()) {
		sErrMsg = ""Pass is empty"";
		return false;
	}

	if (m_sUserName.empty()) {
		sErrMsg = ""Username is empty"";
		return false;
	}

	if (!CUser::IsValidUserName(m_sUserName)) {
		sErrMsg = ""Username is invalid"";
		return false;
	}

	return true;
}

bool CUser::AddChan(CChan* pChan) {
	if (!pChan) {
		return false;
	}

	for (unsigned int a = 0; a < m_vChans.size(); a++) {
		if (m_vChans[a]->GetName().CaseCmp(pChan->GetName()) == 0) {
			delete pChan;
			return false;
		}
	}

	m_vChans.push_back(pChan);
	return true;
}

bool CUser::AddChan(const CString& sName, bool bInConfig) {
	if (sName.empty() || FindChan(sName)) {
		return false;
	}

	CChan* pChan = new CChan(sName, this, bInConfig);
	m_vChans.push_back(pChan);
	return true;
}

bool CUser::DelChan(const CString& sName) {
	for (vector<CChan*>::iterator a = m_vChans.begin(); a != m_vChans.end(); a++) {
		if (sName.CaseCmp((*a)->GetName()) == 0) {
			delete *a;
			m_vChans.erase(a);
			return true;
		}
	}

	return false;
}

bool CUser::PrintLine(CFile& File, const CString& sName, const CString& sValue) {
	if (sName.empty() || sValue.empty()) {
		return false;
	}

	return File.Write(""\t"" + sName + "" = "" + sValue + ""\n"");
}

bool CUser::WriteConfig(CFile& File) {
	File.Write(""<User "" + GetUserName() + "">\n"");

	if (IsPassHashed()) {
		if (m_sPassSalt.empty()) {
			PrintLine(File, ""Pass"", ""md5#"" + GetPass());
		} else {
			PrintLine(File, ""Pass"", ""md5#"" + GetPass() + ""#"" + m_sPassSalt + ""#"");
		}
	} else {
		PrintLine(File, ""Pass"", ""plain#"" + GetPass());
	}
	PrintLine(File, ""Nick"", GetNick());
	PrintLine(File, ""AltNick"", GetAltNick());
	PrintLine(File, ""Ident"", GetIdent());
	PrintLine(File, ""RealName"", GetRealName());
	PrintLine(File, ""VHost"", GetVHost());
	PrintLine(File, ""QuitMsg"", GetQuitMsg());
	if (CZNC::Get().GetStatusPrefix() != GetStatusPrefix())
		PrintLine(File, ""StatusPrefix"", GetStatusPrefix());
	PrintLine(File, ""ChanModes"", GetDefaultChanModes());
	PrintLine(File, ""Buffer"", CString(GetBufferCount()));
	PrintLine(File, ""KeepBuffer"", CString((KeepBuffer()) ? ""true"" : ""false""));
	PrintLine(File, ""MultiClients"", CString((MultiClients()) ? ""true"" : ""false""));
	PrintLine(File, ""BounceDCCs"", CString((BounceDCCs()) ? ""true"" : ""false""));
	PrintLine(File, ""DenyLoadMod"", CString((DenyLoadMod()) ? ""true"" : ""false""));
	PrintLine(File, ""Admin"", CString((IsAdmin()) ? ""true"" : ""false""));
	PrintLine(File, ""DenySetVHost"", CString((DenySetVHost()) ? ""true"" : ""false""));
	PrintLine(File, ""DCCLookupMethod"", CString((UseClientIP()) ? ""client"" : ""default""));
	PrintLine(File, ""TimestampFormat"", GetTimestampFormat());
	PrintLine(File, ""AppendTimestamp"", CString((GetTimestampAppend()) ? ""true"" : ""false""));
	PrintLine(File, ""PrependTimestamp"", CString((GetTimestampPrepend()) ? ""true"" : ""false""));
	PrintLine(File, ""TimezoneOffset"", CString(m_fTimezoneOffset));
	PrintLine(File, ""JoinTries"", CString(m_uMaxJoinTries));
	PrintLine(File, ""MaxJoins"", CString(m_uMaxJoins));
	File.Write(""\n"");

	// Allow Hosts
	if (!m_ssAllowedHosts.empty()) {
		for (set<CString>::iterator it = m_ssAllowedHosts.begin(); it != m_ssAllowedHosts.end(); it++) {
			PrintLine(File, ""Allow"", *it);
		}

		File.Write(""\n"");
	}

	// CTCP Replies
	if (!m_mssCTCPReplies.empty()) {
		for (MCString::iterator itb = m_mssCTCPReplies.begin(); itb != m_mssCTCPReplies.end(); itb++) {
			PrintLine(File, ""CTCPReply"", itb->first.AsUpper() + "" "" + itb->second);
		}

		File.Write(""\n"");
	}

#ifdef _MODULES
	// Modules
	CModules& Mods = GetModules();

	if (!Mods.empty()) {
		for (unsigned int a = 0; a < Mods.size(); a++) {
			CString sArgs = Mods[a]->GetArgs();

			if (!sArgs.empty()) {
				sArgs = "" "" + sArgs;
			}

			PrintLine(File, ""LoadModule"", Mods[a]->GetModName() + sArgs);
		}

		File.Write(""\n"");
	}
#endif

	// Servers
	for (unsigned int b = 0; b < m_vServers.size(); b++) {
		PrintLine(File, ""Server"", m_vServers[b]->GetString());
	}

	// Chans
	for (unsigned int c = 0; c < m_vChans.size(); c++) {
		CChan* pChan = m_vChans[c];
		if (pChan->InConfig()) {
			File.Write(""\n"");
			if (!pChan->WriteConfig(File)) {
				return false;
			}
		}
	}

	File.Write(""</User>\n"");

	return true;
}

CChan* CUser::FindChan(const CString& sName) const {
	for (unsigned int a = 0; a < m_vChans.size(); a++) {
		CChan* pChan = m_vChans[a];
		if (sName.CaseCmp(pChan->GetName()) == 0) {
			return pChan;
		}
	}

	return NULL;
}

void CUser::JoinChans() {
	unsigned int uJoins = m_uMaxJoins;
	for (unsigned int a = 0; a < m_vChans.size(); a++) {
		CChan* pChan = m_vChans[a];
		if (!pChan->IsOn() && !pChan->IsDisabled()) {
			if (JoinTries() != 0 && pChan->GetJoinTries() >= JoinTries()) {
				PutStatus(""The channel "" + pChan->GetName() + "" could not be joined, disabling it."");
				pChan->Disable();
			} else {
				pChan->IncJoinTries();
				PutIRC(""JOIN "" + pChan->GetName() + "" "" + pChan->GetKey());

				// Limit the number of joins
				if (uJoins != 0 && --uJoins == 0)
					return;
			}
		}
	}
}

CServer* CUser::FindServer(const CString& sName) const {
	for (unsigned int a = 0; a < m_vServers.size(); a++) {
		CServer* pServer = m_vServers[a];
		if (sName.CaseCmp(pServer->GetName()) == 0) {
			return pServer;
		}
	}

	return NULL;
}

bool CUser::DelServer(const CString& sName) {
	if (sName.empty()) {
		return false;
	}

	unsigned int a = 0;

	for (vector<CServer*>::iterator it = m_vServers.begin(); it != m_vServers.end(); it++, a++) {
		CServer* pServer = *it;

		if (pServer->GetName().CaseCmp(sName) == 0) {
			CServer* pCurServer = GetCurrentServer();
			m_vServers.erase(it);

			if (pServer == pCurServer) {
				CIRCSock* pIRCSock = GetIRCSock();

				if (m_uServerIdx) {
					m_uServerIdx--;
				}

				if (pIRCSock) {
					pIRCSock->Quit();
					PutStatus(""Your current server was removed, jumping..."");
				}
			} else if (m_uServerIdx >= m_vServers.size()) {
				m_uServerIdx = 0;
			}

			delete pServer;

			return true;
		}
	}

	return false;
}

bool CUser::AddServer(const CString& sName, bool bIPV6) {
	if (sName.empty()) {
		return false;
	}

	bool bSSL = false;
	CString sLine = sName;
	sLine.Trim();

	CString sHost = sLine.Token(0);
	CString sPort = sLine.Token(1);

	if (sPort.Left(1) == ""+"") {
		bSSL = true;
		sPort.LeftChomp();
	}

	unsigned short uPort = strtoul(sPort.c_str(), NULL, 10);
	CString sPass = sLine.Token(2, true);

	return AddServer(sHost, uPort, sPass, bSSL, bIPV6);
}

bool CUser::AddServer(const CString& sName, unsigned short uPort, const CString& sPass, bool bSSL, bool bIPV6) {
#ifndef HAVE_LIBSSL
	if (bSSL) {
		return false;
	}
#endif

#ifndef HAVE_IPV6
	if (bIPV6) {
		return false;
	}
#endif

	if (sName.empty()) {
		return false;
	}

	if (!uPort) {
		uPort = 6667;
	}

	CServer* pServer = new CServer(sName, uPort, sPass, bSSL, bIPV6);
	m_vServers.push_back(pServer);

	CheckIRCConnect();

	return true;
}

bool CUser::IsLastServer() const {
	return (m_uServerIdx >= m_vServers.size());
}

CServer* CUser::GetNextServer() {
	if (m_vServers.empty()) {
		return NULL;
	}

	if (m_uServerIdx >= m_vServers.size()) {
		m_uServerIdx = 0;
	}

	return m_vServers[m_uServerIdx++];	// Todo: cycle through these
}

CServer* CUser::GetCurrentServer() const {
	unsigned int uIdx = (m_uServerIdx) ? m_uServerIdx -1 : 0;

	if (uIdx >= m_vServers.size()) {
		return NULL;
	}

	return m_vServers[uIdx];
}

bool CUser::CheckPass(const CString& sPass) const {
	if (!m_bPassHashed) {
		return (sPass == m_sPass);
	}

	CString sSaltedPass = sPass + m_sPassSalt;

	return (m_sPass.CaseCmp(sSaltedPass.MD5()) == 0);
}

/*CClient* CUser::GetClient() {
	// Todo: optimize this by saving a pointer to the sock
	CSockManager& Manager = CZNC::Get().GetManager();
	CString sSockName = ""USR::"" + m_sUserName;

	for (unsigned int a = 0; a < Manager.size(); a++) {
		Csock* pSock = Manager[a];
		if (pSock->GetSockName().CaseCmp(sSockName) == 0) {
			if (!pSock->IsClosed()) {
				return (CClient*) pSock;
			}
		}
	}

	return (CClient*) CZNC::Get().GetManager().FindSockByName(sSockName);
}*/

CString CUser::GetLocalIP() {
	CIRCSock* pIRCSock = GetIRCSock();

	if (pIRCSock) {
		return pIRCSock->GetLocalIP();
	}

	if (m_vClients.size()) {
		return m_vClients[0]->GetLocalIP();
	}

	return """";
}

bool CUser::PutIRC(const CString& sLine) {
	CIRCSock* pIRCSock = GetIRCSock();

	if (!pIRCSock) {
		return false;
	}

	pIRCSock->PutIRC(sLine);
	return true;
}

bool CUser::PutUser(const CString& sLine, CClient* pClient, CClient* pSkipClient) {
	for (unsigned int a = 0; a < m_vClients.size(); a++) {
		if ((!pClient || pClient == m_vClients[a]) && pSkipClient != m_vClients[a]) {
			m_vClients[a]->PutClient(sLine);

			if (pClient) {
				return true;
			}
		}
	}

	return (pClient == NULL);
}

bool CUser::PutStatus(const CString& sLine, CClient* pClient, CClient* pSkipClient) {
	for (unsigned int a = 0; a < m_vClients.size(); a++) {
		if ((!pClient || pClient == m_vClients[a]) && pSkipClient != m_vClients[a]) {
			m_vClients[a]->PutStatus(sLine);

			if (pClient) {
				return true;
			}
		}
	}

	return (pClient == NULL);
}

bool CUser::PutStatusNotice(const CString& sLine, CClient* pClient, CClient* pSkipClient) {
	for (unsigned int a = 0; a < m_vClients.size(); a++) {
		if ((!pClient || pClient == m_vClients[a]) && pSkipClient != m_vClients[a]) {
			m_vClients[a]->PutStatusNotice(sLine);

			if (pClient) {
				return true;
			}
		}
	}

	return (pClient == NULL);
}

bool CUser::PutModule(const CString& sModule, const CString& sLine, CClient* pClient, CClient* pSkipClient) {
	for (unsigned int a = 0; a < m_vClients.size(); a++) {
		if ((!pClient || pClient == m_vClients[a]) && pSkipClient != m_vClients[a]) {
			m_vClients[a]->PutModule(sModule, sLine);

			if (pClient) {
				return true;
			}
		}
	}

	return (pClient == NULL);
}

bool CUser::ResumeFile(unsigned short uPort, unsigned long uFileSize) {
	CSockManager& Manager = CZNC::Get().GetManager();

	for (unsigned int a = 0; a < Manager.size(); a++) {
		if (strncasecmp(Manager[a]->GetSockName().c_str(), ""DCC::LISTEN::"", 13) == 0) {
			CDCCSock* pSock = (CDCCSock*) Manager[a];

			if (pSock->GetLocalPort() == uPort) {
				if (pSock->Seek(uFileSize)) {
					PutModule(pSock->GetModuleName(), ""DCC -> ["" + pSock->GetRemoteNick() + ""]["" + pSock->GetFileName() + ""] - Attempting to resume from file position ["" + CString(uFileSize) + ""]"");
					return true;
				} else {
					return false;
				}
			}
		}
	}

	return false;
}

bool CUser::SendFile(const CString& sRemoteNick, const CString& sFileName, const CString& sModuleName) {
	CString sFullPath = CDir::ChangeDir(GetDLPath(), sFileName, CZNC::Get().GetHomePath());
	CDCCSock* pSock = new CDCCSock(this, sRemoteNick, sFullPath, sModuleName);

	CFile* pFile = pSock->OpenFile(false);

	if (!pFile) {
		delete pSock;
		return false;
	}

	unsigned short uPort = CZNC::Get().GetManager().ListenRand(""DCC::LISTEN::"" + sRemoteNick, GetLocalIP(), false, SOMAXCONN, pSock, 120);

	if (GetNick().CaseCmp(sRemoteNick) == 0) {
		PutUser("":"" + GetStatusPrefix() + ""status!znc@znc.in PRIVMSG "" + sRemoteNick + "" :\001DCC SEND "" + pFile->GetShortName() + "" "" + CString(CUtils::GetLongIP(GetLocalIP())) + "" ""
				+ CString(uPort) + "" "" + CString(pFile->GetSize()) + ""\001"");
	} else {
		PutIRC(""PRIVMSG "" + sRemoteNick + "" :\001DCC SEND "" + pFile->GetShortName() + "" "" + CString(CUtils::GetLongIP(GetLocalIP())) + "" ""
			    + CString(uPort) + "" "" + CString(pFile->GetSize()) + ""\001"");
	}

	PutModule(sModuleName, ""DCC -> ["" + sRemoteNick + ""]["" + pFile->GetShortName() + ""] - Attempting Send."");
	return true;
}

bool CUser::GetFile(const CString& sRemoteNick, const CString& sRemoteIP, unsigned short uRemotePort, const CString& sFileName, unsigned long uFileSize, const CString& sModuleName) {
	if (CFile::Exists(sFileName)) {
		PutModule(sModuleName, ""DCC <- ["" + sRemoteNick + ""]["" + sFileName + ""] - File already exists."");
		return false;
	}

	CDCCSock* pSock = new CDCCSock(this, sRemoteNick, sRemoteIP, uRemotePort, sFileName, uFileSize, sModuleName);

	if (!pSock->OpenFile()) {
		delete pSock;
		return false;
	}

	if (!CZNC::Get().GetManager().Connect(sRemoteIP, uRemotePort, ""DCC::GET::"" + sRemoteNick, 60, false, GetLocalIP(), pSock)) {
		PutModule(sModuleName, ""DCC <- ["" + sRemoteNick + ""]["" + sFileName + ""] - Unable to connect."");
		return false;
	}

	PutModule(sModuleName, ""DCC <- ["" + sRemoteNick + ""]["" + sFileName + ""] - Attempting to connect to ["" + sRemoteIP + ""]"");
	return true;
}

CString CUser::GetCurNick() const {
	const CIRCSock* pIRCSock = GetIRCSock();

	if (pIRCSock) {
		return pIRCSock->GetNick();
	}

	if (m_vClients.size()) {
		return m_vClients[0]->GetNick();
	}

	return """";
}

CString CUser::MakeCleanUserName(const CString& sUserName) {
	return sUserName.Token(0, false, ""@"").Replace_n(""."", """");
}

// Setters
void CUser::SetUserName(const CString& s) {
	m_sCleanUserName = CUser::MakeCleanUserName(s);
	m_sUserName = s;
}

bool CUser::IsChan(const CString& sChan) const {
	if (sChan.empty())
		return false; // There is no way this is a chan
	if (GetChanPrefixes().empty())
		return true; // We can't know, so we allow everything
	// Thanks to the above if (empty), we can do sChan[0]
	return GetChanPrefixes().find(sChan[0]) != CString::npos;
}

void CUser::SetNick(const CString& s) { m_sNick = s; }
void CUser::SetAltNick(const CString& s) { m_sAltNick = s; }
void CUser::SetIdent(const CString& s) { m_sIdent = s; }
void CUser::SetRealName(const CString& s) { m_sRealName = s; }
void CUser::SetVHost(const CString& s) { m_sVHost = s; }
void CUser::SetPass(const CString& s, bool bHashed, const CString& sSalt) {
	m_sPass = s;
	m_bPassHashed = bHashed;
	m_sPassSalt = sSalt;
}
void CUser::SetMultiClients(bool b) { m_bMultiClients = b; }
void CUser::SetBounceDCCs(bool b) { m_bBounceDCCs = b; }
void CUser::SetUseClientIP(bool b) { m_bUseClientIP = b; }
void CUser::SetDenyLoadMod(bool b) { m_bDenyLoadMod = b; }
void CUser::SetAdmin(bool b) { m_bAdmin = b; }
void CUser::SetDenySetVHost(bool b) { m_bDenySetVHost = b; }
void CUser::SetDefaultChanModes(const CString& s) { m_sDefaultChanModes = s; }
void CUser::SetIRCServer(const CString& s) { m_sIRCServer = s; }
void CUser::SetQuitMsg(const CString& s) { m_sQuitMsg = s; }
void CUser::SetBufferCount(unsigned int u) { m_uBufferCount = u; }
void CUser::SetKeepBuffer(bool b) { m_bKeepBuffer = b; }

void CUser::CheckIRCConnect()
{
	// Do we want to connect?
	if (m_bIRCConnectEnabled && GetIRCSock() == NULL)
		CZNC::Get().EnableConnectUser();
}

void CUser::SetIRCNick(const CNick& n) {
	m_IRCNick = n;

	for (unsigned int a = 0; a < m_vClients.size(); a++) {
		m_vClients[a]->SetNick(n.GetNick());
	}
}

bool CUser::AddCTCPReply(const CString& sCTCP, const CString& sReply) {
	if (sCTCP.empty()) {
		return false;
	}

	m_mssCTCPReplies[sCTCP.AsUpper()] = sReply;
	return true;
}

bool CUser::SetStatusPrefix(const CString& s) {
	if ((!s.empty()) && (s.length() < 6) && (s.find(' ') == CString::npos)) {
		m_sStatusPrefix = (s.empty()) ? ""*"" : s;
		return true;
	}

	return false;
}
// !Setters

// Getters
const CString& CUser::GetUserName() const { return m_sUserName; }
const CString& CUser::GetCleanUserName() const { return m_sCleanUserName; }
const CString& CUser::GetNick(bool bAllowDefault) const { return (bAllowDefault && m_sNick.empty()) ? GetCleanUserName() : m_sNick; }
const CString& CUser::GetAltNick(bool bAllowDefault) const { return (bAllowDefault && m_sAltNick.empty()) ? GetCleanUserName() : m_sAltNick; }
const CString& CUser::GetIdent(bool bAllowDefault) const { return (bAllowDefault && m_sIdent.empty()) ? GetCleanUserName() : m_sIdent; }
const CString& CUser::GetRealName() const { return m_sRealName.empty() ? m_sUserName : m_sRealName; }
const CString& CUser::GetVHost() const { return m_sVHost; }
const CString& CUser::GetPass() const { return m_sPass; }
bool CUser::IsPassHashed() const { return m_bPassHashed; }
const CString& CUser::GetPassSalt() const { return m_sPassSalt; }

bool CUser::ConnectPaused() {
	if (!m_uConnectTime) {
		m_uConnectTime = time(NULL);
		return false;
	}

	if (time(NULL) - m_uConnectTime >= 5) {
		m_uConnectTime = time(NULL);
		return false;
	}

	return true;
}

bool CUser::UseClientIP() const { return m_bUseClientIP; }
bool CUser::DenyLoadMod() const { return m_bDenyLoadMod; }
bool CUser::IsAdmin() const { return m_bAdmin; }
bool CUser::DenySetVHost() const { return m_bDenySetVHost; }
bool CUser::MultiClients() const { return m_bMultiClients; }
bool CUser::BounceDCCs() const { return m_bBounceDCCs; }
const CString& CUser::GetStatusPrefix() const { return m_sStatusPrefix; }
const CString& CUser::GetDefaultChanModes() const { return m_sDefaultChanModes; }
const vector<CChan*>& CUser::GetChans() const { return m_vChans; }
const vector<CServer*>& CUser::GetServers() const { return m_vServers; }
const CNick& CUser::GetIRCNick() const { return m_IRCNick; }
const CString& CUser::GetIRCServer() const { return m_sIRCServer; }
CString CUser::GetQuitMsg() const { return (!m_sQuitMsg.empty()) ? m_sQuitMsg : CZNC::GetTag(false); }
const MCString& CUser::GetCTCPReplies() const { return m_mssCTCPReplies; }
unsigned int CUser::GetBufferCount() const { return m_uBufferCount; }
bool CUser::KeepBuffer() const { return m_bKeepBuffer; }
// !Getters
""","""/*
 * Copyright (C) 2004-2008  See the AUTHORS file for details.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 as published
 * by the Free Software Foundation.
 */

#include ""User.h""
#include ""Chan.h""
#include ""DCCSock.h""
#include ""IRCSock.h""
#include ""Server.h""
#include ""Timers.h""
#include ""znc.h""

CUser::CUser(const CString& sUserName) {
	m_pIRCSock = NULL;
	m_fTimezoneOffset = 0;
	m_uConnectTime = 0;
	SetUserName(sUserName);
	m_sNick = m_sCleanUserName;
	m_sIdent = m_sCleanUserName;
	m_sRealName = sUserName;
	m_uServerIdx = 0;
	m_uBytesRead = 0;
	m_uBytesWritten = 0;
#ifdef _MODULES
	m_pModules = new CModules;
#endif
	m_RawBuffer.SetLineCount(100);		// This should be more than enough raws, especially since we are buffering the MOTD separately
	m_MotdBuffer.SetLineCount(200);		// This should be more than enough motd lines
	m_bMultiClients = true;
	m_bBounceDCCs = true;
	m_bPassHashed = false;
	m_bUseClientIP = false;
	m_bDenyLoadMod = false;
	m_bAdmin= false;
	m_bDenySetVHost= false;
	m_sStatusPrefix = ""*"";
	m_sChanPrefixes = """";
	m_uBufferCount = 50;
	m_uMaxJoinTries = 0;
	m_uMaxJoins = 5;
	m_bKeepBuffer = false;
	m_bBeingDeleted = false;
	m_sTimestampFormat = ""[%H:%M:%S]"";
	m_bAppendTimestamp = false;
	m_bPrependTimestamp = true;
	m_bIRCConnectEnabled = true;
	m_pJoinTimer = new CJoinTimer(this);
	m_pMiscTimer = new CMiscTimer(this);
	CZNC::Get().GetManager().AddCron(m_pJoinTimer);
	CZNC::Get().GetManager().AddCron(m_pMiscTimer);
	m_sUserPath = CZNC::Get().GetUserPath() + ""/"" + sUserName;
	m_sDLPath = GetUserPath() + ""/downloads"";
}

CUser::~CUser() {
	DelClients();

#ifdef _MODULES
	DelModules();
#endif

	DelServers();

	for (unsigned int b = 0; b < m_vChans.size(); b++) {
		delete m_vChans[b];
	}

	CZNC::Get().GetManager().DelCronByAddr(m_pJoinTimer);
	CZNC::Get().GetManager().DelCronByAddr(m_pMiscTimer);
}

#ifdef _MODULES
void CUser::DelModules() {
	if (m_pModules) {
		delete m_pModules;
		m_pModules = NULL;
	}
}
#endif

void CUser::DelClients() {
	for (unsigned int c = 0; c < m_vClients.size(); c++) {
		CClient* pClient = m_vClients[c];
		CZNC::Get().GetManager().DelSockByAddr(pClient);
	}

	m_vClients.clear();
}

void CUser::DelServers()
{
	for (unsigned int a = 0; a < m_vServers.size(); a++) {
		delete m_vServers[a];
	}

	m_vServers.clear();
}

void CUser::IRCConnected(CIRCSock* pIRCSock) {
	m_pIRCSock = pIRCSock;

	for (unsigned int a = 0; a < m_vClients.size(); a++) {
		m_vClients[a]->IRCConnected(pIRCSock);
	}
}

void CUser::IRCDisconnected() {
	m_pIRCSock = NULL;

	for (unsigned int a = 0; a < m_vClients.size(); a++) {
		m_vClients[a]->IRCDisconnected();
	}

	SetIRCServer("""");

	// Get the reconnect going
	CheckIRCConnect();
}

CString CUser::ExpandString(const CString& sStr) const {
	CString sRet;
	return ExpandString(sStr, sRet);
}

CString& CUser::ExpandString(const CString& sStr, CString& sRet) const {
	// offset is in hours, so * 60 * 60 gets us seconds
	time_t iUserTime = time(NULL) + (time_t)(m_fTimezoneOffset * 60 * 60);
	char *szTime = ctime(&iUserTime);
	CString sTime;

	if (szTime) {
		sTime = szTime;
		// ctime() adds a trailing newline
		sTime.Trim();
	}

	sRet = sStr;
	sRet.Replace(""%user%"", GetUserName());
	sRet.Replace(""%defnick%"", GetNick());
	sRet.Replace(""%nick%"", GetCurNick());
	sRet.Replace(""%altnick%"", GetAltNick());
	sRet.Replace(""%ident%"", GetIdent());
	sRet.Replace(""%realname%"", GetRealName());
	sRet.Replace(""%vhost%"", GetVHost());
	sRet.Replace(""%version%"", CZNC::GetVersion());
	sRet.Replace(""%time%"", sTime);
	sRet.Replace(""%uptime%"", CZNC::Get().GetUptime());
	// The following lines do not exist. You must be on DrUgS!
	sRet.Replace(""%znc%"", ""All your IRC are belong to ZNC"");
	// Chosen by fair zocchihedron dice roll by SilverLeo
	sRet.Replace(""%rand%"", ""42"");

	return sRet;
}

CString CUser::AddTimestamp(const CString& sStr) const {
	CString sRet;
	return AddTimestamp(sStr, sRet);
}

CString& CUser::AddTimestamp(const CString& sStr, CString& sRet) const {
	char szTimestamp[1024];
	time_t tm;

	if (GetTimestampFormat().empty() || (!m_bAppendTimestamp && !m_bPrependTimestamp)) {
		sRet = sStr;
	} else {
		time(&tm);
		tm += (time_t)(m_fTimezoneOffset * 60 * 60); // offset is in hours
		strftime(szTimestamp, sizeof(szTimestamp) / sizeof(char), GetTimestampFormat().c_str(), localtime(&tm));

		sRet = sStr;
		if (m_bPrependTimestamp) {
			sRet = szTimestamp;
			sRet += "" "" + sStr;
		}
		if (m_bAppendTimestamp) {
			sRet += "" "";
			sRet += szTimestamp;
		}
	}
	return sRet;
}

void CUser::BounceAllClients() {
	for (unsigned int a = 0; a < m_vClients.size(); a++) {
		m_vClients[a]->BouncedOff();
	}

	m_vClients.clear();
}

void CUser::UserConnected(CClient* pClient) {
	if (!MultiClients()) {
		BounceAllClients();
	}

	PutStatus(""Another client authenticated as your user, use the 'ListClients' command to see all clients"");
	m_vClients.push_back(pClient);

	if (m_RawBuffer.IsEmpty()) {
		pClient->PutClient("":irc.znc.in 001 "" + pClient->GetNick() + "" :- Welcome to ZNC -"");
	} else {
		unsigned int uIdx = 0;
		CString sLine;

		while (m_RawBuffer.GetLine(GetIRCNick().GetNick(), sLine, uIdx++)) {
			pClient->PutClient(sLine);
		}
	}

	// Send the cached MOTD
	if (m_MotdBuffer.IsEmpty()) {
		PutIRC(""MOTD"");
	} else {
		unsigned int uIdx = 0;
		CString sLine;

		while (m_MotdBuffer.GetLine(GetIRCNick().GetNick(), sLine, uIdx++)) {
			pClient->PutClient(sLine);
		}
	}

	if (GetIRCSock() != NULL) {
		CString sUserMode("""");
		const set<unsigned char>& scUserModes = GetIRCSock()->GetUserModes();
		for (set<unsigned char>::iterator it = scUserModes.begin();
				it != scUserModes.end(); it++) {
			sUserMode += *it;
		}
		if (!sUserMode.empty()) {
			pClient->PutClient("":"" + GetIRCNick().GetNick() + "" MODE "" + GetIRCNick().GetNick() + "" :+"" + sUserMode);
		}
	}

	const vector<CChan*>& vChans = GetChans();
	for (unsigned int a = 0; a < vChans.size(); a++) {
		if ((vChans[a]->IsOn()) && (!vChans[a]->IsDetached())) {
			vChans[a]->JoinUser(true, """", pClient);
		}
	}

	CString sBufLine;
	while (m_QueryBuffer.GetNextLine(GetIRCNick().GetNick(), sBufLine)) {
		pClient->PutClient(sBufLine);
	}

	// Tell them why they won't connect
	if (!GetIRCConnectEnabled())
		pClient->PutStatus(""You are currently disconnected from IRC. ""
				""Use 'connect' to reconnect."");
}

void CUser::UserDisconnected(CClient* pClient) {
	for (unsigned int a = 0; a < m_vClients.size(); a++) {
		if (m_vClients[a] == pClient) {
			m_vClients.erase(m_vClients.begin() + a);
			break;
		}
	}
}

bool CUser::Clone(const CUser& User, CString& sErrorRet, bool bCloneChans) {
	unsigned int a = 0;
	sErrorRet.clear();

	if (!User.IsValid(sErrorRet, true)) {
		return false;
	}

	if (GetUserName() != User.GetUserName()) {
		if (CZNC::Get().FindUser(User.GetUserName())) {
			sErrorRet = ""New username already exists"";
			return false;
		}

		SetUserName(User.GetUserName());
	}

	if (!User.GetPass().empty()) {
		SetPass(User.GetPass(), User.IsPassHashed(), User.GetPassSalt());
	}

	SetNick(User.GetNick(false));
	SetAltNick(User.GetAltNick(false));
	SetIdent(User.GetIdent(false));
	SetRealName(User.GetRealName());
	SetStatusPrefix(User.GetStatusPrefix());
	SetVHost(User.GetVHost());
	SetQuitMsg(User.GetQuitMsg());
	SetDefaultChanModes(User.GetDefaultChanModes());
	SetBufferCount(User.GetBufferCount());
	SetJoinTries(User.JoinTries());
	SetMaxJoins(User.MaxJoins());

	// Allowed Hosts
	m_ssAllowedHosts.clear();
	const set<CString>& ssHosts = User.GetAllowedHosts();
	for (set<CString>::const_iterator it = ssHosts.begin(); it != ssHosts.end(); it++) {
		AddAllowedHost(*it);
	}

	for (a = 0; a < m_vClients.size(); a++) {
		CClient* pSock = m_vClients[a];

		if (!IsHostAllowed(pSock->GetRemoteIP())) {
			pSock->PutStatusNotice(""You are being disconnected because your IP is no longer allowed to connect to this user"");
			pSock->Close();
		}
	}

	// !Allowed Hosts

#ifdef _MODULES
	// Modules
	set<CString> ssUnloadMods;
	CModules& vCurMods = GetModules();
	const CModules& vNewMods = User.GetModules();

	for (a = 0; a < vNewMods.size(); a++) {
		CString sModRet;
		CModule* pNewMod = vNewMods[a];
		CModule* pCurMod = vCurMods.FindModule(pNewMod->GetModName());

		if (!pCurMod) {
			vCurMods.LoadModule(pNewMod->GetModName(), pNewMod->GetArgs(), this, sModRet);
		} else if (pNewMod->GetArgs() != pCurMod->GetArgs()) {
			vCurMods.ReloadModule(pNewMod->GetModName(), pNewMod->GetArgs(), this, sModRet);
		}
	}

	for (a = 0; a < vCurMods.size(); a++) {
		CModule* pCurMod = vCurMods[a];
		CModule* pNewMod = vNewMods.FindModule(pCurMod->GetModName());

		if (!pNewMod) {
			ssUnloadMods.insert(pCurMod->GetModName());
		}
	}

	for (set<CString>::iterator it = ssUnloadMods.begin(); it != ssUnloadMods.end(); it++) {
		vCurMods.UnloadModule(*it);
	}
	// !Modules
#endif // !_MODULES

	// Servers
	const vector<CServer*>& vServers = User.GetServers();
	CString sServer;
	CServer* pCurServ = GetCurrentServer();

	if (pCurServ) {
		sServer = pCurServ->GetName();
	}

	DelServers();

	for (a = 0; a < vServers.size(); a++) {
		CServer* pServer = vServers[a];
		AddServer(pServer->GetName(), pServer->GetPort(), pServer->GetPass(), pServer->IsSSL());
	}

	for (a = 0; a < m_vServers.size(); a++) {
		if (sServer.CaseCmp(m_vServers[a]->GetName()) == 0) {
			m_uServerIdx = a +1;
			break;
		}

		if (a == m_vServers.size() -1) {
			m_uServerIdx = m_vServers.size();
			CIRCSock* pSock = GetIRCSock();

			if (pSock) {
				PutStatus(""Jumping servers because this server is no longer in the list"");
				pSock->Quit();
			}
		}
	}
	// !Servers

	// Chans
	const vector<CChan*>& vChans = User.GetChans();
	for (a = 0; a < vChans.size(); a++) {
		CChan* pNewChan = vChans[a];
		CChan* pChan = FindChan(pNewChan->GetName());

		if (pChan) {
			pChan->SetInConfig(pNewChan->InConfig());
		} else {
			AddChan(pNewChan->GetName(), pNewChan->InConfig());
		}
	}

	for (a = 0; a < m_vChans.size(); a++) {
		CChan* pChan = m_vChans[a];
		CChan* pNewChan = User.FindChan(pChan->GetName());

		if (!pNewChan) {
			pChan->SetInConfig(false);
		} else {
			if (bCloneChans)
				pChan->Clone(*pNewChan);
		}
	}
	// !Chans

	// CTCP Replies
	m_mssCTCPReplies.clear();
	const MCString& msReplies = User.GetCTCPReplies();
	for (MCString::const_iterator it = msReplies.begin(); it != msReplies.end(); it++) {
		AddCTCPReply(it->first, it->second);
	}
	// !CTCP Replies

	// Flags
	SetKeepBuffer(User.KeepBuffer());
	SetMultiClients(User.MultiClients());
	SetBounceDCCs(User.BounceDCCs());
	SetUseClientIP(User.UseClientIP());
	SetDenyLoadMod(User.DenyLoadMod());
	SetAdmin(User.IsAdmin());
	SetDenySetVHost(User.DenySetVHost());
	SetTimestampAppend(User.GetTimestampAppend());
	SetTimestampPrepend(User.GetTimestampPrepend());
	SetTimestampFormat(User.GetTimestampFormat());
	SetTimezoneOffset(User.GetTimezoneOffset());
	// !Flags

	return true;
}

const set<CString>& CUser::GetAllowedHosts() const { return m_ssAllowedHosts; }
bool CUser::AddAllowedHost(const CString& sHostMask) {
	if (sHostMask.empty() || m_ssAllowedHosts.find(sHostMask) != m_ssAllowedHosts.end()) {
		return false;
	}

	m_ssAllowedHosts.insert(sHostMask);
	return true;
}

bool CUser::IsHostAllowed(const CString& sHostMask) const {
	if (m_ssAllowedHosts.empty()) {
		return true;
	}

	for (set<CString>::iterator a = m_ssAllowedHosts.begin(); a != m_ssAllowedHosts.end(); a++) {
		if (sHostMask.WildCmp(*a)) {
			return true;
		}
	}

	return false;
}

const CString& CUser::GetTimestampFormat() const { return m_sTimestampFormat; }
bool CUser::GetTimestampAppend() const { return m_bAppendTimestamp; }
bool CUser::GetTimestampPrepend() const { return m_bPrependTimestamp; }

bool CUser::IsValidUserName(const CString& sUserName) {
	const char* p = sUserName.c_str();

	if (sUserName.empty()) {
		return false;
	}

	if ((*p < 'a' || *p > 'z') && (*p < 'A' || *p > 'Z')) {
		return false;
	}

	while (*p) {
		if (*p != '@' && *p != '.' && *p != '-' && *p != '_' && !isalnum(*p)) {
			return false;
		}

		*p++;
	}

	return true;
}

bool CUser::IsValid(CString& sErrMsg, bool bSkipPass) const {
	sErrMsg.clear();

	if (!bSkipPass && m_sPass.empty()) {
		sErrMsg = ""Pass is empty"";
		return false;
	}

	if (m_sUserName.empty()) {
		sErrMsg = ""Username is empty"";
		return false;
	}

	if (!CUser::IsValidUserName(m_sUserName)) {
		sErrMsg = ""Username is invalid"";
		return false;
	}

	return true;
}

bool CUser::AddChan(CChan* pChan) {
	if (!pChan) {
		return false;
	}

	for (unsigned int a = 0; a < m_vChans.size(); a++) {
		if (m_vChans[a]->GetName().CaseCmp(pChan->GetName()) == 0) {
			delete pChan;
			return false;
		}
	}

	m_vChans.push_back(pChan);
	return true;
}

bool CUser::AddChan(const CString& sName, bool bInConfig) {
	if (sName.empty() || FindChan(sName)) {
		return false;
	}

	CChan* pChan = new CChan(sName, this, bInConfig);
	m_vChans.push_back(pChan);
	return true;
}

bool CUser::DelChan(const CString& sName) {
	for (vector<CChan*>::iterator a = m_vChans.begin(); a != m_vChans.end(); a++) {
		if (sName.CaseCmp((*a)->GetName()) == 0) {
			delete *a;
			m_vChans.erase(a);
			return true;
		}
	}

	return false;
}

bool CUser::PrintLine(CFile& File, const CString& sName, const CString& sValue) {
	if (sName.empty() || sValue.empty()) {
		return false;
	}

	return File.Write(""\t"" + sName + "" = "" + sValue + ""\n"");
}

bool CUser::WriteConfig(CFile& File) {
	File.Write(""<User "" + GetUserName() + "">\n"");

	if (IsPassHashed()) {
		if (m_sPassSalt.empty()) {
			PrintLine(File, ""Pass"", ""md5#"" + GetPass());
		} else {
			PrintLine(File, ""Pass"", ""md5#"" + GetPass() + ""#"" + m_sPassSalt + ""#"");
		}
	} else {
		PrintLine(File, ""Pass"", ""plain#"" + GetPass());
	}
	PrintLine(File, ""Nick"", GetNick());
	PrintLine(File, ""AltNick"", GetAltNick());
	PrintLine(File, ""Ident"", GetIdent());
	PrintLine(File, ""RealName"", GetRealName());
	PrintLine(File, ""VHost"", GetVHost());
	PrintLine(File, ""QuitMsg"", GetQuitMsg());
	if (CZNC::Get().GetStatusPrefix() != GetStatusPrefix())
		PrintLine(File, ""StatusPrefix"", GetStatusPrefix());
	PrintLine(File, ""ChanModes"", GetDefaultChanModes());
	PrintLine(File, ""Buffer"", CString(GetBufferCount()));
	PrintLine(File, ""KeepBuffer"", CString((KeepBuffer()) ? ""true"" : ""false""));
	PrintLine(File, ""MultiClients"", CString((MultiClients()) ? ""true"" : ""false""));
	PrintLine(File, ""BounceDCCs"", CString((BounceDCCs()) ? ""true"" : ""false""));
	PrintLine(File, ""DenyLoadMod"", CString((DenyLoadMod()) ? ""true"" : ""false""));
	PrintLine(File, ""Admin"", CString((IsAdmin()) ? ""true"" : ""false""));
	PrintLine(File, ""DenySetVHost"", CString((DenySetVHost()) ? ""true"" : ""false""));
	PrintLine(File, ""DCCLookupMethod"", CString((UseClientIP()) ? ""client"" : ""default""));
	PrintLine(File, ""TimestampFormat"", GetTimestampFormat());
	PrintLine(File, ""AppendTimestamp"", CString((GetTimestampAppend()) ? ""true"" : ""false""));
	PrintLine(File, ""PrependTimestamp"", CString((GetTimestampPrepend()) ? ""true"" : ""false""));
	PrintLine(File, ""TimezoneOffset"", CString(m_fTimezoneOffset));
	PrintLine(File, ""JoinTries"", CString(m_uMaxJoinTries));
	PrintLine(File, ""MaxJoins"", CString(m_uMaxJoins));
	File.Write(""\n"");

	// Allow Hosts
	if (!m_ssAllowedHosts.empty()) {
		for (set<CString>::iterator it = m_ssAllowedHosts.begin(); it != m_ssAllowedHosts.end(); it++) {
			PrintLine(File, ""Allow"", *it);
		}

		File.Write(""\n"");
	}

	// CTCP Replies
	if (!m_mssCTCPReplies.empty()) {
		for (MCString::iterator itb = m_mssCTCPReplies.begin(); itb != m_mssCTCPReplies.end(); itb++) {
			PrintLine(File, ""CTCPReply"", itb->first.AsUpper() + "" "" + itb->second);
		}

		File.Write(""\n"");
	}

#ifdef _MODULES
	// Modules
	CModules& Mods = GetModules();

	if (!Mods.empty()) {
		for (unsigned int a = 0; a < Mods.size(); a++) {
			CString sArgs = Mods[a]->GetArgs();

			if (!sArgs.empty()) {
				sArgs = "" "" + sArgs;
			}

			PrintLine(File, ""LoadModule"", Mods[a]->GetModName() + sArgs);
		}

		File.Write(""\n"");
	}
#endif

	// Servers
	for (unsigned int b = 0; b < m_vServers.size(); b++) {
		PrintLine(File, ""Server"", m_vServers[b]->GetString());
	}

	// Chans
	for (unsigned int c = 0; c < m_vChans.size(); c++) {
		CChan* pChan = m_vChans[c];
		if (pChan->InConfig()) {
			File.Write(""\n"");
			if (!pChan->WriteConfig(File)) {
				return false;
			}
		}
	}

	File.Write(""</User>\n"");

	return true;
}

CChan* CUser::FindChan(const CString& sName) const {
	for (unsigned int a = 0; a < m_vChans.size(); a++) {
		CChan* pChan = m_vChans[a];
		if (sName.CaseCmp(pChan->GetName()) == 0) {
			return pChan;
		}
	}

	return NULL;
}

void CUser::JoinChans() {
	unsigned int uJoins = m_uMaxJoins;
	for (unsigned int a = 0; a < m_vChans.size(); a++) {
		CChan* pChan = m_vChans[a];
		if (!pChan->IsOn() && !pChan->IsDisabled()) {
			if (JoinTries() != 0 && pChan->GetJoinTries() >= JoinTries()) {
				PutStatus(""The channel "" + pChan->GetName() + "" could not be joined, disabling it."");
				pChan->Disable();
			} else {
				pChan->IncJoinTries();
				PutIRC(""JOIN "" + pChan->GetName() + "" "" + pChan->GetKey());

				// Limit the number of joins
				if (uJoins != 0 && --uJoins == 0)
					return;
			}
		}
	}
}

CServer* CUser::FindServer(const CString& sName) const {
	for (unsigned int a = 0; a < m_vServers.size(); a++) {
		CServer* pServer = m_vServers[a];
		if (sName.CaseCmp(pServer->GetName()) == 0) {
			return pServer;
		}
	}

	return NULL;
}

bool CUser::DelServer(const CString& sName) {
	if (sName.empty()) {
		return false;
	}

	unsigned int a = 0;

	for (vector<CServer*>::iterator it = m_vServers.begin(); it != m_vServers.end(); it++, a++) {
		CServer* pServer = *it;

		if (pServer->GetName().CaseCmp(sName) == 0) {
			CServer* pCurServer = GetCurrentServer();
			m_vServers.erase(it);

			if (pServer == pCurServer) {
				CIRCSock* pIRCSock = GetIRCSock();

				if (m_uServerIdx) {
					m_uServerIdx--;
				}

				if (pIRCSock) {
					pIRCSock->Quit();
					PutStatus(""Your current server was removed, jumping..."");
				}
			} else if (m_uServerIdx >= m_vServers.size()) {
				m_uServerIdx = 0;
			}

			delete pServer;

			return true;
		}
	}

	return false;
}

bool CUser::AddServer(const CString& sName, bool bIPV6) {
	if (sName.empty()) {
		return false;
	}

	bool bSSL = false;
	CString sLine = sName;
	sLine.Trim();

	CString sHost = sLine.Token(0);
	CString sPort = sLine.Token(1);

	if (sPort.Left(1) == ""+"") {
		bSSL = true;
		sPort.LeftChomp();
	}

	unsigned short uPort = strtoul(sPort.c_str(), NULL, 10);
	CString sPass = sLine.Token(2, true);

	return AddServer(sHost, uPort, sPass, bSSL, bIPV6);
}

bool CUser::AddServer(const CString& sName, unsigned short uPort, const CString& sPass, bool bSSL, bool bIPV6) {
#ifndef HAVE_LIBSSL
	if (bSSL) {
		return false;
	}
#endif

#ifndef HAVE_IPV6
	if (bIPV6) {
		return false;
	}
#endif

	if (sName.empty()) {
		return false;
	}

	if (!uPort) {
		uPort = 6667;
	}

	CServer* pServer = new CServer(sName, uPort, sPass, bSSL, bIPV6);
	m_vServers.push_back(pServer);

	CheckIRCConnect();

	return true;
}

bool CUser::IsLastServer() const {
	return (m_uServerIdx >= m_vServers.size());
}

CServer* CUser::GetNextServer() {
	if (m_vServers.empty()) {
		return NULL;
	}

	if (m_uServerIdx >= m_vServers.size()) {
		m_uServerIdx = 0;
	}

	return m_vServers[m_uServerIdx++];	// Todo: cycle through these
}

CServer* CUser::GetCurrentServer() const {
	unsigned int uIdx = (m_uServerIdx) ? m_uServerIdx -1 : 0;

	if (uIdx >= m_vServers.size()) {
		return NULL;
	}

	return m_vServers[uIdx];
}

bool CUser::CheckPass(const CString& sPass) const {
	if (!m_bPassHashed) {
		return (sPass == m_sPass);
	}

	CString sSaltedPass = sPass + m_sPassSalt;

	return (m_sPass.CaseCmp(sSaltedPass.MD5()) == 0);
}

/*CClient* CUser::GetClient() {
	// Todo: optimize this by saving a pointer to the sock
	CSockManager& Manager = CZNC::Get().GetManager();
	CString sSockName = ""USR::"" + m_sUserName;

	for (unsigned int a = 0; a < Manager.size(); a++) {
		Csock* pSock = Manager[a];
		if (pSock->GetSockName().CaseCmp(sSockName) == 0) {
			if (!pSock->IsClosed()) {
				return (CClient*) pSock;
			}
		}
	}

	return (CClient*) CZNC::Get().GetManager().FindSockByName(sSockName);
}*/

CString CUser::GetLocalIP() {
	CIRCSock* pIRCSock = GetIRCSock();

	if (pIRCSock) {
		return pIRCSock->GetLocalIP();
	}

	if (m_vClients.size()) {
		return m_vClients[0]->GetLocalIP();
	}

	return """";
}

bool CUser::PutIRC(const CString& sLine) {
	CIRCSock* pIRCSock = GetIRCSock();

	if (!pIRCSock) {
		return false;
	}

	pIRCSock->PutIRC(sLine);
	return true;
}

bool CUser::PutUser(const CString& sLine, CClient* pClient, CClient* pSkipClient) {
	for (unsigned int a = 0; a < m_vClients.size(); a++) {
		if ((!pClient || pClient == m_vClients[a]) && pSkipClient != m_vClients[a]) {
			m_vClients[a]->PutClient(sLine);

			if (pClient) {
				return true;
			}
		}
	}

	return (pClient == NULL);
}

bool CUser::PutStatus(const CString& sLine, CClient* pClient, CClient* pSkipClient) {
	for (unsigned int a = 0; a < m_vClients.size(); a++) {
		if ((!pClient || pClient == m_vClients[a]) && pSkipClient != m_vClients[a]) {
			m_vClients[a]->PutStatus(sLine);

			if (pClient) {
				return true;
			}
		}
	}

	return (pClient == NULL);
}

bool CUser::PutStatusNotice(const CString& sLine, CClient* pClient, CClient* pSkipClient) {
	for (unsigned int a = 0; a < m_vClients.size(); a++) {
		if ((!pClient || pClient == m_vClients[a]) && pSkipClient != m_vClients[a]) {
			m_vClients[a]->PutStatusNotice(sLine);

			if (pClient) {
				return true;
			}
		}
	}

	return (pClient == NULL);
}

bool CUser::PutModule(const CString& sModule, const CString& sLine, CClient* pClient, CClient* pSkipClient) {
	for (unsigned int a = 0; a < m_vClients.size(); a++) {
		if ((!pClient || pClient == m_vClients[a]) && pSkipClient != m_vClients[a]) {
			m_vClients[a]->PutModule(sModule, sLine);

			if (pClient) {
				return true;
			}
		}
	}

	return (pClient == NULL);
}

bool CUser::ResumeFile(unsigned short uPort, unsigned long uFileSize) {
	CSockManager& Manager = CZNC::Get().GetManager();

	for (unsigned int a = 0; a < Manager.size(); a++) {
		if (strncasecmp(Manager[a]->GetSockName().c_str(), ""DCC::LISTEN::"", 13) == 0) {
			CDCCSock* pSock = (CDCCSock*) Manager[a];

			if (pSock->GetLocalPort() == uPort) {
				if (pSock->Seek(uFileSize)) {
					PutModule(pSock->GetModuleName(), ""DCC -> ["" + pSock->GetRemoteNick() + ""]["" + pSock->GetFileName() + ""] - Attempting to resume from file position ["" + CString(uFileSize) + ""]"");
					return true;
				} else {
					return false;
				}
			}
		}
	}

	return false;
}

bool CUser::SendFile(const CString& sRemoteNick, const CString& sFileName, const CString& sModuleName) {
	CString sFullPath = CDir::ChangeDir(GetDLPath(), sFileName, CZNC::Get().GetHomePath());
	CDCCSock* pSock = new CDCCSock(this, sRemoteNick, sFullPath, sModuleName);

	CFile* pFile = pSock->OpenFile(false);

	if (!pFile) {
		delete pSock;
		return false;
	}

	unsigned short uPort = CZNC::Get().GetManager().ListenRand(""DCC::LISTEN::"" + sRemoteNick, GetLocalIP(), false, SOMAXCONN, pSock, 120);

	if (GetNick().CaseCmp(sRemoteNick) == 0) {
		PutUser("":"" + GetStatusPrefix() + ""status!znc@znc.in PRIVMSG "" + sRemoteNick + "" :\001DCC SEND "" + pFile->GetShortName() + "" "" + CString(CUtils::GetLongIP(GetLocalIP())) + "" ""
				+ CString(uPort) + "" "" + CString(pFile->GetSize()) + ""\001"");
	} else {
		PutIRC(""PRIVMSG "" + sRemoteNick + "" :\001DCC SEND "" + pFile->GetShortName() + "" "" + CString(CUtils::GetLongIP(GetLocalIP())) + "" ""
			    + CString(uPort) + "" "" + CString(pFile->GetSize()) + ""\001"");
	}

	PutModule(sModuleName, ""DCC -> ["" + sRemoteNick + ""]["" + pFile->GetShortName() + ""] - Attempting Send."");
	return true;
}

bool CUser::GetFile(const CString& sRemoteNick, const CString& sRemoteIP, unsigned short uRemotePort, const CString& sFileName, unsigned long uFileSize, const CString& sModuleName) {
	if (CFile::Exists(sFileName)) {
		PutModule(sModuleName, ""DCC <- ["" + sRemoteNick + ""]["" + sFileName + ""] - File already exists."");
		return false;
	}

	CDCCSock* pSock = new CDCCSock(this, sRemoteNick, sRemoteIP, uRemotePort, sFileName, uFileSize, sModuleName);

	if (!pSock->OpenFile()) {
		delete pSock;
		return false;
	}

	if (!CZNC::Get().GetManager().Connect(sRemoteIP, uRemotePort, ""DCC::GET::"" + sRemoteNick, 60, false, GetLocalIP(), pSock)) {
		PutModule(sModuleName, ""DCC <- ["" + sRemoteNick + ""]["" + sFileName + ""] - Unable to connect."");
		return false;
	}

	PutModule(sModuleName, ""DCC <- ["" + sRemoteNick + ""]["" + sFileName + ""] - Attempting to connect to ["" + sRemoteIP + ""]"");
	return true;
}

CString CUser::GetCurNick() const {
	const CIRCSock* pIRCSock = GetIRCSock();

	if (pIRCSock) {
		return pIRCSock->GetNick();
	}

	if (m_vClients.size()) {
		return m_vClients[0]->GetNick();
	}

	return """";
}

CString CUser::MakeCleanUserName(const CString& sUserName) {
	return sUserName.Token(0, false, ""@"").Replace_n(""."", """");
}

// Setters
void CUser::SetUserName(const CString& s) {
	m_sCleanUserName = CUser::MakeCleanUserName(s);
	m_sUserName = s;
}

bool CUser::IsChan(const CString& sChan) const {
	if (sChan.empty())
		return false; // There is no way this is a chan
	if (GetChanPrefixes().empty())
		return true; // We can't know, so we allow everything
	// Thanks to the above if (empty), we can do sChan[0]
	return GetChanPrefixes().find(sChan[0]) != CString::npos;
}

void CUser::SetNick(const CString& s) { m_sNick = s; }
void CUser::SetAltNick(const CString& s) { m_sAltNick = s; }
void CUser::SetIdent(const CString& s) { m_sIdent = s; }
void CUser::SetRealName(const CString& s) { m_sRealName = s; }
void CUser::SetVHost(const CString& s) { m_sVHost = s; }
void CUser::SetPass(const CString& s, bool bHashed, const CString& sSalt) {
	m_sPass = s;
	m_bPassHashed = bHashed;
	m_sPassSalt = sSalt;
}
void CUser::SetMultiClients(bool b) { m_bMultiClients = b; }
void CUser::SetBounceDCCs(bool b) { m_bBounceDCCs = b; }
void CUser::SetUseClientIP(bool b) { m_bUseClientIP = b; }
void CUser::SetDenyLoadMod(bool b) { m_bDenyLoadMod = b; }
void CUser::SetAdmin(bool b) { m_bAdmin = b; }
void CUser::SetDenySetVHost(bool b) { m_bDenySetVHost = b; }
void CUser::SetDefaultChanModes(const CString& s) { m_sDefaultChanModes = s; }
void CUser::SetIRCServer(const CString& s) { m_sIRCServer = s; }
void CUser::SetQuitMsg(const CString& s) { m_sQuitMsg = s; }
void CUser::SetBufferCount(unsigned int u) { m_uBufferCount = u; }
void CUser::SetKeepBuffer(bool b) { m_bKeepBuffer = b; }

void CUser::CheckIRCConnect()
{
	// Do we want to connect?
	if (m_bIRCConnectEnabled && GetIRCSock() == NULL)
		CZNC::Get().EnableConnectUser();
}

void CUser::SetIRCNick(const CNick& n) {
	m_IRCNick = n;

	for (unsigned int a = 0; a < m_vClients.size(); a++) {
		m_vClients[a]->SetNick(n.GetNick());
	}
}

bool CUser::AddCTCPReply(const CString& sCTCP, const CString& sReply) {
	if (sCTCP.empty()) {
		return false;
	}

	m_mssCTCPReplies[sCTCP.AsUpper()] = sReply;
	return true;
}

bool CUser::SetStatusPrefix(const CString& s) {
	if ((!s.empty()) && (s.length() < 6) && (s.find(' ') == CString::npos)) {
		m_sStatusPrefix = (s.empty()) ? ""*"" : s;
		return true;
	}

	return false;
}
// !Setters

// Getters
const CString& CUser::GetUserName() const { return m_sUserName; }
const CString& CUser::GetCleanUserName() const { return m_sCleanUserName; }
const CString& CUser::GetNick(bool bAllowDefault) const { return (bAllowDefault && m_sNick.empty()) ? GetCleanUserName() : m_sNick; }
const CString& CUser::GetAltNick(bool bAllowDefault) const { return (bAllowDefault && m_sAltNick.empty()) ? GetCleanUserName() : m_sAltNick; }
const CString& CUser::GetIdent(bool bAllowDefault) const { return (bAllowDefault && m_sIdent.empty()) ? GetCleanUserName() : m_sIdent; }
const CString& CUser::GetRealName() const { return m_sRealName.empty() ? m_sUserName : m_sRealName; }
const CString& CUser::GetVHost() const { return m_sVHost; }
const CString& CUser::GetPass() const { return m_sPass; }
bool CUser::IsPassHashed() const { return m_bPassHashed; }
const CString& CUser::GetPassSalt() const { return m_sPassSalt; }

bool CUser::ConnectPaused() {
	if (!m_uConnectTime) {
		m_uConnectTime = time(NULL);
		return false;
	}

	if (time(NULL) - m_uConnectTime >= 5) {
		m_uConnectTime = time(NULL);
		return false;
	}

	return true;
}

bool CUser::UseClientIP() const { return m_bUseClientIP; }
bool CUser::DenyLoadMod() const { return m_bDenyLoadMod; }
bool CUser::IsAdmin() const { return m_bAdmin; }
bool CUser::DenySetVHost() const { return m_bDenySetVHost; }
bool CUser::MultiClients() const { return m_bMultiClients; }
bool CUser::BounceDCCs() const { return m_bBounceDCCs; }
const CString& CUser::GetStatusPrefix() const { return m_sStatusPrefix; }
const CString& CUser::GetDefaultChanModes() const { return m_sDefaultChanModes; }
const vector<CChan*>& CUser::GetChans() const { return m_vChans; }
const vector<CServer*>& CUser::GetServers() const { return m_vServers; }
const CNick& CUser::GetIRCNick() const { return m_IRCNick; }
const CString& CUser::GetIRCServer() const { return m_sIRCServer; }
CString CUser::GetQuitMsg() const { return (!m_sQuitMsg.empty()) ? m_sQuitMsg : CZNC::GetTag(false); }
const MCString& CUser::GetCTCPReplies() const { return m_mssCTCPReplies; }
unsigned int CUser::GetBufferCount() const { return m_uBufferCount; }
bool CUser::KeepBuffer() const { return m_bKeepBuffer; }
// !Getters
""",CUser::IRCDisconnected,[111:122]
znc,https://github.com/znc/znc/commit/751f267f30b963d7592a0e70ebcf51ab87e740fa,"""Improve CFile::ReadLine() a little

IMHO it is now a little clearer how this function works and it might be
a little faster. Biggest change is that we now read 4k of the file at once
instead of reading it in 64byte chunks. I doubt that this causes a lot more
memory usage, because CFile instances usually dont live for long, but it
should really lower the number of syscalls we need for reading a file.


git-svn-id: https://znc.svn.sourceforge.net/svnroot/znc/trunk@1306 726aef4b-f618-498e-8847-2d620e286838""","""/*
 * Copyright (C) 2004-2008  See the AUTHORS file for details.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 as published
 * by the Free Software Foundation.
 */

#include ""FileUtils.h""
#include ""Utils.h""
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/wait.h>

CFile::CFile() {
	m_iFD = -1;
	m_bClose = false;
}

CFile::CFile(const CString& sLongName) {
	m_iFD = -1;
	m_bClose = false;

	SetFileName(sLongName);
}

CFile::CFile(int iFD, const CString& sLongName) {
	m_iFD = iFD;
	m_bClose = false;

	SetFileName(sLongName);
}

CFile::~CFile() {
	if (m_bClose && m_iFD != -1) {
		Close();
	}
}

void CFile::SetFileName(const CString& sLongName) {
	m_sLongName = sLongName;

	m_sShortName = sLongName;
	m_sShortName.TrimRight(""/"");

	CString::size_type uPos = m_sShortName.rfind('/');
	if (uPos != CString::npos) {
		m_sShortName = m_sShortName.substr(uPos +1);
	}
}

bool CFile::IsReg(const CString& sLongName, bool bUseLstat) { return CFile::FType(sLongName, FT_REGULAR, bUseLstat); }
bool CFile::IsDir(const CString& sLongName, bool bUseLstat) { return CFile::FType(sLongName, FT_DIRECTORY, bUseLstat); }
bool CFile::IsChr(const CString& sLongName, bool bUseLstat)  { return CFile::FType(sLongName, FT_CHARACTER, bUseLstat); }
bool CFile::IsBlk(const CString& sLongName, bool bUseLstat)  { return CFile::FType(sLongName, FT_BLOCK, bUseLstat); }
bool CFile::IsFifo(const CString& sLongName, bool bUseLstat)  { return CFile::FType(sLongName, FT_FIFO, bUseLstat); }
bool CFile::IsLnk(const CString& sLongName, bool bUseLstat)  { return CFile::FType(sLongName, FT_LINK, bUseLstat); }
bool CFile::IsSock(const CString& sLongName, bool bUseLstat)  { return CFile::FType(sLongName, FT_SOCK, bUseLstat); }

bool CFile::IsReg(bool bUseLstat) const { return CFile::IsReg(m_sLongName, bUseLstat); }
bool CFile::IsDir(bool bUseLstat) const { return CFile::IsDir(m_sLongName, bUseLstat); }
bool CFile::IsChr(bool bUseLstat) const { return CFile::IsChr(m_sLongName, bUseLstat); }
bool CFile::IsBlk(bool bUseLstat) const { return CFile::IsBlk(m_sLongName, bUseLstat); }
bool CFile::IsFifo(bool bUseLstat) const { return CFile::IsFifo(m_sLongName, bUseLstat); }
bool CFile::IsLnk(bool bUseLstat) const { return CFile::IsLnk(m_sLongName, bUseLstat); }
bool CFile::IsSock(bool bUseLstat) const { return CFile::IsSock(m_sLongName, bUseLstat); }

bool CFile::access(int mode) { return (::access(m_sLongName.c_str(), mode) == 0); }

// for gettin file types, using fstat instead
bool CFile::FType(const CString sFileName, EFileTypes eType, bool bUseLstat) {
	struct stat st;

	if (!bUseLstat) {
		if (stat(sFileName.c_str(), &st) != 0) {
			return false;
		}
	} else {
		if (lstat(sFileName.c_str(), &st) != 0) {
			return false;
		}
	}

	switch (eType) {
		case FT_REGULAR:
			return S_ISREG(st.st_mode);
		case FT_DIRECTORY:
			return S_ISDIR(st.st_mode);
		case FT_CHARACTER:
			return S_ISCHR(st.st_mode);
		case FT_BLOCK:
			return S_ISBLK(st.st_mode);
		case FT_FIFO:
			return S_ISFIFO(st.st_mode);
		case FT_LINK:
			return S_ISLNK(st.st_mode);
		case FT_SOCK:
			return S_ISSOCK(st.st_mode);
		default:
			return false;
	}
	return false;
}

//
// Functions to retrieve file information
//
bool CFile::Exists() const { return CFile::Exists(m_sLongName); }
unsigned long long CFile::GetSize() const { return CFile::GetSize(m_sLongName); }
unsigned int CFile::GetATime() const { return CFile::GetATime(m_sLongName); }
unsigned int CFile::GetMTime() const { return CFile::GetMTime(m_sLongName); }
unsigned int CFile::GetCTime() const { return CFile::GetCTime(m_sLongName); }
int CFile::GetUID() const { return CFile::GetUID(m_sLongName); }
int CFile::GetGID() const { return CFile::GetGID(m_sLongName); }
bool CFile::Exists(const CString& sFile) {
	struct stat st;
	return (stat(sFile.c_str(), &st) == 0);
}

unsigned long long CFile::GetSize(const CString& sFile) {
	struct stat st;
	if (stat(sFile.c_str(), &st) != 0) {
		return 0;
	}

	return (S_ISREG(st.st_mode)) ? st.st_size : 0;
}

unsigned int CFile::GetATime(const CString& sFile) {
	struct stat st;
	return (stat(sFile.c_str(), &st) != 0) ? 0 : st.st_atime;
}

unsigned int CFile::GetMTime(const CString& sFile) {
	struct stat st;
	return (stat(sFile.c_str(), &st) != 0) ? 0 : st.st_mtime;
}

unsigned int CFile::GetCTime(const CString& sFile) {
	struct stat st;
	return (stat(sFile.c_str(), &st) != 0) ? 0 : st.st_ctime;
}

int CFile::GetUID(const CString& sFile) {
	struct stat st;
	return (stat(sFile.c_str(), &st) != 0) ? -1 : (int) st.st_uid;
}

int CFile::GetGID(const CString& sFile) {
	struct stat st;
	return (stat(sFile.c_str(), &st) != 0) ? -1 : (int) st.st_gid;
}
int CFile::GetInfo(const CString& sFile, struct stat& st) {
	return stat(sFile.c_str(), &st);
}

//
// Functions to manipulate the file on the filesystem
//
bool CFile::Delete() { return CFile::Delete(m_sLongName); }
int CFile::Move(const CString& sNewFileName, bool bOverwrite) {
	return CFile::Move(m_sLongName, sNewFileName, bOverwrite);
}

int CFile::Copy(const CString& sNewFileName, bool bOverwrite) {
	return CFile::Copy(m_sLongName, sNewFileName, bOverwrite);
}

bool CFile::Delete(const CString& sFileName) {
	if (!CFile::Exists(sFileName)) {
		return false;
	}

	return (unlink(sFileName.c_str()) == 0) ? true : false;
}

bool CFile::Move(const CString& sOldFileName, const CString& sNewFileName, bool bOverwrite) {
	if ((!bOverwrite) && (CFile::Exists(sNewFileName))) {
		return false;
	}

	//CString sNewLongName = (sNewFileName[0] == '/') ? sNewFileName : m_sPath + ""/"" + sNewFileName;
	return (rename(sOldFileName.c_str(), sNewFileName.c_str()) == 0) ? true : false;
}

bool CFile::Copy(const CString& sOldFileName, const CString& sNewFileName, bool bOverwrite) {
	if ((!bOverwrite) && (CFile::Exists(sNewFileName))) {
		return false;
	}

	CFile OldFile(sOldFileName);
	CFile NewFile(sNewFileName);

	if (!OldFile.Open(O_RDONLY)) {
		return false;
	}

	if (!NewFile.Open(O_WRONLY | O_CREAT | O_TRUNC)) {
		return false;
	}

	char szBuf[8192];
	int len = 0;

	while ((len = OldFile.Read(szBuf, 8192))) {
		if (len < 0) {
			DEBUG_ONLY(cout << ""CFile::Copy() failed: "" << strerror(errno) << endl);
			OldFile.Close();

			// That file is only a partial copy, get rid of it
			NewFile.Close();
			NewFile.Delete();

			return false;
		}
		NewFile.Write(szBuf, len);
	}

	OldFile.Close();
	NewFile.Close();

	return true;
}

bool CFile::Chmod(mode_t mode) {
	return CFile::Chmod(m_sLongName, mode);
}

bool CFile::Chmod(const CString& sFile, mode_t mode) {
	return (chmod(sFile.c_str(), mode) == 0);
}

bool CFile::Seek(unsigned long uPos) {
	if (m_iFD != -1 && (unsigned int) lseek(m_iFD, uPos, SEEK_SET) == uPos) {
		ClearBuffer();
		return true;
	}

	return false;
}

bool CFile::Truncate() {
	if (m_iFD != -1 && ftruncate(m_iFD, 0) == 0) {
		ClearBuffer();
		return true;
	}

	return false;
}

bool CFile::Open(const CString& sFileName, int iFlags, mode_t iMode) {
	SetFileName(sFileName);
	return Open(iFlags, iMode);
}

bool CFile::Open(int iFlags, mode_t iMode) {
	if (m_iFD != -1) {
		return false;
	}

	m_iFD = open(m_sLongName.c_str(), iFlags, iMode);
	if (m_iFD < 0)
		return false;

	/* Make sure this FD isn't given to childs */
	SetFdCloseOnExec(m_iFD);

	m_bClose = true;
	return true;
}

int CFile::Read(char *pszBuffer, int iBytes) {
	if (m_iFD == -1) {
		return -1;
	}

	return read(m_iFD, pszBuffer, iBytes);
}

bool CFile::ReadLine(CString& sData, const CString & sDelimiter) {
	char buff[64];
	sData.clear();

	if (m_iFD == -1) {
		return false;
	}

	bool bEOF = false;

	while (true) {
		CString::size_type iFind = m_sBuffer.find(sDelimiter);
		if (iFind != CString::npos) {
			sData = m_sBuffer.substr(0, (iFind + 1));
			m_sBuffer.erase(0, (iFind + 1));
			break;
		}

		memset((char *)buff, '\0', 64);
		int iBytes = read(m_iFD, buff, 64);

		switch(iBytes) {
			case -1: {
				bEOF = true;
				break;
			}
			case 0: {
				bEOF = true;
				break;
			}
			default: {
				m_sBuffer.append(buff, iBytes);
				break;
			}
		}

		if (bEOF) {
			break;
		}
	}

	CString::size_type iFind = m_sBuffer.find(sDelimiter);
	if (iFind != CString::npos) {
		return true;
	}

	if (bEOF && m_sBuffer.size()) {
		sData = m_sBuffer;
		m_sBuffer.clear();
		return true;
	}

	return !bEOF;
}

int CFile::Write(const char *pszBuffer, u_int iBytes) {
	if (m_iFD == -1) {
		return -1;
	}

	return write(m_iFD, pszBuffer, iBytes);
}

int CFile::Write(const CString & sData) {
	return Write(sData.data(), sData.size());
}
void CFile::Close() {
	if (m_iFD >= 0 && m_bClose) {
		close(m_iFD);
		m_iFD = -1;
		m_bClose = false;
	}
}
void CFile::ClearBuffer() { m_sBuffer.clear(); }

bool CFile::IsOpen() const { return (m_iFD != -1); }
CString CFile::GetLongName() const { return m_sLongName; }
CString CFile::GetShortName() const { return m_sShortName; }
CString CFile::GetDir() const {
	CString sDir(m_sLongName);

	while (!sDir.empty() && sDir.Right(1) != ""/"" && sDir.Right(1) != ""\\"") {
		sDir.RightChomp();
	}

	return sDir;
}

void CFile::SetFD(int iFD) { m_iFD = iFD; }

CString CDir::ChangeDir(const CString& sPath, const CString& sAdd, const CString& sHomeDir) {
	if (sAdd == ""~"") {
		return sHomeDir;
	}

	CString sAddDir = sAdd;

	if (sAddDir.Left(2) == ""~/"") {
		sAddDir.LeftChomp();
		sAddDir = sHomeDir + sAddDir;
	}

	CString sRet = ((sAddDir.size()) && (sAddDir[0] == '/')) ? """" : sPath;
	sAddDir += ""/"";
	CString sCurDir;

	if (sRet.Right(1) == ""/"") {
		sRet.RightChomp();
	}

	for (unsigned int a = 0; a < sAddDir.size(); a++) {
		switch (sAddDir[a]) {
			case '/':
				if (sCurDir == "".."") {
					sRet = sRet.substr(0, sRet.rfind('/'));
				} else if ((sCurDir != """") && (sCurDir != ""."")) {
					sRet += ""/"" + sCurDir;
				}

				sCurDir = """";
				break;
			default:
				sCurDir += sAddDir[a];
				break;
		}
	}

	return (sRet.empty()) ? ""/"" : sRet;
}

bool CDir::MakeDir(const CString& sPath, mode_t iMode) {
	CString sDir;
	VCString dirs;
	VCString::iterator it;

	// Just in case someone tries this...
	if (sPath.empty())
		return false;

	// If this is an absolute path, we need to handle this now!
	if (sPath.Left(1) == ""/"")
		sDir = ""/"";

	// For every single subpath, do...
	sPath.Split(""/"", dirs, false);
	for (it = dirs.begin(); it != dirs.end(); it++) {
		// Add this to the path we already created
		sDir += *it;

		int i = mkdir(sDir.c_str(), iMode);

		if (i != 0) {
			// All errors except EEXIST are fatal
			if (errno != EEXIST)
				return false;

			// If it's EEXIST we have to make sure it's a dir
			if (!CFile::IsDir(sDir))
				return false;
		}

		sDir += ""/"";
	}

	// All went well
	return true;
}

int CExecSock::popen2(int & iReadFD, int & iWriteFD, const CString & sCommand) {
	int rpipes[2] = { -1, -1 };
	int wpipes[2] = { -1, -1 };
	iReadFD = -1;
	iWriteFD = -1;

	if (pipe(rpipes) < 0)
		return -1;

	if (pipe(wpipes) < 0) {
		close(rpipes[0]);
		close(rpipes[1]);
		return -1;
	}

	int iPid = fork();

	if (iPid == -1) {
		close(rpipes[0]);
		close(rpipes[1]);
		close(wpipes[0]);
		close(wpipes[1]);
		return -1;
	}

	if (iPid == 0) {
		close(wpipes[1]);
		close(rpipes[0]);
		dup2(wpipes[0], 0);
		dup2(rpipes[1], 1);
		dup2(rpipes[1], 2);
		close(wpipes[0]);
		close(rpipes[1]);
		const char * pArgv[] =
		{
			""sh"",
			""-c"",
			sCommand.c_str(),
			NULL
		};
		execvp(""sh"", (char * const *) pArgv);
		exit(0);
	}

	close(wpipes[0]);
	close(rpipes[1]);

	iWriteFD = wpipes[1];
	iReadFD = rpipes[0];

	return iPid;
}

void CExecSock::close2(int iPid, int iReadFD, int iWriteFD) {
	close(iReadFD);
	close(iWriteFD);
	u_int iNow = time(NULL);
	while (waitpid(iPid, NULL, WNOHANG) == 0) {
		if ((time(NULL) - iNow) > 5)
			break;	// giveup
		usleep(100);
	}
	return;
}
""","""/*
 * Copyright (C) 2004-2008  See the AUTHORS file for details.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 as published
 * by the Free Software Foundation.
 */

#include ""FileUtils.h""
#include ""Utils.h""
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/wait.h>

CFile::CFile() {
	m_iFD = -1;
	m_bClose = false;
}

CFile::CFile(const CString& sLongName) {
	m_iFD = -1;
	m_bClose = false;

	SetFileName(sLongName);
}

CFile::CFile(int iFD, const CString& sLongName) {
	m_iFD = iFD;
	m_bClose = false;

	SetFileName(sLongName);
}

CFile::~CFile() {
	if (m_bClose && m_iFD != -1) {
		Close();
	}
}

void CFile::SetFileName(const CString& sLongName) {
	m_sLongName = sLongName;

	m_sShortName = sLongName;
	m_sShortName.TrimRight(""/"");

	CString::size_type uPos = m_sShortName.rfind('/');
	if (uPos != CString::npos) {
		m_sShortName = m_sShortName.substr(uPos +1);
	}
}

bool CFile::IsReg(const CString& sLongName, bool bUseLstat) { return CFile::FType(sLongName, FT_REGULAR, bUseLstat); }
bool CFile::IsDir(const CString& sLongName, bool bUseLstat) { return CFile::FType(sLongName, FT_DIRECTORY, bUseLstat); }
bool CFile::IsChr(const CString& sLongName, bool bUseLstat)  { return CFile::FType(sLongName, FT_CHARACTER, bUseLstat); }
bool CFile::IsBlk(const CString& sLongName, bool bUseLstat)  { return CFile::FType(sLongName, FT_BLOCK, bUseLstat); }
bool CFile::IsFifo(const CString& sLongName, bool bUseLstat)  { return CFile::FType(sLongName, FT_FIFO, bUseLstat); }
bool CFile::IsLnk(const CString& sLongName, bool bUseLstat)  { return CFile::FType(sLongName, FT_LINK, bUseLstat); }
bool CFile::IsSock(const CString& sLongName, bool bUseLstat)  { return CFile::FType(sLongName, FT_SOCK, bUseLstat); }

bool CFile::IsReg(bool bUseLstat) const { return CFile::IsReg(m_sLongName, bUseLstat); }
bool CFile::IsDir(bool bUseLstat) const { return CFile::IsDir(m_sLongName, bUseLstat); }
bool CFile::IsChr(bool bUseLstat) const { return CFile::IsChr(m_sLongName, bUseLstat); }
bool CFile::IsBlk(bool bUseLstat) const { return CFile::IsBlk(m_sLongName, bUseLstat); }
bool CFile::IsFifo(bool bUseLstat) const { return CFile::IsFifo(m_sLongName, bUseLstat); }
bool CFile::IsLnk(bool bUseLstat) const { return CFile::IsLnk(m_sLongName, bUseLstat); }
bool CFile::IsSock(bool bUseLstat) const { return CFile::IsSock(m_sLongName, bUseLstat); }

bool CFile::access(int mode) { return (::access(m_sLongName.c_str(), mode) == 0); }

// for gettin file types, using fstat instead
bool CFile::FType(const CString sFileName, EFileTypes eType, bool bUseLstat) {
	struct stat st;

	if (!bUseLstat) {
		if (stat(sFileName.c_str(), &st) != 0) {
			return false;
		}
	} else {
		if (lstat(sFileName.c_str(), &st) != 0) {
			return false;
		}
	}

	switch (eType) {
		case FT_REGULAR:
			return S_ISREG(st.st_mode);
		case FT_DIRECTORY:
			return S_ISDIR(st.st_mode);
		case FT_CHARACTER:
			return S_ISCHR(st.st_mode);
		case FT_BLOCK:
			return S_ISBLK(st.st_mode);
		case FT_FIFO:
			return S_ISFIFO(st.st_mode);
		case FT_LINK:
			return S_ISLNK(st.st_mode);
		case FT_SOCK:
			return S_ISSOCK(st.st_mode);
		default:
			return false;
	}
	return false;
}

//
// Functions to retrieve file information
//
bool CFile::Exists() const { return CFile::Exists(m_sLongName); }
unsigned long long CFile::GetSize() const { return CFile::GetSize(m_sLongName); }
unsigned int CFile::GetATime() const { return CFile::GetATime(m_sLongName); }
unsigned int CFile::GetMTime() const { return CFile::GetMTime(m_sLongName); }
unsigned int CFile::GetCTime() const { return CFile::GetCTime(m_sLongName); }
int CFile::GetUID() const { return CFile::GetUID(m_sLongName); }
int CFile::GetGID() const { return CFile::GetGID(m_sLongName); }
bool CFile::Exists(const CString& sFile) {
	struct stat st;
	return (stat(sFile.c_str(), &st) == 0);
}

unsigned long long CFile::GetSize(const CString& sFile) {
	struct stat st;
	if (stat(sFile.c_str(), &st) != 0) {
		return 0;
	}

	return (S_ISREG(st.st_mode)) ? st.st_size : 0;
}

unsigned int CFile::GetATime(const CString& sFile) {
	struct stat st;
	return (stat(sFile.c_str(), &st) != 0) ? 0 : st.st_atime;
}

unsigned int CFile::GetMTime(const CString& sFile) {
	struct stat st;
	return (stat(sFile.c_str(), &st) != 0) ? 0 : st.st_mtime;
}

unsigned int CFile::GetCTime(const CString& sFile) {
	struct stat st;
	return (stat(sFile.c_str(), &st) != 0) ? 0 : st.st_ctime;
}

int CFile::GetUID(const CString& sFile) {
	struct stat st;
	return (stat(sFile.c_str(), &st) != 0) ? -1 : (int) st.st_uid;
}

int CFile::GetGID(const CString& sFile) {
	struct stat st;
	return (stat(sFile.c_str(), &st) != 0) ? -1 : (int) st.st_gid;
}
int CFile::GetInfo(const CString& sFile, struct stat& st) {
	return stat(sFile.c_str(), &st);
}

//
// Functions to manipulate the file on the filesystem
//
bool CFile::Delete() { return CFile::Delete(m_sLongName); }
int CFile::Move(const CString& sNewFileName, bool bOverwrite) {
	return CFile::Move(m_sLongName, sNewFileName, bOverwrite);
}

int CFile::Copy(const CString& sNewFileName, bool bOverwrite) {
	return CFile::Copy(m_sLongName, sNewFileName, bOverwrite);
}

bool CFile::Delete(const CString& sFileName) {
	if (!CFile::Exists(sFileName)) {
		return false;
	}

	return (unlink(sFileName.c_str()) == 0) ? true : false;
}

bool CFile::Move(const CString& sOldFileName, const CString& sNewFileName, bool bOverwrite) {
	if ((!bOverwrite) && (CFile::Exists(sNewFileName))) {
		return false;
	}

	//CString sNewLongName = (sNewFileName[0] == '/') ? sNewFileName : m_sPath + ""/"" + sNewFileName;
	return (rename(sOldFileName.c_str(), sNewFileName.c_str()) == 0) ? true : false;
}

bool CFile::Copy(const CString& sOldFileName, const CString& sNewFileName, bool bOverwrite) {
	if ((!bOverwrite) && (CFile::Exists(sNewFileName))) {
		return false;
	}

	CFile OldFile(sOldFileName);
	CFile NewFile(sNewFileName);

	if (!OldFile.Open(O_RDONLY)) {
		return false;
	}

	if (!NewFile.Open(O_WRONLY | O_CREAT | O_TRUNC)) {
		return false;
	}

	char szBuf[8192];
	int len = 0;

	while ((len = OldFile.Read(szBuf, 8192))) {
		if (len < 0) {
			DEBUG_ONLY(cout << ""CFile::Copy() failed: "" << strerror(errno) << endl);
			OldFile.Close();

			// That file is only a partial copy, get rid of it
			NewFile.Close();
			NewFile.Delete();

			return false;
		}
		NewFile.Write(szBuf, len);
	}

	OldFile.Close();
	NewFile.Close();

	return true;
}

bool CFile::Chmod(mode_t mode) {
	return CFile::Chmod(m_sLongName, mode);
}

bool CFile::Chmod(const CString& sFile, mode_t mode) {
	return (chmod(sFile.c_str(), mode) == 0);
}

bool CFile::Seek(unsigned long uPos) {
	if (m_iFD != -1 && (unsigned int) lseek(m_iFD, uPos, SEEK_SET) == uPos) {
		ClearBuffer();
		return true;
	}

	return false;
}

bool CFile::Truncate() {
	if (m_iFD != -1 && ftruncate(m_iFD, 0) == 0) {
		ClearBuffer();
		return true;
	}

	return false;
}

bool CFile::Open(const CString& sFileName, int iFlags, mode_t iMode) {
	SetFileName(sFileName);
	return Open(iFlags, iMode);
}

bool CFile::Open(int iFlags, mode_t iMode) {
	if (m_iFD != -1) {
		return false;
	}

	m_iFD = open(m_sLongName.c_str(), iFlags, iMode);
	if (m_iFD < 0)
		return false;

	/* Make sure this FD isn't given to childs */
	SetFdCloseOnExec(m_iFD);

	m_bClose = true;
	return true;
}

int CFile::Read(char *pszBuffer, int iBytes) {
	if (m_iFD == -1) {
		return -1;
	}

	return read(m_iFD, pszBuffer, iBytes);
}

bool CFile::ReadLine(CString& sData, const CString & sDelimiter) {
	char buff[4096];

	if (m_iFD == -1) {
		return false;
	}

	bool bEOF = false;

	while (!bEOF) {
		CString::size_type iFind = m_sBuffer.find(sDelimiter);
		if (iFind != CString::npos) {
			// We found a line, return it
			sData = m_sBuffer.substr(0, (iFind + 1));
			m_sBuffer.erase(0, (iFind + 1));
			return true;
		}

		int iBytes = read(m_iFD, buff, sizeof(buff));

		switch(iBytes) {
			case -1: {
				bEOF = true;
				break;
			}
			case 0: {
				bEOF = true;
				break;
			}
			default: {
				m_sBuffer.append(buff, iBytes);
				break;
			}
		}
	}

	// We are at the end of the file or an error happened

	if (m_sBuffer.size()) {
		// ..but there is still some partial line in the buffer
		sData = m_sBuffer;
		m_sBuffer.clear();
		return true;
	}

	// Nothing left for reading :(
	return false;
}

int CFile::Write(const char *pszBuffer, u_int iBytes) {
	if (m_iFD == -1) {
		return -1;
	}

	return write(m_iFD, pszBuffer, iBytes);
}

int CFile::Write(const CString & sData) {
	return Write(sData.data(), sData.size());
}
void CFile::Close() {
	if (m_iFD >= 0 && m_bClose) {
		close(m_iFD);
		m_iFD = -1;
		m_bClose = false;
	}
}
void CFile::ClearBuffer() { m_sBuffer.clear(); }

bool CFile::IsOpen() const { return (m_iFD != -1); }
CString CFile::GetLongName() const { return m_sLongName; }
CString CFile::GetShortName() const { return m_sShortName; }
CString CFile::GetDir() const {
	CString sDir(m_sLongName);

	while (!sDir.empty() && sDir.Right(1) != ""/"" && sDir.Right(1) != ""\\"") {
		sDir.RightChomp();
	}

	return sDir;
}

void CFile::SetFD(int iFD) { m_iFD = iFD; }

CString CDir::ChangeDir(const CString& sPath, const CString& sAdd, const CString& sHomeDir) {
	if (sAdd == ""~"") {
		return sHomeDir;
	}

	CString sAddDir = sAdd;

	if (sAddDir.Left(2) == ""~/"") {
		sAddDir.LeftChomp();
		sAddDir = sHomeDir + sAddDir;
	}

	CString sRet = ((sAddDir.size()) && (sAddDir[0] == '/')) ? """" : sPath;
	sAddDir += ""/"";
	CString sCurDir;

	if (sRet.Right(1) == ""/"") {
		sRet.RightChomp();
	}

	for (unsigned int a = 0; a < sAddDir.size(); a++) {
		switch (sAddDir[a]) {
			case '/':
				if (sCurDir == "".."") {
					sRet = sRet.substr(0, sRet.rfind('/'));
				} else if ((sCurDir != """") && (sCurDir != ""."")) {
					sRet += ""/"" + sCurDir;
				}

				sCurDir = """";
				break;
			default:
				sCurDir += sAddDir[a];
				break;
		}
	}

	return (sRet.empty()) ? ""/"" : sRet;
}

bool CDir::MakeDir(const CString& sPath, mode_t iMode) {
	CString sDir;
	VCString dirs;
	VCString::iterator it;

	// Just in case someone tries this...
	if (sPath.empty())
		return false;

	// If this is an absolute path, we need to handle this now!
	if (sPath.Left(1) == ""/"")
		sDir = ""/"";

	// For every single subpath, do...
	sPath.Split(""/"", dirs, false);
	for (it = dirs.begin(); it != dirs.end(); it++) {
		// Add this to the path we already created
		sDir += *it;

		int i = mkdir(sDir.c_str(), iMode);

		if (i != 0) {
			// All errors except EEXIST are fatal
			if (errno != EEXIST)
				return false;

			// If it's EEXIST we have to make sure it's a dir
			if (!CFile::IsDir(sDir))
				return false;
		}

		sDir += ""/"";
	}

	// All went well
	return true;
}

int CExecSock::popen2(int & iReadFD, int & iWriteFD, const CString & sCommand) {
	int rpipes[2] = { -1, -1 };
	int wpipes[2] = { -1, -1 };
	iReadFD = -1;
	iWriteFD = -1;

	if (pipe(rpipes) < 0)
		return -1;

	if (pipe(wpipes) < 0) {
		close(rpipes[0]);
		close(rpipes[1]);
		return -1;
	}

	int iPid = fork();

	if (iPid == -1) {
		close(rpipes[0]);
		close(rpipes[1]);
		close(wpipes[0]);
		close(wpipes[1]);
		return -1;
	}

	if (iPid == 0) {
		close(wpipes[1]);
		close(rpipes[0]);
		dup2(wpipes[0], 0);
		dup2(rpipes[1], 1);
		dup2(rpipes[1], 2);
		close(wpipes[0]);
		close(rpipes[1]);
		const char * pArgv[] =
		{
			""sh"",
			""-c"",
			sCommand.c_str(),
			NULL
		};
		execvp(""sh"", (char * const *) pArgv);
		exit(0);
	}

	close(wpipes[0]);
	close(rpipes[1]);

	iWriteFD = wpipes[1];
	iReadFD = rpipes[0];

	return iPid;
}

void CExecSock::close2(int iPid, int iReadFD, int iWriteFD) {
	close(iReadFD);
	close(iWriteFD);
	u_int iNow = time(NULL);
	while (waitpid(iPid, NULL, WNOHANG) == 0) {
		if ((time(NULL) - iNow) > 5)
			break;	// giveup
		usleep(100);
	}
	return;
}
""",CFile::ReadLine,[280:327]
znc,https://github.com/znc/znc/commit/8728c994db49c5c964f85b85ec09ec273afbe9e1,"""Make CChan::AddNicks() easier to understand and probably a little faster


git-svn-id: https://znc.svn.sourceforge.net/svnroot/znc/trunk@1307 726aef4b-f618-498e-8847-2d620e286838""","""/*
 * Copyright (C) 2004-2008  See the AUTHORS file for details.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 as published
 * by the Free Software Foundation.
 */

#include ""Chan.h""
#include ""IRCSock.h""
#include ""User.h""
#include ""znc.h""

CChan::CChan(const CString& sName, CUser* pUser, bool bInConfig) {
	m_sName = sName.Token(0);
	m_sKey = sName.Token(1);
	m_pUser = pUser;

	if (!m_pUser->IsChan(m_sName)) {
		m_sName = ""#"" + m_sName;
	}

	m_bInConfig = bInConfig;
	m_Nick.SetUser(pUser);
	m_bDetached = false;
	m_uBufferCount = m_pUser->GetBufferCount();
	m_bKeepBuffer = m_pUser->KeepBuffer();
	m_bDisabled = false;
	Reset();
}

CChan::~CChan() {
	ClearNicks();
}

void CChan::Reset() {
	m_bIsOn = false;
	m_musModes.clear();
	m_sTopic = """";
	m_sTopicOwner = """";
	m_ulTopicDate = 0;
	m_ulCreationDate = 0;
	m_Nick.Reset();
	ClearNicks();
	ResetJoinTries();
}

bool CChan::WriteConfig(CFile& File) {
	if (!InConfig()) {
		return false;
	}

	File.Write(""\t<Chan "" + GetName() + "">\n"");

	if (m_pUser->GetBufferCount() != GetBufferCount())
		File.Write(""\t\tBuffer     = "" + CString(GetBufferCount()) + ""\n"");
	if (m_pUser->KeepBuffer() != KeepBuffer())
		File.Write(""\t\tKeepBuffer = "" + CString(KeepBuffer()) + ""\n"");
	if (IsDetached())
		File.Write(""\t\tDetached   = true\n"");
	if (!GetKey().empty()) { File.Write(""\t\tKey        = "" + GetKey() + ""\n""); }
	if (!GetDefaultModes().empty()) { File.Write(""\t\tModes      = "" + GetDefaultModes() + ""\n""); }

	File.Write(""\t</Chan>\n"");
	return true;
}

void CChan::Clone(CChan& chan) {
	// We assume that m_sName and m_pUser are equal
	SetBufferCount(chan.GetBufferCount());
	SetKeepBuffer(chan.KeepBuffer());
	SetKey(chan.GetKey());
	SetDefaultModes(chan.GetDefaultModes());

	if (IsDetached() != chan.IsDetached()) {
		// Only send something if it makes sense
		// (= Only detach if client is on the channel
		//    and only attach if we are on the channel)
		if (IsOn()) {
			if (IsDetached()) {
				JoinUser(false, """");
			} else {
				DetachUser();
			}
		}
		SetDetached(chan.IsDetached());
	}
}

void CChan::Cycle() const {
	m_pUser->PutIRC(""PART "" + GetName() + ""\r\nJOIN "" + GetName() + "" "" + GetKey());
}

void CChan::JoinUser(bool bForce, const CString& sKey, CClient* pClient) {
	if (!bForce && (!IsOn() || !IsDetached())) {
		m_pUser->PutIRC(""JOIN "" + GetName() + "" "" + ((sKey.empty()) ? GetKey() : sKey));
		return;
	}

	m_pUser->PutUser("":"" + m_pUser->GetIRCNick().GetNickMask() + "" JOIN :"" + GetName(), pClient);

	if (!GetTopic().empty()) {
		m_pUser->PutUser("":"" + m_pUser->GetIRCServer() + "" 332 "" + m_pUser->GetIRCNick().GetNick() + "" "" + GetName() + "" :"" + GetTopic(), pClient);
		m_pUser->PutUser("":"" + m_pUser->GetIRCServer() + "" 333 "" + m_pUser->GetIRCNick().GetNick() + "" "" + GetName() + "" "" + GetTopicOwner() + "" "" + CString(GetTopicDate()), pClient);
	}

	CString sPre = "":"" + m_pUser->GetIRCServer() + "" 353 "" + m_pUser->GetIRCNick().GetNick() + "" "" + GetModeForNames() + "" "" + GetName() + "" :"";
	CString sLine = sPre;
	CString sPerm, sNick;

	vector<CClient*>& vpClients = m_pUser->GetClients();
	for (vector<CClient*>::iterator it = vpClients.begin(); it != vpClients.end(); it++) {
		CClient* pThisClient;
		if (!pClient)
			pThisClient = *it;
		else
			pThisClient = pClient;

		for (map<CString,CNick*>::iterator a = m_msNicks.begin(); a != m_msNicks.end(); a++) {
			if (pThisClient->HasNamesx()) {
				sPerm = a->second->GetPermStr();
			} else {
				char c = a->second->GetPermChar();
				sPerm = """";
				if (c != '\0') {
					sPerm += c;
				}
			}
			if (pThisClient->HasUHNames() && !a->second->GetIdent().empty() && !a->second->GetHost().empty()) {
				sNick = a->first + ""!"" + a->second->GetIdent() + ""@"" + a->second->GetHost();
			} else {
				sNick = a->first;
			}

			sLine += sPerm + sNick;

			if (sLine.size() >= 490 || a == (--m_msNicks.end())) {
				m_pUser->PutUser(sLine, pThisClient);
				sLine = sPre;
			} else {
				sLine += "" "";
			}
		}

		if (pClient) // We only want to do this for one client
			break;
	}

	m_pUser->PutUser("":"" + m_pUser->GetIRCServer() + "" 366 "" + m_pUser->GetIRCNick().GetNick() + "" "" + GetName() + "" :End of /NAMES list."", pClient);
	m_bDetached = false;

	// Send Buffer
	SendBuffer(pClient);
}

void CChan::DetachUser() {
	if (!m_bDetached) {
		m_pUser->PutUser("":"" + m_pUser->GetIRCNick().GetNickMask() + "" PART "" + GetName());
		m_bDetached = true;
	}
}

void CChan::AttachUser() {
	if (m_bDetached) {
		m_pUser->PutUser("":"" + m_pUser->GetIRCNick().GetNickMask() + "" JOIN "" + GetName());
		m_bDetached = false;
	}
}

CString CChan::GetModeString() const {
	CString sModes, sArgs;

	for (map<unsigned char, CString>::const_iterator it = m_musModes.begin(); it != m_musModes.end(); it++) {
		sModes += it->first;
		if (it->second.size()) {
			sArgs += "" "" + it->second;
		}
	}

	return sModes.empty() ? sModes : CString(""+"" + sModes + sArgs);
}

CString CChan::GetModeForNames() const {
	CString sMode;

	for (map<unsigned char, CString>::const_iterator it = m_musModes.begin(); it != m_musModes.end(); it++) {
		if (it->first == 's') {
			sMode = ""@"";
		} else if ((it->first == 'p') && sMode.empty()){
			sMode = ""*"";
		}
	}

	return (sMode.empty() ? ""="" : sMode);
}

void CChan::SetModes(const CString& sModes) {
	m_musModes.clear();
	ModeChange(sModes);
}

void CChan::OnWho(const CString& sNick, const CString& sIdent, const CString& sHost) {
	CNick* pNick = FindNick(sNick);

	if (pNick) {
		pNick->SetIdent(sIdent);
		pNick->SetHost(sHost);
	}
}

void CChan::ModeChange(const CString& sModes, const CString& sOpNick) {
	CString sModeArg = sModes.Token(0);
	CString sArgs = sModes.Token(1, true);
	bool bAdd = true;

#ifdef _MODULES
	CNick* pOpNick = FindNick(sOpNick);

	if (pOpNick) {
		MODULECALL(OnRawMode(*pOpNick, *this, sModeArg, sArgs), m_pUser, NULL, );
	}
#endif

	for (unsigned int a = 0; a < sModeArg.size(); a++) {
		const unsigned char& uMode = sModeArg[a];

		if (uMode == '+') {
			bAdd = true;
		} else if (uMode == '-') {
			bAdd = false;
		} else if (m_pUser->GetIRCSock()->IsPermMode(uMode)) {
			CString sArg = GetModeArg(sArgs);
			CNick* pNick = FindNick(sArg);
			if (pNick) {
				unsigned char uPerm = m_pUser->GetIRCSock()->GetPermFromMode(uMode);

				if (uPerm) {
					if (bAdd) {
						pNick->AddPerm(uPerm);

						if (pNick->GetNick().Equals(m_pUser->GetCurNick())) {
							AddPerm(uPerm);
						}
					} else {
						pNick->RemPerm(uPerm);

						if (pNick->GetNick().Equals(m_pUser->GetCurNick())) {
							RemPerm(uPerm);
						}
					}
#ifdef _MODULES
					bool bNoChange = (pNick->HasPerm(uPerm) == bAdd);

					if (uMode && pOpNick) {
						MODULECALL(OnChanPermission(*pOpNick, *pNick, *this, uMode, bAdd, bNoChange), m_pUser, NULL, );

						if (uMode == CChan::M_Op) {
							if (bAdd) {
								MODULECALL(OnOp(*pOpNick, *pNick, *this, bNoChange), m_pUser, NULL, );
							} else {
								MODULECALL(OnDeop(*pOpNick, *pNick, *this, bNoChange), m_pUser, NULL, );
							}
						} else if (uMode == CChan::M_Voice) {
							if (bAdd) {
								MODULECALL(OnVoice(*pOpNick, *pNick, *this, bNoChange), m_pUser, NULL, );
							} else {
								MODULECALL(OnDevoice(*pOpNick, *pNick, *this, bNoChange), m_pUser, NULL, );
							}
						}
					}
#endif
				}
			}
		} else {
			bool bList = false;
			CString sArg;

			switch (m_pUser->GetIRCSock()->GetModeType(uMode)) {
				case CIRCSock::ListArg:
					bList = true;
					sArg = GetModeArg(sArgs);
					break;
				case CIRCSock::HasArg:
					sArg = GetModeArg(sArgs);
					break;
				case CIRCSock::NoArg:
					break;
				case CIRCSock::ArgWhenSet:
					if (bAdd) {
						sArg = GetModeArg(sArgs);
					}

					break;
			}

#ifdef _MODULES
			bool bNoChange;
			if (bList) {
				bNoChange = false;
			} else if (bAdd) {
				bNoChange = HasMode(uMode) && GetModeArg(uMode) == sArg;
			} else {
				bNoChange = !HasMode(uMode);
			}
			MODULECALL(OnMode(*pOpNick, *this, uMode, sArg, bAdd, bNoChange), m_pUser, NULL, );
#endif

			if (!bList) {
				(bAdd) ? AddMode(uMode, sArg) : RemMode(uMode, sArg);
			}
		}
	}
}

CString CChan::GetOptions() const {
	CString sRet;

	if (IsDetached()) {
		sRet += (sRet.empty()) ? ""Detached"" : "", Detached"";
	}

	if (KeepBuffer()) {
		sRet += (sRet.empty()) ? ""KeepBuffer"" : "", KeepBuffer"";
	}

	return sRet;
}

CString CChan::GetModeArg(unsigned char uMode) const {
	if (uMode) {
		map<unsigned char, CString>::const_iterator it = m_musModes.find(uMode);

		if (it != m_musModes.end()) {
			return it->second;
		}
	}

	return """";
}

bool CChan::HasMode(unsigned char uMode) const {
	return (uMode && m_musModes.find(uMode) != m_musModes.end());
}

bool CChan::AddMode(unsigned char uMode, const CString& sArg) {
	m_musModes[uMode] = sArg;
	return true;
}

bool CChan::RemMode(unsigned char uMode, const CString& sArg) {
	if (!HasMode(uMode)) {
		return false;
	}

	m_musModes.erase(uMode);
	return true;
}

CString CChan::GetModeArg(CString& sArgs) const {
	CString sRet = sArgs.substr(0, sArgs.find(' '));
	sArgs = (sRet.size() < sArgs.size()) ? sArgs.substr(sRet.size() +1) : """";
	return sRet;
}

void CChan::ClearNicks() {
	for (map<CString,CNick*>::iterator a = m_msNicks.begin(); a != m_msNicks.end(); a++) {
		delete a->second;
	}

	m_msNicks.clear();
}

int CChan::AddNicks(const CString& sNicks) {
	int iRet = 0;
	CString sCurNick;

	for (unsigned int a = 0; a < sNicks.size(); a++) {
		switch (sNicks[a]) {
			case ' ':
				if (AddNick(sCurNick)) {
					iRet++;
				}

				sCurNick = """";

				break;
			default:
				sCurNick += sNicks[a];
				break;
		}
	}

	if (!sCurNick.empty()) {
		if (AddNick(sCurNick)) {
			iRet++;
		}
	}

	return iRet;
}

bool CChan::AddNick(const CString& sNick) {
	const char* p = sNick.c_str();
	CString sPrefix, sTmp, sIdent, sHost;

	while (m_pUser->GetIRCSock()->IsPermChar(*p)) {
		sPrefix += *p;

		if (!*++p) {
			return false;
		}
	}

	sTmp = p;
	sIdent = sTmp.Token(1, true, ""!"").Token(0, false, ""@"");
	sHost = sTmp.Token(1, true, ""@"");
	sTmp = sTmp.Token(0, false, ""!"");

	CNick* pNick = FindNick(sTmp);
	if (!pNick) {
		pNick = new CNick(sTmp);
		pNick->SetUser(m_pUser);
	}

	if (!sIdent.empty())
		pNick->SetIdent(sIdent);
	if (!sHost.empty())
		pNick->SetHost(sHost);

	for (CString::size_type i = 0; i < sPrefix.length(); i++) {
		pNick->AddPerm(sPrefix[i]);
	}

	if (pNick->GetNick().Equals(m_pUser->GetCurNick())) {
		for (CString::size_type i = 0; i < sPrefix.length(); i++) {
			AddPerm(sPrefix[i]);
		}
	}

	m_msNicks[pNick->GetNick()] = pNick;

	return true;
}

map<char, unsigned int> CChan::GetPermCounts() const {
	map<char, unsigned int> mRet;

	map<CString,CNick*>::const_iterator it;
	for (it = m_msNicks.begin(); it != m_msNicks.end(); it++) {
		CString sPerms = it->second->GetPermStr();

		for (unsigned int p = 0; p < sPerms.size(); p++) {
			mRet[sPerms[p]]++;
		}
	}

	return mRet;
}

bool CChan::RemNick(const CString& sNick) {
	map<CString,CNick*>::iterator it;
	set<unsigned char>::iterator it2;

	it = m_msNicks.find(sNick);
	if (it == m_msNicks.end()) {
		return false;
	}

	delete it->second;
	m_msNicks.erase(it);

	return true;
}

bool CChan::ChangeNick(const CString& sOldNick, const CString& sNewNick) {
	map<CString,CNick*>::iterator it = m_msNicks.find(sOldNick);

	if (it == m_msNicks.end()) {
		return false;
	}

	// Rename this nick
	it->second->SetNick(sNewNick);

	// Insert a new element into the map then erase the old one, do this to change the key to the new nick
	m_msNicks[sNewNick] = it->second;
	m_msNicks.erase(it);

	return true;
}

CNick* CChan::FindNick(const CString& sNick) const {
	map<CString,CNick*>::const_iterator it = m_msNicks.find(sNick);
	return (it != m_msNicks.end()) ? it->second : NULL;
}

int CChan::AddBuffer(const CString& sLine) {
	// Todo: revisit the buffering
	if (!m_uBufferCount) {
		return 0;
	}

	if (m_vsBuffer.size() >= m_uBufferCount) {
		m_vsBuffer.erase(m_vsBuffer.begin());
	}

	m_vsBuffer.push_back(sLine);
	return m_vsBuffer.size();
}

void CChan::ClearBuffer() {
	m_vsBuffer.clear();
}

void CChan::SendBuffer(CClient* pClient) {
	if (m_pUser && m_pUser->IsUserAttached()) {
		const vector<CString>& vsBuffer = GetBuffer();

		if (vsBuffer.size()) {
			m_pUser->PutUser("":***!znc@znc.in PRIVMSG "" + GetName() + "" :Buffer Playback..."", pClient);

			for (unsigned int a = 0; a < vsBuffer.size(); a++) {
				m_pUser->PutUser(vsBuffer[a], pClient);
			}

			if (!KeepBuffer()) {
				ClearBuffer();
			}

			m_pUser->PutUser("":***!znc@znc.in PRIVMSG "" + GetName() + "" :Playback Complete."", pClient);
		}
	}
}
""","""/*
 * Copyright (C) 2004-2008  See the AUTHORS file for details.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 as published
 * by the Free Software Foundation.
 */

#include ""Chan.h""
#include ""IRCSock.h""
#include ""User.h""
#include ""znc.h""

CChan::CChan(const CString& sName, CUser* pUser, bool bInConfig) {
	m_sName = sName.Token(0);
	m_sKey = sName.Token(1);
	m_pUser = pUser;

	if (!m_pUser->IsChan(m_sName)) {
		m_sName = ""#"" + m_sName;
	}

	m_bInConfig = bInConfig;
	m_Nick.SetUser(pUser);
	m_bDetached = false;
	m_uBufferCount = m_pUser->GetBufferCount();
	m_bKeepBuffer = m_pUser->KeepBuffer();
	m_bDisabled = false;
	Reset();
}

CChan::~CChan() {
	ClearNicks();
}

void CChan::Reset() {
	m_bIsOn = false;
	m_musModes.clear();
	m_sTopic = """";
	m_sTopicOwner = """";
	m_ulTopicDate = 0;
	m_ulCreationDate = 0;
	m_Nick.Reset();
	ClearNicks();
	ResetJoinTries();
}

bool CChan::WriteConfig(CFile& File) {
	if (!InConfig()) {
		return false;
	}

	File.Write(""\t<Chan "" + GetName() + "">\n"");

	if (m_pUser->GetBufferCount() != GetBufferCount())
		File.Write(""\t\tBuffer     = "" + CString(GetBufferCount()) + ""\n"");
	if (m_pUser->KeepBuffer() != KeepBuffer())
		File.Write(""\t\tKeepBuffer = "" + CString(KeepBuffer()) + ""\n"");
	if (IsDetached())
		File.Write(""\t\tDetached   = true\n"");
	if (!GetKey().empty()) { File.Write(""\t\tKey        = "" + GetKey() + ""\n""); }
	if (!GetDefaultModes().empty()) { File.Write(""\t\tModes      = "" + GetDefaultModes() + ""\n""); }

	File.Write(""\t</Chan>\n"");
	return true;
}

void CChan::Clone(CChan& chan) {
	// We assume that m_sName and m_pUser are equal
	SetBufferCount(chan.GetBufferCount());
	SetKeepBuffer(chan.KeepBuffer());
	SetKey(chan.GetKey());
	SetDefaultModes(chan.GetDefaultModes());

	if (IsDetached() != chan.IsDetached()) {
		// Only send something if it makes sense
		// (= Only detach if client is on the channel
		//    and only attach if we are on the channel)
		if (IsOn()) {
			if (IsDetached()) {
				JoinUser(false, """");
			} else {
				DetachUser();
			}
		}
		SetDetached(chan.IsDetached());
	}
}

void CChan::Cycle() const {
	m_pUser->PutIRC(""PART "" + GetName() + ""\r\nJOIN "" + GetName() + "" "" + GetKey());
}

void CChan::JoinUser(bool bForce, const CString& sKey, CClient* pClient) {
	if (!bForce && (!IsOn() || !IsDetached())) {
		m_pUser->PutIRC(""JOIN "" + GetName() + "" "" + ((sKey.empty()) ? GetKey() : sKey));
		return;
	}

	m_pUser->PutUser("":"" + m_pUser->GetIRCNick().GetNickMask() + "" JOIN :"" + GetName(), pClient);

	if (!GetTopic().empty()) {
		m_pUser->PutUser("":"" + m_pUser->GetIRCServer() + "" 332 "" + m_pUser->GetIRCNick().GetNick() + "" "" + GetName() + "" :"" + GetTopic(), pClient);
		m_pUser->PutUser("":"" + m_pUser->GetIRCServer() + "" 333 "" + m_pUser->GetIRCNick().GetNick() + "" "" + GetName() + "" "" + GetTopicOwner() + "" "" + CString(GetTopicDate()), pClient);
	}

	CString sPre = "":"" + m_pUser->GetIRCServer() + "" 353 "" + m_pUser->GetIRCNick().GetNick() + "" "" + GetModeForNames() + "" "" + GetName() + "" :"";
	CString sLine = sPre;
	CString sPerm, sNick;

	vector<CClient*>& vpClients = m_pUser->GetClients();
	for (vector<CClient*>::iterator it = vpClients.begin(); it != vpClients.end(); it++) {
		CClient* pThisClient;
		if (!pClient)
			pThisClient = *it;
		else
			pThisClient = pClient;

		for (map<CString,CNick*>::iterator a = m_msNicks.begin(); a != m_msNicks.end(); a++) {
			if (pThisClient->HasNamesx()) {
				sPerm = a->second->GetPermStr();
			} else {
				char c = a->second->GetPermChar();
				sPerm = """";
				if (c != '\0') {
					sPerm += c;
				}
			}
			if (pThisClient->HasUHNames() && !a->second->GetIdent().empty() && !a->second->GetHost().empty()) {
				sNick = a->first + ""!"" + a->second->GetIdent() + ""@"" + a->second->GetHost();
			} else {
				sNick = a->first;
			}

			sLine += sPerm + sNick;

			if (sLine.size() >= 490 || a == (--m_msNicks.end())) {
				m_pUser->PutUser(sLine, pThisClient);
				sLine = sPre;
			} else {
				sLine += "" "";
			}
		}

		if (pClient) // We only want to do this for one client
			break;
	}

	m_pUser->PutUser("":"" + m_pUser->GetIRCServer() + "" 366 "" + m_pUser->GetIRCNick().GetNick() + "" "" + GetName() + "" :End of /NAMES list."", pClient);
	m_bDetached = false;

	// Send Buffer
	SendBuffer(pClient);
}

void CChan::DetachUser() {
	if (!m_bDetached) {
		m_pUser->PutUser("":"" + m_pUser->GetIRCNick().GetNickMask() + "" PART "" + GetName());
		m_bDetached = true;
	}
}

void CChan::AttachUser() {
	if (m_bDetached) {
		m_pUser->PutUser("":"" + m_pUser->GetIRCNick().GetNickMask() + "" JOIN "" + GetName());
		m_bDetached = false;
	}
}

CString CChan::GetModeString() const {
	CString sModes, sArgs;

	for (map<unsigned char, CString>::const_iterator it = m_musModes.begin(); it != m_musModes.end(); it++) {
		sModes += it->first;
		if (it->second.size()) {
			sArgs += "" "" + it->second;
		}
	}

	return sModes.empty() ? sModes : CString(""+"" + sModes + sArgs);
}

CString CChan::GetModeForNames() const {
	CString sMode;

	for (map<unsigned char, CString>::const_iterator it = m_musModes.begin(); it != m_musModes.end(); it++) {
		if (it->first == 's') {
			sMode = ""@"";
		} else if ((it->first == 'p') && sMode.empty()){
			sMode = ""*"";
		}
	}

	return (sMode.empty() ? ""="" : sMode);
}

void CChan::SetModes(const CString& sModes) {
	m_musModes.clear();
	ModeChange(sModes);
}

void CChan::OnWho(const CString& sNick, const CString& sIdent, const CString& sHost) {
	CNick* pNick = FindNick(sNick);

	if (pNick) {
		pNick->SetIdent(sIdent);
		pNick->SetHost(sHost);
	}
}

void CChan::ModeChange(const CString& sModes, const CString& sOpNick) {
	CString sModeArg = sModes.Token(0);
	CString sArgs = sModes.Token(1, true);
	bool bAdd = true;

#ifdef _MODULES
	CNick* pOpNick = FindNick(sOpNick);

	if (pOpNick) {
		MODULECALL(OnRawMode(*pOpNick, *this, sModeArg, sArgs), m_pUser, NULL, );
	}
#endif

	for (unsigned int a = 0; a < sModeArg.size(); a++) {
		const unsigned char& uMode = sModeArg[a];

		if (uMode == '+') {
			bAdd = true;
		} else if (uMode == '-') {
			bAdd = false;
		} else if (m_pUser->GetIRCSock()->IsPermMode(uMode)) {
			CString sArg = GetModeArg(sArgs);
			CNick* pNick = FindNick(sArg);
			if (pNick) {
				unsigned char uPerm = m_pUser->GetIRCSock()->GetPermFromMode(uMode);

				if (uPerm) {
					if (bAdd) {
						pNick->AddPerm(uPerm);

						if (pNick->GetNick().Equals(m_pUser->GetCurNick())) {
							AddPerm(uPerm);
						}
					} else {
						pNick->RemPerm(uPerm);

						if (pNick->GetNick().Equals(m_pUser->GetCurNick())) {
							RemPerm(uPerm);
						}
					}
#ifdef _MODULES
					bool bNoChange = (pNick->HasPerm(uPerm) == bAdd);

					if (uMode && pOpNick) {
						MODULECALL(OnChanPermission(*pOpNick, *pNick, *this, uMode, bAdd, bNoChange), m_pUser, NULL, );

						if (uMode == CChan::M_Op) {
							if (bAdd) {
								MODULECALL(OnOp(*pOpNick, *pNick, *this, bNoChange), m_pUser, NULL, );
							} else {
								MODULECALL(OnDeop(*pOpNick, *pNick, *this, bNoChange), m_pUser, NULL, );
							}
						} else if (uMode == CChan::M_Voice) {
							if (bAdd) {
								MODULECALL(OnVoice(*pOpNick, *pNick, *this, bNoChange), m_pUser, NULL, );
							} else {
								MODULECALL(OnDevoice(*pOpNick, *pNick, *this, bNoChange), m_pUser, NULL, );
							}
						}
					}
#endif
				}
			}
		} else {
			bool bList = false;
			CString sArg;

			switch (m_pUser->GetIRCSock()->GetModeType(uMode)) {
				case CIRCSock::ListArg:
					bList = true;
					sArg = GetModeArg(sArgs);
					break;
				case CIRCSock::HasArg:
					sArg = GetModeArg(sArgs);
					break;
				case CIRCSock::NoArg:
					break;
				case CIRCSock::ArgWhenSet:
					if (bAdd) {
						sArg = GetModeArg(sArgs);
					}

					break;
			}

#ifdef _MODULES
			bool bNoChange;
			if (bList) {
				bNoChange = false;
			} else if (bAdd) {
				bNoChange = HasMode(uMode) && GetModeArg(uMode) == sArg;
			} else {
				bNoChange = !HasMode(uMode);
			}
			MODULECALL(OnMode(*pOpNick, *this, uMode, sArg, bAdd, bNoChange), m_pUser, NULL, );
#endif

			if (!bList) {
				(bAdd) ? AddMode(uMode, sArg) : RemMode(uMode, sArg);
			}
		}
	}
}

CString CChan::GetOptions() const {
	CString sRet;

	if (IsDetached()) {
		sRet += (sRet.empty()) ? ""Detached"" : "", Detached"";
	}

	if (KeepBuffer()) {
		sRet += (sRet.empty()) ? ""KeepBuffer"" : "", KeepBuffer"";
	}

	return sRet;
}

CString CChan::GetModeArg(unsigned char uMode) const {
	if (uMode) {
		map<unsigned char, CString>::const_iterator it = m_musModes.find(uMode);

		if (it != m_musModes.end()) {
			return it->second;
		}
	}

	return """";
}

bool CChan::HasMode(unsigned char uMode) const {
	return (uMode && m_musModes.find(uMode) != m_musModes.end());
}

bool CChan::AddMode(unsigned char uMode, const CString& sArg) {
	m_musModes[uMode] = sArg;
	return true;
}

bool CChan::RemMode(unsigned char uMode, const CString& sArg) {
	if (!HasMode(uMode)) {
		return false;
	}

	m_musModes.erase(uMode);
	return true;
}

CString CChan::GetModeArg(CString& sArgs) const {
	CString sRet = sArgs.substr(0, sArgs.find(' '));
	sArgs = (sRet.size() < sArgs.size()) ? sArgs.substr(sRet.size() +1) : """";
	return sRet;
}

void CChan::ClearNicks() {
	for (map<CString,CNick*>::iterator a = m_msNicks.begin(); a != m_msNicks.end(); a++) {
		delete a->second;
	}

	m_msNicks.clear();
}

int CChan::AddNicks(const CString& sNicks) {
	int iRet = 0;
	VCString vsNicks;
	VCString::iterator it;

	sNicks.Split("" "", vsNicks, false);

	for (it = vsNicks.begin(); it != vsNicks.end(); it++) {
		if (AddNick(*it)) {
			iRet++;
		}
	}

	return iRet;
}

bool CChan::AddNick(const CString& sNick) {
	const char* p = sNick.c_str();
	CString sPrefix, sTmp, sIdent, sHost;

	while (m_pUser->GetIRCSock()->IsPermChar(*p)) {
		sPrefix += *p;

		if (!*++p) {
			return false;
		}
	}

	sTmp = p;
	sIdent = sTmp.Token(1, true, ""!"").Token(0, false, ""@"");
	sHost = sTmp.Token(1, true, ""@"");
	sTmp = sTmp.Token(0, false, ""!"");

	CNick* pNick = FindNick(sTmp);
	if (!pNick) {
		pNick = new CNick(sTmp);
		pNick->SetUser(m_pUser);
	}

	if (!sIdent.empty())
		pNick->SetIdent(sIdent);
	if (!sHost.empty())
		pNick->SetHost(sHost);

	for (CString::size_type i = 0; i < sPrefix.length(); i++) {
		pNick->AddPerm(sPrefix[i]);
	}

	if (pNick->GetNick().Equals(m_pUser->GetCurNick())) {
		for (CString::size_type i = 0; i < sPrefix.length(); i++) {
			AddPerm(sPrefix[i]);
		}
	}

	m_msNicks[pNick->GetNick()] = pNick;

	return true;
}

map<char, unsigned int> CChan::GetPermCounts() const {
	map<char, unsigned int> mRet;

	map<CString,CNick*>::const_iterator it;
	for (it = m_msNicks.begin(); it != m_msNicks.end(); it++) {
		CString sPerms = it->second->GetPermStr();

		for (unsigned int p = 0; p < sPerms.size(); p++) {
			mRet[sPerms[p]]++;
		}
	}

	return mRet;
}

bool CChan::RemNick(const CString& sNick) {
	map<CString,CNick*>::iterator it;
	set<unsigned char>::iterator it2;

	it = m_msNicks.find(sNick);
	if (it == m_msNicks.end()) {
		return false;
	}

	delete it->second;
	m_msNicks.erase(it);

	return true;
}

bool CChan::ChangeNick(const CString& sOldNick, const CString& sNewNick) {
	map<CString,CNick*>::iterator it = m_msNicks.find(sOldNick);

	if (it == m_msNicks.end()) {
		return false;
	}

	// Rename this nick
	it->second->SetNick(sNewNick);

	// Insert a new element into the map then erase the old one, do this to change the key to the new nick
	m_msNicks[sNewNick] = it->second;
	m_msNicks.erase(it);

	return true;
}

CNick* CChan::FindNick(const CString& sNick) const {
	map<CString,CNick*>::const_iterator it = m_msNicks.find(sNick);
	return (it != m_msNicks.end()) ? it->second : NULL;
}

int CChan::AddBuffer(const CString& sLine) {
	// Todo: revisit the buffering
	if (!m_uBufferCount) {
		return 0;
	}

	if (m_vsBuffer.size() >= m_uBufferCount) {
		m_vsBuffer.erase(m_vsBuffer.begin());
	}

	m_vsBuffer.push_back(sLine);
	return m_vsBuffer.size();
}

void CChan::ClearBuffer() {
	m_vsBuffer.clear();
}

void CChan::SendBuffer(CClient* pClient) {
	if (m_pUser && m_pUser->IsUserAttached()) {
		const vector<CString>& vsBuffer = GetBuffer();

		if (vsBuffer.size()) {
			m_pUser->PutUser("":***!znc@znc.in PRIVMSG "" + GetName() + "" :Buffer Playback..."", pClient);

			for (unsigned int a = 0; a < vsBuffer.size(); a++) {
				m_pUser->PutUser(vsBuffer[a], pClient);
			}

			if (!KeepBuffer()) {
				ClearBuffer();
			}

			m_pUser->PutUser("":***!znc@znc.in PRIVMSG "" + GetName() + "" :Playback Complete."", pClient);
		}
	}
}
""",CChan::AddNicks,[373:387]
znc,https://github.com/znc/znc/commit/f5eff8196f8021a5a162e0ae23c09d2295334212,"""Make CString::Trim*() faster

Before, they would remove one character at a time.
Now they do everything at once.


git-svn-id: https://znc.svn.sourceforge.net/svnroot/znc/trunk@1322 726aef4b-f618-498e-8847-2d620e286838""","""/*
 * Copyright (C) 2004-2009  See the AUTHORS file for details.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 as published
 * by the Free Software Foundation.
 */

#include ""ZNCString.h""
#include ""FileUtils.h""
#include ""MD5.h""
#include ""Utils.h""
#include <sstream>

using std::stringstream;

static const char* const g_szHTMLescapes[256] = {
	""&#0;"", 0, 0, 0, 0, 0, 0, 0, 0, 0,               // 0-9
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                    // 10-19
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                    // 20-29
	0, 0, 0, 0, ""&quot;"", 0, 0, 0, ""&amp;"", ""&#39;"", // 30-39
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                    // 40-49
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                    // 50-59
	""&lt;"", 0, ""&gt;"", 0, 0, 0, 0, 0, 0, 0,          // 60-69
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                    // 70-79
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                    // 80-89
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                    // 90-99
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                    // 100-109
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                    // 110-119
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                    // 120-129
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                    // 130-139
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                    // 140-149
	0, 0, 0, ""&trade;"", 0, 0, 0, 0, 0, 0,            // 150-159
	""&nbsp;"",   // 160
	""&iexcl;"",  // 161
	""&cent;"",   // 162
	""&pound;"",  // 163
	""&curren;"", // 164
	""&yen;"",    // 165
	""&brvbar;"", // 166
	""&sect;"",   // 167
	""&uml;"",    // 168
	""&copy;"",   // 169
	""&ordf;"",   // 170
	""&laquo;"",  // 171
	""&not;"",    // 172
	""&shy;"",    // 173
	""&reg;"",    // 174
	""&macr;"",   // 175
	""&deg;"",    // 176
	""&plusmn;"", // 177
	""&sup2;"",   // 178
	""&sup3;"",   // 179
	""&acute;"",  // 180
	""&micro;"",  // 181
	""&para;"",   // 182
	""&middot;"", // 183
	""&cedil;"",  // 184
	""&sup1;"",   // 185
	""&ordm;"",   // 186
	""&raquo;"",  // 187
	""&frac14;"", // 188
	""&frac12;"", // 189
	""&frac34;"", // 190
	""&iquest;"", // 191
	""&Agrave;"", // 192
	""&Aacute;"", // 193
	""&Acirc;"",  // 194
	""&Atilde;"", // 195
	""&Auml;"",   // 196
	""&Aring;"",  // 197
	""&AElig;"",  // 198
	""&Ccedil;"", // 199
	""&Egrave;"", // 200
	""&Eacute;"", // 201
	""&Ecirc;"",  // 202
	""&Euml;"",   // 203
	""&Igrave;"", // 204
	""&Iacute;"", // 205
	""&Icirc;"",  // 206
	""&Iuml;"",   // 207
	""&ETH;"",    // 208
	""&Ntilde;"", // 209
	""&Ograve;"", // 210
	""&Oacute;"", // 211
	""&Ocirc;"",  // 212
	""&Otilde;"", // 213
	""&Ouml;"",   // 214
	""&times;"",  // 215
	""&Oslash;"", // 216
	""&Ugrave;"", // 217
	""&Uacute;"", // 218
	""&Ucirc;"",  // 219
	""&Uuml;"",   // 220
	""&Yacute;"", // 221
	""&THORN;"",  // 222
	""&szlig;"",  // 223
	""&agrave;"", // 224
	""&aacute;"", // 225
	""&acirc;"",  // 226
	""&atilde;"", // 227
	""&auml;"",   // 228
	""&aring;"",  // 229
	""&aelig;"",  // 230
	""&ccedil;"", // 231
	""&egrave;"", // 232
	""&eacute;"", // 233
	""&ecirc;"",  // 234
	""&euml;"",   // 235
	""&igrave;"", // 236
	""&iacute;"", // 237
	""&icirc;"",  // 238
	""&iuml;"",   // 239
	""&eth;"",    // 240
	""&ntilde;"", // 241
	""&ograve;"", // 242
	""&oacute;"", // 243
	""&ocirc;"",  // 244
	""&otilde;"", // 245
	""&ouml;"",   // 246
	""&divide;"", // 247
	""&oslash;"", // 248
	""&ugrave;"", // 249
	""&uacute;"", // 250
	""&ucirc;"",  // 251
	""&uuml;"",   // 252
	""&yacute;"", // 253
	""&thorn;"",  // 254
	""&yuml;"",   // 255
};

CString::CString(char c) : string() { stringstream s; s << c; *this = s.str(); }
CString::CString(unsigned char c) : string() { stringstream s; s << c; *this = s.str(); }
CString::CString(short i) : string() { stringstream s; s << i; *this = s.str(); }
CString::CString(unsigned short i) : string() { stringstream s; s << i; *this = s.str(); }
CString::CString(int i) : string() { stringstream s; s << i; *this = s.str(); }
CString::CString(unsigned int i) : string() { stringstream s; s << i; *this = s.str(); }
CString::CString(long i) : string() { stringstream s; s << i; *this = s.str(); }
CString::CString(unsigned long i) : string() { stringstream s; s << i; *this = s.str(); }
CString::CString(long long i) : string() { stringstream s; s << i; *this = s.str(); }
CString::CString(unsigned long long i) : string() { stringstream s; s << i; *this = s.str(); }
CString::CString(double i) : string() { stringstream s; s << i; *this = s.str(); }
CString::CString(float i) : string() { stringstream s; s << i; *this = s.str(); }

inline unsigned char* CString::strnchr(const unsigned char* src, unsigned char c, unsigned int iMaxBytes, unsigned char* pFill, unsigned int* piCount) const {
	for (unsigned int a = 0; a < iMaxBytes && *src; a++, src++) {
		if (pFill) {
			pFill[a] = *src;
		}

		if (*src == c) {
			if (pFill) {
				pFill[a +1] = 0;
			}

			if (piCount) {
				*piCount = a;
			}

			return (unsigned char*) src;
		}
	}

	if (pFill) {
		*pFill = 0;
	}

	if (piCount) {
		*piCount = 0;
	}

	return NULL;
}

int CString::CaseCmp(const CString& s, unsigned long uLen) const {
	if (uLen != CString::npos) {
		return strncasecmp(c_str(), s.c_str(), uLen);
	}
	return strcasecmp(c_str(), s.c_str());
}

int CString::StrCmp(const CString& s, unsigned long uLen) const {
	if (uLen != CString::npos) {
		return strncmp(c_str(), s.c_str(), uLen);
	}
	return strcmp(c_str(), s.c_str());
}

bool CString::Equals(const CString& s, bool bCaseSensitive, unsigned long uLen) const {
	if (bCaseSensitive)
		return (StrCmp(s, uLen) == 0);
	else
		return (CaseCmp(s, uLen) == 0);
}

bool CString::WildCmp(const CString& sWild, const CString& sString) {
	// Written by Jack Handy - jakkhandy@hotmail.com
	const char *wild = sWild.c_str(), *CString = sString.c_str();
	const char *cp = NULL, *mp = NULL;

	while ((*CString) && (*wild != '*')) {
		if ((*wild != *CString) && (*wild != '?')) {
			return false;
		}

		wild++;
		CString++;
	}

	while (*CString) {
		if (*wild == '*') {
			if (!*++wild) {
				return true;
			}

			mp = wild;
			cp = CString+1;
		} else if ((*wild == *CString) || (*wild == '?')) {
			wild++;
			CString++;
		} else {
			wild = mp;
			CString = cp++;
		}
	}

	while (*wild == '*') {
		wild++;
	}

	return (*wild == 0);
}

bool CString::WildCmp(const CString& sWild) const {
	return CString::WildCmp(sWild, *this);
}

CString& CString::MakeUpper() {
	for (unsigned int a = 0; a < length(); a++) {
		char& c = (*this)[a];
		c = toupper(c);
	}

	return *this;
}

CString& CString::MakeLower() {
	for (unsigned int a = 0; a < length(); a++) {
		char& c = (*this)[a];
		c = tolower(c);
	}

	return *this;
}

CString CString::AsUpper() const {
	CString sRet = *this;

	for (unsigned int a = 0; a < length(); a++) {
		char& c = sRet[a];
		c = toupper(c);
	}

	return sRet;
}

CString CString::AsLower() const {
	CString sRet = *this;

	for (unsigned int a = 0; a < length(); a++) {
		char& c = sRet[a];
		c = tolower(c);
	}

	return sRet;
}

CString::EEscape CString::ToEscape(const CString& sEsc) {
	if (sEsc.Equals(""ASCII"")) {
		return EASCII;
	} else if (sEsc.Equals(""HTML"")) {
		return EHTML;
	} else if (sEsc.Equals(""URL"")) {
		return EURL;
	} else if (sEsc.Equals(""SQL"")) {
		return ESQL;
	}

	return EASCII;
}

CString CString::Escape_n(EEscape eFrom, EEscape eTo) const {
	CString sRet;
	const char szHex[] = ""0123456789ABCDEF"";
	const unsigned char *pStart = (const unsigned char*) data();
	const unsigned char *p = (const unsigned char*) data();
	unsigned int iLength = length();
	sRet.reserve(iLength *3);
	unsigned int iMaxLen = (eFrom == EHTML) ? 20 : 0;
	unsigned char pTmp[iMaxLen +1];
	unsigned int iCounted = 0;

	for (unsigned int a = 0; a < iLength; a++, p = pStart + a) {
		unsigned char ch = 0;

		switch (eFrom) {
			case EHTML:
				if ((*p == '&') && (strnchr((unsigned char*) p, ';', iMaxLen, pTmp, &iCounted))) {
					if ((iCounted >= 3) && (pTmp[1] == '#')) {	// do XML and HTML &#97; &#x3c
						int base = 10;

						if ((pTmp[2] & 0xDF) == 'X') {
							base = 16;
						}

						char* endptr = NULL;
						unsigned int b = strtol((const char*) (pTmp +2 + (base == 16)), &endptr, base);

						if ((*endptr == ';') && (b <= 255)) { // incase they do something like &#7777777777;
							ch = b;
							a += iCounted;
							break;
						}
					}

					for (unsigned int c = 0; c < 256; c++) {
						if (g_szHTMLescapes[c] && strcmp(g_szHTMLescapes[c], (const char*) &pTmp) == 0) {
							ch = c;
							break;
						}
					}

					if (ch > 0) {
						a += iCounted;
					} else {
						ch = *p;	 // Not a valid escape, just record the &
					}
				} else {
					ch = *p;
				}
				break;
			case EASCII:
				ch = *p;
				break;
			case EURL:
				if (*p == '%' && (a +2) < iLength && isxdigit(*(p +1)) && isxdigit(*(p +2))) {
					p++;
					if (isdigit(*p)) {
						ch = (*p - '0') << 4;
					} else {
						ch = (tolower(*p) - 'a' +10) << 4;
					}

					p++;
					if (isdigit(*p)) {
						ch |= (*p - '0');
					} else {
						ch |= (tolower(*p) - 'a' +10);
					}

					a += 2;
				} else if (pStart[a] == '+') {
					ch = ' ';
				} else {
					ch = *p;
				}

				break;
			case ESQL:
				if (*p != '\\' || iLength < (a +1)) {
					ch = *p;
				} else {
					a++;
					p++;

					if (*p == 'n') {
						ch = '\n';
					} else if (*p == 'r') {
						ch = '\r';
					} else if (*p == '0') {
						ch = '\0';
					} else if (*p == 't') {
						ch = '\t';
					} else if (*p == 'b') {
						ch = '\b';
					} else {
						ch = *p;
					}
				}

				break;
		}

		switch (eTo) {
			case EHTML:
				if (g_szHTMLescapes[ch]) {
					sRet += g_szHTMLescapes[ch];
				} else {
					sRet += ch;
				}

				break;
			case EASCII:
				sRet += ch;
				break;
			case EURL:
				if (isalnum(ch) || ch == '_' || ch == '.' || ch == '-') {
					sRet += ch;
				} else if (ch == ' ') {
					sRet += '+';
				} else {
					sRet += '%';
					sRet += szHex[ch >> 4];
					sRet += szHex[ch & 0xf];
				}

				break;
			case ESQL:
				if (ch == '\0') { sRet += '\\'; sRet += '0';
				} else if (ch == '\n') { sRet += '\\'; sRet += 'n';
				} else if (ch == '\t') { sRet += '\\'; sRet += 't';
				} else if (ch == '\r') { sRet += '\\'; sRet += 'r';
				} else if (ch == '\b') { sRet += '\\'; sRet += 'b';
				} else if (ch == '\""') { sRet += '\\'; sRet += '\""';
				} else if (ch == '\'') { sRet += '\\'; sRet += '\'';
				} else if (ch == '\\') { sRet += '\\'; sRet += '\\';
				} else { sRet += ch; }

				break;
		}
	}

	sRet.reserve(0);
	return sRet;
}

CString CString::Escape_n(EEscape eTo) const {
	return Escape_n(EASCII, eTo);
}

CString& CString::Escape(EEscape eFrom, EEscape eTo) {
	return (*this = Escape_n(eFrom, eTo));
}

CString& CString::Escape(EEscape eTo) {
	return (*this = Escape_n(eTo));
}

CString CString::Replace_n(const CString& sReplace, const CString& sWith, const CString& sLeft, const CString& sRight, bool bRemoveDelims) const {
	CString sRet = *this;
	CString::Replace(sRet, sReplace, sWith, sLeft, sRight, bRemoveDelims);
	return sRet;
}

unsigned int CString::Replace(const CString& sReplace, const CString& sWith, const CString& sLeft, const CString& sRight, bool bRemoveDelims) {
	return CString::Replace(*this, sReplace, sWith, sLeft, sRight, bRemoveDelims);
}

unsigned int CString::Replace(CString& sStr, const CString& sReplace, const CString& sWith, const CString& sLeft, const CString& sRight, bool bRemoveDelims) {
	unsigned int uRet = 0;
	CString sCopy = sStr;
	sStr.clear();

	unsigned int uReplaceWidth = sReplace.length();
	unsigned int uLeftWidth = sLeft.length();
	unsigned int uRightWidth = sRight.length();
	const char* p = sCopy.c_str();
	bool bInside = false;

	while (*p) {
		if (!bInside && uLeftWidth && strncmp(p, sLeft.c_str(), uLeftWidth) == 0) {
			if (!bRemoveDelims) {
				sStr += sLeft;
			}

			p += uLeftWidth -1;
			bInside = true;
		} else if (bInside && uRightWidth && strncmp(p, sRight.c_str(), uRightWidth) == 0) {
			if (!bRemoveDelims) {
				sStr += sRight;
			}

			p += uRightWidth -1;
			bInside = false;
		} else if (!bInside && strncmp(p, sReplace.c_str(), uReplaceWidth) == 0) {
			sStr += sWith;
			p += uReplaceWidth -1;
			uRet++;
		} else {
			sStr.append(p, 1);
		}

		p++;
	}

	return uRet;
}

CString CString::Token(unsigned int uPos, bool bRest, const CString& sSep) const {
	const char *sep_str = sSep.c_str();
	size_t sep_len = sSep.length();
	const char *str = c_str();
	size_t str_len = length();
	size_t start_pos = 0;
	size_t end_pos;

	// First, find the start of our token
	while (uPos != 0 && start_pos < str_len) {
		if (strncmp(&str[start_pos], sep_str, sep_len) == 0) {
			start_pos += sep_len;
			uPos--;
		} else {
			start_pos++;
		}
	}

	// String is over?
	if (start_pos >= str_len)
		return """";

	// If they want everything from here on, give it to them
	if (bRest) {
		return substr(start_pos);
	}

	// Now look for the end of the token they want
	end_pos = start_pos;
	while (end_pos < str_len) {
		if (strncmp(&str[end_pos], sep_str, sep_len) == 0)
			return substr(start_pos, end_pos - start_pos);

		end_pos++;
	}

	// They want the last token in the string, not something in between
	return substr(start_pos);
}

CString CString::Ellipsize(unsigned int uLen) const {
	if (uLen >= size()) {
		return *this;
	}

	string sRet;

	// @todo this looks suspect
	if (uLen < 4) {
		for (unsigned int a = 0; a < uLen; a++) {
			sRet += ""."";
		}

		return sRet;
	}

	sRet = substr(0, uLen -3) + ""..."";

	return sRet;
}

CString CString::Left(unsigned int uCount) const {
	uCount = (uCount > length()) ? length() : uCount;
	return substr(0, uCount);
}

CString CString::Right(unsigned int uCount) const {
	uCount = (uCount > length()) ? length() : uCount;
	return substr(length() - uCount, uCount);
}

unsigned int CString::URLSplit(MCString& msRet) const {
	msRet.clear();

	VCString vsPairs;
	Split(""&"", vsPairs);

	for (size_t a = 0; a < vsPairs.size(); a++) {
		const CString& sPair = vsPairs[a];

		msRet[sPair.Token(0, false, ""="").Escape(CString::EURL, CString::EASCII)] = sPair.Token(1, true, ""="").Escape(CString::EURL, CString::EASCII);
	}

	return msRet.size();
}

unsigned int CString::Split(const CString& sDelim, VCString& vsRet, bool bAllowEmpty, const CString& sLeft, const CString& sRight) const {
	vsRet.clear();

	if (empty()) {
		return 0;
	}

	CString sTmp;
	bool bInside = false;
	unsigned int uDelimLen = sDelim.length();
	unsigned int uLeftLen = sLeft.length();
	unsigned int uRightLen = sRight.length();
	const char* p = c_str();

	if (!bAllowEmpty) {
		while (strncasecmp(p, sDelim.c_str(), uDelimLen) == 0) {
			p += uDelimLen;
		}
	}

	while (*p) {
		if (uLeftLen && uRightLen && !bInside && strncasecmp(p, sLeft.c_str(), uLeftLen) == 0) {
			p += uLeftLen;
			bInside = true;
			continue;
		}

		if (uLeftLen && uRightLen && bInside && strncasecmp(p, sRight.c_str(), uRightLen) == 0) {
			p += uRightLen;
			bInside = false;
			continue;
		}

		if (uDelimLen && !bInside && strncasecmp(p, sDelim.c_str(), uDelimLen) == 0) {
			vsRet.push_back(sTmp);
			sTmp.clear();
			p += uDelimLen;

			if (!bAllowEmpty) {
				while (strncasecmp(p, sDelim.c_str(), uDelimLen) == 0) {
					p += uDelimLen;
				}
			}

			bInside = false;
			continue;
		} else {
			sTmp += *p;
		}

		p++;
	}

	if (!sTmp.empty()) {
		vsRet.push_back(sTmp);
	}

	return vsRet.size();

	/*vsRet.clear();
	CString sTmp = *this;

	while (sTmp.size()) {
		CString sTok = sTmp.Token(0, false, sDelim);
		CString sRest = sTmp.Token(1, true, sDelim);

		if (bAllowEmpty || !sTok.empty()) {
			vsRet.push_back(sTok);
		}

		if (bAllowEmpty && sRest.empty() && sTok.size() < sTmp.size()) {
			vsRet.push_back("""");
		}

		sTmp = sRest;
	}

	return vsRet.size();*/
}

unsigned int CString::Split(const CString& sDelim, SCString& ssRet, bool bAllowEmpty, const CString& sLeft, const CString& sRight) const {
	VCString vsTokens;

	Split(sDelim, vsTokens, bAllowEmpty, sLeft, sRight);

	ssRet.clear();

	for (size_t a = 0; a < vsTokens.size(); a++) {
		ssRet.insert(vsTokens[a]);
	}

	return ssRet.size();
}

CString CString::RandomString(unsigned int uLength) {
	const char chars[] = ""abcdefghijklmnopqrstuvwxyz""
		""ABCDEFGHIJKLMNOPQRSTUVWXYZ""
		""0123456789!?.,:;/*-+_()"";
	// -1 because sizeof() includes the trailing '\0' byte
	const size_t len = sizeof(chars) / sizeof(chars[0]) - 1;
	size_t p;
	CString sRet;

	for (unsigned int a = 0; a < uLength; a++) {
		p = (size_t) (len * (rand() / (RAND_MAX + 1.0)));
		sRet += chars[p];
	}

	return sRet;
}

bool CString::Base64Encode(unsigned int uWrap) {
	CString sCopy(*this);
	return sCopy.Base64Encode(*this, uWrap);
}

unsigned long CString::Base64Decode() {
	CString sCopy(*this);
	return sCopy.Base64Decode(*this);
}

CString CString::Base64Encode_n(unsigned int uWrap) const {
	CString sRet;
	Base64Encode(sRet, uWrap);
	return sRet;
}

CString CString::Base64Decode_n() const {
	CString sRet;
	Base64Decode(sRet);
	return sRet;
}

bool CString::Base64Encode(CString& sRet, unsigned int uWrap) const {
	const char b64table[] = ""ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"";
	sRet.clear();
	size_t len = size();
	const unsigned char* input = (const unsigned char*) c_str();
	unsigned char *output, *p;
	size_t        i = 0, mod = len % 3, toalloc;
	toalloc = (len / 3) * 4 + (3 - mod) % 3 + 1 + 8;

	if (uWrap) {
		toalloc += len / 57;
		if (len % 57) {
			toalloc++;
		}
	}

	if (toalloc < len) {
		return 0;
	}

	//p = output = (unsigned char *)malloc(toalloc);
	p = output = new unsigned char [toalloc];

	if (!p) {
		return false;
	}

	while (i < len - mod) {
		*p++ = b64table[input[i++] >> 2];
		*p++ = b64table[((input[i - 1] << 4) | (input[i] >> 4)) & 0x3f];
		*p++ = b64table[((input[i] << 2) | (input[i + 1] >> 6)) & 0x3f];
		*p++ = b64table[input[i + 1] & 0x3f];
		i += 2;

		if (uWrap && !(i % 57)) {
			*p++ = '\n';
		}
	}

	if (!mod) {
		if (uWrap && i % 57) {
			*p++ = '\n';
		}
	} else {
		*p++ = b64table[input[i++] >> 2];
		*p++ = b64table[((input[i - 1] << 4) | (input[i] >> 4)) & 0x3f];
		if (mod == 1) {
			*p++ = '=';
		} else {
			*p++ = b64table[(input[i] << 2) & 0x3f];
		}

		*p++ = '=';

		if (uWrap) {
			*p++ = '\n';
		}
	}

	*p = 0;
	sRet = (char*) output;
	delete[] output;
	return true;
}

unsigned long CString::Base64Decode(CString& sRet) const {
	const char* in = c_str();
	char c, c1, *p;
	unsigned long i;
	unsigned long uLen = size();
	char* out = (char*) malloc(size() +1);

	for (i = 0, p = out; i < uLen; i++) {
		c = (char)base64_table[(unsigned char)in[i++]];
		c1 = (char)base64_table[(unsigned char)in[i++]];
		*p++ = (c << 2) | ((c1 >> 4) & 0x3);

		if (i < uLen) {
			if (in[i] == '=') {
				break;
			}
			c = (char)base64_table[(unsigned char)in[i]];
			*p++ = ((c1 << 4) & 0xf0) | ((c >> 2) & 0xf);
		}

		if (++i < uLen) {
			if (in[i] == '=') {
				break;
			}
			*p++ = ((c << 6) & 0xc0) | (char)base64_table[(unsigned char)in[i]];
		}
	}

	*p = '\0';
	unsigned long uRet = p - out;
	sRet.clear();
	sRet.append(out, uRet);
	free(out);

	return uRet;
}

CString CString::MD5() const {
	return (const char*) CMD5(*this);
}

#ifdef HAVE_LIBSSL
CString CString::Encrypt_n(const CString& sPass, const CString& sIvec) {
	CString sRet;
	sRet.Encrypt(sPass, sIvec);
	return sRet;
}

CString CString::Decrypt_n(const CString& sPass, const CString& sIvec) {
	CString sRet;
	sRet.Decrypt(sPass, sIvec);
	return sRet;
}

void CString::Encrypt(const CString& sPass, const CString& sIvec) {
	Crypt(sPass, true, sIvec);
}

void CString::Decrypt(const CString& sPass, const CString& sIvec) {
	Crypt(sPass, false, sIvec);
}

void CString::Crypt(const CString& sPass, bool bEncrypt, const CString& sIvec) {
	unsigned char szIvec[8] = {0,0,0,0,0,0,0,0};
	BF_KEY bKey;

	if (sIvec.length() >= 8) {
		memcpy(szIvec, sIvec.data(), 8);
	}

	BF_set_key(&bKey, sPass.length(), (unsigned char*) sPass.data());
	unsigned int uPad = (length() % 8);

	if (uPad) {
		uPad = 8 - uPad;
		append(uPad, '\0');
	}

	size_t uLen = length();
	unsigned char* szBuff = (unsigned char*) malloc(uLen);
	BF_cbc_encrypt((const unsigned char*) data(), szBuff, uLen, &bKey, szIvec, ((bEncrypt) ? BF_ENCRYPT : BF_DECRYPT));

	clear();
	append((const char*) szBuff, uLen);
	free(szBuff);
}
#endif	// HAVE_LIBSSL

CString CString::ToPercent(double d) {
	char szRet[32];
	snprintf(szRet, 32, ""%.02f%%"", d);
	return szRet;
}

CString CString::ToByteStr(unsigned long long d) {
	const unsigned long long KiB = 1024;
	const unsigned long long MiB = KiB * 1024;
	const unsigned long long GiB = MiB * 1024;
	const unsigned long long TiB = GiB * 1024;

	if (d > TiB) {
		return CString(d / (double) TiB) + "" TiB"";
	} else if (d > GiB) {
		return CString(d / (double) GiB) + "" GiB"";
	} else if (d > MiB) {
		return CString(d / (double) MiB) + "" MiB"";
	} else if (d > KiB) {
		return CString(d / (double) KiB) + "" KiB"";
	}

	return CString(d) + "" B"";
}

CString CString::ToTimeStr(unsigned long s) {
	const unsigned long m = 60;
	const unsigned long h = m * 60;
	const unsigned long d = h * 24;
	const unsigned long w = d * 7;
	const unsigned long y = d * 365;
	CString sRet;

#define TIMESPAN(time, str)			\
	if (s >= time) {		\
		sRet += CString(s / time) + str "" ""; \
		s = s % time;		\
	}
	TIMESPAN(y, ""y"");
	TIMESPAN(w, ""w"");
	TIMESPAN(d, ""d"");
	TIMESPAN(h, ""h"");
	TIMESPAN(m, ""m"");
	TIMESPAN(1, ""s"");

	if (sRet.empty())
		return ""0s"";

	return sRet.RightChomp_n();
}

bool CString::ToBool() const { return (!Trim_n().Trim_n(""0"").empty() && !Trim_n().Equals(""false"")); }
short CString::ToShort() const { return strtoul(this->c_str(), (char**) NULL, 10); }
unsigned short CString::ToUShort() const { return strtoul(this->c_str(), (char**) NULL, 10); }
unsigned int CString::ToUInt() const { return strtoul(this->c_str(), (char**) NULL, 10); }
int CString::ToInt() const { return strtoul(this->c_str(), (char**) NULL, 10); }
long CString::ToLong() const { return strtoul(this->c_str(), (char**) NULL, 10); }
unsigned long CString::ToULong() const { return strtoul(c_str(), NULL, 10); }
unsigned long long CString::ToULongLong() const { return strtoull(c_str(), NULL, 10); }
long long CString::ToLongLong() const { return strtoll(c_str(), NULL, 10); }
double CString::ToDouble() const { return strtod(c_str(), NULL); }


bool CString::Trim(const CString& s) {
	bool bLeft = TrimLeft(s);
	return (TrimRight(s) || bLeft);
}

bool CString::TrimLeft(const CString& s) {
	bool bRet = false;

	while (length() && s.find(Left(1)) != CString::npos) {
		LeftChomp();
		bRet = true;
	}

	return bRet;
}

bool CString::TrimRight(const CString& s) {
	bool bRet = false;

	while (length() && s.find(Right(1)) != CString::npos) {
		RightChomp();
		bRet = true;
	}

	return bRet;
}

CString CString::Trim_n(const CString& s) const {
	CString sRet = *this;
	sRet.Trim(s);
	return sRet;
}

CString CString::TrimLeft_n(const CString& s) const {
	CString sRet = *this;
	sRet.TrimLeft(s);
	return sRet;
}

CString CString::TrimRight_n(const CString& s) const {
	CString sRet = *this;
	sRet.TrimRight(s);
	return sRet;
}

bool CString::TrimPrefix(const CString& sPrefix) {
	if (Equals(sPrefix, false, sPrefix.length())) {
		LeftChomp(sPrefix.length());
		return true;
	} else {
		return false;
	}
}

bool CString::TrimSuffix(const CString& sSuffix) {
	if (Right(sSuffix.length()).Equals(sSuffix)) {
		RightChomp(sSuffix.length());
		return true;
	} else {
		return false;
	}
}


CString CString::TrimPrefix_n(const CString& sPrefix) const {
	CString sRet = *this;
	sRet.TrimPrefix(sPrefix);
	return sRet;
}

CString CString::TrimSuffix_n(const CString& sSuffix) const {
	CString sRet = *this;
	sRet.TrimSuffix(sSuffix);
	return sRet;
}

CString CString::LeftChomp_n(unsigned int uLen) const {
	CString sRet = *this;
	sRet.LeftChomp(uLen);
	return sRet;
}

CString CString::RightChomp_n(unsigned int uLen) const {
	CString sRet = *this;
	sRet.RightChomp(uLen);
	return sRet;
}

bool CString::LeftChomp(unsigned int uLen) {
	bool bRet = false;

	while ((uLen--) && (length())) {
		erase(0, 1);
		bRet = true;
	}

	return bRet;
}

bool CString::RightChomp(unsigned int uLen) {
	bool bRet = false;

	while ((uLen--) && (length())) {
		erase(length() -1);
		bRet = true;
	}

	return bRet;
}

//////////////// MCString ////////////////
int MCString::WriteToDisk(const CString& sPath, mode_t iMode) {
	CFile cFile(sPath);

	if (this->empty()) {
		if (!cFile.Exists())
			return MCS_SUCCESS;
		if (cFile.Delete())
			return MCS_SUCCESS;
	}

	if (!cFile.Open(O_WRONLY|O_CREAT|O_TRUNC, iMode)) {
		return MCS_EOPEN;
	}

	for (MCString::iterator it = this->begin(); it != this->end(); it++) {
		CString sKey = it->first;
		CString sValue = it->second;
		if (!WriteFilter(sKey, sValue)) {
			return MCS_EWRITEFIL;
		}

		if (sKey.empty()) {
			continue;
		}

		if (cFile.Write(Encode(sKey) + "" "" +  Encode(sValue) + ""\n"") <= 0) {
			return MCS_EWRITE;
		}
	}

	cFile.Close();

	return MCS_SUCCESS;
}

int MCString::ReadFromDisk(const CString& sPath, mode_t iMode) {
	clear();
	CFile cFile(sPath);
	if (!cFile.Open(O_RDONLY, iMode)) {
		return MCS_EOPEN;
	}

	CString sBuffer;

	while (cFile.ReadLine(sBuffer)) {
		sBuffer.Trim();
		CString sKey = sBuffer.Token(0);
		CString sValue = sBuffer.Token(1);
		Decode(sKey);
		Decode(sValue);

		if (!ReadFilter(sKey, sValue))
			return MCS_EREADFIL;

		(*this)[sKey] = sValue;
	}
	cFile.Close();

	return MCS_SUCCESS;
}


static const char hexdigits[] = ""0123456789abcdef"";

CString& MCString::Encode(CString& sValue) {
	CString sTmp;
	for (CString::iterator it = sValue.begin(); it != sValue.end(); it++) {
		if (isalnum(*it)) {
			sTmp += *it;
		} else {
			sTmp += ""%"";
			sTmp += hexdigits[*it >> 4];
			sTmp += hexdigits[*it & 0xf];
			sTmp += "";"";
		}
	}
	sValue = sTmp;
	return sValue;
}

CString& MCString::Decode(CString& sValue) {
	const char *pTmp = sValue.c_str();
	char *endptr;
	CString sTmp;

	while (*pTmp) {
		if (*pTmp != '%') {
			sTmp += *pTmp++;
		} else {
			char ch = (char) strtol(pTmp + 1, &endptr, 16);
			if (*endptr == ';') {
				sTmp += ch;
				pTmp = ++endptr;
			} else {
				sTmp += *pTmp++;
			}
		}
	}

	sValue = sTmp;
	return sValue;
}
""","""/*
 * Copyright (C) 2004-2009  See the AUTHORS file for details.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 as published
 * by the Free Software Foundation.
 */

#include ""ZNCString.h""
#include ""FileUtils.h""
#include ""MD5.h""
#include ""Utils.h""
#include <sstream>

using std::stringstream;

static const char* const g_szHTMLescapes[256] = {
	""&#0;"", 0, 0, 0, 0, 0, 0, 0, 0, 0,               // 0-9
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                    // 10-19
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                    // 20-29
	0, 0, 0, 0, ""&quot;"", 0, 0, 0, ""&amp;"", ""&#39;"", // 30-39
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                    // 40-49
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                    // 50-59
	""&lt;"", 0, ""&gt;"", 0, 0, 0, 0, 0, 0, 0,          // 60-69
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                    // 70-79
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                    // 80-89
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                    // 90-99
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                    // 100-109
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                    // 110-119
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                    // 120-129
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                    // 130-139
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                    // 140-149
	0, 0, 0, ""&trade;"", 0, 0, 0, 0, 0, 0,            // 150-159
	""&nbsp;"",   // 160
	""&iexcl;"",  // 161
	""&cent;"",   // 162
	""&pound;"",  // 163
	""&curren;"", // 164
	""&yen;"",    // 165
	""&brvbar;"", // 166
	""&sect;"",   // 167
	""&uml;"",    // 168
	""&copy;"",   // 169
	""&ordf;"",   // 170
	""&laquo;"",  // 171
	""&not;"",    // 172
	""&shy;"",    // 173
	""&reg;"",    // 174
	""&macr;"",   // 175
	""&deg;"",    // 176
	""&plusmn;"", // 177
	""&sup2;"",   // 178
	""&sup3;"",   // 179
	""&acute;"",  // 180
	""&micro;"",  // 181
	""&para;"",   // 182
	""&middot;"", // 183
	""&cedil;"",  // 184
	""&sup1;"",   // 185
	""&ordm;"",   // 186
	""&raquo;"",  // 187
	""&frac14;"", // 188
	""&frac12;"", // 189
	""&frac34;"", // 190
	""&iquest;"", // 191
	""&Agrave;"", // 192
	""&Aacute;"", // 193
	""&Acirc;"",  // 194
	""&Atilde;"", // 195
	""&Auml;"",   // 196
	""&Aring;"",  // 197
	""&AElig;"",  // 198
	""&Ccedil;"", // 199
	""&Egrave;"", // 200
	""&Eacute;"", // 201
	""&Ecirc;"",  // 202
	""&Euml;"",   // 203
	""&Igrave;"", // 204
	""&Iacute;"", // 205
	""&Icirc;"",  // 206
	""&Iuml;"",   // 207
	""&ETH;"",    // 208
	""&Ntilde;"", // 209
	""&Ograve;"", // 210
	""&Oacute;"", // 211
	""&Ocirc;"",  // 212
	""&Otilde;"", // 213
	""&Ouml;"",   // 214
	""&times;"",  // 215
	""&Oslash;"", // 216
	""&Ugrave;"", // 217
	""&Uacute;"", // 218
	""&Ucirc;"",  // 219
	""&Uuml;"",   // 220
	""&Yacute;"", // 221
	""&THORN;"",  // 222
	""&szlig;"",  // 223
	""&agrave;"", // 224
	""&aacute;"", // 225
	""&acirc;"",  // 226
	""&atilde;"", // 227
	""&auml;"",   // 228
	""&aring;"",  // 229
	""&aelig;"",  // 230
	""&ccedil;"", // 231
	""&egrave;"", // 232
	""&eacute;"", // 233
	""&ecirc;"",  // 234
	""&euml;"",   // 235
	""&igrave;"", // 236
	""&iacute;"", // 237
	""&icirc;"",  // 238
	""&iuml;"",   // 239
	""&eth;"",    // 240
	""&ntilde;"", // 241
	""&ograve;"", // 242
	""&oacute;"", // 243
	""&ocirc;"",  // 244
	""&otilde;"", // 245
	""&ouml;"",   // 246
	""&divide;"", // 247
	""&oslash;"", // 248
	""&ugrave;"", // 249
	""&uacute;"", // 250
	""&ucirc;"",  // 251
	""&uuml;"",   // 252
	""&yacute;"", // 253
	""&thorn;"",  // 254
	""&yuml;"",   // 255
};

CString::CString(char c) : string() { stringstream s; s << c; *this = s.str(); }
CString::CString(unsigned char c) : string() { stringstream s; s << c; *this = s.str(); }
CString::CString(short i) : string() { stringstream s; s << i; *this = s.str(); }
CString::CString(unsigned short i) : string() { stringstream s; s << i; *this = s.str(); }
CString::CString(int i) : string() { stringstream s; s << i; *this = s.str(); }
CString::CString(unsigned int i) : string() { stringstream s; s << i; *this = s.str(); }
CString::CString(long i) : string() { stringstream s; s << i; *this = s.str(); }
CString::CString(unsigned long i) : string() { stringstream s; s << i; *this = s.str(); }
CString::CString(long long i) : string() { stringstream s; s << i; *this = s.str(); }
CString::CString(unsigned long long i) : string() { stringstream s; s << i; *this = s.str(); }
CString::CString(double i) : string() { stringstream s; s << i; *this = s.str(); }
CString::CString(float i) : string() { stringstream s; s << i; *this = s.str(); }

inline unsigned char* CString::strnchr(const unsigned char* src, unsigned char c, unsigned int iMaxBytes, unsigned char* pFill, unsigned int* piCount) const {
	for (unsigned int a = 0; a < iMaxBytes && *src; a++, src++) {
		if (pFill) {
			pFill[a] = *src;
		}

		if (*src == c) {
			if (pFill) {
				pFill[a +1] = 0;
			}

			if (piCount) {
				*piCount = a;
			}

			return (unsigned char*) src;
		}
	}

	if (pFill) {
		*pFill = 0;
	}

	if (piCount) {
		*piCount = 0;
	}

	return NULL;
}

int CString::CaseCmp(const CString& s, unsigned long uLen) const {
	if (uLen != CString::npos) {
		return strncasecmp(c_str(), s.c_str(), uLen);
	}
	return strcasecmp(c_str(), s.c_str());
}

int CString::StrCmp(const CString& s, unsigned long uLen) const {
	if (uLen != CString::npos) {
		return strncmp(c_str(), s.c_str(), uLen);
	}
	return strcmp(c_str(), s.c_str());
}

bool CString::Equals(const CString& s, bool bCaseSensitive, unsigned long uLen) const {
	if (bCaseSensitive)
		return (StrCmp(s, uLen) == 0);
	else
		return (CaseCmp(s, uLen) == 0);
}

bool CString::WildCmp(const CString& sWild, const CString& sString) {
	// Written by Jack Handy - jakkhandy@hotmail.com
	const char *wild = sWild.c_str(), *CString = sString.c_str();
	const char *cp = NULL, *mp = NULL;

	while ((*CString) && (*wild != '*')) {
		if ((*wild != *CString) && (*wild != '?')) {
			return false;
		}

		wild++;
		CString++;
	}

	while (*CString) {
		if (*wild == '*') {
			if (!*++wild) {
				return true;
			}

			mp = wild;
			cp = CString+1;
		} else if ((*wild == *CString) || (*wild == '?')) {
			wild++;
			CString++;
		} else {
			wild = mp;
			CString = cp++;
		}
	}

	while (*wild == '*') {
		wild++;
	}

	return (*wild == 0);
}

bool CString::WildCmp(const CString& sWild) const {
	return CString::WildCmp(sWild, *this);
}

CString& CString::MakeUpper() {
	for (unsigned int a = 0; a < length(); a++) {
		char& c = (*this)[a];
		c = toupper(c);
	}

	return *this;
}

CString& CString::MakeLower() {
	for (unsigned int a = 0; a < length(); a++) {
		char& c = (*this)[a];
		c = tolower(c);
	}

	return *this;
}

CString CString::AsUpper() const {
	CString sRet = *this;

	for (unsigned int a = 0; a < length(); a++) {
		char& c = sRet[a];
		c = toupper(c);
	}

	return sRet;
}

CString CString::AsLower() const {
	CString sRet = *this;

	for (unsigned int a = 0; a < length(); a++) {
		char& c = sRet[a];
		c = tolower(c);
	}

	return sRet;
}

CString::EEscape CString::ToEscape(const CString& sEsc) {
	if (sEsc.Equals(""ASCII"")) {
		return EASCII;
	} else if (sEsc.Equals(""HTML"")) {
		return EHTML;
	} else if (sEsc.Equals(""URL"")) {
		return EURL;
	} else if (sEsc.Equals(""SQL"")) {
		return ESQL;
	}

	return EASCII;
}

CString CString::Escape_n(EEscape eFrom, EEscape eTo) const {
	CString sRet;
	const char szHex[] = ""0123456789ABCDEF"";
	const unsigned char *pStart = (const unsigned char*) data();
	const unsigned char *p = (const unsigned char*) data();
	unsigned int iLength = length();
	sRet.reserve(iLength *3);
	unsigned int iMaxLen = (eFrom == EHTML) ? 20 : 0;
	unsigned char pTmp[iMaxLen +1];
	unsigned int iCounted = 0;

	for (unsigned int a = 0; a < iLength; a++, p = pStart + a) {
		unsigned char ch = 0;

		switch (eFrom) {
			case EHTML:
				if ((*p == '&') && (strnchr((unsigned char*) p, ';', iMaxLen, pTmp, &iCounted))) {
					if ((iCounted >= 3) && (pTmp[1] == '#')) {	// do XML and HTML &#97; &#x3c
						int base = 10;

						if ((pTmp[2] & 0xDF) == 'X') {
							base = 16;
						}

						char* endptr = NULL;
						unsigned int b = strtol((const char*) (pTmp +2 + (base == 16)), &endptr, base);

						if ((*endptr == ';') && (b <= 255)) { // incase they do something like &#7777777777;
							ch = b;
							a += iCounted;
							break;
						}
					}

					for (unsigned int c = 0; c < 256; c++) {
						if (g_szHTMLescapes[c] && strcmp(g_szHTMLescapes[c], (const char*) &pTmp) == 0) {
							ch = c;
							break;
						}
					}

					if (ch > 0) {
						a += iCounted;
					} else {
						ch = *p;	 // Not a valid escape, just record the &
					}
				} else {
					ch = *p;
				}
				break;
			case EASCII:
				ch = *p;
				break;
			case EURL:
				if (*p == '%' && (a +2) < iLength && isxdigit(*(p +1)) && isxdigit(*(p +2))) {
					p++;
					if (isdigit(*p)) {
						ch = (*p - '0') << 4;
					} else {
						ch = (tolower(*p) - 'a' +10) << 4;
					}

					p++;
					if (isdigit(*p)) {
						ch |= (*p - '0');
					} else {
						ch |= (tolower(*p) - 'a' +10);
					}

					a += 2;
				} else if (pStart[a] == '+') {
					ch = ' ';
				} else {
					ch = *p;
				}

				break;
			case ESQL:
				if (*p != '\\' || iLength < (a +1)) {
					ch = *p;
				} else {
					a++;
					p++;

					if (*p == 'n') {
						ch = '\n';
					} else if (*p == 'r') {
						ch = '\r';
					} else if (*p == '0') {
						ch = '\0';
					} else if (*p == 't') {
						ch = '\t';
					} else if (*p == 'b') {
						ch = '\b';
					} else {
						ch = *p;
					}
				}

				break;
		}

		switch (eTo) {
			case EHTML:
				if (g_szHTMLescapes[ch]) {
					sRet += g_szHTMLescapes[ch];
				} else {
					sRet += ch;
				}

				break;
			case EASCII:
				sRet += ch;
				break;
			case EURL:
				if (isalnum(ch) || ch == '_' || ch == '.' || ch == '-') {
					sRet += ch;
				} else if (ch == ' ') {
					sRet += '+';
				} else {
					sRet += '%';
					sRet += szHex[ch >> 4];
					sRet += szHex[ch & 0xf];
				}

				break;
			case ESQL:
				if (ch == '\0') { sRet += '\\'; sRet += '0';
				} else if (ch == '\n') { sRet += '\\'; sRet += 'n';
				} else if (ch == '\t') { sRet += '\\'; sRet += 't';
				} else if (ch == '\r') { sRet += '\\'; sRet += 'r';
				} else if (ch == '\b') { sRet += '\\'; sRet += 'b';
				} else if (ch == '\""') { sRet += '\\'; sRet += '\""';
				} else if (ch == '\'') { sRet += '\\'; sRet += '\'';
				} else if (ch == '\\') { sRet += '\\'; sRet += '\\';
				} else { sRet += ch; }

				break;
		}
	}

	sRet.reserve(0);
	return sRet;
}

CString CString::Escape_n(EEscape eTo) const {
	return Escape_n(EASCII, eTo);
}

CString& CString::Escape(EEscape eFrom, EEscape eTo) {
	return (*this = Escape_n(eFrom, eTo));
}

CString& CString::Escape(EEscape eTo) {
	return (*this = Escape_n(eTo));
}

CString CString::Replace_n(const CString& sReplace, const CString& sWith, const CString& sLeft, const CString& sRight, bool bRemoveDelims) const {
	CString sRet = *this;
	CString::Replace(sRet, sReplace, sWith, sLeft, sRight, bRemoveDelims);
	return sRet;
}

unsigned int CString::Replace(const CString& sReplace, const CString& sWith, const CString& sLeft, const CString& sRight, bool bRemoveDelims) {
	return CString::Replace(*this, sReplace, sWith, sLeft, sRight, bRemoveDelims);
}

unsigned int CString::Replace(CString& sStr, const CString& sReplace, const CString& sWith, const CString& sLeft, const CString& sRight, bool bRemoveDelims) {
	unsigned int uRet = 0;
	CString sCopy = sStr;
	sStr.clear();

	unsigned int uReplaceWidth = sReplace.length();
	unsigned int uLeftWidth = sLeft.length();
	unsigned int uRightWidth = sRight.length();
	const char* p = sCopy.c_str();
	bool bInside = false;

	while (*p) {
		if (!bInside && uLeftWidth && strncmp(p, sLeft.c_str(), uLeftWidth) == 0) {
			if (!bRemoveDelims) {
				sStr += sLeft;
			}

			p += uLeftWidth -1;
			bInside = true;
		} else if (bInside && uRightWidth && strncmp(p, sRight.c_str(), uRightWidth) == 0) {
			if (!bRemoveDelims) {
				sStr += sRight;
			}

			p += uRightWidth -1;
			bInside = false;
		} else if (!bInside && strncmp(p, sReplace.c_str(), uReplaceWidth) == 0) {
			sStr += sWith;
			p += uReplaceWidth -1;
			uRet++;
		} else {
			sStr.append(p, 1);
		}

		p++;
	}

	return uRet;
}

CString CString::Token(unsigned int uPos, bool bRest, const CString& sSep) const {
	const char *sep_str = sSep.c_str();
	size_t sep_len = sSep.length();
	const char *str = c_str();
	size_t str_len = length();
	size_t start_pos = 0;
	size_t end_pos;

	// First, find the start of our token
	while (uPos != 0 && start_pos < str_len) {
		if (strncmp(&str[start_pos], sep_str, sep_len) == 0) {
			start_pos += sep_len;
			uPos--;
		} else {
			start_pos++;
		}
	}

	// String is over?
	if (start_pos >= str_len)
		return """";

	// If they want everything from here on, give it to them
	if (bRest) {
		return substr(start_pos);
	}

	// Now look for the end of the token they want
	end_pos = start_pos;
	while (end_pos < str_len) {
		if (strncmp(&str[end_pos], sep_str, sep_len) == 0)
			return substr(start_pos, end_pos - start_pos);

		end_pos++;
	}

	// They want the last token in the string, not something in between
	return substr(start_pos);
}

CString CString::Ellipsize(unsigned int uLen) const {
	if (uLen >= size()) {
		return *this;
	}

	string sRet;

	// @todo this looks suspect
	if (uLen < 4) {
		for (unsigned int a = 0; a < uLen; a++) {
			sRet += ""."";
		}

		return sRet;
	}

	sRet = substr(0, uLen -3) + ""..."";

	return sRet;
}

CString CString::Left(unsigned int uCount) const {
	uCount = (uCount > length()) ? length() : uCount;
	return substr(0, uCount);
}

CString CString::Right(unsigned int uCount) const {
	uCount = (uCount > length()) ? length() : uCount;
	return substr(length() - uCount, uCount);
}

unsigned int CString::URLSplit(MCString& msRet) const {
	msRet.clear();

	VCString vsPairs;
	Split(""&"", vsPairs);

	for (size_t a = 0; a < vsPairs.size(); a++) {
		const CString& sPair = vsPairs[a];

		msRet[sPair.Token(0, false, ""="").Escape(CString::EURL, CString::EASCII)] = sPair.Token(1, true, ""="").Escape(CString::EURL, CString::EASCII);
	}

	return msRet.size();
}

unsigned int CString::Split(const CString& sDelim, VCString& vsRet, bool bAllowEmpty, const CString& sLeft, const CString& sRight) const {
	vsRet.clear();

	if (empty()) {
		return 0;
	}

	CString sTmp;
	bool bInside = false;
	unsigned int uDelimLen = sDelim.length();
	unsigned int uLeftLen = sLeft.length();
	unsigned int uRightLen = sRight.length();
	const char* p = c_str();

	if (!bAllowEmpty) {
		while (strncasecmp(p, sDelim.c_str(), uDelimLen) == 0) {
			p += uDelimLen;
		}
	}

	while (*p) {
		if (uLeftLen && uRightLen && !bInside && strncasecmp(p, sLeft.c_str(), uLeftLen) == 0) {
			p += uLeftLen;
			bInside = true;
			continue;
		}

		if (uLeftLen && uRightLen && bInside && strncasecmp(p, sRight.c_str(), uRightLen) == 0) {
			p += uRightLen;
			bInside = false;
			continue;
		}

		if (uDelimLen && !bInside && strncasecmp(p, sDelim.c_str(), uDelimLen) == 0) {
			vsRet.push_back(sTmp);
			sTmp.clear();
			p += uDelimLen;

			if (!bAllowEmpty) {
				while (strncasecmp(p, sDelim.c_str(), uDelimLen) == 0) {
					p += uDelimLen;
				}
			}

			bInside = false;
			continue;
		} else {
			sTmp += *p;
		}

		p++;
	}

	if (!sTmp.empty()) {
		vsRet.push_back(sTmp);
	}

	return vsRet.size();

	/*vsRet.clear();
	CString sTmp = *this;

	while (sTmp.size()) {
		CString sTok = sTmp.Token(0, false, sDelim);
		CString sRest = sTmp.Token(1, true, sDelim);

		if (bAllowEmpty || !sTok.empty()) {
			vsRet.push_back(sTok);
		}

		if (bAllowEmpty && sRest.empty() && sTok.size() < sTmp.size()) {
			vsRet.push_back("""");
		}

		sTmp = sRest;
	}

	return vsRet.size();*/
}

unsigned int CString::Split(const CString& sDelim, SCString& ssRet, bool bAllowEmpty, const CString& sLeft, const CString& sRight) const {
	VCString vsTokens;

	Split(sDelim, vsTokens, bAllowEmpty, sLeft, sRight);

	ssRet.clear();

	for (size_t a = 0; a < vsTokens.size(); a++) {
		ssRet.insert(vsTokens[a]);
	}

	return ssRet.size();
}

CString CString::RandomString(unsigned int uLength) {
	const char chars[] = ""abcdefghijklmnopqrstuvwxyz""
		""ABCDEFGHIJKLMNOPQRSTUVWXYZ""
		""0123456789!?.,:;/*-+_()"";
	// -1 because sizeof() includes the trailing '\0' byte
	const size_t len = sizeof(chars) / sizeof(chars[0]) - 1;
	size_t p;
	CString sRet;

	for (unsigned int a = 0; a < uLength; a++) {
		p = (size_t) (len * (rand() / (RAND_MAX + 1.0)));
		sRet += chars[p];
	}

	return sRet;
}

bool CString::Base64Encode(unsigned int uWrap) {
	CString sCopy(*this);
	return sCopy.Base64Encode(*this, uWrap);
}

unsigned long CString::Base64Decode() {
	CString sCopy(*this);
	return sCopy.Base64Decode(*this);
}

CString CString::Base64Encode_n(unsigned int uWrap) const {
	CString sRet;
	Base64Encode(sRet, uWrap);
	return sRet;
}

CString CString::Base64Decode_n() const {
	CString sRet;
	Base64Decode(sRet);
	return sRet;
}

bool CString::Base64Encode(CString& sRet, unsigned int uWrap) const {
	const char b64table[] = ""ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"";
	sRet.clear();
	size_t len = size();
	const unsigned char* input = (const unsigned char*) c_str();
	unsigned char *output, *p;
	size_t        i = 0, mod = len % 3, toalloc;
	toalloc = (len / 3) * 4 + (3 - mod) % 3 + 1 + 8;

	if (uWrap) {
		toalloc += len / 57;
		if (len % 57) {
			toalloc++;
		}
	}

	if (toalloc < len) {
		return 0;
	}

	//p = output = (unsigned char *)malloc(toalloc);
	p = output = new unsigned char [toalloc];

	if (!p) {
		return false;
	}

	while (i < len - mod) {
		*p++ = b64table[input[i++] >> 2];
		*p++ = b64table[((input[i - 1] << 4) | (input[i] >> 4)) & 0x3f];
		*p++ = b64table[((input[i] << 2) | (input[i + 1] >> 6)) & 0x3f];
		*p++ = b64table[input[i + 1] & 0x3f];
		i += 2;

		if (uWrap && !(i % 57)) {
			*p++ = '\n';
		}
	}

	if (!mod) {
		if (uWrap && i % 57) {
			*p++ = '\n';
		}
	} else {
		*p++ = b64table[input[i++] >> 2];
		*p++ = b64table[((input[i - 1] << 4) | (input[i] >> 4)) & 0x3f];
		if (mod == 1) {
			*p++ = '=';
		} else {
			*p++ = b64table[(input[i] << 2) & 0x3f];
		}

		*p++ = '=';

		if (uWrap) {
			*p++ = '\n';
		}
	}

	*p = 0;
	sRet = (char*) output;
	delete[] output;
	return true;
}

unsigned long CString::Base64Decode(CString& sRet) const {
	const char* in = c_str();
	char c, c1, *p;
	unsigned long i;
	unsigned long uLen = size();
	char* out = (char*) malloc(size() +1);

	for (i = 0, p = out; i < uLen; i++) {
		c = (char)base64_table[(unsigned char)in[i++]];
		c1 = (char)base64_table[(unsigned char)in[i++]];
		*p++ = (c << 2) | ((c1 >> 4) & 0x3);

		if (i < uLen) {
			if (in[i] == '=') {
				break;
			}
			c = (char)base64_table[(unsigned char)in[i]];
			*p++ = ((c1 << 4) & 0xf0) | ((c >> 2) & 0xf);
		}

		if (++i < uLen) {
			if (in[i] == '=') {
				break;
			}
			*p++ = ((c << 6) & 0xc0) | (char)base64_table[(unsigned char)in[i]];
		}
	}

	*p = '\0';
	unsigned long uRet = p - out;
	sRet.clear();
	sRet.append(out, uRet);
	free(out);

	return uRet;
}

CString CString::MD5() const {
	return (const char*) CMD5(*this);
}

#ifdef HAVE_LIBSSL
CString CString::Encrypt_n(const CString& sPass, const CString& sIvec) {
	CString sRet;
	sRet.Encrypt(sPass, sIvec);
	return sRet;
}

CString CString::Decrypt_n(const CString& sPass, const CString& sIvec) {
	CString sRet;
	sRet.Decrypt(sPass, sIvec);
	return sRet;
}

void CString::Encrypt(const CString& sPass, const CString& sIvec) {
	Crypt(sPass, true, sIvec);
}

void CString::Decrypt(const CString& sPass, const CString& sIvec) {
	Crypt(sPass, false, sIvec);
}

void CString::Crypt(const CString& sPass, bool bEncrypt, const CString& sIvec) {
	unsigned char szIvec[8] = {0,0,0,0,0,0,0,0};
	BF_KEY bKey;

	if (sIvec.length() >= 8) {
		memcpy(szIvec, sIvec.data(), 8);
	}

	BF_set_key(&bKey, sPass.length(), (unsigned char*) sPass.data());
	unsigned int uPad = (length() % 8);

	if (uPad) {
		uPad = 8 - uPad;
		append(uPad, '\0');
	}

	size_t uLen = length();
	unsigned char* szBuff = (unsigned char*) malloc(uLen);
	BF_cbc_encrypt((const unsigned char*) data(), szBuff, uLen, &bKey, szIvec, ((bEncrypt) ? BF_ENCRYPT : BF_DECRYPT));

	clear();
	append((const char*) szBuff, uLen);
	free(szBuff);
}
#endif	// HAVE_LIBSSL

CString CString::ToPercent(double d) {
	char szRet[32];
	snprintf(szRet, 32, ""%.02f%%"", d);
	return szRet;
}

CString CString::ToByteStr(unsigned long long d) {
	const unsigned long long KiB = 1024;
	const unsigned long long MiB = KiB * 1024;
	const unsigned long long GiB = MiB * 1024;
	const unsigned long long TiB = GiB * 1024;

	if (d > TiB) {
		return CString(d / (double) TiB) + "" TiB"";
	} else if (d > GiB) {
		return CString(d / (double) GiB) + "" GiB"";
	} else if (d > MiB) {
		return CString(d / (double) MiB) + "" MiB"";
	} else if (d > KiB) {
		return CString(d / (double) KiB) + "" KiB"";
	}

	return CString(d) + "" B"";
}

CString CString::ToTimeStr(unsigned long s) {
	const unsigned long m = 60;
	const unsigned long h = m * 60;
	const unsigned long d = h * 24;
	const unsigned long w = d * 7;
	const unsigned long y = d * 365;
	CString sRet;

#define TIMESPAN(time, str)			\
	if (s >= time) {		\
		sRet += CString(s / time) + str "" ""; \
		s = s % time;		\
	}
	TIMESPAN(y, ""y"");
	TIMESPAN(w, ""w"");
	TIMESPAN(d, ""d"");
	TIMESPAN(h, ""h"");
	TIMESPAN(m, ""m"");
	TIMESPAN(1, ""s"");

	if (sRet.empty())
		return ""0s"";

	return sRet.RightChomp_n();
}

bool CString::ToBool() const { return (!Trim_n().Trim_n(""0"").empty() && !Trim_n().Equals(""false"")); }
short CString::ToShort() const { return strtoul(this->c_str(), (char**) NULL, 10); }
unsigned short CString::ToUShort() const { return strtoul(this->c_str(), (char**) NULL, 10); }
unsigned int CString::ToUInt() const { return strtoul(this->c_str(), (char**) NULL, 10); }
int CString::ToInt() const { return strtoul(this->c_str(), (char**) NULL, 10); }
long CString::ToLong() const { return strtoul(this->c_str(), (char**) NULL, 10); }
unsigned long CString::ToULong() const { return strtoul(c_str(), NULL, 10); }
unsigned long long CString::ToULongLong() const { return strtoull(c_str(), NULL, 10); }
long long CString::ToLongLong() const { return strtoll(c_str(), NULL, 10); }
double CString::ToDouble() const { return strtod(c_str(), NULL); }


bool CString::Trim(const CString& s) {
	bool bLeft = TrimLeft(s);
	return (TrimRight(s) || bLeft);
}

bool CString::TrimLeft(const CString& s) {
	size_type i = find_first_not_of(s);

	if (i == 0)
		return false;

	if (i != npos)
		this->erase(0, i);
	else
		this->clear();

	return true;
}

bool CString::TrimRight(const CString& s) {
	size_type i = find_last_not_of(s);

	if (i + 1 == length())
		return false;

	if (i != npos)
		this->erase(i + 1, npos);
	else
		this->clear();

	return true;
}

CString CString::Trim_n(const CString& s) const {
	CString sRet = *this;
	sRet.Trim(s);
	return sRet;
}

CString CString::TrimLeft_n(const CString& s) const {
	CString sRet = *this;
	sRet.TrimLeft(s);
	return sRet;
}

CString CString::TrimRight_n(const CString& s) const {
	CString sRet = *this;
	sRet.TrimRight(s);
	return sRet;
}

bool CString::TrimPrefix(const CString& sPrefix) {
	if (Equals(sPrefix, false, sPrefix.length())) {
		LeftChomp(sPrefix.length());
		return true;
	} else {
		return false;
	}
}

bool CString::TrimSuffix(const CString& sSuffix) {
	if (Right(sSuffix.length()).Equals(sSuffix)) {
		RightChomp(sSuffix.length());
		return true;
	} else {
		return false;
	}
}


CString CString::TrimPrefix_n(const CString& sPrefix) const {
	CString sRet = *this;
	sRet.TrimPrefix(sPrefix);
	return sRet;
}

CString CString::TrimSuffix_n(const CString& sSuffix) const {
	CString sRet = *this;
	sRet.TrimSuffix(sSuffix);
	return sRet;
}

CString CString::LeftChomp_n(unsigned int uLen) const {
	CString sRet = *this;
	sRet.LeftChomp(uLen);
	return sRet;
}

CString CString::RightChomp_n(unsigned int uLen) const {
	CString sRet = *this;
	sRet.RightChomp(uLen);
	return sRet;
}

bool CString::LeftChomp(unsigned int uLen) {
	bool bRet = false;

	while ((uLen--) && (length())) {
		erase(0, 1);
		bRet = true;
	}

	return bRet;
}

bool CString::RightChomp(unsigned int uLen) {
	bool bRet = false;

	while ((uLen--) && (length())) {
		erase(length() -1);
		bRet = true;
	}

	return bRet;
}

//////////////// MCString ////////////////
int MCString::WriteToDisk(const CString& sPath, mode_t iMode) {
	CFile cFile(sPath);

	if (this->empty()) {
		if (!cFile.Exists())
			return MCS_SUCCESS;
		if (cFile.Delete())
			return MCS_SUCCESS;
	}

	if (!cFile.Open(O_WRONLY|O_CREAT|O_TRUNC, iMode)) {
		return MCS_EOPEN;
	}

	for (MCString::iterator it = this->begin(); it != this->end(); it++) {
		CString sKey = it->first;
		CString sValue = it->second;
		if (!WriteFilter(sKey, sValue)) {
			return MCS_EWRITEFIL;
		}

		if (sKey.empty()) {
			continue;
		}

		if (cFile.Write(Encode(sKey) + "" "" +  Encode(sValue) + ""\n"") <= 0) {
			return MCS_EWRITE;
		}
	}

	cFile.Close();

	return MCS_SUCCESS;
}

int MCString::ReadFromDisk(const CString& sPath, mode_t iMode) {
	clear();
	CFile cFile(sPath);
	if (!cFile.Open(O_RDONLY, iMode)) {
		return MCS_EOPEN;
	}

	CString sBuffer;

	while (cFile.ReadLine(sBuffer)) {
		sBuffer.Trim();
		CString sKey = sBuffer.Token(0);
		CString sValue = sBuffer.Token(1);
		Decode(sKey);
		Decode(sValue);

		if (!ReadFilter(sKey, sValue))
			return MCS_EREADFIL;

		(*this)[sKey] = sValue;
	}
	cFile.Close();

	return MCS_SUCCESS;
}


static const char hexdigits[] = ""0123456789abcdef"";

CString& MCString::Encode(CString& sValue) {
	CString sTmp;
	for (CString::iterator it = sValue.begin(); it != sValue.end(); it++) {
		if (isalnum(*it)) {
			sTmp += *it;
		} else {
			sTmp += ""%"";
			sTmp += hexdigits[*it >> 4];
			sTmp += hexdigits[*it & 0xf];
			sTmp += "";"";
		}
	}
	sValue = sTmp;
	return sValue;
}

CString& MCString::Decode(CString& sValue) {
	const char *pTmp = sValue.c_str();
	char *endptr;
	CString sTmp;

	while (*pTmp) {
		if (*pTmp != '%') {
			sTmp += *pTmp++;
		} else {
			char ch = (char) strtol(pTmp + 1, &endptr, 16);
			if (*endptr == ';') {
				sTmp += ch;
				pTmp = ++endptr;
			} else {
				sTmp += *pTmp++;
			}
		}
	}

	sValue = sTmp;
	return sValue;
}
""",,
znc,https://github.com/znc/znc/commit/ef8b28fb68995d5fac0c56d2e263238acc5c1790,"""Micro optimization


git-svn-id: https://znc.svn.sourceforge.net/svnroot/znc/trunk@1462 726aef4b-f618-498e-8847-2d620e286838""","""/*
 * Copyright (C) 2004-2009  See the AUTHORS file for details.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 as published
 * by the Free Software Foundation.
 */

#include ""DCCBounce.h""
#include ""User.h""
#include ""znc.h""

// If we buffer more than this in memory, we will throttle the receiving side
const unsigned int CDCCBounce::m_uiMaxDCCBuffer = 10 * 1024;
// If less than this is in the buffer, the receiving side continues
const unsigned int CDCCBounce::m_uiMinDCCBuffer = 2 * 1024;

CDCCBounce::CDCCBounce(CUser* pUser, unsigned long uLongIP, unsigned short uPort,
		const CString& sFileName, const CString& sRemoteNick,
		const CString& sRemoteIP, CString sLocalIP, bool bIsChat) : Csock() {
	m_uRemotePort = uPort;
	m_sConnectIP = CUtils::GetIP(uLongIP);
	m_sRemoteIP = sRemoteIP;
	m_sFileName = sFileName;
	m_sRemoteNick = sRemoteNick;
	m_pUser = pUser;
	m_bIsChat = bIsChat;
	m_sLocalIP = sLocalIP;
	m_pPeer = NULL;
	m_bIsRemote = false;

	if (bIsChat) {
		EnableReadLine();
	}
}

CDCCBounce::CDCCBounce(const CString& sHostname, unsigned short uPort, CUser* pUser,
		const CString& sRemoteNick, const CString& sRemoteIP, const CString& sFileName,
		int iTimeout, bool bIsChat) : Csock(sHostname, uPort, iTimeout) {
	m_uRemotePort = 0;
	m_bIsChat = bIsChat;
	m_pUser = pUser;
	m_pPeer = NULL;
	m_sRemoteNick = sRemoteNick;
	m_sFileName = sFileName;
	m_sRemoteIP = sRemoteIP;
	m_bIsRemote = false;

	SetMaxBufferThreshold(10240);
	if (bIsChat) {
		EnableReadLine();
	}
}

CDCCBounce::~CDCCBounce() {
	if (m_pPeer) {
		m_pPeer->Shutdown();
		m_pPeer = NULL;
	}
	if (m_pUser) {
		m_pUser->AddBytesRead(GetBytesRead());
		m_pUser->AddBytesWritten(GetBytesWritten());
	}
}

void CDCCBounce::ReadLine(const CString& sData) {
	CString sLine = sData;

	while ((sLine.Right(1) == ""\r"") || (sLine.Right(1) == ""\n"")) {
		sLine.RightChomp();
	}

	DEBUG(GetSockName() << "" <- ["" << sLine << ""]"");

	PutPeer(sLine);
}

void CDCCBounce::ReachedMaxBuffer() {
	DEBUG(GetSockName() << "" == ReachedMaxBuffer()"");

	CString sType = (m_bIsChat) ? ""Chat"" : ""Xfer"";

	m_pUser->PutStatus(""DCC "" + sType + "" Bounce ("" + m_sRemoteNick + ""): Too long line received"");
	Close();
}

void CDCCBounce::ReadData(const char* data, int len) {
	size_t BufLen;

	if (m_pPeer) {
		m_pPeer->Write(data, len);

		BufLen = m_pPeer->GetInternalWriteBuffer().length();

		if (BufLen >= m_uiMaxDCCBuffer) {
			DEBUG(GetSockName() << "" The send buffer is over the ""
					""limit ("" << BufLen <<""), throttling"");
			PauseRead();
		}
	}
}

void CDCCBounce::ReadPaused() {
	if (!m_pPeer || m_pPeer->GetInternalWriteBuffer().length() <= m_uiMinDCCBuffer)
		UnPauseRead();
}

void CDCCBounce::Timeout() {
	DEBUG(GetSockName() << "" == Timeout()"");
	CString sType = (m_bIsChat) ? ""Chat"" : ""Xfer"";

	if (IsRemote()) {
		CString sHost = Csock::GetHostName();
		if (!sHost.empty()) {
			sHost = "" to ["" + sHost + "":"" + CString(Csock::GetPort()) + ""]"";
		} else {
			sHost = ""."";
		}

		m_pUser->PutStatus(""DCC "" + sType + "" Bounce ("" + m_sRemoteNick + ""): Timeout while connecting"" + sHost);
	} else {
		m_pUser->PutStatus(""DCC "" + sType + "" Bounce ("" + m_sRemoteNick + ""): Timeout waiting for incoming connection ["" + Csock::GetLocalIP() + "":"" + CString(Csock::GetLocalPort()) + ""]"");
	}
}

void CDCCBounce::ConnectionRefused() {
	DEBUG(GetSockName() << "" == ConnectionRefused()"");

	CString sType = (m_bIsChat) ? ""Chat"" : ""Xfer"";
	CString sHost = Csock::GetHostName();
	if (!sHost.empty()) {
		sHost = "" to ["" + sHost + "":"" + CString(Csock::GetPort()) + ""]"";
	} else {
		sHost = ""."";
	}

	m_pUser->PutStatus(""DCC "" + sType + "" Bounce ("" + m_sRemoteNick + ""): Connection Refused while connecting"" + sHost);
}

void CDCCBounce::SockError(int iErrno) {
	DEBUG(GetSockName() << "" == SockError("" << iErrno << "")"");
	CString sType = (m_bIsChat) ? ""Chat"" : ""Xfer"";

	if (IsRemote()) {
		CString sHost = Csock::GetHostName();
		if (!sHost.empty()) {
			sHost = ""["" + sHost + "":"" + CString(Csock::GetPort()) + ""]"";
		}

		m_pUser->PutStatus(""DCC "" + sType + "" Bounce ("" + m_sRemoteNick + ""): Socket error ["" + CString(strerror(iErrno)) + ""]"" + sHost);
	} else {
		m_pUser->PutStatus(""DCC "" + sType + "" Bounce ("" + m_sRemoteNick + ""): Socket error ["" + CString(strerror(iErrno)) + ""] ["" + Csock::GetLocalIP() + "":"" + CString(Csock::GetLocalPort()) + ""]"");
	}
}

void CDCCBounce::Connected() {
	DEBUG(GetSockName() << "" == Connected()"");
	SetTimeout(0);
}

void CDCCBounce::Disconnected() {
	DEBUG(GetSockName() << "" == Disconnected()"");
}

void CDCCBounce::Shutdown() {
	m_pPeer = NULL;
	DEBUG(GetSockName() << "" == Close(); because my peer told me to"");
	Close();
}

Csock* CDCCBounce::GetSockObj(const CString& sHost, unsigned short uPort) {
	Close();

	if (m_sRemoteIP.empty()) {
		m_sRemoteIP = sHost;
	}

	CDCCBounce* pSock = new CDCCBounce(sHost, uPort, m_pUser, m_sRemoteNick, m_sRemoteIP, m_sFileName, m_bIsChat);
	CDCCBounce* pRemoteSock = new CDCCBounce(sHost, uPort, m_pUser, m_sRemoteNick, m_sRemoteIP, m_sFileName, m_bIsChat);
	pSock->SetPeer(pRemoteSock);
	pRemoteSock->SetPeer(pSock);
	pRemoteSock->SetRemote(true);
	pSock->SetRemote(false);

	if (!CZNC::Get().GetManager().Connect(m_sConnectIP, m_uRemotePort, ""DCC::"" + CString((m_bIsChat) ? ""Chat"" : ""XFER"") + ""::Remote::"" + m_sRemoteNick, 60, false, m_sLocalIP, pRemoteSock)) {
		pRemoteSock->Close();
	}

	pSock->SetSockName(GetSockName());
	pSock->SetTimeout(0);
	return pSock;
}

void CDCCBounce::PutServ(const CString& sLine) {
	DEBUG(GetSockName() << "" -> ["" << sLine << ""]"");
	Write(sLine + ""\r\n"");
}

void CDCCBounce::PutPeer(const CString& sLine) {
	if (m_pPeer) {
		m_pPeer->PutServ(sLine);
	} else {
		PutServ(""*** Not connected yet ***"");
	}
}

unsigned short CDCCBounce::DCCRequest(const CString& sNick, unsigned long uLongIP, unsigned short uPort, const CString& sFileName, bool bIsChat, CUser* pUser, const CString& sLocalIP, const CString& sRemoteIP) {
	CDCCBounce* pDCCBounce = new CDCCBounce(pUser, uLongIP, uPort, sFileName, sNick, sRemoteIP, sLocalIP, bIsChat);
	unsigned short uListenPort = CZNC::Get().GetManager().ListenRand(""DCC::"" + CString((bIsChat) ? ""Chat"" : ""Xfer"") + ""::Local::"" + sNick, sLocalIP, false, SOMAXCONN, pDCCBounce, 120);

	return uListenPort;
}

""","""/*
 * Copyright (C) 2004-2009  See the AUTHORS file for details.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 as published
 * by the Free Software Foundation.
 */

#include ""DCCBounce.h""
#include ""User.h""
#include ""znc.h""

// If we buffer more than this in memory, we will throttle the receiving side
const unsigned int CDCCBounce::m_uiMaxDCCBuffer = 10 * 1024;
// If less than this is in the buffer, the receiving side continues
const unsigned int CDCCBounce::m_uiMinDCCBuffer = 2 * 1024;

CDCCBounce::CDCCBounce(CUser* pUser, unsigned long uLongIP, unsigned short uPort,
		const CString& sFileName, const CString& sRemoteNick,
		const CString& sRemoteIP, CString sLocalIP, bool bIsChat) : Csock() {
	m_uRemotePort = uPort;
	m_sConnectIP = CUtils::GetIP(uLongIP);
	m_sRemoteIP = sRemoteIP;
	m_sFileName = sFileName;
	m_sRemoteNick = sRemoteNick;
	m_pUser = pUser;
	m_bIsChat = bIsChat;
	m_sLocalIP = sLocalIP;
	m_pPeer = NULL;
	m_bIsRemote = false;

	if (bIsChat) {
		EnableReadLine();
	}
}

CDCCBounce::CDCCBounce(const CString& sHostname, unsigned short uPort, CUser* pUser,
		const CString& sRemoteNick, const CString& sRemoteIP, const CString& sFileName,
		int iTimeout, bool bIsChat) : Csock(sHostname, uPort, iTimeout) {
	m_uRemotePort = 0;
	m_bIsChat = bIsChat;
	m_pUser = pUser;
	m_pPeer = NULL;
	m_sRemoteNick = sRemoteNick;
	m_sFileName = sFileName;
	m_sRemoteIP = sRemoteIP;
	m_bIsRemote = false;

	SetMaxBufferThreshold(10240);
	if (bIsChat) {
		EnableReadLine();
	}
}

CDCCBounce::~CDCCBounce() {
	if (m_pPeer) {
		m_pPeer->Shutdown();
		m_pPeer = NULL;
	}
	if (m_pUser) {
		m_pUser->AddBytesRead(GetBytesRead());
		m_pUser->AddBytesWritten(GetBytesWritten());
	}
}

void CDCCBounce::ReadLine(const CString& sData) {
	CString sLine = sData.TrimRight_n(""\r\n"");

	DEBUG(GetSockName() << "" <- ["" << sLine << ""]"");

	PutPeer(sLine);
}

void CDCCBounce::ReachedMaxBuffer() {
	DEBUG(GetSockName() << "" == ReachedMaxBuffer()"");

	CString sType = (m_bIsChat) ? ""Chat"" : ""Xfer"";

	m_pUser->PutStatus(""DCC "" + sType + "" Bounce ("" + m_sRemoteNick + ""): Too long line received"");
	Close();
}

void CDCCBounce::ReadData(const char* data, int len) {
	size_t BufLen;

	if (m_pPeer) {
		m_pPeer->Write(data, len);

		BufLen = m_pPeer->GetInternalWriteBuffer().length();

		if (BufLen >= m_uiMaxDCCBuffer) {
			DEBUG(GetSockName() << "" The send buffer is over the ""
					""limit ("" << BufLen <<""), throttling"");
			PauseRead();
		}
	}
}

void CDCCBounce::ReadPaused() {
	if (!m_pPeer || m_pPeer->GetInternalWriteBuffer().length() <= m_uiMinDCCBuffer)
		UnPauseRead();
}

void CDCCBounce::Timeout() {
	DEBUG(GetSockName() << "" == Timeout()"");
	CString sType = (m_bIsChat) ? ""Chat"" : ""Xfer"";

	if (IsRemote()) {
		CString sHost = Csock::GetHostName();
		if (!sHost.empty()) {
			sHost = "" to ["" + sHost + "":"" + CString(Csock::GetPort()) + ""]"";
		} else {
			sHost = ""."";
		}

		m_pUser->PutStatus(""DCC "" + sType + "" Bounce ("" + m_sRemoteNick + ""): Timeout while connecting"" + sHost);
	} else {
		m_pUser->PutStatus(""DCC "" + sType + "" Bounce ("" + m_sRemoteNick + ""): Timeout waiting for incoming connection ["" + Csock::GetLocalIP() + "":"" + CString(Csock::GetLocalPort()) + ""]"");
	}
}

void CDCCBounce::ConnectionRefused() {
	DEBUG(GetSockName() << "" == ConnectionRefused()"");

	CString sType = (m_bIsChat) ? ""Chat"" : ""Xfer"";
	CString sHost = Csock::GetHostName();
	if (!sHost.empty()) {
		sHost = "" to ["" + sHost + "":"" + CString(Csock::GetPort()) + ""]"";
	} else {
		sHost = ""."";
	}

	m_pUser->PutStatus(""DCC "" + sType + "" Bounce ("" + m_sRemoteNick + ""): Connection Refused while connecting"" + sHost);
}

void CDCCBounce::SockError(int iErrno) {
	DEBUG(GetSockName() << "" == SockError("" << iErrno << "")"");
	CString sType = (m_bIsChat) ? ""Chat"" : ""Xfer"";

	if (IsRemote()) {
		CString sHost = Csock::GetHostName();
		if (!sHost.empty()) {
			sHost = ""["" + sHost + "":"" + CString(Csock::GetPort()) + ""]"";
		}

		m_pUser->PutStatus(""DCC "" + sType + "" Bounce ("" + m_sRemoteNick + ""): Socket error ["" + CString(strerror(iErrno)) + ""]"" + sHost);
	} else {
		m_pUser->PutStatus(""DCC "" + sType + "" Bounce ("" + m_sRemoteNick + ""): Socket error ["" + CString(strerror(iErrno)) + ""] ["" + Csock::GetLocalIP() + "":"" + CString(Csock::GetLocalPort()) + ""]"");
	}
}

void CDCCBounce::Connected() {
	DEBUG(GetSockName() << "" == Connected()"");
	SetTimeout(0);
}

void CDCCBounce::Disconnected() {
	DEBUG(GetSockName() << "" == Disconnected()"");
}

void CDCCBounce::Shutdown() {
	m_pPeer = NULL;
	DEBUG(GetSockName() << "" == Close(); because my peer told me to"");
	Close();
}

Csock* CDCCBounce::GetSockObj(const CString& sHost, unsigned short uPort) {
	Close();

	if (m_sRemoteIP.empty()) {
		m_sRemoteIP = sHost;
	}

	CDCCBounce* pSock = new CDCCBounce(sHost, uPort, m_pUser, m_sRemoteNick, m_sRemoteIP, m_sFileName, m_bIsChat);
	CDCCBounce* pRemoteSock = new CDCCBounce(sHost, uPort, m_pUser, m_sRemoteNick, m_sRemoteIP, m_sFileName, m_bIsChat);
	pSock->SetPeer(pRemoteSock);
	pRemoteSock->SetPeer(pSock);
	pRemoteSock->SetRemote(true);
	pSock->SetRemote(false);

	if (!CZNC::Get().GetManager().Connect(m_sConnectIP, m_uRemotePort, ""DCC::"" + CString((m_bIsChat) ? ""Chat"" : ""XFER"") + ""::Remote::"" + m_sRemoteNick, 60, false, m_sLocalIP, pRemoteSock)) {
		pRemoteSock->Close();
	}

	pSock->SetSockName(GetSockName());
	pSock->SetTimeout(0);
	return pSock;
}

void CDCCBounce::PutServ(const CString& sLine) {
	DEBUG(GetSockName() << "" -> ["" << sLine << ""]"");
	Write(sLine + ""\r\n"");
}

void CDCCBounce::PutPeer(const CString& sLine) {
	if (m_pPeer) {
		m_pPeer->PutServ(sLine);
	} else {
		PutServ(""*** Not connected yet ***"");
	}
}

unsigned short CDCCBounce::DCCRequest(const CString& sNick, unsigned long uLongIP, unsigned short uPort, const CString& sFileName, bool bIsChat, CUser* pUser, const CString& sLocalIP, const CString& sRemoteIP) {
	CDCCBounce* pDCCBounce = new CDCCBounce(pUser, uLongIP, uPort, sFileName, sNick, sRemoteIP, sLocalIP, bIsChat);
	unsigned short uListenPort = CZNC::Get().GetManager().ListenRand(""DCC::"" + CString((bIsChat) ? ""Chat"" : ""Xfer"") + ""::Local::"" + sNick, sLocalIP, false, SOMAXCONN, pDCCBounce, 120);

	return uListenPort;
}

""",CDCCBounce::ReadLine,[66:72]
znc,https://github.com/znc/znc/commit/aaaae4e51a01e11a73dbb29ed09f024cf0ec786c,"""Micro-optimization

!m.empty() might be a littler faster than m.size() > 0, but I doubt one can
measure the difference here...


git-svn-id: https://znc.svn.sourceforge.net/svnroot/znc/trunk@1501 726aef4b-f618-498e-8847-2d620e286838""","""/*
 * Copyright (C) 2004-2009  See the AUTHORS file for details.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 as published
 * by the Free Software Foundation.
 */

#ifndef _USER_H
#define _USER_H

#include ""Buffer.h""
#include ""FileUtils.h""
#ifdef _MODULES
#include ""Modules.h""
#endif
#include ""Nick.h""
#include <set>
#include <vector>

using std::set;
using std::vector;

class CChan;
class CClient;
class CIRCSock;
class CJoinTimer;
class CMiscTimer;
class CServer;

class CUser {
public:
	CUser(const CString& sUserName);
	~CUser();

	bool PrintLine(CFile& File, const CString& sName, const CString& sValue);
	bool WriteConfig(CFile& File);
	CChan* FindChan(const CString& sName) const;
	bool AddChan(CChan* pChan);
	bool AddChan(const CString& sName, bool bInConfig);
	bool DelChan(const CString& sName);
	void JoinChans();
	CServer* FindServer(const CString& sName) const;
	bool DelServer(const CString& sName);
	bool AddServer(const CString& sName);
	bool AddServer(const CString& sName, unsigned short uPort, const CString& sPass = """", bool bSSL = false);
	CServer* GetNextServer();
	CServer* GetCurrentServer() const;
	bool CheckPass(const CString& sPass) const;
	bool AddAllowedHost(const CString& sHostMask);
	bool IsHostAllowed(const CString& sHostMask) const;
	bool IsValid(CString& sErrMsg, bool bSkipPass = false) const;
	static bool IsValidUserName(const CString& sUserName);
	static CString MakeCleanUserName(const CString& sUserName);
	bool IsLastServer() const;
	bool ConnectPaused();

	void DelClients();
	void DelServers();
#ifdef _MODULES
	void DelModules();

	// Unloads a module on all users who have it loaded and loads it again.
	static bool UpdateModule(const CString &sModule);

	// Modules
	CModules& GetModules() { return *m_pModules; }
	const CModules& GetModules() const { return *m_pModules; }
	// !Modules
#endif

	// Buffers
	void AddRawBuffer(const CString& sPre, const CString& sPost, bool bIncNick = true) { m_RawBuffer.AddLine(sPre, sPost, bIncNick); }
	void AddMotdBuffer(const CString& sPre, const CString& sPost, bool bIncNick = true) { m_MotdBuffer.AddLine(sPre, sPost, bIncNick); }
	void AddQueryBuffer(const CString& sPre, const CString& sPost, bool bIncNick = true) { m_QueryBuffer.AddLine(sPre, sPost, bIncNick); }
	void UpdateRawBuffer(const CString& sPre, const CString& sPost, bool bIncNick = true) { m_RawBuffer.UpdateLine(sPre, sPost, bIncNick); }
	void UpdateMotdBuffer(const CString& sPre, const CString& sPost, bool bIncNick = true) { m_MotdBuffer.UpdateLine(sPre, sPost, bIncNick); }
	void UpdateQueryBuffer(const CString& sPre, const CString& sPost, bool bIncNick = true) { m_QueryBuffer.UpdateLine(sPre, sPost, bIncNick); }
	void ClearRawBuffer() { m_RawBuffer.Clear(); }
	void ClearMotdBuffer() { m_MotdBuffer.Clear(); }
	void ClearQueryBuffer() { m_QueryBuffer.Clear(); }
	// !Buffers

	bool PutIRC(const CString& sLine);
	bool PutUser(const CString& sLine, CClient* pClient = NULL, CClient* pSkipClient = NULL);
	bool PutStatus(const CString& sLine, CClient* pClient = NULL, CClient* pSkipClient = NULL);
	bool PutStatusNotice(const CString& sLine, CClient* pClient = NULL, CClient* pSkipClient = NULL);
	bool PutModule(const CString& sModule, const CString& sLine, CClient* pClient = NULL, CClient* pSkipClient = NULL);

	bool IsUserAttached() const { return (m_vClients.size() > 0); }
	void UserConnected(CClient* pClient);
	void UserDisconnected(CClient* pClient);

	CString GetLocalIP();
	bool IsIRCConnected() const { return GetIRCSock() != NULL; }
	void IRCConnected(CIRCSock* pIRCSock);
	void IRCDisconnected();
	void CheckIRCConnect();

	CString ExpandString(const CString& sStr) const;
	CString& ExpandString(const CString& sStr, CString& sRet) const;

	CString AddTimestamp(const CString& sStr) const;
	CString& AddTimestamp(const CString& sStr, CString& sRet) const;

	bool SendFile(const CString& sRemoteNick, const CString& sFileName, const CString& sModuleName = """");
	bool GetFile(const CString& sRemoteNick, const CString& sRemoteIP, unsigned short uRemotePort, const CString& sFileName, unsigned long uFileSize, const CString& sModuleName = """");
	bool ResumeFile(unsigned short uPort, unsigned long uFileSize);
	CString GetCurNick() const;
	bool Clone(const CUser& User, CString& sErrorRet, bool bCloneChans = true);
	void BounceAllClients();

	void AddBytesRead(unsigned long long u) { m_uBytesRead += u; }
	void AddBytesWritten(unsigned long long u) { m_uBytesWritten += u; }

	// Setters
	void SetUserName(const CString& s);
	void SetNick(const CString& s);
	void SetAltNick(const CString& s);
	void SetIdent(const CString& s);
	void SetRealName(const CString& s);
	void SetVHost(const CString& s);
	void SetPass(const CString& s, bool bHashed, const CString& sSalt = """");
	void SetBounceDCCs(bool b);
	void SetMultiClients(bool b);
	void SetUseClientIP(bool b);
	void SetDenyLoadMod(bool b);
	void SetAdmin(bool b);
	void SetDenySetVHost(bool b);
	bool SetStatusPrefix(const CString& s);
	void SetDefaultChanModes(const CString& s);
	void SetIRCNick(const CNick& n);
	void SetIRCServer(const CString& s);
	void SetQuitMsg(const CString& s);
	bool AddCTCPReply(const CString& sCTCP, const CString& sReply);
	void SetBufferCount(unsigned int u);
	void SetKeepBuffer(bool b);
	void SetChanPrefixes(const CString& s) { m_sChanPrefixes = s; }
	void SetBeingDeleted(bool b) { m_bBeingDeleted = b; }
	void SetTimestampFormat(const CString& s) { m_sTimestampFormat = s; }
	void SetTimestampAppend(bool b) { m_bAppendTimestamp = b; }
	void SetTimestampPrepend(bool b) { m_bPrependTimestamp = b; }
	void SetTimezoneOffset(float b) { m_fTimezoneOffset = b; }
	void SetJoinTries(unsigned int i) { m_uMaxJoinTries = i; }
	void SetMaxJoins(unsigned int i) { m_uMaxJoins = i; }
	void SetIRCConnectEnabled(bool b) { m_bIRCConnectEnabled = b; }
	// !Setters

	// Getters
	vector<CClient*>& GetClients() { return m_vClients; }
	CIRCSock* GetIRCSock() { return m_pIRCSock; }
	const CIRCSock* GetIRCSock() const { return m_pIRCSock; }
	const CString& GetUserName() const;
	const CString& GetCleanUserName() const;
	const CString& GetNick(bool bAllowDefault = true) const;
	const CString& GetAltNick(bool bAllowDefault = true) const;
	const CString& GetIdent(bool bAllowDefault = true) const;
	const CString& GetRealName() const;
	const CString& GetVHost() const;
	const CString& GetPass() const;
	bool IsPassHashed() const;
	const CString& GetPassSalt() const;
	const set<CString>& GetAllowedHosts() const;
	const CString& GetTimestampFormat() const;
	bool GetTimestampAppend() const;
	bool GetTimestampPrepend() const;
	bool GetIRCConnectEnabled() const { return m_bIRCConnectEnabled; }

	const CString& GetChanPrefixes() const { return m_sChanPrefixes; }
	bool IsChan(const CString& sChan) const;

	const CString& GetUserPath() const { if (!CFile::Exists(m_sUserPath)) { CDir::MakeDir(m_sUserPath); } return m_sUserPath; }
	const CString& GetDLPath() const { if (!CFile::Exists(m_sDLPath)) { CDir::MakeDir(m_sDLPath); } return m_sDLPath; }

	bool UseClientIP() const;
	bool DenyLoadMod() const;
	bool IsAdmin() const;
	bool DenySetVHost() const;
	bool BounceDCCs() const;
	bool MultiClients() const;
	const CString& GetStatusPrefix() const;
	const CString& GetDefaultChanModes() const;
	const vector<CChan*>& GetChans() const;
	const vector<CServer*>& GetServers() const;
	const CNick& GetIRCNick() const;
	const CString& GetIRCServer() const;
	CString GetQuitMsg() const;
	const MCString& GetCTCPReplies() const;
	unsigned int GetBufferCount() const;
	bool KeepBuffer() const;
	bool IsBeingDeleted() const { return m_bBeingDeleted; }
	bool HasServers() const { return m_vServers.size() > 0; }
	float GetTimezoneOffset() const { return m_fTimezoneOffset; }
	unsigned long long BytesRead() const { return m_uBytesRead; }
	unsigned long long BytesWritten() const { return m_uBytesWritten; }
	unsigned int JoinTries() const { return m_uMaxJoinTries; }
	unsigned int MaxJoins() const { return m_uMaxJoins; }
	// !Getters
private:
protected:
	time_t			m_uConnectTime;
	CString			m_sUserName;
	CString			m_sCleanUserName;
	CString			m_sNick;
	CString			m_sAltNick;
	CString			m_sIdent;
	CString			m_sRealName;
	CString			m_sVHost;
	CString			m_sPass;
	CString			m_sPassSalt;
	CString			m_sStatusPrefix;
	CString			m_sDefaultChanModes;
	CString			m_sChanPrefixes;
	CNick			m_IRCNick;
	CString			m_sIRCServer;
	CString			m_sQuitMsg;
	MCString		m_mssCTCPReplies;
	CString			m_sTimestampFormat;
	float			m_fTimezoneOffset;

	// Paths
	CString			m_sUserPath;
	CString			m_sDLPath;
	// !Paths

	CBuffer				m_RawBuffer;
	CBuffer				m_MotdBuffer;
	CBuffer				m_QueryBuffer;
	bool				m_bMultiClients;
	bool				m_bBounceDCCs;
	bool				m_bPassHashed;
	bool				m_bUseClientIP;
	bool				m_bDenyLoadMod;
	bool				m_bAdmin;
	bool				m_bDenySetVHost;
	bool				m_bKeepBuffer;
	bool				m_bBeingDeleted;
	bool				m_bAppendTimestamp;
	bool				m_bPrependTimestamp;
	bool				m_bIRCConnectEnabled;
	CIRCSock*			m_pIRCSock;

	CJoinTimer*			m_pJoinTimer;
	CMiscTimer*			m_pMiscTimer;

	vector<CServer*>	m_vServers;
	vector<CChan*>		m_vChans;
	vector<CClient*>	m_vClients;
	set<CString>		m_ssAllowedHosts;
	unsigned int		m_uServerIdx;
	unsigned int		m_uBufferCount;
	unsigned long long      m_uBytesRead;
	unsigned long long      m_uBytesWritten;
	unsigned int		m_uMaxJoinTries;
	unsigned int		m_uMaxJoins;

#ifdef _MODULES
	CModules*		m_pModules;
#endif
};

#endif // !_USER_H
""","""/*
 * Copyright (C) 2004-2009  See the AUTHORS file for details.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 as published
 * by the Free Software Foundation.
 */

#ifndef _USER_H
#define _USER_H

#include ""Buffer.h""
#include ""FileUtils.h""
#ifdef _MODULES
#include ""Modules.h""
#endif
#include ""Nick.h""
#include <set>
#include <vector>

using std::set;
using std::vector;

class CChan;
class CClient;
class CIRCSock;
class CJoinTimer;
class CMiscTimer;
class CServer;

class CUser {
public:
	CUser(const CString& sUserName);
	~CUser();

	bool PrintLine(CFile& File, const CString& sName, const CString& sValue);
	bool WriteConfig(CFile& File);
	CChan* FindChan(const CString& sName) const;
	bool AddChan(CChan* pChan);
	bool AddChan(const CString& sName, bool bInConfig);
	bool DelChan(const CString& sName);
	void JoinChans();
	CServer* FindServer(const CString& sName) const;
	bool DelServer(const CString& sName);
	bool AddServer(const CString& sName);
	bool AddServer(const CString& sName, unsigned short uPort, const CString& sPass = """", bool bSSL = false);
	CServer* GetNextServer();
	CServer* GetCurrentServer() const;
	bool CheckPass(const CString& sPass) const;
	bool AddAllowedHost(const CString& sHostMask);
	bool IsHostAllowed(const CString& sHostMask) const;
	bool IsValid(CString& sErrMsg, bool bSkipPass = false) const;
	static bool IsValidUserName(const CString& sUserName);
	static CString MakeCleanUserName(const CString& sUserName);
	bool IsLastServer() const;
	bool ConnectPaused();

	void DelClients();
	void DelServers();
#ifdef _MODULES
	void DelModules();

	// Unloads a module on all users who have it loaded and loads it again.
	static bool UpdateModule(const CString &sModule);

	// Modules
	CModules& GetModules() { return *m_pModules; }
	const CModules& GetModules() const { return *m_pModules; }
	// !Modules
#endif

	// Buffers
	void AddRawBuffer(const CString& sPre, const CString& sPost, bool bIncNick = true) { m_RawBuffer.AddLine(sPre, sPost, bIncNick); }
	void AddMotdBuffer(const CString& sPre, const CString& sPost, bool bIncNick = true) { m_MotdBuffer.AddLine(sPre, sPost, bIncNick); }
	void AddQueryBuffer(const CString& sPre, const CString& sPost, bool bIncNick = true) { m_QueryBuffer.AddLine(sPre, sPost, bIncNick); }
	void UpdateRawBuffer(const CString& sPre, const CString& sPost, bool bIncNick = true) { m_RawBuffer.UpdateLine(sPre, sPost, bIncNick); }
	void UpdateMotdBuffer(const CString& sPre, const CString& sPost, bool bIncNick = true) { m_MotdBuffer.UpdateLine(sPre, sPost, bIncNick); }
	void UpdateQueryBuffer(const CString& sPre, const CString& sPost, bool bIncNick = true) { m_QueryBuffer.UpdateLine(sPre, sPost, bIncNick); }
	void ClearRawBuffer() { m_RawBuffer.Clear(); }
	void ClearMotdBuffer() { m_MotdBuffer.Clear(); }
	void ClearQueryBuffer() { m_QueryBuffer.Clear(); }
	// !Buffers

	bool PutIRC(const CString& sLine);
	bool PutUser(const CString& sLine, CClient* pClient = NULL, CClient* pSkipClient = NULL);
	bool PutStatus(const CString& sLine, CClient* pClient = NULL, CClient* pSkipClient = NULL);
	bool PutStatusNotice(const CString& sLine, CClient* pClient = NULL, CClient* pSkipClient = NULL);
	bool PutModule(const CString& sModule, const CString& sLine, CClient* pClient = NULL, CClient* pSkipClient = NULL);

	bool IsUserAttached() const { return !m_vClients.empty(); }
	void UserConnected(CClient* pClient);
	void UserDisconnected(CClient* pClient);

	CString GetLocalIP();
	bool IsIRCConnected() const { return GetIRCSock() != NULL; }
	void IRCConnected(CIRCSock* pIRCSock);
	void IRCDisconnected();
	void CheckIRCConnect();

	CString ExpandString(const CString& sStr) const;
	CString& ExpandString(const CString& sStr, CString& sRet) const;

	CString AddTimestamp(const CString& sStr) const;
	CString& AddTimestamp(const CString& sStr, CString& sRet) const;

	bool SendFile(const CString& sRemoteNick, const CString& sFileName, const CString& sModuleName = """");
	bool GetFile(const CString& sRemoteNick, const CString& sRemoteIP, unsigned short uRemotePort, const CString& sFileName, unsigned long uFileSize, const CString& sModuleName = """");
	bool ResumeFile(unsigned short uPort, unsigned long uFileSize);
	CString GetCurNick() const;
	bool Clone(const CUser& User, CString& sErrorRet, bool bCloneChans = true);
	void BounceAllClients();

	void AddBytesRead(unsigned long long u) { m_uBytesRead += u; }
	void AddBytesWritten(unsigned long long u) { m_uBytesWritten += u; }

	// Setters
	void SetUserName(const CString& s);
	void SetNick(const CString& s);
	void SetAltNick(const CString& s);
	void SetIdent(const CString& s);
	void SetRealName(const CString& s);
	void SetVHost(const CString& s);
	void SetPass(const CString& s, bool bHashed, const CString& sSalt = """");
	void SetBounceDCCs(bool b);
	void SetMultiClients(bool b);
	void SetUseClientIP(bool b);
	void SetDenyLoadMod(bool b);
	void SetAdmin(bool b);
	void SetDenySetVHost(bool b);
	bool SetStatusPrefix(const CString& s);
	void SetDefaultChanModes(const CString& s);
	void SetIRCNick(const CNick& n);
	void SetIRCServer(const CString& s);
	void SetQuitMsg(const CString& s);
	bool AddCTCPReply(const CString& sCTCP, const CString& sReply);
	void SetBufferCount(unsigned int u);
	void SetKeepBuffer(bool b);
	void SetChanPrefixes(const CString& s) { m_sChanPrefixes = s; }
	void SetBeingDeleted(bool b) { m_bBeingDeleted = b; }
	void SetTimestampFormat(const CString& s) { m_sTimestampFormat = s; }
	void SetTimestampAppend(bool b) { m_bAppendTimestamp = b; }
	void SetTimestampPrepend(bool b) { m_bPrependTimestamp = b; }
	void SetTimezoneOffset(float b) { m_fTimezoneOffset = b; }
	void SetJoinTries(unsigned int i) { m_uMaxJoinTries = i; }
	void SetMaxJoins(unsigned int i) { m_uMaxJoins = i; }
	void SetIRCConnectEnabled(bool b) { m_bIRCConnectEnabled = b; }
	// !Setters

	// Getters
	vector<CClient*>& GetClients() { return m_vClients; }
	CIRCSock* GetIRCSock() { return m_pIRCSock; }
	const CIRCSock* GetIRCSock() const { return m_pIRCSock; }
	const CString& GetUserName() const;
	const CString& GetCleanUserName() const;
	const CString& GetNick(bool bAllowDefault = true) const;
	const CString& GetAltNick(bool bAllowDefault = true) const;
	const CString& GetIdent(bool bAllowDefault = true) const;
	const CString& GetRealName() const;
	const CString& GetVHost() const;
	const CString& GetPass() const;
	bool IsPassHashed() const;
	const CString& GetPassSalt() const;
	const set<CString>& GetAllowedHosts() const;
	const CString& GetTimestampFormat() const;
	bool GetTimestampAppend() const;
	bool GetTimestampPrepend() const;
	bool GetIRCConnectEnabled() const { return m_bIRCConnectEnabled; }

	const CString& GetChanPrefixes() const { return m_sChanPrefixes; }
	bool IsChan(const CString& sChan) const;

	const CString& GetUserPath() const { if (!CFile::Exists(m_sUserPath)) { CDir::MakeDir(m_sUserPath); } return m_sUserPath; }
	const CString& GetDLPath() const { if (!CFile::Exists(m_sDLPath)) { CDir::MakeDir(m_sDLPath); } return m_sDLPath; }

	bool UseClientIP() const;
	bool DenyLoadMod() const;
	bool IsAdmin() const;
	bool DenySetVHost() const;
	bool BounceDCCs() const;
	bool MultiClients() const;
	const CString& GetStatusPrefix() const;
	const CString& GetDefaultChanModes() const;
	const vector<CChan*>& GetChans() const;
	const vector<CServer*>& GetServers() const;
	const CNick& GetIRCNick() const;
	const CString& GetIRCServer() const;
	CString GetQuitMsg() const;
	const MCString& GetCTCPReplies() const;
	unsigned int GetBufferCount() const;
	bool KeepBuffer() const;
	bool IsBeingDeleted() const { return m_bBeingDeleted; }
	bool HasServers() const { return m_vServers.size() > 0; }
	float GetTimezoneOffset() const { return m_fTimezoneOffset; }
	unsigned long long BytesRead() const { return m_uBytesRead; }
	unsigned long long BytesWritten() const { return m_uBytesWritten; }
	unsigned int JoinTries() const { return m_uMaxJoinTries; }
	unsigned int MaxJoins() const { return m_uMaxJoins; }
	// !Getters
private:
protected:
	time_t			m_uConnectTime;
	CString			m_sUserName;
	CString			m_sCleanUserName;
	CString			m_sNick;
	CString			m_sAltNick;
	CString			m_sIdent;
	CString			m_sRealName;
	CString			m_sVHost;
	CString			m_sPass;
	CString			m_sPassSalt;
	CString			m_sStatusPrefix;
	CString			m_sDefaultChanModes;
	CString			m_sChanPrefixes;
	CNick			m_IRCNick;
	CString			m_sIRCServer;
	CString			m_sQuitMsg;
	MCString		m_mssCTCPReplies;
	CString			m_sTimestampFormat;
	float			m_fTimezoneOffset;

	// Paths
	CString			m_sUserPath;
	CString			m_sDLPath;
	// !Paths

	CBuffer				m_RawBuffer;
	CBuffer				m_MotdBuffer;
	CBuffer				m_QueryBuffer;
	bool				m_bMultiClients;
	bool				m_bBounceDCCs;
	bool				m_bPassHashed;
	bool				m_bUseClientIP;
	bool				m_bDenyLoadMod;
	bool				m_bAdmin;
	bool				m_bDenySetVHost;
	bool				m_bKeepBuffer;
	bool				m_bBeingDeleted;
	bool				m_bAppendTimestamp;
	bool				m_bPrependTimestamp;
	bool				m_bIRCConnectEnabled;
	CIRCSock*			m_pIRCSock;

	CJoinTimer*			m_pJoinTimer;
	CMiscTimer*			m_pMiscTimer;

	vector<CServer*>	m_vServers;
	vector<CChan*>		m_vChans;
	vector<CClient*>	m_vClients;
	set<CString>		m_ssAllowedHosts;
	unsigned int		m_uServerIdx;
	unsigned int		m_uBufferCount;
	unsigned long long      m_uBytesRead;
	unsigned long long      m_uBytesWritten;
	unsigned int		m_uMaxJoinTries;
	unsigned int		m_uMaxJoins;

#ifdef _MODULES
	CModules*		m_pModules;
#endif
};

#endif // !_USER_H
""",CUser::IsUserAttached,[90:90]
znc,https://github.com/znc/znc/commit/338e52af9c3ec7217eae36b706cc810e2c91a183,"""Add /msg *perform execute

This command lets perform send the perform lines now. This can be useful for
testing.


git-svn-id: https://znc.svn.sourceforge.net/svnroot/znc/trunk@1558 726aef4b-f618-498e-8847-2d620e286838""","""/*
 * Copyright (C) 2004-2009  See the AUTHORS file for details.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 as published
 * by the Free Software Foundation.
 */

#include ""User.h""

class CPerform : public CModule {
public:
	MODCONSTRUCTOR(CPerform) {}

	virtual ~CPerform() {}

	virtual bool OnLoad(const CString& sArgs, CString& sMessage) {
		GetNV(""Perform"").Split(""\n"", m_vPerform, false);

		return true;
	}

	virtual void OnModCommand(const CString& sCommand) {
		CString sCmdName = sCommand.Token(0).AsLower();
		if (sCmdName == ""add"") {
			CString sPerf = sCommand.Token(1, true);

			if (sPerf.empty()) {
				PutModule(""Usage: add <command>"");
				return;
			}

			if (sPerf.Left(1) == ""/"")
				sPerf.LeftChomp();

			if (sPerf.Token(0).Equals(""MSG"")) {
				sPerf = ""PRIVMSG "" + sPerf.Token(1, true);
			}

			if ((sPerf.Token(0).Equals(""PRIVMSG"") ||
				sPerf.Token(0).Equals(""NOTICE"")) &&
				sPerf.Token(2).Left(1) != "":"") {
				sPerf = sPerf.Token(0) + "" "" + sPerf.Token(1)
					+ "" :"" + sPerf.Token(2, true);
			}
			m_vPerform.push_back(sPerf);
			PutModule(""Added!"");
			Save();
		} else if (sCmdName == ""del"") {
			u_int iNum = sCommand.Token(1, true).ToUInt();
			if (iNum > m_vPerform.size() || iNum <= 0) {
				PutModule(""Illegal # Requested"");
				return;
			} else {
				m_vPerform.erase(m_vPerform.begin() + iNum - 1);
				PutModule(""Command Erased."");
			}
			Save();
		} else if (sCmdName == ""list"") {
			int i = 1;
			CString sExpanded;
			for (VCString::iterator it = m_vPerform.begin(); it != m_vPerform.end(); it++, i++) {
				sExpanded = GetUser()->ExpandString(*it);
				if (sExpanded != *it)
					PutModule(CString(i) + "": "" + *it + "" ("" + sExpanded + "")"");
				else
					PutModule(CString(i) + "": "" + *it);
			}
			PutModule("" -- End of List"");
		} else {
			PutModule(""Commands: add <command>, del <nr>, list"");
		}
	}

	virtual void OnIRCConnected() {
		for (VCString::iterator it = m_vPerform.begin();
			it != m_vPerform.end();  it++) {
			PutIRC(GetUser()->ExpandString(*it));
		}
	}

private:
	bool Save() {
		CString sBuffer = """";

		for (VCString::iterator it = m_vPerform.begin(); it != m_vPerform.end(); it++) {
			sBuffer += *it + ""\n"";
		}
		SetNV(""Perform"", sBuffer);

		return true;
	}

	VCString	m_vPerform;
};

MODULEDEFS(CPerform, ""Adds perform capabilities"")
""","""/*
 * Copyright (C) 2004-2009  See the AUTHORS file for details.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 as published
 * by the Free Software Foundation.
 */

#include ""User.h""

class CPerform : public CModule {
public:
	MODCONSTRUCTOR(CPerform) {}

	virtual ~CPerform() {}

	virtual bool OnLoad(const CString& sArgs, CString& sMessage) {
		GetNV(""Perform"").Split(""\n"", m_vPerform, false);

		return true;
	}

	virtual void OnModCommand(const CString& sCommand) {
		CString sCmdName = sCommand.Token(0).AsLower();
		if (sCmdName == ""add"") {
			CString sPerf = sCommand.Token(1, true);

			if (sPerf.empty()) {
				PutModule(""Usage: add <command>"");
				return;
			}

			if (sPerf.Left(1) == ""/"")
				sPerf.LeftChomp();

			if (sPerf.Token(0).Equals(""MSG"")) {
				sPerf = ""PRIVMSG "" + sPerf.Token(1, true);
			}

			if ((sPerf.Token(0).Equals(""PRIVMSG"") ||
				sPerf.Token(0).Equals(""NOTICE"")) &&
				sPerf.Token(2).Left(1) != "":"") {
				sPerf = sPerf.Token(0) + "" "" + sPerf.Token(1)
					+ "" :"" + sPerf.Token(2, true);
			}
			m_vPerform.push_back(sPerf);
			PutModule(""Added!"");
			Save();
		} else if (sCmdName == ""del"") {
			u_int iNum = sCommand.Token(1, true).ToUInt();
			if (iNum > m_vPerform.size() || iNum <= 0) {
				PutModule(""Illegal # Requested"");
				return;
			} else {
				m_vPerform.erase(m_vPerform.begin() + iNum - 1);
				PutModule(""Command Erased."");
			}
			Save();
		} else if (sCmdName == ""list"") {
			int i = 1;
			CString sExpanded;
			for (VCString::iterator it = m_vPerform.begin(); it != m_vPerform.end(); it++, i++) {
				sExpanded = GetUser()->ExpandString(*it);
				if (sExpanded != *it)
					PutModule(CString(i) + "": "" + *it + "" ("" + sExpanded + "")"");
				else
					PutModule(CString(i) + "": "" + *it);
			}
			PutModule("" -- End of List"");
		} else if (sCmdName == ""execute"") {
			OnIRCConnected();
			PutModule(""perform commands sent"");
		} else {
			PutModule(""Commands: add <command>, del <nr>, list, execute"");
		}
	}

	virtual void OnIRCConnected() {
		for (VCString::iterator it = m_vPerform.begin();
			it != m_vPerform.end();  it++) {
			PutIRC(GetUser()->ExpandString(*it));
		}
	}

private:
	bool Save() {
		CString sBuffer = """";

		for (VCString::iterator it = m_vPerform.begin(); it != m_vPerform.end(); it++) {
			sBuffer += *it + ""\n"";
		}
		SetNV(""Perform"", sBuffer);

		return true;
	}

	VCString	m_vPerform;
};

MODULEDEFS(CPerform, ""Adds perform capabilities"")
""",CPerform::OnModCommand,[23:76]
znc,https://github.com/znc/znc/commit/39364f057fb7d2e0bf62e2aad103ff4fa64657f4,"""Add a ""swap"" command to perform to change the order of commands

Patch by KiNgMaR, thanks.


git-svn-id: https://znc.svn.sourceforge.net/svnroot/znc/trunk@1560 726aef4b-f618-498e-8847-2d620e286838""","""/*
 * Copyright (C) 2004-2009  See the AUTHORS file for details.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 as published
 * by the Free Software Foundation.
 */

#include ""User.h""

class CPerform : public CModule {
public:
	MODCONSTRUCTOR(CPerform) {}

	virtual ~CPerform() {}

	virtual bool OnLoad(const CString& sArgs, CString& sMessage) {
		GetNV(""Perform"").Split(""\n"", m_vPerform, false);

		return true;
	}

	virtual void OnModCommand(const CString& sCommand) {
		CString sCmdName = sCommand.Token(0).AsLower();
		if (sCmdName == ""add"") {
			CString sPerf = sCommand.Token(1, true);

			if (sPerf.empty()) {
				PutModule(""Usage: add <command>"");
				return;
			}

			if (sPerf.Left(1) == ""/"")
				sPerf.LeftChomp();

			if (sPerf.Token(0).Equals(""MSG"")) {
				sPerf = ""PRIVMSG "" + sPerf.Token(1, true);
			}

			if ((sPerf.Token(0).Equals(""PRIVMSG"") ||
				sPerf.Token(0).Equals(""NOTICE"")) &&
				sPerf.Token(2).Left(1) != "":"") {
				sPerf = sPerf.Token(0) + "" "" + sPerf.Token(1)
					+ "" :"" + sPerf.Token(2, true);
			}
			m_vPerform.push_back(sPerf);
			PutModule(""Added!"");
			Save();
		} else if (sCmdName == ""del"") {
			u_int iNum = sCommand.Token(1, true).ToUInt();
			if (iNum > m_vPerform.size() || iNum <= 0) {
				PutModule(""Illegal # Requested"");
				return;
			} else {
				m_vPerform.erase(m_vPerform.begin() + iNum - 1);
				PutModule(""Command Erased."");
			}
			Save();
		} else if (sCmdName == ""list"") {
			int i = 1;
			CString sExpanded;
			for (VCString::iterator it = m_vPerform.begin(); it != m_vPerform.end(); it++, i++) {
				sExpanded = GetUser()->ExpandString(*it);
				if (sExpanded != *it)
					PutModule(CString(i) + "": "" + *it + "" ("" + sExpanded + "")"");
				else
					PutModule(CString(i) + "": "" + *it);
			}
			PutModule("" -- End of List"");
		} else if (sCmdName == ""execute"") {
			OnIRCConnected();
			PutModule(""perform commands sent"");
		} else {
			PutModule(""Commands: add <command>, del <nr>, list, execute"");
		}
	}

	virtual void OnIRCConnected() {
		for (VCString::iterator it = m_vPerform.begin();
			it != m_vPerform.end();  it++) {
			PutIRC(GetUser()->ExpandString(*it));
		}
	}

private:
	bool Save() {
		CString sBuffer = """";

		for (VCString::iterator it = m_vPerform.begin(); it != m_vPerform.end(); it++) {
			sBuffer += *it + ""\n"";
		}
		SetNV(""Perform"", sBuffer);

		return true;
	}

	VCString	m_vPerform;
};

MODULEDEFS(CPerform, ""Adds perform capabilities"")
""","""/*
 * Copyright (C) 2004-2009  See the AUTHORS file for details.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 as published
 * by the Free Software Foundation.
 */

#include ""User.h""
#include <algorithm>

class CPerform : public CModule {
public:
	MODCONSTRUCTOR(CPerform) {}

	virtual ~CPerform() {}

	virtual bool OnLoad(const CString& sArgs, CString& sMessage) {
		GetNV(""Perform"").Split(""\n"", m_vPerform, false);

		return true;
	}

	virtual void OnModCommand(const CString& sCommand) {
		CString sCmdName = sCommand.Token(0).AsLower();
		if (sCmdName == ""add"") {
			CString sPerf = sCommand.Token(1, true);

			if (sPerf.empty()) {
				PutModule(""Usage: add <command>"");
				return;
			}

			if (sPerf.Left(1) == ""/"")
				sPerf.LeftChomp();

			if (sPerf.Token(0).Equals(""MSG"")) {
				sPerf = ""PRIVMSG "" + sPerf.Token(1, true);
			}

			if ((sPerf.Token(0).Equals(""PRIVMSG"") ||
				sPerf.Token(0).Equals(""NOTICE"")) &&
				sPerf.Token(2).Left(1) != "":"") {
				sPerf = sPerf.Token(0) + "" "" + sPerf.Token(1)
					+ "" :"" + sPerf.Token(2, true);
			}
			m_vPerform.push_back(sPerf);
			PutModule(""Added!"");
			Save();
		} else if (sCmdName == ""del"") {
			u_int iNum = sCommand.Token(1, true).ToUInt();
			if (iNum > m_vPerform.size() || iNum <= 0) {
				PutModule(""Illegal # Requested"");
				return;
			} else {
				m_vPerform.erase(m_vPerform.begin() + iNum - 1);
				PutModule(""Command Erased."");
			}
			Save();
		} else if (sCmdName == ""list"") {
			int i = 1;
			CString sExpanded;
			for (VCString::iterator it = m_vPerform.begin(); it != m_vPerform.end(); it++, i++) {
				sExpanded = GetUser()->ExpandString(*it);
				if (sExpanded != *it)
					PutModule(CString(i) + "": "" + *it + "" ("" + sExpanded + "")"");
				else
					PutModule(CString(i) + "": "" + *it);
			}
			PutModule("" -- End of List"");
		} else if (sCmdName == ""execute"") {
			OnIRCConnected();
			PutModule(""perform commands sent"");
		} else if (sCmdName == ""swap"") {
			u_int iNumA = sCommand.Token(1).ToUInt();
			u_int iNumB = sCommand.Token(2).ToUInt();

			if (iNumA > m_vPerform.size() || iNumA <= 0 || iNumB > m_vPerform.size() || iNumB <= 0) {
				PutModule(""Illegal # Requested"");
			} else {
				std::iter_swap(m_vPerform.begin() + (iNumA - 1), m_vPerform.begin() + (iNumB - 1));
				PutModule(""Commands Swapped."");
				Save();
			}
		} else {
			PutModule(""Commands: add <command>, del <nr>, list, execute, swap <nr> <nr>"");
		}
	}

	virtual void OnIRCConnected() {
		for (VCString::iterator it = m_vPerform.begin();
			it != m_vPerform.end();  it++) {
			PutIRC(GetUser()->ExpandString(*it));
		}
	}

private:
	bool Save() {
		CString sBuffer = """";

		for (VCString::iterator it = m_vPerform.begin(); it != m_vPerform.end(); it++) {
			sBuffer += *it + ""\n"";
		}
		SetNV(""Perform"", sBuffer);

		return true;
	}

	VCString	m_vPerform;
};

MODULEDEFS(CPerform, ""Adds perform capabilities"")
""",CPerform::OnModCommand,[24:88]
znc,https://github.com/znc/znc/commit/03f3e348e4542f60bbb6441aed7778374efa95ea,"""Micro-optimization: Use existing functions in CModule::RemTimer()

CModule::RemTimer(const CString& sLabel) now uses FindTimer() and
RemTimer(CTimer *) to do the work instead of doing all of this by itself.

Thanks to KiNgMaR again.


git-svn-id: https://znc.svn.sourceforge.net/svnroot/znc/trunk@1651 726aef4b-f618-498e-8847-2d620e286838""","""/*
 * Copyright (C) 2004-2009  See the AUTHORS file for details.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 as published
 * by the Free Software Foundation.
 */

#ifdef _MODULES

#include ""Modules.h""
#include ""User.h""
#include ""znc.h""
#include <dlfcn.h>

#ifndef RTLD_LOCAL
# define RTLD_LOCAL 0
# warning ""your crap box doesnt define RTLD_LOCAL !?""
#endif

#define _MODUNLOADCHK(func, type)								\
	for (unsigned int a = 0; a < size(); a++) {			\
		try {											\
			type* pMod = (type *) (*this)[a];					\
			CClient* pOldClient = pMod->GetClient();			\
			pMod->SetClient(m_pClient);					\
			if (m_pUser) {							\
				CUser* pOldUser = pMod->GetUser();			\
				pMod->SetUser(m_pUser);					\
				pMod->func;						\
				pMod->SetUser(pOldUser);				\
			} else {							\
				pMod->func;						\
			}								\
			pMod->SetClient(pOldClient);					\
		} catch (CModule::EModException e) {			\
			if (e == CModule::UNLOAD) {					\
				UnloadModule((*this)[a]->GetModName());	\
			}											\
		}												\
	}

#define MODUNLOADCHK(func)	_MODUNLOADCHK(func, CModule)
#define GLOBALMODCALL(func)	_MODUNLOADCHK(func, CGlobalModule)

#define _MODHALTCHK(func, type)							\
	bool bHaltCore = false;								\
	for (unsigned int a = 0; a < size(); a++) {			\
		try {											\
			type* pMod = (type*) (*this)[a];			\
			CModule::EModRet e = CModule::CONTINUE;		\
			CClient* pOldClient = pMod->GetClient();			\
			pMod->SetClient(m_pClient);				\
			if (m_pUser) {								\
				CUser* pOldUser = pMod->GetUser();			\
				pMod->SetUser(m_pUser);					\
				e = pMod->func;							\
				pMod->SetUser(pOldUser);				\
			} else {									\
				e = pMod->func;							\
			}											\
			pMod->SetClient(pOldClient);				\
			if (e == CModule::HALTMODS) {				\
				break;									\
			} else if (e == CModule::HALTCORE) {		\
				bHaltCore = true;						\
			} else if (e == CModule::HALT) {			\
				bHaltCore = true;						\
				break;									\
			}											\
		} catch (CModule::EModException e) {			\
			if (e == CModule::UNLOAD) {					\
				UnloadModule((*this)[a]->GetModName());	\
			}											\
		}												\
	}													\
	return bHaltCore;

#define MODHALTCHK(func)	_MODHALTCHK(func, CModule)
#define GLOBALMODHALTCHK(func)	_MODHALTCHK(func, CGlobalModule)

/////////////////// Timer ///////////////////
CTimer::CTimer(CModule* pModule, unsigned int uInterval, unsigned int uCycles, const CString& sLabel, const CString& sDescription) : CCron() {
	SetName(sLabel);
	m_sDescription = sDescription;
	m_pModule = pModule;

	if (uCycles) {
		StartMaxCycles(uInterval, uCycles);
	} else {
		Start(uInterval);
	}
}

CTimer::~CTimer() {
	m_pModule->UnlinkTimer(this);
}

void CTimer::SetModule(CModule* p) { m_pModule = p; }
void CTimer::SetDescription(const CString& s) { m_sDescription = s; }
CModule* CTimer::GetModule() const { return m_pModule; }
const CString& CTimer::GetDescription() const { return m_sDescription; }
/////////////////// !Timer ///////////////////

/////////////////// Socket ///////////////////
CSocket::CSocket(CModule* pModule) : CZNCSock() {
	m_pModule = pModule;
	m_pModule->AddSocket(this);
	EnableReadLine();
	SetMaxBufferThreshold(10240);
}

CSocket::CSocket(CModule* pModule, const CString& sHostname, unsigned short uPort, int iTimeout) : CZNCSock(sHostname, uPort, iTimeout) {
	m_pModule = pModule;
	m_pModule->AddSocket(this);
	EnableReadLine();
	SetMaxBufferThreshold(10240);
}

CSocket::~CSocket() {
	CUser *pUser = m_pModule->GetUser();

	m_pModule->UnlinkSocket(this);

	if (!m_pModule->IsGlobal() && pUser) {
		pUser->AddBytesWritten(GetBytesWritten());
		pUser->AddBytesRead(GetBytesRead());
	} else {
		CZNC::Get().AddBytesWritten(GetBytesWritten());
		CZNC::Get().AddBytesRead(GetBytesRead());
	}
}

void CSocket::ReachedMaxBuffer() {
	DEBUG(GetSockName() << "" == ReachedMaxBuffer()"");
	PutModule(""Some socket reached its max buffer limit and was closed!"");
	Close();
}

void CSocket::SockError(int iErrno) {
	DEBUG(GetSockName() << "" == SockError("" << strerror(iErrno) << "")"");
	if (iErrno == EMFILE) {
		// We have too many open fds, this can cause a busy loop.
		Close();
	}
}

bool CSocket::ConnectionFrom(const CString& sHost, unsigned short uPort) {
	return CZNC::Get().AllowConnectionFrom(sHost);
}

bool CSocket::Connect(const CString& sHostname, unsigned short uPort, bool bSSL, unsigned int uTimeout) {
	CUser* pUser = m_pModule->GetUser();
	CString sSockName = ""MOD::C::"" + m_pModule->GetModName();
	CString sVHost;

	if (pUser) {
		sSockName += ""::"" + pUser->GetUserName();
		sVHost = m_pModule->GetUser()->GetVHost();
	}

	// Don't overwrite the socket name if one is already set
	if (!GetSockName().empty()) {
		sSockName = GetSockName();
	}

	return m_pModule->GetManager()->Connect(sHostname, uPort, sSockName, uTimeout, bSSL, sVHost, this);
}

bool CSocket::Listen(unsigned short uPort, bool bSSL, unsigned int uTimeout) {
	CUser* pUser = m_pModule->GetUser();
	CString sSockName = ""MOD::L::"" + m_pModule->GetModName();

	if (pUser) {
		sSockName += ""::"" + pUser->GetUserName();
	}
	// Don't overwrite the socket name if one is already set
	if (!GetSockName().empty()) {
		sSockName = GetSockName();
	}

	return m_pModule->GetManager()->ListenAll(uPort, sSockName, bSSL, SOMAXCONN, this);
}

bool CSocket::PutIRC(const CString& sLine) {
	return (m_pModule) ? m_pModule->PutIRC(sLine) : false;
}

bool CSocket::PutUser(const CString& sLine) {
	return (m_pModule) ? m_pModule->PutUser(sLine) : false;
}

bool CSocket::PutStatus(const CString& sLine) {
	return (m_pModule) ? m_pModule->PutStatus(sLine) : false;
}

bool CSocket::PutModule(const CString& sLine, const CString& sIdent, const CString& sHost) {
	return (m_pModule) ? m_pModule->PutModule(sLine, sIdent, sHost) : false;
}
bool CSocket::PutModNotice(const CString& sLine, const CString& sIdent, const CString& sHost) {
	return (m_pModule) ? m_pModule->PutModNotice(sLine, sIdent, sHost) : false;
}

void CSocket::SetModule(CModule* p) { m_pModule = p; }
CModule* CSocket::GetModule() const { return m_pModule; }
/////////////////// !Socket ///////////////////

CModule::CModule(ModHandle pDLL, CUser* pUser, const CString& sModName, const CString& sDataDir) {
	m_bFake = false;
	m_bGlobal = false;
	m_pDLL = pDLL;
	m_pManager = &(CZNC::Get().GetManager());;
	m_pUser = pUser;
	m_pClient = NULL;
	m_sModName = sModName;
	m_sDataDir = sDataDir;

	if (m_pUser) {
		m_sSavePath = m_pUser->GetUserPath() + ""/moddata/"" + m_sModName;
		LoadRegistry();
	}
}

CModule::CModule(ModHandle pDLL, const CString& sModName, const CString& sDataDir) {
	m_bFake = false;
	m_pDLL = pDLL;
	m_pManager = &(CZNC::Get().GetManager());
	m_pUser = NULL;
	m_pClient = NULL;
	m_sModName = sModName;
	m_sDataDir = sDataDir;

	m_sSavePath = CZNC::Get().GetZNCPath() + ""/moddata/"" + m_sModName;
	LoadRegistry();
}

CModule::~CModule() {
	while (!m_sTimers.empty()) {
		RemTimer(*m_sTimers.begin());
	}

	while (!m_sSockets.empty()) {
		RemSocket(*m_sSockets.begin());
	}

	SaveRegistry();
}

void CModule::SetUser(CUser* pUser) { m_pUser = pUser; }
void CModule::SetClient(CClient* pClient) { m_pClient = pClient; }
void CModule::Unload() { throw UNLOAD; }

bool CModule::LoadRegistry() {
	//CString sPrefix = (m_pUser) ? m_pUser->GetUserName() : "".global"";
	return (m_mssRegistry.ReadFromDisk(GetSavePath() + ""/.registry"", 0600) == MCString::MCS_SUCCESS);
}

bool CModule::SaveRegistry() {
	//CString sPrefix = (m_pUser) ? m_pUser->GetUserName() : "".global"";
	return (m_mssRegistry.WriteToDisk(GetSavePath() + ""/.registry"", 0600) == MCString::MCS_SUCCESS);
}

bool CModule::SetNV(const CString & sName, const CString & sValue, bool bWriteToDisk) {
	m_mssRegistry[sName] = sValue;
	if (bWriteToDisk) {
		return SaveRegistry();
	}

	return true;
}

CString CModule::GetNV(const CString & sName) {
	MCString::iterator it = m_mssRegistry.find(sName);

	if (it != m_mssRegistry.end()) {
		return it->second;
	}

	return """";
}

bool CModule::DelNV(const CString & sName, bool bWriteToDisk) {
	MCString::iterator it = m_mssRegistry.find(sName);

	if (it != m_mssRegistry.end()) {
		m_mssRegistry.erase(it);
	} else {
		return false;
	}

	if (bWriteToDisk) {
		return SaveRegistry();
	}

	return true;
}

bool CModule::ClearNV(bool bWriteToDisk) {
	m_mssRegistry.clear();

	if (bWriteToDisk) {
		return SaveRegistry();
	}
	return true;
}

bool CModule::AddTimer(CTimer* pTimer) {
	if ((!pTimer) || (FindTimer(pTimer->GetName()))) {
		delete pTimer;
		return false;
	}

	if (!m_sTimers.insert(pTimer).second)
		// Was already added
		return true;

	m_pManager->AddCron(pTimer);
	return true;
}

bool CModule::AddTimer(FPTimer_t pFBCallback, const CString& sLabel, u_int uInterval, u_int uCycles, const CString& sDescription) {
	CFPTimer *pTimer = new CFPTimer(this, uInterval, uCycles, sLabel, sDescription);
	pTimer->SetFPCallback(pFBCallback);

	return AddTimer(pTimer);
}

bool CModule::RemTimer(CTimer* pTimer) {
	if (m_sTimers.erase(pTimer) == 0)
		return false;
	m_pManager->DelCronByAddr(pTimer);
	return true;
}

bool CModule::RemTimer(const CString& sLabel) {
	set<CTimer*>::iterator it;
	for (it = m_sTimers.begin(); it != m_sTimers.end(); ++it) {
		CTimer* pTimer = *it;

		if (pTimer->GetName().Equals(sLabel)) {
			m_sTimers.erase(it);
			m_pManager->DelCronByAddr(pTimer);
			return true;
		}
	}

	return false;
}

bool CModule::UnlinkTimer(CTimer* pTimer) {
	set<CTimer*>::iterator it;
	for (it = m_sTimers.begin(); it != m_sTimers.end(); ++it) {
		if (pTimer == *it) {
			m_sTimers.erase(it);
			return true;
		}
	}

	return false;
}

CTimer* CModule::FindTimer(const CString& sLabel) {
	set<CTimer*>::iterator it;
	for (it = m_sTimers.begin(); it != m_sTimers.end(); ++it) {
		CTimer* pTimer = *it;
		if (pTimer->GetName().Equals(sLabel)) {
			return pTimer;
		}
	}

	return NULL;
}

void CModule::ListTimers() {
	if (m_sTimers.empty()) {
		PutModule(""You have no timers running."");
		return;
	}

	CTable Table;
	Table.AddColumn(""Name"");
	Table.AddColumn(""Secs"");
	Table.AddColumn(""Cycles"");
	Table.AddColumn(""Description"");

	set<CTimer*>::iterator it;
	for (it = m_sTimers.begin(); it != m_sTimers.end(); ++it) {
		CTimer* pTimer = *it;
		unsigned int uCycles = pTimer->GetCyclesLeft();

		Table.AddRow();
		Table.SetCell(""Name"", pTimer->GetName());
		Table.SetCell(""Secs"", CString(pTimer->GetInterval()));
		Table.SetCell(""Cycles"", ((uCycles) ? CString(uCycles) : ""INF""));
		Table.SetCell(""Description"", pTimer->GetDescription());
	}

	PutModule(Table);
}

bool CModule::AddSocket(CSocket* pSocket) {
	if (!pSocket) {
		return false;
	}

	m_sSockets.insert(pSocket);
	return true;
}

bool CModule::RemSocket(CSocket* pSocket) {
	set<CSocket*>::iterator it;
	for (it = m_sSockets.begin(); it != m_sSockets.end(); ++it) {
		if (*it == pSocket) {
			m_sSockets.erase(it);
			m_pManager->DelSockByAddr(pSocket);
			return true;
		}
	}

	return false;
}

bool CModule::RemSocket(const CString& sSockName) {
	set<CSocket*>::iterator it;
	for (it = m_sSockets.begin(); it != m_sSockets.end(); ++it) {
		CSocket* pSocket = *it;

		if (pSocket->GetSockName().Equals(sSockName)) {
			m_sSockets.erase(it);
			m_pManager->DelSockByAddr(pSocket);
			return true;
		}
	}

	return false;
}

bool CModule::UnlinkSocket(CSocket* pSocket) {
	set<CSocket*>::iterator it;
	for (it = m_sSockets.begin(); it != m_sSockets.end(); ++it) {
		if (pSocket == *it) {
			m_sSockets.erase(it);
			return true;
		}
	}

	return false;
}

CSocket* CModule::FindSocket(const CString& sSockName) {
	set<CSocket*>::iterator it;
	for (it = m_sSockets.begin(); it != m_sSockets.end(); ++it) {
		CSocket* pSocket = *it;
		if (pSocket->GetSockName().Equals(sSockName)) {
			return pSocket;
		}
	}

	return NULL;
}

void CModule::ListSockets() {
	if (m_sSockets.empty()) {
		PutModule(""You have no open sockets."");
		return;
	}

	CTable Table;
	Table.AddColumn(""Name"");
	Table.AddColumn(""State"");
	Table.AddColumn(""LocalPort"");
	Table.AddColumn(""SSL"");
	Table.AddColumn(""RemoteIP"");
	Table.AddColumn(""RemotePort"");

	set<CSocket*>::iterator it;
	for (it = m_sSockets.begin(); it != m_sSockets.end(); ++it) {
		CSocket* pSocket = *it;

		Table.AddRow();
		Table.SetCell(""Name"", pSocket->GetSockName());

		if (pSocket->GetType() == CSocket::LISTENER) {
			Table.SetCell(""State"", ""Listening"");
		} else {
			Table.SetCell(""State"", (pSocket->IsConnected() ? ""Connected"" : """"));
		}

		Table.SetCell(""LocalPort"", CString(pSocket->GetLocalPort()));
		Table.SetCell(""SSL"", (pSocket->GetSSL() ? ""yes"" : ""no""));
		Table.SetCell(""RemoteIP"", pSocket->GetRemoteIP());
		Table.SetCell(""RemotePort"", (pSocket->GetRemotePort()) ? CString(pSocket->GetRemotePort()) : CString(""""));
	}

	PutModule(Table);
}

CString CModule::GetModNick() const { return ((m_pUser) ? m_pUser->GetStatusPrefix() : ""*"") + m_sModName; }

bool CModule::OnLoad(const CString& sArgs, CString& sMessage) { sMessage = """"; return true; }
bool CModule::OnBoot() { return true; }
void CModule::OnPreRehash() {}
void CModule::OnPostRehash() {}
void CModule::OnIRCDisconnected() {}
void CModule::OnIRCConnected() {}
CModule::EModRet CModule::OnIRCConnecting(CIRCSock *IRCSock) { return CONTINUE; }
CModule::EModRet CModule::OnIRCRegistration(CString& sPass, CString& sNick, CString& sIdent, CString& sRealName) { return CONTINUE; }
CModule::EModRet CModule::OnBroadcast(CString& sMessage) { return CONTINUE; }

CModule::EModRet CModule::OnDCCUserSend(const CNick& RemoteNick, unsigned long uLongIP, unsigned short uPort, const CString& sFile, unsigned long uFileSize) { return CONTINUE; }

void CModule::OnChanPermission(const CNick& OpNick, const CNick& Nick, CChan& Channel, unsigned char uMode, bool bAdded, bool bNoChange) {}
void CModule::OnOp(const CNick& OpNick, const CNick& Nick, CChan& Channel, bool bNoChange) {}
void CModule::OnDeop(const CNick& OpNick, const CNick& Nick, CChan& Channel, bool bNoChange) {}
void CModule::OnVoice(const CNick& OpNick, const CNick& Nick, CChan& Channel, bool bNoChange) {}
void CModule::OnDevoice(const CNick& OpNick, const CNick& Nick, CChan& Channel, bool bNoChange) {}
void CModule::OnRawMode(const CNick& OpNick, CChan& Channel, const CString& sModes, const CString& sArgs) {}
void CModule::OnMode(const CNick& OpNick, CChan& Channel, char uMode, const CString& sArg, bool bAdded, bool bNoChange) {}

CModule::EModRet CModule::OnRaw(CString& sLine) { return CONTINUE; }

CModule::EModRet CModule::OnStatusCommand(CString& sCommand) { return CONTINUE; }
void CModule::OnModCommand(const CString& sCommand) {}
void CModule::OnModNotice(const CString& sMessage) {}
void CModule::OnModCTCP(const CString& sMessage) {}

void CModule::OnQuit(const CNick& Nick, const CString& sMessage, const vector<CChan*>& vChans) {}
void CModule::OnNick(const CNick& Nick, const CString& sNewNick, const vector<CChan*>& vChans) {}
void CModule::OnKick(const CNick& Nick, const CString& sKickedNick, CChan& Channel, const CString& sMessage) {}
void CModule::OnJoin(const CNick& Nick, CChan& Channel) {}
void CModule::OnPart(const CNick& Nick, CChan& Channel) {}

CModule::EModRet CModule::OnChanBufferStarting(CChan& Chan, CClient& Client) { return CONTINUE; }
CModule::EModRet CModule::OnChanBufferEnding(CChan& Chan, CClient& Client) { return CONTINUE; }
CModule::EModRet CModule::OnChanBufferPlayLine(CChan& Chan, CClient& Client, CString& sLine) { return CONTINUE; }
CModule::EModRet CModule::OnPrivBufferPlayLine(CClient& Client, CString& sLine) { return CONTINUE; }

void CModule::OnClientLogin() {}
void CModule::OnClientDisconnect() {}
CModule::EModRet CModule::OnUserRaw(CString& sLine) { return CONTINUE; }
CModule::EModRet CModule::OnUserCTCPReply(CString& sTarget, CString& sMessage) { return CONTINUE; }
CModule::EModRet CModule::OnUserCTCP(CString& sTarget, CString& sMessage) { return CONTINUE; }
CModule::EModRet CModule::OnUserAction(CString& sTarget, CString& sMessage) { return CONTINUE; }
CModule::EModRet CModule::OnUserMsg(CString& sTarget, CString& sMessage) { return CONTINUE; }
CModule::EModRet CModule::OnUserNotice(CString& sTarget, CString& sMessage) { return CONTINUE; }
CModule::EModRet CModule::OnUserJoin(CString& sChannel, CString& sKey) { return CONTINUE; }
CModule::EModRet CModule::OnUserPart(CString& sChannel, CString& sMessage) { return CONTINUE; }
CModule::EModRet CModule::OnUserTopic(CString& sChannel, CString& sTopic) { return CONTINUE; }
CModule::EModRet CModule::OnUserTopicRequest(CString& sChannel) { return CONTINUE; }

CModule::EModRet CModule::OnCTCPReply(CNick& Nick, CString& sMessage) { return CONTINUE; }
CModule::EModRet CModule::OnPrivCTCP(CNick& Nick, CString& sMessage) { return CONTINUE; }
CModule::EModRet CModule::OnChanCTCP(CNick& Nick, CChan& Channel, CString& sMessage) { return CONTINUE; }
CModule::EModRet CModule::OnPrivAction(CNick& Nick, CString& sMessage) { return CONTINUE; }
CModule::EModRet CModule::OnChanAction(CNick& Nick, CChan& Channel, CString& sMessage) { return CONTINUE; }
CModule::EModRet CModule::OnPrivMsg(CNick& Nick, CString& sMessage) { return CONTINUE; }
CModule::EModRet CModule::OnChanMsg(CNick& Nick, CChan& Channel, CString& sMessage) { return CONTINUE; }
CModule::EModRet CModule::OnPrivNotice(CNick& Nick, CString& sMessage) { return CONTINUE; }
CModule::EModRet CModule::OnChanNotice(CNick& Nick, CChan& Channel, CString& sMessage) { return CONTINUE; }
CModule::EModRet CModule::OnTopic(CNick& Nick, CChan& Channel, CString& sTopic) { return CONTINUE; }
CModule::EModRet CModule::OnTimerAutoJoin(CChan& Channel) { return CONTINUE; }

ModHandle CModule::GetDLL() { return m_pDLL; }
bool CModule::PutIRC(const CString& sLine) {
	return (m_pUser) ? m_pUser->PutIRC(sLine) : false;
}
bool CModule::PutUser(const CString& sLine) {
	return (m_pUser) ? m_pUser->PutUser(sLine, m_pClient) : false;
}
bool CModule::PutStatus(const CString& sLine) {
	return (m_pUser) ? m_pUser->PutStatus(sLine, m_pClient) : false;
}
unsigned int CModule::PutModule(const CTable& table, const CString& sIdent, const CString& sHost) {
	if (!m_pUser)
		return 0;

	unsigned int idx = 0;
	CString sLine;
	while (table.GetLine(idx++, sLine))
		PutModule(sLine, sIdent, sHost);
	return idx - 1;
}
bool CModule::PutModule(const CString& sLine, const CString& sIdent, const CString& sHost) {
	if (!m_pUser)
		return false;
	return m_pUser->PutUser("":"" + GetModNick() + ""!"" +
		(sIdent.empty() ? GetModName() : sIdent) + ""@"" + sHost +
		"" PRIVMSG "" + m_pUser->GetCurNick() + "" :"" + sLine,
		m_pClient);
}
bool CModule::PutModNotice(const CString& sLine, const CString& sIdent, const CString& sHost) {
	if (!m_pUser)
		return false;
	return m_pUser->PutUser("":"" + GetModNick() + ""!"" +
		(sIdent.empty() ? GetModName() : sIdent) + ""@"" + sHost +
		"" NOTICE "" + m_pUser->GetCurNick() + "" :"" + sLine,
		m_pClient);
}

///////////////////
// CGlobalModule //
///////////////////
CModule::EModRet CGlobalModule::OnConfigLine(const CString& sName, const CString& sValue, CUser* pUser, CChan* pChan) { return CONTINUE; }
CModule::EModRet CGlobalModule::OnDeleteUser(CUser& User) { return CONTINUE; }
void CGlobalModule::OnClientConnect(CClient* pClient, const CString& sHost, unsigned short uPort) {}
CModule::EModRet CGlobalModule::OnLoginAttempt(CSmartPtr<CAuthBase> Auth) { return CONTINUE; }
void CGlobalModule::OnFailedLogin(const CString& sUsername, const CString& sRemoteIP) {}
CModule::EModRet CGlobalModule::OnUnknownUserRaw(CClient* pClient, CString& sLine) { return CONTINUE; }


CModules::CModules() {
	m_pUser = NULL;
	m_pClient = NULL;
}

CModules::~CModules() {
	UnloadAll();
}

void CModules::UnloadAll() {
	while (size()) {
		CString sRetMsg;
		CString sModName = (*this)[0]->GetModName();
		UnloadModule(sModName, sRetMsg);
	}
}

bool CModules::OnBoot() {
	for (unsigned int a = 0; a < size(); a++) {
		try {
			if (!(*this)[a]->OnBoot()) {
				return false;
			}
		} catch (CModule::EModException e) {
			if (e == CModule::UNLOAD) {
				UnloadModule((*this)[a]->GetModName());
			}
		}
	}

	return true;
}

bool CModules::OnPreRehash() { MODUNLOADCHK(OnPreRehash()); return false; }
bool CModules::OnPostRehash() { MODUNLOADCHK(OnPostRehash()); return false; }
bool CModules::OnIRCConnected() { MODUNLOADCHK(OnIRCConnected()); return false; }
bool CModules::OnIRCConnecting(CIRCSock *pIRCSock) { MODHALTCHK(OnIRCConnecting(pIRCSock)); }
bool CModules::OnIRCRegistration(CString& sPass, CString& sNick, CString& sIdent, CString& sRealName) { MODHALTCHK(OnIRCRegistration(sPass, sNick, sIdent, sRealName)); }
bool CModules::OnBroadcast(CString& sMessage) { MODHALTCHK(OnBroadcast(sMessage)); }
bool CModules::OnIRCDisconnected() { MODUNLOADCHK(OnIRCDisconnected()); return false; }
bool CModules::OnDCCUserSend(const CNick& RemoteNick, unsigned long uLongIP, unsigned short uPort, const CString& sFile, unsigned long uFileSize) { MODHALTCHK(OnDCCUserSend(RemoteNick, uLongIP, uPort, sFile, uFileSize)); }
bool CModules::OnChanPermission(const CNick& OpNick, const CNick& Nick, CChan& Channel, unsigned char uMode, bool bAdded, bool bNoChange) { MODUNLOADCHK(OnChanPermission(OpNick, Nick, Channel, uMode, bAdded, bNoChange)); return false; }
bool CModules::OnOp(const CNick& OpNick, const CNick& Nick, CChan& Channel, bool bNoChange) { MODUNLOADCHK(OnOp(OpNick, Nick, Channel, bNoChange)); return false; }
bool CModules::OnDeop(const CNick& OpNick, const CNick& Nick, CChan& Channel, bool bNoChange) { MODUNLOADCHK(OnDeop(OpNick, Nick, Channel, bNoChange)); return false; }
bool CModules::OnVoice(const CNick& OpNick, const CNick& Nick, CChan& Channel, bool bNoChange) { MODUNLOADCHK(OnVoice(OpNick, Nick, Channel, bNoChange)); return false; }
bool CModules::OnDevoice(const CNick& OpNick, const CNick& Nick, CChan& Channel, bool bNoChange) { MODUNLOADCHK(OnDevoice(OpNick, Nick, Channel, bNoChange)); return false; }
bool CModules::OnRawMode(const CNick& OpNick, CChan& Channel, const CString& sModes, const CString& sArgs) { MODUNLOADCHK(OnRawMode(OpNick, Channel, sModes, sArgs)); return false; }
bool CModules::OnMode(const CNick& OpNick, CChan& Channel, char uMode, const CString& sArg, bool bAdded, bool bNoChange) { MODUNLOADCHK(OnMode(OpNick, Channel, uMode, sArg, bAdded, bNoChange)); return false; }
bool CModules::OnRaw(CString& sLine) { MODHALTCHK(OnRaw(sLine)); }

bool CModules::OnClientLogin() { MODUNLOADCHK(OnClientLogin()); return false; }
bool CModules::OnClientDisconnect() { MODUNLOADCHK(OnClientDisconnect()); return false; }
bool CModules::OnUserRaw(CString& sLine) { MODHALTCHK(OnUserRaw(sLine)); }
bool CModules::OnUserCTCPReply(CString& sTarget, CString& sMessage) { MODHALTCHK(OnUserCTCPReply(sTarget, sMessage)); }
bool CModules::OnUserCTCP(CString& sTarget, CString& sMessage) { MODHALTCHK(OnUserCTCP(sTarget, sMessage)); }
bool CModules::OnUserAction(CString& sTarget, CString& sMessage) { MODHALTCHK(OnUserAction(sTarget, sMessage)); }
bool CModules::OnUserMsg(CString& sTarget, CString& sMessage) { MODHALTCHK(OnUserMsg(sTarget, sMessage)); }
bool CModules::OnUserNotice(CString& sTarget, CString& sMessage) { MODHALTCHK(OnUserNotice(sTarget, sMessage)); }
bool CModules::OnUserJoin(CString& sChannel, CString& sKey) { MODHALTCHK(OnUserJoin(sChannel, sKey)); }
bool CModules::OnUserPart(CString& sChannel, CString& sMessage) { MODHALTCHK(OnUserPart(sChannel, sMessage)); }
bool CModules::OnUserTopic(CString& sChannel, CString& sTopic) { MODHALTCHK(OnUserTopic(sChannel, sTopic)); }
bool CModules::OnUserTopicRequest(CString& sChannel) { MODHALTCHK(OnUserTopicRequest(sChannel)); }

bool CModules::OnQuit(const CNick& Nick, const CString& sMessage, const vector<CChan*>& vChans) { MODUNLOADCHK(OnQuit(Nick, sMessage, vChans)); return false; }
bool CModules::OnNick(const CNick& Nick, const CString& sNewNick, const vector<CChan*>& vChans) { MODUNLOADCHK(OnNick(Nick, sNewNick, vChans)); return false; }
bool CModules::OnKick(const CNick& Nick, const CString& sKickedNick, CChan& Channel, const CString& sMessage) { MODUNLOADCHK(OnKick(Nick, sKickedNick, Channel, sMessage)); return false; }
bool CModules::OnJoin(const CNick& Nick, CChan& Channel) { MODUNLOADCHK(OnJoin(Nick, Channel)); return false; }
bool CModules::OnPart(const CNick& Nick, CChan& Channel) { MODUNLOADCHK(OnPart(Nick, Channel)); return false; }
bool CModules::OnChanBufferStarting(CChan& Chan, CClient& Client) { MODHALTCHK(OnChanBufferStarting(Chan, Client)); }
bool CModules::OnChanBufferEnding(CChan& Chan, CClient& Client) { MODHALTCHK(OnChanBufferEnding(Chan, Client)); }
bool CModules::OnChanBufferPlayLine(CChan& Chan, CClient& Client, CString& sLine) { MODHALTCHK(OnChanBufferPlayLine(Chan, Client, sLine)); }
bool CModules::OnPrivBufferPlayLine(CClient& Client, CString& sLine) { MODHALTCHK(OnPrivBufferPlayLine(Client, sLine)); }
bool CModules::OnCTCPReply(CNick& Nick, CString& sMessage) { MODHALTCHK(OnCTCPReply(Nick, sMessage)); }
bool CModules::OnPrivCTCP(CNick& Nick, CString& sMessage) { MODHALTCHK(OnPrivCTCP(Nick, sMessage)); }
bool CModules::OnChanCTCP(CNick& Nick, CChan& Channel, CString& sMessage) { MODHALTCHK(OnChanCTCP(Nick, Channel, sMessage)); }
bool CModules::OnPrivAction(CNick& Nick, CString& sMessage) { MODHALTCHK(OnPrivAction(Nick, sMessage)); }
bool CModules::OnChanAction(CNick& Nick, CChan& Channel, CString& sMessage) { MODHALTCHK(OnChanAction(Nick, Channel, sMessage)); }
bool CModules::OnPrivMsg(CNick& Nick, CString& sMessage) { MODHALTCHK(OnPrivMsg(Nick, sMessage)); }
bool CModules::OnChanMsg(CNick& Nick, CChan& Channel, CString& sMessage) { MODHALTCHK(OnChanMsg(Nick, Channel, sMessage)); }
bool CModules::OnPrivNotice(CNick& Nick, CString& sMessage) { MODHALTCHK(OnPrivNotice(Nick, sMessage)); }
bool CModules::OnChanNotice(CNick& Nick, CChan& Channel, CString& sMessage) { MODHALTCHK(OnChanNotice(Nick, Channel, sMessage)); }
bool CModules::OnTopic(CNick& Nick, CChan& Channel, CString& sTopic) { MODHALTCHK(OnTopic(Nick, Channel, sTopic)); }
bool CModules::OnTimerAutoJoin(CChan& Channel) { MODHALTCHK(OnTimerAutoJoin(Channel)); }
bool CModules::OnStatusCommand(CString& sCommand) { MODHALTCHK(OnStatusCommand(sCommand)); }
bool CModules::OnModCommand(const CString& sCommand) { MODUNLOADCHK(OnModCommand(sCommand)); return false; }
bool CModules::OnModNotice(const CString& sMessage) { MODUNLOADCHK(OnModNotice(sMessage)); return false; }
bool CModules::OnModCTCP(const CString& sMessage) { MODUNLOADCHK(OnModCTCP(sMessage)); return false; }

////////////////////
// CGlobalModules //
////////////////////
bool CGlobalModules::OnConfigLine(const CString& sName, const CString& sValue, CUser* pUser, CChan* pChan) {
	GLOBALMODHALTCHK(OnConfigLine(sName, sValue, pUser, pChan));
}

bool CGlobalModules::OnDeleteUser(CUser& User) {
	GLOBALMODHALTCHK(OnDeleteUser(User));
}

void CGlobalModules::OnClientConnect(CClient* pClient, const CString& sHost, unsigned short uPort) {
	GLOBALMODCALL(OnClientConnect(pClient, sHost, uPort));
}

bool CGlobalModules::OnLoginAttempt(CSmartPtr<CAuthBase> Auth) {
	GLOBALMODHALTCHK(OnLoginAttempt(Auth));
}

void CGlobalModules::OnFailedLogin(const CString& sUsername, const CString& sRemoteIP) {
	GLOBALMODCALL(OnFailedLogin(sUsername, sRemoteIP));
}

bool CGlobalModules::OnUnknownUserRaw(CClient* pClient, CString& sLine) {
	GLOBALMODHALTCHK(OnUnknownUserRaw(pClient, sLine));
}

CModule* CModules::FindModule(const CString& sModule) const {
	for (unsigned int a = 0; a < size(); a++) {
		if (sModule.Equals((*this)[a]->GetModName())) {
			return (*this)[a];
		}
	}

	return NULL;
}

bool CModules::LoadModule(const CString& sModule, const CString& sArgs, CUser* pUser, CString& sRetMsg, bool bFake) {
	sRetMsg = """";

	if (FindModule(sModule) != NULL) {
		sRetMsg = ""Module ["" + sModule + ""] already loaded."";
		return false;
	}

	if (bFake) {
		CModule* pModule = new CModule(NULL, sModule, """");
		pModule->SetArgs(sArgs);
		pModule->SetDescription(""<<Fake Module>>"");
		pModule->SetFake(true);
		push_back(pModule);
		sRetMsg = ""Loaded fake module ["" + sModule + ""]"";
		return true;
	}

	CString sModPath, sDataPath;
	CString sDesc;
	bool bVersionMismatch;
	bool bIsGlobal;

	if (!FindModPath(sModule, sModPath, sDataPath)) {
		sRetMsg = ""Unable to find module ["" + sModule + ""]"";
		return false;
	}

	ModHandle p = OpenModule(sModule, sModPath, bVersionMismatch, bIsGlobal, sDesc, sRetMsg);

	if (!p)
		return false;

	if (bVersionMismatch) {
		dlclose(p);
		sRetMsg = ""Version mismatch, recompile this module."";
		return false;
	}

	if ((pUser == NULL) != bIsGlobal) {
		dlclose(p);
		sRetMsg = ""Module ["" + sModule + ""] is "";
		sRetMsg += (bIsGlobal) ? """" : ""not "";
		sRetMsg += ""a global module."";
		return false;
	}

	CModule* pModule = NULL;

	if (pUser) {
		typedef CModule* (*fp)(ModHandle, CUser* pUser,
				const CString& sModName, const CString& sDataPath);
		fp Load = (fp) dlsym(p, ""ZNCModLoad"");

		if (!Load) {
			dlclose(p);
			sRetMsg = ""Could not find ZNCModLoad() in module ["" + sModule + ""]"";
			return false;
		}

		pModule = Load(p, pUser, sModule, sDataPath);
	} else {
		typedef CModule* (*fp)(ModHandle, const CString& sModName,
				const CString& sDataPath);
		fp Load = (fp) dlsym(p, ""ZNCModLoad"");

		if (!Load) {
			dlclose(p);
			sRetMsg = ""Could not find ZNCModLoad() in module ["" + sModule + ""]"";
			return false;
		}

		pModule = Load(p, sModule, sDataPath);
	}

	pModule->SetDescription(sDesc);
	pModule->SetGlobal(bIsGlobal);
	pModule->SetArgs(sArgs);
	push_back(pModule);

	bool bLoaded;
	try {
		bLoaded = pModule->OnLoad(sArgs, sRetMsg);
	} catch (CModule::EModException) {
		bLoaded = false;
		sRetMsg = ""Caught an exception"";
	}

	if (!bLoaded) {
		UnloadModule(sModule, sModPath);
		if (!sRetMsg.empty())
			sRetMsg = ""Module ["" + sModule + ""] aborted: "" + sRetMsg;
		else
			sRetMsg = ""Module ["" + sModule + ""] aborted."";
		return false;
	}

	if (!sRetMsg.empty()) {
		sRetMsg = ""Loaded module ["" + sModule + ""] ["" + sRetMsg + ""] ["" + sModPath + ""]"";
	} else {
		sRetMsg = ""Loaded module ["" + sModule + ""] ["" + sModPath + ""]"";
	}
	return true;
}

bool CModules::UnloadModule(const CString& sModule) {
	CString s;
	return UnloadModule(sModule, s);
}

bool CModules::UnloadModule(const CString& sModule, CString& sRetMsg) {
	CString sMod = sModule;	// Make a copy incase the reference passed in is from CModule::GetModName()
	CModule* pModule = FindModule(sMod);
	sRetMsg = """";

	if (!pModule) {
		sRetMsg = ""Module ["" + sMod + ""] not loaded."";
		return false;
	}

	if (pModule->IsFake()) {
		for (iterator it = begin(); it != end(); it++) {
			if (*it == pModule) {
				erase(it);
				sRetMsg = ""Fake module ["" + sMod + ""] unloaded"";
				return true;
			}
		}

		sRetMsg = ""Fake module ["" + sMod + ""] not loaded."";
		return false;
	}

	ModHandle p = pModule->GetDLL();

	if (p) {
		typedef void (*fp)(CModule*);
		fp Unload = (fp)dlsym(p, ""ZNCModUnload"");

		if (Unload) {
			Unload(pModule);

			for (iterator it = begin(); it != end(); it++) {
				if (*it == pModule) {
					erase(it);
					break;
				}
			}

			dlclose(p);
			sRetMsg = ""Module ["" + sMod + ""] unloaded"";

			return true;
		} else {
			sRetMsg = ""Unable to unload module ["" + sMod + ""] could not find ZNCModUnload()"";
			return false;
		}
	}

	sRetMsg = ""Unable to unload module ["" + sMod + ""]"";
	return false;
}

bool CModules::ReloadModule(const CString& sModule, const CString& sArgs, CUser* pUser, CString& sRetMsg) {
	CString sMod = sModule;	// Make a copy incase the reference passed in is from CModule::GetModName()
	sRetMsg = """";
	if (!UnloadModule(sMod, sRetMsg)) {
		return false;
	}

	if (!LoadModule(sMod, sArgs, pUser, sRetMsg)) {
		return false;
	}

	sRetMsg = ""Reloaded module ["" + sMod + ""]"";
	return true;
}

bool CModules::GetModInfo(CModInfo& ModInfo, const CString& sModule, CString& sRetMsg) {
	CString sModPath, sTmp;

	if (!FindModPath(sModule, sModPath, sTmp)) {
		sRetMsg = ""Unable to find module ["" + sModule + ""]"";
		return false;
	}

	return GetModPathInfo(ModInfo, sModule, sModPath, sRetMsg);
}

bool CModules::GetModPathInfo(CModInfo& ModInfo, const CString& sModule, const CString& sModPath, CString& sRetMsg) {
	CString sDesc;
	bool bVersionMismatch;
	bool bIsGlobal;

	ModHandle p = OpenModule(sModule, sModPath, bVersionMismatch, bIsGlobal, sDesc, sRetMsg);

	if (!p)
		return false;

	ModInfo.SetGlobal(bIsGlobal);
	ModInfo.SetDescription(sDesc);
	ModInfo.SetName(sModule);
	ModInfo.SetPath(sModPath);

	if (bVersionMismatch) {
		ModInfo.SetDescription(""--- Version mismatch, recompile this module. ---"");
	}

	dlclose(p);

	return true;
}

void CModules::GetAvailableMods(set<CModInfo>& ssMods, bool bGlobal) {
	ssMods.clear();

	unsigned int a = 0;
	CDir Dir;

	ModDirList dirs = GetModDirs();

	while (!dirs.empty()) {
		Dir.FillByWildcard(dirs.front().first, ""*.so"");
		dirs.pop();

		for (a = 0; a < Dir.size(); a++) {
			CFile& File = *Dir[a];
			CString sName = File.GetShortName();
			CString sPath = File.GetLongName();
			CModInfo ModInfo;
			sName.RightChomp(3);

			CString sIgnoreRetMsg;
			if (GetModPathInfo(ModInfo, sName, sPath, sIgnoreRetMsg)) {
				if (ModInfo.IsGlobal() == bGlobal) {
					ssMods.insert(ModInfo);
				}
			}
		}
	}
}

bool CModules::FindModPath(const CString& sModule, CString& sModPath,
		CString& sDataPath) {
	CString sMod = sModule;
	CString sDir = sMod;
	if (sModule.find(""."") == CString::npos)
		sMod += "".so"";

	ModDirList dirs = GetModDirs();

	while (!dirs.empty()) {
		sModPath = dirs.front().first + sMod;
		sDataPath = dirs.front().second;
		dirs.pop();

		if (CFile::Exists(sModPath)) {
			sDataPath += sDir;
			return true;
		}
	}

	return false;
}

CModules::ModDirList CModules::GetModDirs() {
	ModDirList ret;

	// ./modules
	CString sDir = CZNC::Get().GetCurPath() + ""/modules/"";
	ret.push(std::make_pair(sDir, sDir));

	// ./modules/extra
	sDir = CZNC::Get().GetCurPath() + ""/modules/extra/"";
	ret.push(std::make_pair(sDir, sDir));

	// ~/.znc/modules
	sDir = CZNC::Get().GetModPath() + ""/"";
	ret.push(std::make_pair(sDir, sDir));

	// <moduledir> and <datadir> (<prefix>/lib/znc)
	ret.push(std::make_pair(_MODDIR_ + CString(""/""), _DATADIR_ + CString(""/"")));

	return ret;
}

ModHandle CModules::OpenModule(const CString& sModule, const CString& sModPath, bool &bVersionMismatch,
		bool &bIsGlobal, CString& sDesc, CString& sRetMsg) {
	for (unsigned int a = 0; a < sModule.length(); a++) {
		if (((sModule[a] < '0') || (sModule[a] > '9')) && ((sModule[a] < 'a') || (sModule[a] > 'z')) && ((sModule[a] < 'A') || (sModule[a] > 'Z')) && (sModule[a] != '_')) {
			sRetMsg = ""Module names can only contain letters, numbers and underscores, ["" + sModule + ""] is invalid."";
			return NULL;
		}
	}

	ModHandle p = dlopen((sModPath).c_str(), RTLD_NOW | RTLD_LOCAL);

	if (!p) {
		sRetMsg = ""Unable to open module ["" + sModule + ""] ["" + dlerror() + ""]"";
		return NULL;
	}

	typedef double (*dFP)();
	dFP Version = (dFP) dlsym(p, ""ZNCModVersion"");

	if (!Version) {
		dlclose(p);
		sRetMsg = ""Could not find ZNCModVersion() in module ["" + sModule + ""]"";
		return NULL;
	}

	typedef bool (*bFP)();
	bFP IsGlobal = (bFP) dlsym(p, ""ZNCModGlobal"");

	if (!IsGlobal) {
		dlclose(p);
		sRetMsg = ""Could not find ZNCModGlobal() in module ["" + sModule + ""]"";
		return NULL;
	}

	typedef CString (*sFP)();
	sFP GetDesc = (sFP) dlsym(p, ""ZNCModDescription"");

	if (!GetDesc) {
		dlclose(p);
		sRetMsg = ""Could not find ZNCModDescription() in module ["" + sModule + ""]"";
		return false;
	}

	bIsGlobal = IsGlobal();
	sDesc = GetDesc();

	if (CModule::GetCoreVersion() != Version()) {
		bVersionMismatch = true;
		sRetMsg = ""Version mismatch, recompile this module."";
	} else {
		sRetMsg = """";
		bVersionMismatch = false;
	}

	return p;
}

#endif // _MODULES
""","""/*
 * Copyright (C) 2004-2009  See the AUTHORS file for details.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 as published
 * by the Free Software Foundation.
 */

#ifdef _MODULES

#include ""Modules.h""
#include ""User.h""
#include ""znc.h""
#include <dlfcn.h>

#ifndef RTLD_LOCAL
# define RTLD_LOCAL 0
# warning ""your crap box doesnt define RTLD_LOCAL !?""
#endif

#define _MODUNLOADCHK(func, type)								\
	for (unsigned int a = 0; a < size(); a++) {			\
		try {											\
			type* pMod = (type *) (*this)[a];					\
			CClient* pOldClient = pMod->GetClient();			\
			pMod->SetClient(m_pClient);					\
			if (m_pUser) {							\
				CUser* pOldUser = pMod->GetUser();			\
				pMod->SetUser(m_pUser);					\
				pMod->func;						\
				pMod->SetUser(pOldUser);				\
			} else {							\
				pMod->func;						\
			}								\
			pMod->SetClient(pOldClient);					\
		} catch (CModule::EModException e) {			\
			if (e == CModule::UNLOAD) {					\
				UnloadModule((*this)[a]->GetModName());	\
			}											\
		}												\
	}

#define MODUNLOADCHK(func)	_MODUNLOADCHK(func, CModule)
#define GLOBALMODCALL(func)	_MODUNLOADCHK(func, CGlobalModule)

#define _MODHALTCHK(func, type)							\
	bool bHaltCore = false;								\
	for (unsigned int a = 0; a < size(); a++) {			\
		try {											\
			type* pMod = (type*) (*this)[a];			\
			CModule::EModRet e = CModule::CONTINUE;		\
			CClient* pOldClient = pMod->GetClient();			\
			pMod->SetClient(m_pClient);				\
			if (m_pUser) {								\
				CUser* pOldUser = pMod->GetUser();			\
				pMod->SetUser(m_pUser);					\
				e = pMod->func;							\
				pMod->SetUser(pOldUser);				\
			} else {									\
				e = pMod->func;							\
			}											\
			pMod->SetClient(pOldClient);				\
			if (e == CModule::HALTMODS) {				\
				break;									\
			} else if (e == CModule::HALTCORE) {		\
				bHaltCore = true;						\
			} else if (e == CModule::HALT) {			\
				bHaltCore = true;						\
				break;									\
			}											\
		} catch (CModule::EModException e) {			\
			if (e == CModule::UNLOAD) {					\
				UnloadModule((*this)[a]->GetModName());	\
			}											\
		}												\
	}													\
	return bHaltCore;

#define MODHALTCHK(func)	_MODHALTCHK(func, CModule)
#define GLOBALMODHALTCHK(func)	_MODHALTCHK(func, CGlobalModule)

/////////////////// Timer ///////////////////
CTimer::CTimer(CModule* pModule, unsigned int uInterval, unsigned int uCycles, const CString& sLabel, const CString& sDescription) : CCron() {
	SetName(sLabel);
	m_sDescription = sDescription;
	m_pModule = pModule;

	if (uCycles) {
		StartMaxCycles(uInterval, uCycles);
	} else {
		Start(uInterval);
	}
}

CTimer::~CTimer() {
	m_pModule->UnlinkTimer(this);
}

void CTimer::SetModule(CModule* p) { m_pModule = p; }
void CTimer::SetDescription(const CString& s) { m_sDescription = s; }
CModule* CTimer::GetModule() const { return m_pModule; }
const CString& CTimer::GetDescription() const { return m_sDescription; }
/////////////////// !Timer ///////////////////

/////////////////// Socket ///////////////////
CSocket::CSocket(CModule* pModule) : CZNCSock() {
	m_pModule = pModule;
	m_pModule->AddSocket(this);
	EnableReadLine();
	SetMaxBufferThreshold(10240);
}

CSocket::CSocket(CModule* pModule, const CString& sHostname, unsigned short uPort, int iTimeout) : CZNCSock(sHostname, uPort, iTimeout) {
	m_pModule = pModule;
	m_pModule->AddSocket(this);
	EnableReadLine();
	SetMaxBufferThreshold(10240);
}

CSocket::~CSocket() {
	CUser *pUser = m_pModule->GetUser();

	m_pModule->UnlinkSocket(this);

	if (!m_pModule->IsGlobal() && pUser) {
		pUser->AddBytesWritten(GetBytesWritten());
		pUser->AddBytesRead(GetBytesRead());
	} else {
		CZNC::Get().AddBytesWritten(GetBytesWritten());
		CZNC::Get().AddBytesRead(GetBytesRead());
	}
}

void CSocket::ReachedMaxBuffer() {
	DEBUG(GetSockName() << "" == ReachedMaxBuffer()"");
	PutModule(""Some socket reached its max buffer limit and was closed!"");
	Close();
}

void CSocket::SockError(int iErrno) {
	DEBUG(GetSockName() << "" == SockError("" << strerror(iErrno) << "")"");
	if (iErrno == EMFILE) {
		// We have too many open fds, this can cause a busy loop.
		Close();
	}
}

bool CSocket::ConnectionFrom(const CString& sHost, unsigned short uPort) {
	return CZNC::Get().AllowConnectionFrom(sHost);
}

bool CSocket::Connect(const CString& sHostname, unsigned short uPort, bool bSSL, unsigned int uTimeout) {
	CUser* pUser = m_pModule->GetUser();
	CString sSockName = ""MOD::C::"" + m_pModule->GetModName();
	CString sVHost;

	if (pUser) {
		sSockName += ""::"" + pUser->GetUserName();
		sVHost = m_pModule->GetUser()->GetVHost();
	}

	// Don't overwrite the socket name if one is already set
	if (!GetSockName().empty()) {
		sSockName = GetSockName();
	}

	return m_pModule->GetManager()->Connect(sHostname, uPort, sSockName, uTimeout, bSSL, sVHost, this);
}

bool CSocket::Listen(unsigned short uPort, bool bSSL, unsigned int uTimeout) {
	CUser* pUser = m_pModule->GetUser();
	CString sSockName = ""MOD::L::"" + m_pModule->GetModName();

	if (pUser) {
		sSockName += ""::"" + pUser->GetUserName();
	}
	// Don't overwrite the socket name if one is already set
	if (!GetSockName().empty()) {
		sSockName = GetSockName();
	}

	return m_pModule->GetManager()->ListenAll(uPort, sSockName, bSSL, SOMAXCONN, this);
}

bool CSocket::PutIRC(const CString& sLine) {
	return (m_pModule) ? m_pModule->PutIRC(sLine) : false;
}

bool CSocket::PutUser(const CString& sLine) {
	return (m_pModule) ? m_pModule->PutUser(sLine) : false;
}

bool CSocket::PutStatus(const CString& sLine) {
	return (m_pModule) ? m_pModule->PutStatus(sLine) : false;
}

bool CSocket::PutModule(const CString& sLine, const CString& sIdent, const CString& sHost) {
	return (m_pModule) ? m_pModule->PutModule(sLine, sIdent, sHost) : false;
}
bool CSocket::PutModNotice(const CString& sLine, const CString& sIdent, const CString& sHost) {
	return (m_pModule) ? m_pModule->PutModNotice(sLine, sIdent, sHost) : false;
}

void CSocket::SetModule(CModule* p) { m_pModule = p; }
CModule* CSocket::GetModule() const { return m_pModule; }
/////////////////// !Socket ///////////////////

CModule::CModule(ModHandle pDLL, CUser* pUser, const CString& sModName, const CString& sDataDir) {
	m_bFake = false;
	m_bGlobal = false;
	m_pDLL = pDLL;
	m_pManager = &(CZNC::Get().GetManager());;
	m_pUser = pUser;
	m_pClient = NULL;
	m_sModName = sModName;
	m_sDataDir = sDataDir;

	if (m_pUser) {
		m_sSavePath = m_pUser->GetUserPath() + ""/moddata/"" + m_sModName;
		LoadRegistry();
	}
}

CModule::CModule(ModHandle pDLL, const CString& sModName, const CString& sDataDir) {
	m_bFake = false;
	m_pDLL = pDLL;
	m_pManager = &(CZNC::Get().GetManager());
	m_pUser = NULL;
	m_pClient = NULL;
	m_sModName = sModName;
	m_sDataDir = sDataDir;

	m_sSavePath = CZNC::Get().GetZNCPath() + ""/moddata/"" + m_sModName;
	LoadRegistry();
}

CModule::~CModule() {
	while (!m_sTimers.empty()) {
		RemTimer(*m_sTimers.begin());
	}

	while (!m_sSockets.empty()) {
		RemSocket(*m_sSockets.begin());
	}

	SaveRegistry();
}

void CModule::SetUser(CUser* pUser) { m_pUser = pUser; }
void CModule::SetClient(CClient* pClient) { m_pClient = pClient; }
void CModule::Unload() { throw UNLOAD; }

bool CModule::LoadRegistry() {
	//CString sPrefix = (m_pUser) ? m_pUser->GetUserName() : "".global"";
	return (m_mssRegistry.ReadFromDisk(GetSavePath() + ""/.registry"", 0600) == MCString::MCS_SUCCESS);
}

bool CModule::SaveRegistry() {
	//CString sPrefix = (m_pUser) ? m_pUser->GetUserName() : "".global"";
	return (m_mssRegistry.WriteToDisk(GetSavePath() + ""/.registry"", 0600) == MCString::MCS_SUCCESS);
}

bool CModule::SetNV(const CString & sName, const CString & sValue, bool bWriteToDisk) {
	m_mssRegistry[sName] = sValue;
	if (bWriteToDisk) {
		return SaveRegistry();
	}

	return true;
}

CString CModule::GetNV(const CString & sName) {
	MCString::iterator it = m_mssRegistry.find(sName);

	if (it != m_mssRegistry.end()) {
		return it->second;
	}

	return """";
}

bool CModule::DelNV(const CString & sName, bool bWriteToDisk) {
	MCString::iterator it = m_mssRegistry.find(sName);

	if (it != m_mssRegistry.end()) {
		m_mssRegistry.erase(it);
	} else {
		return false;
	}

	if (bWriteToDisk) {
		return SaveRegistry();
	}

	return true;
}

bool CModule::ClearNV(bool bWriteToDisk) {
	m_mssRegistry.clear();

	if (bWriteToDisk) {
		return SaveRegistry();
	}
	return true;
}

bool CModule::AddTimer(CTimer* pTimer) {
	if ((!pTimer) || (FindTimer(pTimer->GetName()))) {
		delete pTimer;
		return false;
	}

	if (!m_sTimers.insert(pTimer).second)
		// Was already added
		return true;

	m_pManager->AddCron(pTimer);
	return true;
}

bool CModule::AddTimer(FPTimer_t pFBCallback, const CString& sLabel, u_int uInterval, u_int uCycles, const CString& sDescription) {
	CFPTimer *pTimer = new CFPTimer(this, uInterval, uCycles, sLabel, sDescription);
	pTimer->SetFPCallback(pFBCallback);

	return AddTimer(pTimer);
}

bool CModule::RemTimer(CTimer* pTimer) {
	if (m_sTimers.erase(pTimer) == 0)
		return false;
	m_pManager->DelCronByAddr(pTimer);
	return true;
}

bool CModule::RemTimer(const CString& sLabel) {
	CTimer *pTimer = FindTimer(sLabel);
	if (!pTimer)
		return false;
	return RemTimer(pTimer);
}

bool CModule::UnlinkTimer(CTimer* pTimer) {
	set<CTimer*>::iterator it;
	for (it = m_sTimers.begin(); it != m_sTimers.end(); ++it) {
		if (pTimer == *it) {
			m_sTimers.erase(it);
			return true;
		}
	}

	return false;
}

CTimer* CModule::FindTimer(const CString& sLabel) {
	set<CTimer*>::iterator it;
	for (it = m_sTimers.begin(); it != m_sTimers.end(); ++it) {
		CTimer* pTimer = *it;
		if (pTimer->GetName().Equals(sLabel)) {
			return pTimer;
		}
	}

	return NULL;
}

void CModule::ListTimers() {
	if (m_sTimers.empty()) {
		PutModule(""You have no timers running."");
		return;
	}

	CTable Table;
	Table.AddColumn(""Name"");
	Table.AddColumn(""Secs"");
	Table.AddColumn(""Cycles"");
	Table.AddColumn(""Description"");

	set<CTimer*>::iterator it;
	for (it = m_sTimers.begin(); it != m_sTimers.end(); ++it) {
		CTimer* pTimer = *it;
		unsigned int uCycles = pTimer->GetCyclesLeft();

		Table.AddRow();
		Table.SetCell(""Name"", pTimer->GetName());
		Table.SetCell(""Secs"", CString(pTimer->GetInterval()));
		Table.SetCell(""Cycles"", ((uCycles) ? CString(uCycles) : ""INF""));
		Table.SetCell(""Description"", pTimer->GetDescription());
	}

	PutModule(Table);
}

bool CModule::AddSocket(CSocket* pSocket) {
	if (!pSocket) {
		return false;
	}

	m_sSockets.insert(pSocket);
	return true;
}

bool CModule::RemSocket(CSocket* pSocket) {
	set<CSocket*>::iterator it;
	for (it = m_sSockets.begin(); it != m_sSockets.end(); ++it) {
		if (*it == pSocket) {
			m_sSockets.erase(it);
			m_pManager->DelSockByAddr(pSocket);
			return true;
		}
	}

	return false;
}

bool CModule::RemSocket(const CString& sSockName) {
	set<CSocket*>::iterator it;
	for (it = m_sSockets.begin(); it != m_sSockets.end(); ++it) {
		CSocket* pSocket = *it;

		if (pSocket->GetSockName().Equals(sSockName)) {
			m_sSockets.erase(it);
			m_pManager->DelSockByAddr(pSocket);
			return true;
		}
	}

	return false;
}

bool CModule::UnlinkSocket(CSocket* pSocket) {
	set<CSocket*>::iterator it;
	for (it = m_sSockets.begin(); it != m_sSockets.end(); ++it) {
		if (pSocket == *it) {
			m_sSockets.erase(it);
			return true;
		}
	}

	return false;
}

CSocket* CModule::FindSocket(const CString& sSockName) {
	set<CSocket*>::iterator it;
	for (it = m_sSockets.begin(); it != m_sSockets.end(); ++it) {
		CSocket* pSocket = *it;
		if (pSocket->GetSockName().Equals(sSockName)) {
			return pSocket;
		}
	}

	return NULL;
}

void CModule::ListSockets() {
	if (m_sSockets.empty()) {
		PutModule(""You have no open sockets."");
		return;
	}

	CTable Table;
	Table.AddColumn(""Name"");
	Table.AddColumn(""State"");
	Table.AddColumn(""LocalPort"");
	Table.AddColumn(""SSL"");
	Table.AddColumn(""RemoteIP"");
	Table.AddColumn(""RemotePort"");

	set<CSocket*>::iterator it;
	for (it = m_sSockets.begin(); it != m_sSockets.end(); ++it) {
		CSocket* pSocket = *it;

		Table.AddRow();
		Table.SetCell(""Name"", pSocket->GetSockName());

		if (pSocket->GetType() == CSocket::LISTENER) {
			Table.SetCell(""State"", ""Listening"");
		} else {
			Table.SetCell(""State"", (pSocket->IsConnected() ? ""Connected"" : """"));
		}

		Table.SetCell(""LocalPort"", CString(pSocket->GetLocalPort()));
		Table.SetCell(""SSL"", (pSocket->GetSSL() ? ""yes"" : ""no""));
		Table.SetCell(""RemoteIP"", pSocket->GetRemoteIP());
		Table.SetCell(""RemotePort"", (pSocket->GetRemotePort()) ? CString(pSocket->GetRemotePort()) : CString(""""));
	}

	PutModule(Table);
}

CString CModule::GetModNick() const { return ((m_pUser) ? m_pUser->GetStatusPrefix() : ""*"") + m_sModName; }

bool CModule::OnLoad(const CString& sArgs, CString& sMessage) { sMessage = """"; return true; }
bool CModule::OnBoot() { return true; }
void CModule::OnPreRehash() {}
void CModule::OnPostRehash() {}
void CModule::OnIRCDisconnected() {}
void CModule::OnIRCConnected() {}
CModule::EModRet CModule::OnIRCConnecting(CIRCSock *IRCSock) { return CONTINUE; }
CModule::EModRet CModule::OnIRCRegistration(CString& sPass, CString& sNick, CString& sIdent, CString& sRealName) { return CONTINUE; }
CModule::EModRet CModule::OnBroadcast(CString& sMessage) { return CONTINUE; }

CModule::EModRet CModule::OnDCCUserSend(const CNick& RemoteNick, unsigned long uLongIP, unsigned short uPort, const CString& sFile, unsigned long uFileSize) { return CONTINUE; }

void CModule::OnChanPermission(const CNick& OpNick, const CNick& Nick, CChan& Channel, unsigned char uMode, bool bAdded, bool bNoChange) {}
void CModule::OnOp(const CNick& OpNick, const CNick& Nick, CChan& Channel, bool bNoChange) {}
void CModule::OnDeop(const CNick& OpNick, const CNick& Nick, CChan& Channel, bool bNoChange) {}
void CModule::OnVoice(const CNick& OpNick, const CNick& Nick, CChan& Channel, bool bNoChange) {}
void CModule::OnDevoice(const CNick& OpNick, const CNick& Nick, CChan& Channel, bool bNoChange) {}
void CModule::OnRawMode(const CNick& OpNick, CChan& Channel, const CString& sModes, const CString& sArgs) {}
void CModule::OnMode(const CNick& OpNick, CChan& Channel, char uMode, const CString& sArg, bool bAdded, bool bNoChange) {}

CModule::EModRet CModule::OnRaw(CString& sLine) { return CONTINUE; }

CModule::EModRet CModule::OnStatusCommand(CString& sCommand) { return CONTINUE; }
void CModule::OnModCommand(const CString& sCommand) {}
void CModule::OnModNotice(const CString& sMessage) {}
void CModule::OnModCTCP(const CString& sMessage) {}

void CModule::OnQuit(const CNick& Nick, const CString& sMessage, const vector<CChan*>& vChans) {}
void CModule::OnNick(const CNick& Nick, const CString& sNewNick, const vector<CChan*>& vChans) {}
void CModule::OnKick(const CNick& Nick, const CString& sKickedNick, CChan& Channel, const CString& sMessage) {}
void CModule::OnJoin(const CNick& Nick, CChan& Channel) {}
void CModule::OnPart(const CNick& Nick, CChan& Channel) {}

CModule::EModRet CModule::OnChanBufferStarting(CChan& Chan, CClient& Client) { return CONTINUE; }
CModule::EModRet CModule::OnChanBufferEnding(CChan& Chan, CClient& Client) { return CONTINUE; }
CModule::EModRet CModule::OnChanBufferPlayLine(CChan& Chan, CClient& Client, CString& sLine) { return CONTINUE; }
CModule::EModRet CModule::OnPrivBufferPlayLine(CClient& Client, CString& sLine) { return CONTINUE; }

void CModule::OnClientLogin() {}
void CModule::OnClientDisconnect() {}
CModule::EModRet CModule::OnUserRaw(CString& sLine) { return CONTINUE; }
CModule::EModRet CModule::OnUserCTCPReply(CString& sTarget, CString& sMessage) { return CONTINUE; }
CModule::EModRet CModule::OnUserCTCP(CString& sTarget, CString& sMessage) { return CONTINUE; }
CModule::EModRet CModule::OnUserAction(CString& sTarget, CString& sMessage) { return CONTINUE; }
CModule::EModRet CModule::OnUserMsg(CString& sTarget, CString& sMessage) { return CONTINUE; }
CModule::EModRet CModule::OnUserNotice(CString& sTarget, CString& sMessage) { return CONTINUE; }
CModule::EModRet CModule::OnUserJoin(CString& sChannel, CString& sKey) { return CONTINUE; }
CModule::EModRet CModule::OnUserPart(CString& sChannel, CString& sMessage) { return CONTINUE; }
CModule::EModRet CModule::OnUserTopic(CString& sChannel, CString& sTopic) { return CONTINUE; }
CModule::EModRet CModule::OnUserTopicRequest(CString& sChannel) { return CONTINUE; }

CModule::EModRet CModule::OnCTCPReply(CNick& Nick, CString& sMessage) { return CONTINUE; }
CModule::EModRet CModule::OnPrivCTCP(CNick& Nick, CString& sMessage) { return CONTINUE; }
CModule::EModRet CModule::OnChanCTCP(CNick& Nick, CChan& Channel, CString& sMessage) { return CONTINUE; }
CModule::EModRet CModule::OnPrivAction(CNick& Nick, CString& sMessage) { return CONTINUE; }
CModule::EModRet CModule::OnChanAction(CNick& Nick, CChan& Channel, CString& sMessage) { return CONTINUE; }
CModule::EModRet CModule::OnPrivMsg(CNick& Nick, CString& sMessage) { return CONTINUE; }
CModule::EModRet CModule::OnChanMsg(CNick& Nick, CChan& Channel, CString& sMessage) { return CONTINUE; }
CModule::EModRet CModule::OnPrivNotice(CNick& Nick, CString& sMessage) { return CONTINUE; }
CModule::EModRet CModule::OnChanNotice(CNick& Nick, CChan& Channel, CString& sMessage) { return CONTINUE; }
CModule::EModRet CModule::OnTopic(CNick& Nick, CChan& Channel, CString& sTopic) { return CONTINUE; }
CModule::EModRet CModule::OnTimerAutoJoin(CChan& Channel) { return CONTINUE; }

ModHandle CModule::GetDLL() { return m_pDLL; }
bool CModule::PutIRC(const CString& sLine) {
	return (m_pUser) ? m_pUser->PutIRC(sLine) : false;
}
bool CModule::PutUser(const CString& sLine) {
	return (m_pUser) ? m_pUser->PutUser(sLine, m_pClient) : false;
}
bool CModule::PutStatus(const CString& sLine) {
	return (m_pUser) ? m_pUser->PutStatus(sLine, m_pClient) : false;
}
unsigned int CModule::PutModule(const CTable& table, const CString& sIdent, const CString& sHost) {
	if (!m_pUser)
		return 0;

	unsigned int idx = 0;
	CString sLine;
	while (table.GetLine(idx++, sLine))
		PutModule(sLine, sIdent, sHost);
	return idx - 1;
}
bool CModule::PutModule(const CString& sLine, const CString& sIdent, const CString& sHost) {
	if (!m_pUser)
		return false;
	return m_pUser->PutUser("":"" + GetModNick() + ""!"" +
		(sIdent.empty() ? GetModName() : sIdent) + ""@"" + sHost +
		"" PRIVMSG "" + m_pUser->GetCurNick() + "" :"" + sLine,
		m_pClient);
}
bool CModule::PutModNotice(const CString& sLine, const CString& sIdent, const CString& sHost) {
	if (!m_pUser)
		return false;
	return m_pUser->PutUser("":"" + GetModNick() + ""!"" +
		(sIdent.empty() ? GetModName() : sIdent) + ""@"" + sHost +
		"" NOTICE "" + m_pUser->GetCurNick() + "" :"" + sLine,
		m_pClient);
}

///////////////////
// CGlobalModule //
///////////////////
CModule::EModRet CGlobalModule::OnConfigLine(const CString& sName, const CString& sValue, CUser* pUser, CChan* pChan) { return CONTINUE; }
CModule::EModRet CGlobalModule::OnDeleteUser(CUser& User) { return CONTINUE; }
void CGlobalModule::OnClientConnect(CClient* pClient, const CString& sHost, unsigned short uPort) {}
CModule::EModRet CGlobalModule::OnLoginAttempt(CSmartPtr<CAuthBase> Auth) { return CONTINUE; }
void CGlobalModule::OnFailedLogin(const CString& sUsername, const CString& sRemoteIP) {}
CModule::EModRet CGlobalModule::OnUnknownUserRaw(CClient* pClient, CString& sLine) { return CONTINUE; }


CModules::CModules() {
	m_pUser = NULL;
	m_pClient = NULL;
}

CModules::~CModules() {
	UnloadAll();
}

void CModules::UnloadAll() {
	while (size()) {
		CString sRetMsg;
		CString sModName = (*this)[0]->GetModName();
		UnloadModule(sModName, sRetMsg);
	}
}

bool CModules::OnBoot() {
	for (unsigned int a = 0; a < size(); a++) {
		try {
			if (!(*this)[a]->OnBoot()) {
				return false;
			}
		} catch (CModule::EModException e) {
			if (e == CModule::UNLOAD) {
				UnloadModule((*this)[a]->GetModName());
			}
		}
	}

	return true;
}

bool CModules::OnPreRehash() { MODUNLOADCHK(OnPreRehash()); return false; }
bool CModules::OnPostRehash() { MODUNLOADCHK(OnPostRehash()); return false; }
bool CModules::OnIRCConnected() { MODUNLOADCHK(OnIRCConnected()); return false; }
bool CModules::OnIRCConnecting(CIRCSock *pIRCSock) { MODHALTCHK(OnIRCConnecting(pIRCSock)); }
bool CModules::OnIRCRegistration(CString& sPass, CString& sNick, CString& sIdent, CString& sRealName) { MODHALTCHK(OnIRCRegistration(sPass, sNick, sIdent, sRealName)); }
bool CModules::OnBroadcast(CString& sMessage) { MODHALTCHK(OnBroadcast(sMessage)); }
bool CModules::OnIRCDisconnected() { MODUNLOADCHK(OnIRCDisconnected()); return false; }
bool CModules::OnDCCUserSend(const CNick& RemoteNick, unsigned long uLongIP, unsigned short uPort, const CString& sFile, unsigned long uFileSize) { MODHALTCHK(OnDCCUserSend(RemoteNick, uLongIP, uPort, sFile, uFileSize)); }
bool CModules::OnChanPermission(const CNick& OpNick, const CNick& Nick, CChan& Channel, unsigned char uMode, bool bAdded, bool bNoChange) { MODUNLOADCHK(OnChanPermission(OpNick, Nick, Channel, uMode, bAdded, bNoChange)); return false; }
bool CModules::OnOp(const CNick& OpNick, const CNick& Nick, CChan& Channel, bool bNoChange) { MODUNLOADCHK(OnOp(OpNick, Nick, Channel, bNoChange)); return false; }
bool CModules::OnDeop(const CNick& OpNick, const CNick& Nick, CChan& Channel, bool bNoChange) { MODUNLOADCHK(OnDeop(OpNick, Nick, Channel, bNoChange)); return false; }
bool CModules::OnVoice(const CNick& OpNick, const CNick& Nick, CChan& Channel, bool bNoChange) { MODUNLOADCHK(OnVoice(OpNick, Nick, Channel, bNoChange)); return false; }
bool CModules::OnDevoice(const CNick& OpNick, const CNick& Nick, CChan& Channel, bool bNoChange) { MODUNLOADCHK(OnDevoice(OpNick, Nick, Channel, bNoChange)); return false; }
bool CModules::OnRawMode(const CNick& OpNick, CChan& Channel, const CString& sModes, const CString& sArgs) { MODUNLOADCHK(OnRawMode(OpNick, Channel, sModes, sArgs)); return false; }
bool CModules::OnMode(const CNick& OpNick, CChan& Channel, char uMode, const CString& sArg, bool bAdded, bool bNoChange) { MODUNLOADCHK(OnMode(OpNick, Channel, uMode, sArg, bAdded, bNoChange)); return false; }
bool CModules::OnRaw(CString& sLine) { MODHALTCHK(OnRaw(sLine)); }

bool CModules::OnClientLogin() { MODUNLOADCHK(OnClientLogin()); return false; }
bool CModules::OnClientDisconnect() { MODUNLOADCHK(OnClientDisconnect()); return false; }
bool CModules::OnUserRaw(CString& sLine) { MODHALTCHK(OnUserRaw(sLine)); }
bool CModules::OnUserCTCPReply(CString& sTarget, CString& sMessage) { MODHALTCHK(OnUserCTCPReply(sTarget, sMessage)); }
bool CModules::OnUserCTCP(CString& sTarget, CString& sMessage) { MODHALTCHK(OnUserCTCP(sTarget, sMessage)); }
bool CModules::OnUserAction(CString& sTarget, CString& sMessage) { MODHALTCHK(OnUserAction(sTarget, sMessage)); }
bool CModules::OnUserMsg(CString& sTarget, CString& sMessage) { MODHALTCHK(OnUserMsg(sTarget, sMessage)); }
bool CModules::OnUserNotice(CString& sTarget, CString& sMessage) { MODHALTCHK(OnUserNotice(sTarget, sMessage)); }
bool CModules::OnUserJoin(CString& sChannel, CString& sKey) { MODHALTCHK(OnUserJoin(sChannel, sKey)); }
bool CModules::OnUserPart(CString& sChannel, CString& sMessage) { MODHALTCHK(OnUserPart(sChannel, sMessage)); }
bool CModules::OnUserTopic(CString& sChannel, CString& sTopic) { MODHALTCHK(OnUserTopic(sChannel, sTopic)); }
bool CModules::OnUserTopicRequest(CString& sChannel) { MODHALTCHK(OnUserTopicRequest(sChannel)); }

bool CModules::OnQuit(const CNick& Nick, const CString& sMessage, const vector<CChan*>& vChans) { MODUNLOADCHK(OnQuit(Nick, sMessage, vChans)); return false; }
bool CModules::OnNick(const CNick& Nick, const CString& sNewNick, const vector<CChan*>& vChans) { MODUNLOADCHK(OnNick(Nick, sNewNick, vChans)); return false; }
bool CModules::OnKick(const CNick& Nick, const CString& sKickedNick, CChan& Channel, const CString& sMessage) { MODUNLOADCHK(OnKick(Nick, sKickedNick, Channel, sMessage)); return false; }
bool CModules::OnJoin(const CNick& Nick, CChan& Channel) { MODUNLOADCHK(OnJoin(Nick, Channel)); return false; }
bool CModules::OnPart(const CNick& Nick, CChan& Channel) { MODUNLOADCHK(OnPart(Nick, Channel)); return false; }
bool CModules::OnChanBufferStarting(CChan& Chan, CClient& Client) { MODHALTCHK(OnChanBufferStarting(Chan, Client)); }
bool CModules::OnChanBufferEnding(CChan& Chan, CClient& Client) { MODHALTCHK(OnChanBufferEnding(Chan, Client)); }
bool CModules::OnChanBufferPlayLine(CChan& Chan, CClient& Client, CString& sLine) { MODHALTCHK(OnChanBufferPlayLine(Chan, Client, sLine)); }
bool CModules::OnPrivBufferPlayLine(CClient& Client, CString& sLine) { MODHALTCHK(OnPrivBufferPlayLine(Client, sLine)); }
bool CModules::OnCTCPReply(CNick& Nick, CString& sMessage) { MODHALTCHK(OnCTCPReply(Nick, sMessage)); }
bool CModules::OnPrivCTCP(CNick& Nick, CString& sMessage) { MODHALTCHK(OnPrivCTCP(Nick, sMessage)); }
bool CModules::OnChanCTCP(CNick& Nick, CChan& Channel, CString& sMessage) { MODHALTCHK(OnChanCTCP(Nick, Channel, sMessage)); }
bool CModules::OnPrivAction(CNick& Nick, CString& sMessage) { MODHALTCHK(OnPrivAction(Nick, sMessage)); }
bool CModules::OnChanAction(CNick& Nick, CChan& Channel, CString& sMessage) { MODHALTCHK(OnChanAction(Nick, Channel, sMessage)); }
bool CModules::OnPrivMsg(CNick& Nick, CString& sMessage) { MODHALTCHK(OnPrivMsg(Nick, sMessage)); }
bool CModules::OnChanMsg(CNick& Nick, CChan& Channel, CString& sMessage) { MODHALTCHK(OnChanMsg(Nick, Channel, sMessage)); }
bool CModules::OnPrivNotice(CNick& Nick, CString& sMessage) { MODHALTCHK(OnPrivNotice(Nick, sMessage)); }
bool CModules::OnChanNotice(CNick& Nick, CChan& Channel, CString& sMessage) { MODHALTCHK(OnChanNotice(Nick, Channel, sMessage)); }
bool CModules::OnTopic(CNick& Nick, CChan& Channel, CString& sTopic) { MODHALTCHK(OnTopic(Nick, Channel, sTopic)); }
bool CModules::OnTimerAutoJoin(CChan& Channel) { MODHALTCHK(OnTimerAutoJoin(Channel)); }
bool CModules::OnStatusCommand(CString& sCommand) { MODHALTCHK(OnStatusCommand(sCommand)); }
bool CModules::OnModCommand(const CString& sCommand) { MODUNLOADCHK(OnModCommand(sCommand)); return false; }
bool CModules::OnModNotice(const CString& sMessage) { MODUNLOADCHK(OnModNotice(sMessage)); return false; }
bool CModules::OnModCTCP(const CString& sMessage) { MODUNLOADCHK(OnModCTCP(sMessage)); return false; }

////////////////////
// CGlobalModules //
////////////////////
bool CGlobalModules::OnConfigLine(const CString& sName, const CString& sValue, CUser* pUser, CChan* pChan) {
	GLOBALMODHALTCHK(OnConfigLine(sName, sValue, pUser, pChan));
}

bool CGlobalModules::OnDeleteUser(CUser& User) {
	GLOBALMODHALTCHK(OnDeleteUser(User));
}

void CGlobalModules::OnClientConnect(CClient* pClient, const CString& sHost, unsigned short uPort) {
	GLOBALMODCALL(OnClientConnect(pClient, sHost, uPort));
}

bool CGlobalModules::OnLoginAttempt(CSmartPtr<CAuthBase> Auth) {
	GLOBALMODHALTCHK(OnLoginAttempt(Auth));
}

void CGlobalModules::OnFailedLogin(const CString& sUsername, const CString& sRemoteIP) {
	GLOBALMODCALL(OnFailedLogin(sUsername, sRemoteIP));
}

bool CGlobalModules::OnUnknownUserRaw(CClient* pClient, CString& sLine) {
	GLOBALMODHALTCHK(OnUnknownUserRaw(pClient, sLine));
}

CModule* CModules::FindModule(const CString& sModule) const {
	for (unsigned int a = 0; a < size(); a++) {
		if (sModule.Equals((*this)[a]->GetModName())) {
			return (*this)[a];
		}
	}

	return NULL;
}

bool CModules::LoadModule(const CString& sModule, const CString& sArgs, CUser* pUser, CString& sRetMsg, bool bFake) {
	sRetMsg = """";

	if (FindModule(sModule) != NULL) {
		sRetMsg = ""Module ["" + sModule + ""] already loaded."";
		return false;
	}

	if (bFake) {
		CModule* pModule = new CModule(NULL, sModule, """");
		pModule->SetArgs(sArgs);
		pModule->SetDescription(""<<Fake Module>>"");
		pModule->SetFake(true);
		push_back(pModule);
		sRetMsg = ""Loaded fake module ["" + sModule + ""]"";
		return true;
	}

	CString sModPath, sDataPath;
	CString sDesc;
	bool bVersionMismatch;
	bool bIsGlobal;

	if (!FindModPath(sModule, sModPath, sDataPath)) {
		sRetMsg = ""Unable to find module ["" + sModule + ""]"";
		return false;
	}

	ModHandle p = OpenModule(sModule, sModPath, bVersionMismatch, bIsGlobal, sDesc, sRetMsg);

	if (!p)
		return false;

	if (bVersionMismatch) {
		dlclose(p);
		sRetMsg = ""Version mismatch, recompile this module."";
		return false;
	}

	if ((pUser == NULL) != bIsGlobal) {
		dlclose(p);
		sRetMsg = ""Module ["" + sModule + ""] is "";
		sRetMsg += (bIsGlobal) ? """" : ""not "";
		sRetMsg += ""a global module."";
		return false;
	}

	CModule* pModule = NULL;

	if (pUser) {
		typedef CModule* (*fp)(ModHandle, CUser* pUser,
				const CString& sModName, const CString& sDataPath);
		fp Load = (fp) dlsym(p, ""ZNCModLoad"");

		if (!Load) {
			dlclose(p);
			sRetMsg = ""Could not find ZNCModLoad() in module ["" + sModule + ""]"";
			return false;
		}

		pModule = Load(p, pUser, sModule, sDataPath);
	} else {
		typedef CModule* (*fp)(ModHandle, const CString& sModName,
				const CString& sDataPath);
		fp Load = (fp) dlsym(p, ""ZNCModLoad"");

		if (!Load) {
			dlclose(p);
			sRetMsg = ""Could not find ZNCModLoad() in module ["" + sModule + ""]"";
			return false;
		}

		pModule = Load(p, sModule, sDataPath);
	}

	pModule->SetDescription(sDesc);
	pModule->SetGlobal(bIsGlobal);
	pModule->SetArgs(sArgs);
	push_back(pModule);

	bool bLoaded;
	try {
		bLoaded = pModule->OnLoad(sArgs, sRetMsg);
	} catch (CModule::EModException) {
		bLoaded = false;
		sRetMsg = ""Caught an exception"";
	}

	if (!bLoaded) {
		UnloadModule(sModule, sModPath);
		if (!sRetMsg.empty())
			sRetMsg = ""Module ["" + sModule + ""] aborted: "" + sRetMsg;
		else
			sRetMsg = ""Module ["" + sModule + ""] aborted."";
		return false;
	}

	if (!sRetMsg.empty()) {
		sRetMsg = ""Loaded module ["" + sModule + ""] ["" + sRetMsg + ""] ["" + sModPath + ""]"";
	} else {
		sRetMsg = ""Loaded module ["" + sModule + ""] ["" + sModPath + ""]"";
	}
	return true;
}

bool CModules::UnloadModule(const CString& sModule) {
	CString s;
	return UnloadModule(sModule, s);
}

bool CModules::UnloadModule(const CString& sModule, CString& sRetMsg) {
	CString sMod = sModule;	// Make a copy incase the reference passed in is from CModule::GetModName()
	CModule* pModule = FindModule(sMod);
	sRetMsg = """";

	if (!pModule) {
		sRetMsg = ""Module ["" + sMod + ""] not loaded."";
		return false;
	}

	if (pModule->IsFake()) {
		for (iterator it = begin(); it != end(); it++) {
			if (*it == pModule) {
				erase(it);
				sRetMsg = ""Fake module ["" + sMod + ""] unloaded"";
				return true;
			}
		}

		sRetMsg = ""Fake module ["" + sMod + ""] not loaded."";
		return false;
	}

	ModHandle p = pModule->GetDLL();

	if (p) {
		typedef void (*fp)(CModule*);
		fp Unload = (fp)dlsym(p, ""ZNCModUnload"");

		if (Unload) {
			Unload(pModule);

			for (iterator it = begin(); it != end(); it++) {
				if (*it == pModule) {
					erase(it);
					break;
				}
			}

			dlclose(p);
			sRetMsg = ""Module ["" + sMod + ""] unloaded"";

			return true;
		} else {
			sRetMsg = ""Unable to unload module ["" + sMod + ""] could not find ZNCModUnload()"";
			return false;
		}
	}

	sRetMsg = ""Unable to unload module ["" + sMod + ""]"";
	return false;
}

bool CModules::ReloadModule(const CString& sModule, const CString& sArgs, CUser* pUser, CString& sRetMsg) {
	CString sMod = sModule;	// Make a copy incase the reference passed in is from CModule::GetModName()
	sRetMsg = """";
	if (!UnloadModule(sMod, sRetMsg)) {
		return false;
	}

	if (!LoadModule(sMod, sArgs, pUser, sRetMsg)) {
		return false;
	}

	sRetMsg = ""Reloaded module ["" + sMod + ""]"";
	return true;
}

bool CModules::GetModInfo(CModInfo& ModInfo, const CString& sModule, CString& sRetMsg) {
	CString sModPath, sTmp;

	if (!FindModPath(sModule, sModPath, sTmp)) {
		sRetMsg = ""Unable to find module ["" + sModule + ""]"";
		return false;
	}

	return GetModPathInfo(ModInfo, sModule, sModPath, sRetMsg);
}

bool CModules::GetModPathInfo(CModInfo& ModInfo, const CString& sModule, const CString& sModPath, CString& sRetMsg) {
	CString sDesc;
	bool bVersionMismatch;
	bool bIsGlobal;

	ModHandle p = OpenModule(sModule, sModPath, bVersionMismatch, bIsGlobal, sDesc, sRetMsg);

	if (!p)
		return false;

	ModInfo.SetGlobal(bIsGlobal);
	ModInfo.SetDescription(sDesc);
	ModInfo.SetName(sModule);
	ModInfo.SetPath(sModPath);

	if (bVersionMismatch) {
		ModInfo.SetDescription(""--- Version mismatch, recompile this module. ---"");
	}

	dlclose(p);

	return true;
}

void CModules::GetAvailableMods(set<CModInfo>& ssMods, bool bGlobal) {
	ssMods.clear();

	unsigned int a = 0;
	CDir Dir;

	ModDirList dirs = GetModDirs();

	while (!dirs.empty()) {
		Dir.FillByWildcard(dirs.front().first, ""*.so"");
		dirs.pop();

		for (a = 0; a < Dir.size(); a++) {
			CFile& File = *Dir[a];
			CString sName = File.GetShortName();
			CString sPath = File.GetLongName();
			CModInfo ModInfo;
			sName.RightChomp(3);

			CString sIgnoreRetMsg;
			if (GetModPathInfo(ModInfo, sName, sPath, sIgnoreRetMsg)) {
				if (ModInfo.IsGlobal() == bGlobal) {
					ssMods.insert(ModInfo);
				}
			}
		}
	}
}

bool CModules::FindModPath(const CString& sModule, CString& sModPath,
		CString& sDataPath) {
	CString sMod = sModule;
	CString sDir = sMod;
	if (sModule.find(""."") == CString::npos)
		sMod += "".so"";

	ModDirList dirs = GetModDirs();

	while (!dirs.empty()) {
		sModPath = dirs.front().first + sMod;
		sDataPath = dirs.front().second;
		dirs.pop();

		if (CFile::Exists(sModPath)) {
			sDataPath += sDir;
			return true;
		}
	}

	return false;
}

CModules::ModDirList CModules::GetModDirs() {
	ModDirList ret;

	// ./modules
	CString sDir = CZNC::Get().GetCurPath() + ""/modules/"";
	ret.push(std::make_pair(sDir, sDir));

	// ./modules/extra
	sDir = CZNC::Get().GetCurPath() + ""/modules/extra/"";
	ret.push(std::make_pair(sDir, sDir));

	// ~/.znc/modules
	sDir = CZNC::Get().GetModPath() + ""/"";
	ret.push(std::make_pair(sDir, sDir));

	// <moduledir> and <datadir> (<prefix>/lib/znc)
	ret.push(std::make_pair(_MODDIR_ + CString(""/""), _DATADIR_ + CString(""/"")));

	return ret;
}

ModHandle CModules::OpenModule(const CString& sModule, const CString& sModPath, bool &bVersionMismatch,
		bool &bIsGlobal, CString& sDesc, CString& sRetMsg) {
	for (unsigned int a = 0; a < sModule.length(); a++) {
		if (((sModule[a] < '0') || (sModule[a] > '9')) && ((sModule[a] < 'a') || (sModule[a] > 'z')) && ((sModule[a] < 'A') || (sModule[a] > 'Z')) && (sModule[a] != '_')) {
			sRetMsg = ""Module names can only contain letters, numbers and underscores, ["" + sModule + ""] is invalid."";
			return NULL;
		}
	}

	ModHandle p = dlopen((sModPath).c_str(), RTLD_NOW | RTLD_LOCAL);

	if (!p) {
		sRetMsg = ""Unable to open module ["" + sModule + ""] ["" + dlerror() + ""]"";
		return NULL;
	}

	typedef double (*dFP)();
	dFP Version = (dFP) dlsym(p, ""ZNCModVersion"");

	if (!Version) {
		dlclose(p);
		sRetMsg = ""Could not find ZNCModVersion() in module ["" + sModule + ""]"";
		return NULL;
	}

	typedef bool (*bFP)();
	bFP IsGlobal = (bFP) dlsym(p, ""ZNCModGlobal"");

	if (!IsGlobal) {
		dlclose(p);
		sRetMsg = ""Could not find ZNCModGlobal() in module ["" + sModule + ""]"";
		return NULL;
	}

	typedef CString (*sFP)();
	sFP GetDesc = (sFP) dlsym(p, ""ZNCModDescription"");

	if (!GetDesc) {
		dlclose(p);
		sRetMsg = ""Could not find ZNCModDescription() in module ["" + sModule + ""]"";
		return false;
	}

	bIsGlobal = IsGlobal();
	sDesc = GetDesc();

	if (CModule::GetCoreVersion() != Version()) {
		bVersionMismatch = true;
		sRetMsg = ""Version mismatch, recompile this module."";
	} else {
		sRetMsg = """";
		bVersionMismatch = false;
	}

	return p;
}

#endif // _MODULES
""",CModule::RemTimer,[335:340]
znc,https://github.com/znc/znc/commit/77dd0c2f9829983241b1028298b23d26c8139756,"""Bug fix for CUser::DelServer()

DelServer() didn't always update m_uServerIdx correctly which means
GetCurServer() started to return the wrong server. This should now be fixed.

This log shows the bug. ZNC starts to think it's connected to irc.efnet.nl:

<znc_psy> listservers
<*status> +-------------------+------+-----+------+
<*status> | Host              | Port | SSL | Pass |
<*status> +-------------------+------+-----+------+
<*status> | irc.efnet.pl      | 6667 |     |      |
<*status> | irc.spotchat.org* | 6667 |     |      |
<*status> | irc.efnet.nl      | 6667 |     |      |
<*status> | irc.freenode.org  | 6667 |     |      |
<*status> +-------------------+------+-----+------+
<znc_psy> delserver irc.efnet.pl
<*status> Server removed
<znc_psy> listservers
<*status> +------------------+------+-----+------+
<*status> | Host             | Port | SSL | Pass |
<*status> +------------------+------+-----+------+
<*status> | irc.spotchat.org | 6667 |     |      |
<*status> | irc.efnet.nl*    | 6667 |     |      |
<*status> | irc.freenode.org | 6667 |     |      |
<*status> +------------------+------+-----+------+

Thanks to tomaw for reporting this bug.


git-svn-id: https://znc.svn.sourceforge.net/svnroot/znc/trunk@1659 726aef4b-f618-498e-8847-2d620e286838""","""/*
 * Copyright (C) 2004-2009  See the AUTHORS file for details.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 as published
 * by the Free Software Foundation.
 */

#include ""User.h""
#include ""Chan.h""
#include ""DCCSock.h""
#include ""IRCSock.h""
#include ""Server.h""
#include ""Timers.h""
#include ""znc.h""

CUser::CUser(const CString& sUserName) {
	m_pIRCSock = NULL;
	m_fTimezoneOffset = 0;
	m_uConnectTime = 0;
	SetUserName(sUserName);
	m_sNick = m_sCleanUserName;
	m_sIdent = m_sCleanUserName;
	m_sRealName = sUserName;
	m_uServerIdx = 0;
	m_uBytesRead = 0;
	m_uBytesWritten = 0;
#ifdef _MODULES
	m_pModules = new CModules;
#endif
	m_RawBuffer.SetLineCount(100);		// This should be more than enough raws, especially since we are buffering the MOTD separately
	m_MotdBuffer.SetLineCount(200);		// This should be more than enough motd lines
	m_bMultiClients = true;
	m_bBounceDCCs = true;
	m_eHashType = HASH_NONE;
	m_bUseClientIP = false;
	m_bDenyLoadMod = false;
	m_bAdmin= false;
	m_bIRCAway = false;
	m_bDenySetVHost= false;
	m_sStatusPrefix = ""*"";
	m_sChanPrefixes = """";
	m_uBufferCount = 50;
	m_uMaxJoinTries = 10;
	m_uMaxJoins = 5;
	m_bKeepBuffer = false;
	m_bBeingDeleted = false;
	m_sTimestampFormat = ""[%H:%M:%S]"";
	m_bAppendTimestamp = false;
	m_bPrependTimestamp = true;
	m_bIRCConnectEnabled = true;
	m_pUserTimer = new CUserTimer(this);
	CZNC::Get().GetManager().AddCron(m_pUserTimer);
	m_sUserPath = CZNC::Get().GetUserPath() + ""/"" + sUserName;
	m_sDLPath = GetUserPath() + ""/downloads"";
}

CUser::~CUser() {
	DelClients();

#ifdef _MODULES
	DelModules();
#endif

	DelServers();

	for (unsigned int b = 0; b < m_vChans.size(); b++) {
		delete m_vChans[b];
	}

	// This will cause an endless loop if the destructor doesn't remove the
	// socket from this list / if the socket doesn't exist any more.
	while (!m_sDCCBounces.empty())
		CZNC::Get().GetManager().DelSockByAddr((CZNCSock*) *m_sDCCBounces.begin());
	while (!m_sDCCSocks.empty())
		CZNC::Get().GetManager().DelSockByAddr((CZNCSock*) *m_sDCCSocks.begin());

	CZNC::Get().GetManager().DelCronByAddr(m_pUserTimer);
}

#ifdef _MODULES
void CUser::DelModules() {
	if (m_pModules) {
		delete m_pModules;
		m_pModules = NULL;
	}
}

bool CUser::UpdateModule(const CString &sModule) {
	const map<CString,CUser*>& Users = CZNC::Get().GetUserMap();
	map<CString,CUser*>::const_iterator it;
	map<CUser*, CString> Affected;
	map<CUser*, CString>::iterator it2;
	bool error = false;

	for (it = Users.begin(); it != Users.end(); it++) {
		CModule *pMod = it->second->GetModules().FindModule(sModule);
		if (pMod) {
			Affected[it->second] = pMod->GetArgs();
			it->second->GetModules().UnloadModule(pMod->GetModName());
		}
	}

	CString sErr;
	for (it2 = Affected.begin(); it2 != Affected.end(); it2++) {
		if (!it2->first->GetModules().LoadModule(sModule, it2->second, it2->first, sErr)) {
			error = true;
			DEBUG(""Failed to reload ["" << sModule << ""] for ["" << it2->first->GetUserName()
					<< ""]: "" << sErr);
		}
	}

	return !error;
}
#endif

void CUser::DelClients() {
	for (unsigned int c = 0; c < m_vClients.size(); c++) {
		CClient* pClient = m_vClients[c];
		CZNC::Get().GetManager().DelSockByAddr(pClient);
	}

	m_vClients.clear();
}

void CUser::DelServers()
{
	for (unsigned int a = 0; a < m_vServers.size(); a++) {
		delete m_vServers[a];
	}

	m_vServers.clear();
}

void CUser::IRCConnected(CIRCSock* pIRCSock) {
	m_pIRCSock = pIRCSock;

	for (unsigned int a = 0; a < m_vClients.size(); a++) {
		m_vClients[a]->IRCConnected(pIRCSock);
	}
}

void CUser::IRCDisconnected() {
	m_pIRCSock = NULL;

	for (unsigned int a = 0; a < m_vClients.size(); a++) {
		m_vClients[a]->IRCDisconnected();
	}

	SetIRCServer("""");
	m_bIRCAway = false;

	// Get the reconnect going
	CheckIRCConnect();
}

CString CUser::ExpandString(const CString& sStr) const {
	CString sRet;
	return ExpandString(sStr, sRet);
}

CString& CUser::ExpandString(const CString& sStr, CString& sRet) const {
	// offset is in hours, so * 60 * 60 gets us seconds
	time_t iUserTime = time(NULL) + (time_t)(m_fTimezoneOffset * 60 * 60);
	char *szTime = ctime(&iUserTime);
	CString sTime;

	if (szTime) {
		sTime = szTime;
		// ctime() adds a trailing newline
		sTime.Trim();
	}

	sRet = sStr;
	sRet.Replace(""%user%"", GetUserName());
	sRet.Replace(""%defnick%"", GetNick());
	sRet.Replace(""%nick%"", GetCurNick());
	sRet.Replace(""%altnick%"", GetAltNick());
	sRet.Replace(""%ident%"", GetIdent());
	sRet.Replace(""%realname%"", GetRealName());
	sRet.Replace(""%vhost%"", GetVHost());
	sRet.Replace(""%version%"", CZNC::GetVersion());
	sRet.Replace(""%time%"", sTime);
	sRet.Replace(""%uptime%"", CZNC::Get().GetUptime());
	// The following lines do not exist. You must be on DrUgS!
	sRet.Replace(""%znc%"", ""All your IRC are belong to ZNC"");
	// Chosen by fair zocchihedron dice roll by SilverLeo
	sRet.Replace(""%rand%"", ""42"");

	return sRet;
}

CString CUser::AddTimestamp(const CString& sStr) const {
	CString sRet;
	return AddTimestamp(sStr, sRet);
}

CString& CUser::AddTimestamp(const CString& sStr, CString& sRet) const {
	char szTimestamp[1024];
	time_t tm;

	if (GetTimestampFormat().empty() || (!m_bAppendTimestamp && !m_bPrependTimestamp)) {
		sRet = sStr;
	} else {
		time(&tm);
		tm += (time_t)(m_fTimezoneOffset * 60 * 60); // offset is in hours
		size_t i = strftime(szTimestamp, sizeof(szTimestamp), GetTimestampFormat().c_str(), localtime(&tm));
		if (i != 0) {
			sRet = sStr;
		} else {
			sRet.clear();
		}

		if (m_bPrependTimestamp) {
			sRet = szTimestamp;
			sRet += "" "" + sStr;
		}
		if (m_bAppendTimestamp) {
			sRet += "" "";
			sRet += szTimestamp;
		}
	}
	return sRet;
}

void CUser::BounceAllClients() {
	for (unsigned int a = 0; a < m_vClients.size(); a++) {
		m_vClients[a]->BouncedOff();
	}

	m_vClients.clear();
}

void CUser::UserConnected(CClient* pClient) {
	if (!MultiClients()) {
		BounceAllClients();
	}

	PutStatus(""Another client authenticated as your user, use the 'ListClients' command to see all clients"");
	m_vClients.push_back(pClient);

	if (m_RawBuffer.IsEmpty()) {
		pClient->PutClient("":irc.znc.in 001 "" + pClient->GetNick() + "" :- Welcome to ZNC -"");
	} else {
		unsigned int uIdx = 0;
		CString sLine;

		while (m_RawBuffer.GetLine(GetIRCNick().GetNick(), sLine, uIdx++)) {
			pClient->PutClient(sLine);
		}

		// The assumption is that the client got this nick from the 001 reply
		pClient->SetNick(GetIRCNick().GetNick());
	}

	// Send the cached MOTD
	if (m_MotdBuffer.IsEmpty()) {
		PutIRC(""MOTD"");
	} else {
		unsigned int uIdx = 0;
		CString sLine;

		while (m_MotdBuffer.GetLine(GetIRCNick().GetNick(), sLine, uIdx++)) {
			pClient->PutClient(sLine);
		}
	}

	if (GetIRCSock() != NULL) {
		CString sUserMode("""");
		const set<unsigned char>& scUserModes = GetIRCSock()->GetUserModes();
		for (set<unsigned char>::const_iterator it = scUserModes.begin();
				it != scUserModes.end(); it++) {
			sUserMode += *it;
		}
		if (!sUserMode.empty()) {
			pClient->PutClient("":"" + GetIRCNick().GetNickMask() + "" MODE "" + GetIRCNick().GetNick() + "" :+"" + sUserMode);
		}
	}

	if (m_bIRCAway) {
		// If they want to know their away reason they'll have to whois
		// themselves. At least we can tell them their away status...
		pClient->PutClient("":irc.znc.in 306 "" + GetIRCNick().GetNick() + "" :You have been marked as being away"");
	}

	const vector<CChan*>& vChans = GetChans();
	for (unsigned int a = 0; a < vChans.size(); a++) {
		if ((vChans[a]->IsOn()) && (!vChans[a]->IsDetached())) {
			vChans[a]->JoinUser(true, """", pClient);
		}
	}

	CString sBufLine;
	while (m_QueryBuffer.GetNextLine(GetIRCNick().GetNick(), sBufLine)) {
		MODULECALL(OnPrivBufferPlayLine(*pClient, sBufLine), this, NULL, continue);
		pClient->PutClient(sBufLine);
	}

	// Tell them why they won't connect
	if (!GetIRCConnectEnabled())
		pClient->PutStatus(""You are currently disconnected from IRC. ""
				""Use 'connect' to reconnect."");
}

void CUser::UserDisconnected(CClient* pClient) {
	for (unsigned int a = 0; a < m_vClients.size(); a++) {
		if (m_vClients[a] == pClient) {
			m_vClients.erase(m_vClients.begin() + a);
			break;
		}
	}
}

bool CUser::Clone(const CUser& User, CString& sErrorRet, bool bCloneChans) {
	unsigned int a = 0;
	sErrorRet.clear();

	if (!User.IsValid(sErrorRet, true)) {
		return false;
	}

	if (GetUserName() != User.GetUserName()) {
		if (CZNC::Get().FindUser(User.GetUserName())) {
			sErrorRet = ""New username already exists"";
			return false;
		}

		SetUserName(User.GetUserName());
	}

	if (!User.GetPass().empty()) {
		SetPass(User.GetPass(), User.GetPassHashType(), User.GetPassSalt());
	}

	SetNick(User.GetNick(false));
	SetAltNick(User.GetAltNick(false));
	SetIdent(User.GetIdent(false));
	SetRealName(User.GetRealName());
	SetStatusPrefix(User.GetStatusPrefix());
	SetVHost(User.GetVHost());
	SetDCCVHost(User.GetDCCVHost());
	SetQuitMsg(User.GetQuitMsg());
	SetDefaultChanModes(User.GetDefaultChanModes());
	SetBufferCount(User.GetBufferCount());
	SetJoinTries(User.JoinTries());
	SetMaxJoins(User.MaxJoins());

	// Allowed Hosts
	m_ssAllowedHosts.clear();
	const set<CString>& ssHosts = User.GetAllowedHosts();
	for (set<CString>::const_iterator it = ssHosts.begin(); it != ssHosts.end(); it++) {
		AddAllowedHost(*it);
	}

	for (a = 0; a < m_vClients.size(); a++) {
		CClient* pSock = m_vClients[a];

		if (!IsHostAllowed(pSock->GetRemoteIP())) {
			pSock->PutStatusNotice(""You are being disconnected because your IP is no longer allowed to connect to this user"");
			pSock->Close();
		}
	}

	// !Allowed Hosts

	// Servers
	const vector<CServer*>& vServers = User.GetServers();
	CString sServer;
	CServer* pCurServ = GetCurrentServer();

	if (pCurServ) {
		sServer = pCurServ->GetName();
	}

	DelServers();

	for (a = 0; a < vServers.size(); a++) {
		CServer* pServer = vServers[a];
		AddServer(pServer->GetName(), pServer->GetPort(), pServer->GetPass(), pServer->IsSSL());
	}

	m_uServerIdx = 0;
	for (a = 0; a < m_vServers.size(); a++) {
		if (sServer.Equals(m_vServers[a]->GetName())) {
			m_uServerIdx = a + 1;
			break;
		}
	}
	if (m_uServerIdx == 0) {
		m_uServerIdx = m_vServers.size();
		CIRCSock* pSock = GetIRCSock();

		if (pSock) {
			PutStatus(""Jumping servers because this server is no longer in the list"");
			pSock->Quit();
		}
	}
	// !Servers

	// Chans
	const vector<CChan*>& vChans = User.GetChans();
	for (a = 0; a < vChans.size(); a++) {
		CChan* pNewChan = vChans[a];
		CChan* pChan = FindChan(pNewChan->GetName());

		if (pChan) {
			pChan->SetInConfig(pNewChan->InConfig());
		} else {
			AddChan(pNewChan->GetName(), pNewChan->InConfig());
		}
	}

	for (a = 0; a < m_vChans.size(); a++) {
		CChan* pChan = m_vChans[a];
		CChan* pNewChan = User.FindChan(pChan->GetName());

		if (!pNewChan) {
			pChan->SetInConfig(false);
		} else {
			if (bCloneChans)
				pChan->Clone(*pNewChan);
		}
	}
	// !Chans

	// CTCP Replies
	m_mssCTCPReplies.clear();
	const MCString& msReplies = User.GetCTCPReplies();
	for (MCString::const_iterator it = msReplies.begin(); it != msReplies.end(); it++) {
		AddCTCPReply(it->first, it->second);
	}
	// !CTCP Replies

	// Flags
	SetKeepBuffer(User.KeepBuffer());
	SetMultiClients(User.MultiClients());
	SetBounceDCCs(User.BounceDCCs());
	SetUseClientIP(User.UseClientIP());
	SetDenyLoadMod(User.DenyLoadMod());
	SetAdmin(User.IsAdmin());
	SetDenySetVHost(User.DenySetVHost());
	SetTimestampAppend(User.GetTimestampAppend());
	SetTimestampPrepend(User.GetTimestampPrepend());
	SetTimestampFormat(User.GetTimestampFormat());
	SetTimezoneOffset(User.GetTimezoneOffset());
	// !Flags

#ifdef _MODULES
	// Modules
	set<CString> ssUnloadMods;
	CModules& vCurMods = GetModules();
	const CModules& vNewMods = User.GetModules();

	for (a = 0; a < vNewMods.size(); a++) {
		CString sModRet;
		CModule* pNewMod = vNewMods[a];
		CModule* pCurMod = vCurMods.FindModule(pNewMod->GetModName());

		if (!pCurMod) {
			vCurMods.LoadModule(pNewMod->GetModName(), pNewMod->GetArgs(), this, sModRet);
		} else if (pNewMod->GetArgs() != pCurMod->GetArgs()) {
			vCurMods.ReloadModule(pNewMod->GetModName(), pNewMod->GetArgs(), this, sModRet);
		}
	}

	for (a = 0; a < vCurMods.size(); a++) {
		CModule* pCurMod = vCurMods[a];
		CModule* pNewMod = vNewMods.FindModule(pCurMod->GetModName());

		if (!pNewMod) {
			ssUnloadMods.insert(pCurMod->GetModName());
		}
	}

	for (set<CString>::iterator it = ssUnloadMods.begin(); it != ssUnloadMods.end(); it++) {
		vCurMods.UnloadModule(*it);
	}
	// !Modules
#endif // !_MODULES

	return true;
}

const set<CString>& CUser::GetAllowedHosts() const { return m_ssAllowedHosts; }
bool CUser::AddAllowedHost(const CString& sHostMask) {
	if (sHostMask.empty() || m_ssAllowedHosts.find(sHostMask) != m_ssAllowedHosts.end()) {
		return false;
	}

	m_ssAllowedHosts.insert(sHostMask);
	return true;
}

bool CUser::IsHostAllowed(const CString& sHostMask) const {
	if (m_ssAllowedHosts.empty()) {
		return true;
	}

	for (set<CString>::const_iterator a = m_ssAllowedHosts.begin(); a != m_ssAllowedHosts.end(); a++) {
		if (sHostMask.WildCmp(*a)) {
			return true;
		}
	}

	return false;
}

const CString& CUser::GetTimestampFormat() const { return m_sTimestampFormat; }
bool CUser::GetTimestampAppend() const { return m_bAppendTimestamp; }
bool CUser::GetTimestampPrepend() const { return m_bPrependTimestamp; }

bool CUser::IsValidUserName(const CString& sUserName) {
	const char* p = sUserName.c_str();

	if (sUserName.empty()) {
		return false;
	}

	if ((*p < 'a' || *p > 'z') && (*p < 'A' || *p > 'Z')) {
		return false;
	}

	while (*p) {
		if (*p != '@' && *p != '.' && *p != '-' && *p != '_' && !isalnum(*p)) {
			return false;
		}

		p++;
	}

	return true;
}

bool CUser::IsValid(CString& sErrMsg, bool bSkipPass) const {
	sErrMsg.clear();

	if (!bSkipPass && m_sPass.empty()) {
		sErrMsg = ""Pass is empty"";
		return false;
	}

	if (m_sUserName.empty()) {
		sErrMsg = ""Username is empty"";
		return false;
	}

	if (!CUser::IsValidUserName(m_sUserName)) {
		sErrMsg = ""Username is invalid"";
		return false;
	}

	return true;
}

bool CUser::AddChan(CChan* pChan) {
	if (!pChan) {
		return false;
	}

	for (unsigned int a = 0; a < m_vChans.size(); a++) {
		if (m_vChans[a]->GetName().Equals(pChan->GetName())) {
			delete pChan;
			return false;
		}
	}

	m_vChans.push_back(pChan);
	return true;
}

bool CUser::AddChan(const CString& sName, bool bInConfig) {
	if (sName.empty() || FindChan(sName)) {
		return false;
	}

	CChan* pChan = new CChan(sName, this, bInConfig);
	m_vChans.push_back(pChan);
	return true;
}

bool CUser::DelChan(const CString& sName) {
	for (vector<CChan*>::iterator a = m_vChans.begin(); a != m_vChans.end(); a++) {
		if (sName.Equals((*a)->GetName())) {
			delete *a;
			m_vChans.erase(a);
			return true;
		}
	}

	return false;
}

bool CUser::PrintLine(CFile& File, const CString& sName, const CString& sValue) {
	if (sName.empty() || sValue.empty()) {
		return false;
	}

	// FirstLine() so that no one can inject new lines to the config if he
	// manages to add ""\n"" to e.g. sValue.
	CString sLine = ""\t"" + sName.FirstLine() + "" = "" + sValue.FirstLine() + ""\n"";
	if (File.Write(sLine) <= 0)
		return false;
	return true;
}

bool CUser::WriteConfig(CFile& File) {
	File.Write(""<User "" + GetUserName().FirstLine() + "">\n"");

	if (m_eHashType != HASH_NONE) {
		CString sHash = ""md5"";
		if (m_eHashType == HASH_SHA256)
			sHash = ""sha256"";
		if (m_sPassSalt.empty()) {
			PrintLine(File, ""Pass"", sHash + ""#"" + GetPass());
		} else {
			PrintLine(File, ""Pass"", sHash + ""#"" + GetPass() + ""#"" + m_sPassSalt + ""#"");
		}
	} else {
		PrintLine(File, ""Pass"", ""plain#"" + GetPass());
	}
	PrintLine(File, ""Nick"", GetNick());
	PrintLine(File, ""AltNick"", GetAltNick());
	PrintLine(File, ""Ident"", GetIdent());
	PrintLine(File, ""RealName"", GetRealName());
	PrintLine(File, ""VHost"", GetVHost());
	PrintLine(File, ""DCCVHost"", GetDCCVHost());
	PrintLine(File, ""QuitMsg"", GetQuitMsg());
	if (CZNC::Get().GetStatusPrefix() != GetStatusPrefix())
		PrintLine(File, ""StatusPrefix"", GetStatusPrefix());
	PrintLine(File, ""ChanModes"", GetDefaultChanModes());
	PrintLine(File, ""Buffer"", CString(GetBufferCount()));
	PrintLine(File, ""KeepBuffer"", CString(KeepBuffer()));
	PrintLine(File, ""MultiClients"", CString(MultiClients()));
	PrintLine(File, ""BounceDCCs"", CString(BounceDCCs()));
	PrintLine(File, ""DenyLoadMod"", CString(DenyLoadMod()));
	PrintLine(File, ""Admin"", CString(IsAdmin()));
	PrintLine(File, ""DenySetVHost"", CString(DenySetVHost()));
	PrintLine(File, ""DCCLookupMethod"", CString((UseClientIP()) ? ""client"" : ""default""));
	PrintLine(File, ""TimestampFormat"", GetTimestampFormat());
	PrintLine(File, ""AppendTimestamp"", CString(GetTimestampAppend()));
	PrintLine(File, ""PrependTimestamp"", CString(GetTimestampPrepend()));
	PrintLine(File, ""TimezoneOffset"", CString(m_fTimezoneOffset));
	PrintLine(File, ""JoinTries"", CString(m_uMaxJoinTries));
	PrintLine(File, ""MaxJoins"", CString(m_uMaxJoins));
	File.Write(""\n"");

	// Allow Hosts
	if (!m_ssAllowedHosts.empty()) {
		for (set<CString>::iterator it = m_ssAllowedHosts.begin(); it != m_ssAllowedHosts.end(); it++) {
			PrintLine(File, ""Allow"", *it);
		}

		File.Write(""\n"");
	}

	// CTCP Replies
	if (!m_mssCTCPReplies.empty()) {
		for (MCString::iterator itb = m_mssCTCPReplies.begin(); itb != m_mssCTCPReplies.end(); itb++) {
			PrintLine(File, ""CTCPReply"", itb->first.AsUpper() + "" "" + itb->second);
		}

		File.Write(""\n"");
	}

#ifdef _MODULES
	// Modules
	CModules& Mods = GetModules();

	if (!Mods.empty()) {
		for (unsigned int a = 0; a < Mods.size(); a++) {
			CString sArgs = Mods[a]->GetArgs();

			if (!sArgs.empty()) {
				sArgs = "" "" + sArgs;
			}

			PrintLine(File, ""LoadModule"", Mods[a]->GetModName() + sArgs);
		}

		File.Write(""\n"");
	}
#endif

	// Servers
	for (unsigned int b = 0; b < m_vServers.size(); b++) {
		PrintLine(File, ""Server"", m_vServers[b]->GetString());
	}

	// Chans
	for (unsigned int c = 0; c < m_vChans.size(); c++) {
		CChan* pChan = m_vChans[c];
		if (pChan->InConfig()) {
			File.Write(""\n"");
			if (!pChan->WriteConfig(File)) {
				return false;
			}
		}
	}

	File.Write(""</User>\n"");

	return true;
}

CChan* CUser::FindChan(const CString& sName) const {
	for (unsigned int a = 0; a < m_vChans.size(); a++) {
		CChan* pChan = m_vChans[a];
		if (sName.Equals(pChan->GetName())) {
			return pChan;
		}
	}

	return NULL;
}

void CUser::JoinChans() {
	// Avoid divsion by zero, it's bad!
	if (m_vChans.size() == 0)
		return;

	// We start at a random offset into the channel list so that if your
	// first 3 channels are invite-only and you got MaxJoins == 3, ZNC will
	// still be able to join the rest of your channels.
	unsigned int start = rand() % m_vChans.size();
	unsigned int uJoins = m_uMaxJoins;
	for (unsigned int a = 0; a < m_vChans.size(); a++) {
		unsigned int idx = (start + a) % m_vChans.size();
		CChan* pChan = m_vChans[idx];
		if (!pChan->IsOn() && !pChan->IsDisabled()) {
			if (!JoinChan(pChan))
				continue;

			// Limit the number of joins
			if (uJoins != 0 && --uJoins == 0)
				return;
		}
	}
}

bool CUser::JoinChan(CChan* pChan) {
	if (JoinTries() != 0 && pChan->GetJoinTries() >= JoinTries()) {
		PutStatus(""The channel "" + pChan->GetName() + "" could not be joined, disabling it."");
		pChan->Disable();
	} else {
		pChan->IncJoinTries();
		MODULECALL(OnTimerAutoJoin(*pChan), this, NULL, return false);

		PutIRC(""JOIN "" + pChan->GetName() + "" "" + pChan->GetKey());
		return true;
	}
	return false;
}

CServer* CUser::FindServer(const CString& sName) const {
	for (unsigned int a = 0; a < m_vServers.size(); a++) {
		CServer* pServer = m_vServers[a];
		if (sName.Equals(pServer->GetName())) {
			return pServer;
		}
	}

	return NULL;
}

bool CUser::DelServer(const CString& sName, unsigned short uPort, const CString& sPass) {
	if (sName.empty()) {
		return false;
	}

	unsigned int a = 0;

	for (vector<CServer*>::iterator it = m_vServers.begin(); it != m_vServers.end(); it++, a++) {
		CServer* pServer = *it;

		if (!pServer->GetName().Equals(sName))
			continue;

		if (uPort != 0 && pServer->GetPort() != uPort)
			continue;

		if (!sPass.empty() && pServer->GetPass() != sPass)
			continue;

		CServer* pCurServer = GetCurrentServer();
		m_vServers.erase(it);

		if (pServer == pCurServer) {
			CIRCSock* pIRCSock = GetIRCSock();

			if (m_uServerIdx) {
				m_uServerIdx--;
			}

			if (pIRCSock) {
				pIRCSock->Quit();
				PutStatus(""Your current server was removed, jumping..."");
			}
		} else if (m_uServerIdx >= m_vServers.size()) {
			m_uServerIdx = 0;
		}

		delete pServer;

		return true;
	}

	return false;
}

bool CUser::AddServer(const CString& sName) {
	if (sName.empty()) {
		return false;
	}

	bool bSSL = false;
	CString sLine = sName;
	sLine.Trim();

	CString sHost = sLine.Token(0);
	CString sPort = sLine.Token(1);

	if (sPort.Left(1) == ""+"") {
		bSSL = true;
		sPort.LeftChomp();
	}

	unsigned short uPort = sPort.ToUShort();
	CString sPass = sLine.Token(2, true);

	return AddServer(sHost, uPort, sPass, bSSL);
}

bool CUser::AddServer(const CString& sName, unsigned short uPort, const CString& sPass, bool bSSL) {
#ifndef HAVE_LIBSSL
	if (bSSL) {
		return false;
	}
#endif

	if (sName.empty()) {
		return false;
	}

	if (!uPort) {
		uPort = 6667;
	}

	// Check if server is already added
	for (unsigned int a = 0; a < m_vServers.size(); a++) {
		CServer* pServer = m_vServers[a];

		if (!sName.Equals(pServer->GetName()))
			continue;

		if (uPort != pServer->GetPort())
			continue;

		if (sPass != pServer->GetPass())
			continue;

		if (bSSL != pServer->IsSSL())
			continue;

		// Server is already added
		return false;
	}

	CServer* pServer = new CServer(sName, uPort, sPass, bSSL);
	m_vServers.push_back(pServer);

	CheckIRCConnect();

	return true;
}

bool CUser::IsLastServer() const {
	return (m_uServerIdx >= m_vServers.size());
}

CServer* CUser::GetNextServer() {
	if (m_vServers.empty()) {
		return NULL;
	}

	if (m_uServerIdx >= m_vServers.size()) {
		m_uServerIdx = 0;
	}

	return m_vServers[m_uServerIdx++];	// Todo: cycle through these
}

CServer* CUser::GetCurrentServer() const {
	unsigned int uIdx = (m_uServerIdx) ? m_uServerIdx -1 : 0;

	if (uIdx >= m_vServers.size()) {
		return NULL;
	}

	return m_vServers[uIdx];
}

bool CUser::CheckPass(const CString& sPass) const {
	switch (m_eHashType)
	{
	case HASH_MD5:
		return m_sPass.Equals(CUtils::SaltedMD5Hash(sPass, m_sPassSalt));
	case HASH_SHA256:
		return m_sPass.Equals(CUtils::SaltedSHA256Hash(sPass, m_sPassSalt));
	case HASH_NONE:
	default:
		return (sPass == m_sPass);
	}
}

/*CClient* CUser::GetClient() {
	// Todo: optimize this by saving a pointer to the sock
	CSockManager& Manager = CZNC::Get().GetManager();
	CString sSockName = ""USR::"" + m_sUserName;

	for (unsigned int a = 0; a < Manager.size(); a++) {
		Csock* pSock = Manager[a];
		if (pSock->GetSockName().Equals(sSockName)) {
			if (!pSock->IsClosed()) {
				return (CClient*) pSock;
			}
		}
	}

	return (CClient*) CZNC::Get().GetManager().FindSockByName(sSockName);
}*/

CString CUser::GetLocalIP() {
	CIRCSock* pIRCSock = GetIRCSock();

	if (pIRCSock) {
		return pIRCSock->GetLocalIP();
	}

	if (m_vClients.size()) {
		return m_vClients[0]->GetLocalIP();
	}

	return """";
}

CString CUser::GetLocalDCCIP() {
	if (!GetDCCVHost().empty())
		return GetDCCVHost();
	return GetLocalIP();
}

bool CUser::PutIRC(const CString& sLine) {
	CIRCSock* pIRCSock = GetIRCSock();

	if (!pIRCSock) {
		return false;
	}

	pIRCSock->PutIRC(sLine);
	return true;
}

bool CUser::PutUser(const CString& sLine, CClient* pClient, CClient* pSkipClient) {
	for (unsigned int a = 0; a < m_vClients.size(); a++) {
		if ((!pClient || pClient == m_vClients[a]) && pSkipClient != m_vClients[a]) {
			m_vClients[a]->PutClient(sLine);

			if (pClient) {
				return true;
			}
		}
	}

	return (pClient == NULL);
}

bool CUser::PutStatus(const CString& sLine, CClient* pClient, CClient* pSkipClient) {
	for (unsigned int a = 0; a < m_vClients.size(); a++) {
		if ((!pClient || pClient == m_vClients[a]) && pSkipClient != m_vClients[a]) {
			m_vClients[a]->PutStatus(sLine);

			if (pClient) {
				return true;
			}
		}
	}

	return (pClient == NULL);
}

bool CUser::PutStatusNotice(const CString& sLine, CClient* pClient, CClient* pSkipClient) {
	for (unsigned int a = 0; a < m_vClients.size(); a++) {
		if ((!pClient || pClient == m_vClients[a]) && pSkipClient != m_vClients[a]) {
			m_vClients[a]->PutStatusNotice(sLine);

			if (pClient) {
				return true;
			}
		}
	}

	return (pClient == NULL);
}

bool CUser::PutModule(const CString& sModule, const CString& sLine, CClient* pClient, CClient* pSkipClient) {
	for (unsigned int a = 0; a < m_vClients.size(); a++) {
		if ((!pClient || pClient == m_vClients[a]) && pSkipClient != m_vClients[a]) {
			m_vClients[a]->PutModule(sModule, sLine);

			if (pClient) {
				return true;
			}
		}
	}

	return (pClient == NULL);
}

bool CUser::ResumeFile(unsigned short uPort, unsigned long uFileSize) {
	CSockManager& Manager = CZNC::Get().GetManager();

	for (unsigned int a = 0; a < Manager.size(); a++) {
		if (Manager[a]->GetSockName().Equals(""DCC::LISTEN::"", false, 13)) {
			CDCCSock* pSock = (CDCCSock*) Manager[a];

			if (pSock->GetLocalPort() == uPort) {
				if (pSock->Seek(uFileSize)) {
					PutModule(pSock->GetModuleName(), ""DCC -> ["" + pSock->GetRemoteNick() + ""]["" + pSock->GetFileName() + ""] - Attempting to resume from file position ["" + CString(uFileSize) + ""]"");
					return true;
				} else {
					return false;
				}
			}
		}
	}

	return false;
}

bool CUser::SendFile(const CString& sRemoteNick, const CString& sFileName, const CString& sModuleName) {
	CString sFullPath = CDir::ChangeDir(GetDLPath(), sFileName, CZNC::Get().GetHomePath());
	CDCCSock* pSock = new CDCCSock(this, sRemoteNick, sFullPath, sModuleName);

	CFile* pFile = pSock->OpenFile(false);

	if (!pFile) {
		delete pSock;
		return false;
	}

	unsigned short uPort = CZNC::Get().GetManager().ListenRand(""DCC::LISTEN::"" + sRemoteNick, GetLocalDCCIP(), false, SOMAXCONN, pSock, 120);

	if (GetNick().Equals(sRemoteNick)) {
		PutUser("":"" + GetStatusPrefix() + ""status!znc@znc.in PRIVMSG "" + sRemoteNick + "" :\001DCC SEND "" + pFile->GetShortName() + "" "" + CString(CUtils::GetLongIP(GetLocalDCCIP())) + "" ""
				+ CString(uPort) + "" "" + CString(pFile->GetSize()) + ""\001"");
	} else {
		PutIRC(""PRIVMSG "" + sRemoteNick + "" :\001DCC SEND "" + pFile->GetShortName() + "" "" + CString(CUtils::GetLongIP(GetLocalDCCIP())) + "" ""
			    + CString(uPort) + "" "" + CString(pFile->GetSize()) + ""\001"");
	}

	PutModule(sModuleName, ""DCC -> ["" + sRemoteNick + ""]["" + pFile->GetShortName() + ""] - Attempting Send."");
	return true;
}

bool CUser::GetFile(const CString& sRemoteNick, const CString& sRemoteIP, unsigned short uRemotePort, const CString& sFileName, unsigned long uFileSize, const CString& sModuleName) {
	if (CFile::Exists(sFileName)) {
		PutModule(sModuleName, ""DCC <- ["" + sRemoteNick + ""]["" + sFileName + ""] - File already exists."");
		return false;
	}

	CDCCSock* pSock = new CDCCSock(this, sRemoteNick, sRemoteIP, uRemotePort, sFileName, uFileSize, sModuleName);

	if (!pSock->OpenFile()) {
		delete pSock;
		return false;
	}

	if (!CZNC::Get().GetManager().Connect(sRemoteIP, uRemotePort, ""DCC::GET::"" + sRemoteNick, 60, false, GetLocalDCCIP(), pSock)) {
		PutModule(sModuleName, ""DCC <- ["" + sRemoteNick + ""]["" + sFileName + ""] - Unable to connect."");
		return false;
	}

	PutModule(sModuleName, ""DCC <- ["" + sRemoteNick + ""]["" + sFileName + ""] - Attempting to connect to ["" + sRemoteIP + ""]"");
	return true;
}

CString CUser::GetCurNick() const {
	const CIRCSock* pIRCSock = GetIRCSock();

	if (pIRCSock) {
		return pIRCSock->GetNick();
	}

	if (m_vClients.size()) {
		return m_vClients[0]->GetNick();
	}

	return """";
}

CString CUser::MakeCleanUserName(const CString& sUserName) {
	return sUserName.Token(0, false, ""@"").Replace_n(""."", """");
}

// Setters
void CUser::SetUserName(const CString& s) {
	m_sCleanUserName = CUser::MakeCleanUserName(s);
	m_sUserName = s;
}

bool CUser::IsChan(const CString& sChan) const {
	if (sChan.empty())
		return false; // There is no way this is a chan
	if (GetChanPrefixes().empty())
		return true; // We can't know, so we allow everything
	// Thanks to the above if (empty), we can do sChan[0]
	return GetChanPrefixes().find(sChan[0]) != CString::npos;
}

void CUser::SetNick(const CString& s) { m_sNick = s; }
void CUser::SetAltNick(const CString& s) { m_sAltNick = s; }
void CUser::SetIdent(const CString& s) { m_sIdent = s; }
void CUser::SetRealName(const CString& s) { m_sRealName = s; }
void CUser::SetVHost(const CString& s) { m_sVHost = s; }
void CUser::SetDCCVHost(const CString& s) { m_sDCCVHost = s; }
void CUser::SetPass(const CString& s, eHashType eHash, const CString& sSalt) {
	m_sPass = s;
	m_eHashType = eHash;
	m_sPassSalt = sSalt;
}
void CUser::SetMultiClients(bool b) { m_bMultiClients = b; }
void CUser::SetBounceDCCs(bool b) { m_bBounceDCCs = b; }
void CUser::SetUseClientIP(bool b) { m_bUseClientIP = b; }
void CUser::SetDenyLoadMod(bool b) { m_bDenyLoadMod = b; }
void CUser::SetAdmin(bool b) { m_bAdmin = b; }
void CUser::SetDenySetVHost(bool b) { m_bDenySetVHost = b; }
void CUser::SetDefaultChanModes(const CString& s) { m_sDefaultChanModes = s; }
void CUser::SetIRCServer(const CString& s) { m_sIRCServer = s; }
void CUser::SetQuitMsg(const CString& s) { m_sQuitMsg = s; }
void CUser::SetBufferCount(unsigned int u) { m_uBufferCount = u; }
void CUser::SetKeepBuffer(bool b) { m_bKeepBuffer = b; }

void CUser::CheckIRCConnect()
{
	// Do we want to connect?
	if (m_bIRCConnectEnabled && GetIRCSock() == NULL)
		CZNC::Get().EnableConnectUser();
}

void CUser::SetIRCNick(const CNick& n) {
	m_IRCNick = n;

	for (unsigned int a = 0; a < m_vClients.size(); a++) {
		m_vClients[a]->SetNick(n.GetNick());
	}
}

bool CUser::AddCTCPReply(const CString& sCTCP, const CString& sReply) {
	if (sCTCP.empty()) {
		return false;
	}

	m_mssCTCPReplies[sCTCP.AsUpper()] = sReply;
	return true;
}

bool CUser::SetStatusPrefix(const CString& s) {
	if ((!s.empty()) && (s.length() < 6) && (s.find(' ') == CString::npos)) {
		m_sStatusPrefix = (s.empty()) ? ""*"" : s;
		return true;
	}

	return false;
}
// !Setters

// Getters
const CString& CUser::GetUserName() const { return m_sUserName; }
const CString& CUser::GetCleanUserName() const { return m_sCleanUserName; }
const CString& CUser::GetNick(bool bAllowDefault) const { return (bAllowDefault && m_sNick.empty()) ? GetCleanUserName() : m_sNick; }
const CString& CUser::GetAltNick(bool bAllowDefault) const { return (bAllowDefault && m_sAltNick.empty()) ? GetCleanUserName() : m_sAltNick; }
const CString& CUser::GetIdent(bool bAllowDefault) const { return (bAllowDefault && m_sIdent.empty()) ? GetCleanUserName() : m_sIdent; }
const CString& CUser::GetRealName() const { return m_sRealName.empty() ? m_sUserName : m_sRealName; }
const CString& CUser::GetVHost() const { return m_sVHost; }
const CString& CUser::GetDCCVHost() const { return m_sDCCVHost; }
const CString& CUser::GetPass() const { return m_sPass; }
CUser::eHashType CUser::GetPassHashType() const { return m_eHashType; }
const CString& CUser::GetPassSalt() const { return m_sPassSalt; }

bool CUser::ConnectPaused() {
	if (!m_uConnectTime) {
		m_uConnectTime = time(NULL);
		return false;
	}

	if (time(NULL) - m_uConnectTime >= 5) {
		m_uConnectTime = time(NULL);
		return false;
	}

	return true;
}

bool CUser::UseClientIP() const { return m_bUseClientIP; }
bool CUser::DenyLoadMod() const { return m_bDenyLoadMod; }
bool CUser::IsAdmin() const { return m_bAdmin; }
bool CUser::DenySetVHost() const { return m_bDenySetVHost; }
bool CUser::MultiClients() const { return m_bMultiClients; }
bool CUser::BounceDCCs() const { return m_bBounceDCCs; }
const CString& CUser::GetStatusPrefix() const { return m_sStatusPrefix; }
const CString& CUser::GetDefaultChanModes() const { return m_sDefaultChanModes; }
const vector<CChan*>& CUser::GetChans() const { return m_vChans; }
const vector<CServer*>& CUser::GetServers() const { return m_vServers; }
const CNick& CUser::GetIRCNick() const { return m_IRCNick; }
const CString& CUser::GetIRCServer() const { return m_sIRCServer; }
CString CUser::GetQuitMsg() const { return (!m_sQuitMsg.empty()) ? m_sQuitMsg : CZNC::GetTag(false); }
const MCString& CUser::GetCTCPReplies() const { return m_mssCTCPReplies; }
unsigned int CUser::GetBufferCount() const { return m_uBufferCount; }
bool CUser::KeepBuffer() const { return m_bKeepBuffer; }
// !Getters
""","""/*
 * Copyright (C) 2004-2009  See the AUTHORS file for details.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 as published
 * by the Free Software Foundation.
 */

#include ""User.h""
#include ""Chan.h""
#include ""DCCSock.h""
#include ""IRCSock.h""
#include ""Server.h""
#include ""Timers.h""
#include ""znc.h""

CUser::CUser(const CString& sUserName) {
	m_pIRCSock = NULL;
	m_fTimezoneOffset = 0;
	m_uConnectTime = 0;
	SetUserName(sUserName);
	m_sNick = m_sCleanUserName;
	m_sIdent = m_sCleanUserName;
	m_sRealName = sUserName;
	m_uServerIdx = 0;
	m_uBytesRead = 0;
	m_uBytesWritten = 0;
#ifdef _MODULES
	m_pModules = new CModules;
#endif
	m_RawBuffer.SetLineCount(100);		// This should be more than enough raws, especially since we are buffering the MOTD separately
	m_MotdBuffer.SetLineCount(200);		// This should be more than enough motd lines
	m_bMultiClients = true;
	m_bBounceDCCs = true;
	m_eHashType = HASH_NONE;
	m_bUseClientIP = false;
	m_bDenyLoadMod = false;
	m_bAdmin= false;
	m_bIRCAway = false;
	m_bDenySetVHost= false;
	m_sStatusPrefix = ""*"";
	m_sChanPrefixes = """";
	m_uBufferCount = 50;
	m_uMaxJoinTries = 10;
	m_uMaxJoins = 5;
	m_bKeepBuffer = false;
	m_bBeingDeleted = false;
	m_sTimestampFormat = ""[%H:%M:%S]"";
	m_bAppendTimestamp = false;
	m_bPrependTimestamp = true;
	m_bIRCConnectEnabled = true;
	m_pUserTimer = new CUserTimer(this);
	CZNC::Get().GetManager().AddCron(m_pUserTimer);
	m_sUserPath = CZNC::Get().GetUserPath() + ""/"" + sUserName;
	m_sDLPath = GetUserPath() + ""/downloads"";
}

CUser::~CUser() {
	DelClients();

#ifdef _MODULES
	DelModules();
#endif

	DelServers();

	for (unsigned int b = 0; b < m_vChans.size(); b++) {
		delete m_vChans[b];
	}

	// This will cause an endless loop if the destructor doesn't remove the
	// socket from this list / if the socket doesn't exist any more.
	while (!m_sDCCBounces.empty())
		CZNC::Get().GetManager().DelSockByAddr((CZNCSock*) *m_sDCCBounces.begin());
	while (!m_sDCCSocks.empty())
		CZNC::Get().GetManager().DelSockByAddr((CZNCSock*) *m_sDCCSocks.begin());

	CZNC::Get().GetManager().DelCronByAddr(m_pUserTimer);
}

#ifdef _MODULES
void CUser::DelModules() {
	if (m_pModules) {
		delete m_pModules;
		m_pModules = NULL;
	}
}

bool CUser::UpdateModule(const CString &sModule) {
	const map<CString,CUser*>& Users = CZNC::Get().GetUserMap();
	map<CString,CUser*>::const_iterator it;
	map<CUser*, CString> Affected;
	map<CUser*, CString>::iterator it2;
	bool error = false;

	for (it = Users.begin(); it != Users.end(); it++) {
		CModule *pMod = it->second->GetModules().FindModule(sModule);
		if (pMod) {
			Affected[it->second] = pMod->GetArgs();
			it->second->GetModules().UnloadModule(pMod->GetModName());
		}
	}

	CString sErr;
	for (it2 = Affected.begin(); it2 != Affected.end(); it2++) {
		if (!it2->first->GetModules().LoadModule(sModule, it2->second, it2->first, sErr)) {
			error = true;
			DEBUG(""Failed to reload ["" << sModule << ""] for ["" << it2->first->GetUserName()
					<< ""]: "" << sErr);
		}
	}

	return !error;
}
#endif

void CUser::DelClients() {
	for (unsigned int c = 0; c < m_vClients.size(); c++) {
		CClient* pClient = m_vClients[c];
		CZNC::Get().GetManager().DelSockByAddr(pClient);
	}

	m_vClients.clear();
}

void CUser::DelServers()
{
	for (unsigned int a = 0; a < m_vServers.size(); a++) {
		delete m_vServers[a];
	}

	m_vServers.clear();
}

void CUser::IRCConnected(CIRCSock* pIRCSock) {
	m_pIRCSock = pIRCSock;

	for (unsigned int a = 0; a < m_vClients.size(); a++) {
		m_vClients[a]->IRCConnected(pIRCSock);
	}
}

void CUser::IRCDisconnected() {
	m_pIRCSock = NULL;

	for (unsigned int a = 0; a < m_vClients.size(); a++) {
		m_vClients[a]->IRCDisconnected();
	}

	SetIRCServer("""");
	m_bIRCAway = false;

	// Get the reconnect going
	CheckIRCConnect();
}

CString CUser::ExpandString(const CString& sStr) const {
	CString sRet;
	return ExpandString(sStr, sRet);
}

CString& CUser::ExpandString(const CString& sStr, CString& sRet) const {
	// offset is in hours, so * 60 * 60 gets us seconds
	time_t iUserTime = time(NULL) + (time_t)(m_fTimezoneOffset * 60 * 60);
	char *szTime = ctime(&iUserTime);
	CString sTime;

	if (szTime) {
		sTime = szTime;
		// ctime() adds a trailing newline
		sTime.Trim();
	}

	sRet = sStr;
	sRet.Replace(""%user%"", GetUserName());
	sRet.Replace(""%defnick%"", GetNick());
	sRet.Replace(""%nick%"", GetCurNick());
	sRet.Replace(""%altnick%"", GetAltNick());
	sRet.Replace(""%ident%"", GetIdent());
	sRet.Replace(""%realname%"", GetRealName());
	sRet.Replace(""%vhost%"", GetVHost());
	sRet.Replace(""%version%"", CZNC::GetVersion());
	sRet.Replace(""%time%"", sTime);
	sRet.Replace(""%uptime%"", CZNC::Get().GetUptime());
	// The following lines do not exist. You must be on DrUgS!
	sRet.Replace(""%znc%"", ""All your IRC are belong to ZNC"");
	// Chosen by fair zocchihedron dice roll by SilverLeo
	sRet.Replace(""%rand%"", ""42"");

	return sRet;
}

CString CUser::AddTimestamp(const CString& sStr) const {
	CString sRet;
	return AddTimestamp(sStr, sRet);
}

CString& CUser::AddTimestamp(const CString& sStr, CString& sRet) const {
	char szTimestamp[1024];
	time_t tm;

	if (GetTimestampFormat().empty() || (!m_bAppendTimestamp && !m_bPrependTimestamp)) {
		sRet = sStr;
	} else {
		time(&tm);
		tm += (time_t)(m_fTimezoneOffset * 60 * 60); // offset is in hours
		size_t i = strftime(szTimestamp, sizeof(szTimestamp), GetTimestampFormat().c_str(), localtime(&tm));
		if (i != 0) {
			sRet = sStr;
		} else {
			sRet.clear();
		}

		if (m_bPrependTimestamp) {
			sRet = szTimestamp;
			sRet += "" "" + sStr;
		}
		if (m_bAppendTimestamp) {
			sRet += "" "";
			sRet += szTimestamp;
		}
	}
	return sRet;
}

void CUser::BounceAllClients() {
	for (unsigned int a = 0; a < m_vClients.size(); a++) {
		m_vClients[a]->BouncedOff();
	}

	m_vClients.clear();
}

void CUser::UserConnected(CClient* pClient) {
	if (!MultiClients()) {
		BounceAllClients();
	}

	PutStatus(""Another client authenticated as your user, use the 'ListClients' command to see all clients"");
	m_vClients.push_back(pClient);

	if (m_RawBuffer.IsEmpty()) {
		pClient->PutClient("":irc.znc.in 001 "" + pClient->GetNick() + "" :- Welcome to ZNC -"");
	} else {
		unsigned int uIdx = 0;
		CString sLine;

		while (m_RawBuffer.GetLine(GetIRCNick().GetNick(), sLine, uIdx++)) {
			pClient->PutClient(sLine);
		}

		// The assumption is that the client got this nick from the 001 reply
		pClient->SetNick(GetIRCNick().GetNick());
	}

	// Send the cached MOTD
	if (m_MotdBuffer.IsEmpty()) {
		PutIRC(""MOTD"");
	} else {
		unsigned int uIdx = 0;
		CString sLine;

		while (m_MotdBuffer.GetLine(GetIRCNick().GetNick(), sLine, uIdx++)) {
			pClient->PutClient(sLine);
		}
	}

	if (GetIRCSock() != NULL) {
		CString sUserMode("""");
		const set<unsigned char>& scUserModes = GetIRCSock()->GetUserModes();
		for (set<unsigned char>::const_iterator it = scUserModes.begin();
				it != scUserModes.end(); it++) {
			sUserMode += *it;
		}
		if (!sUserMode.empty()) {
			pClient->PutClient("":"" + GetIRCNick().GetNickMask() + "" MODE "" + GetIRCNick().GetNick() + "" :+"" + sUserMode);
		}
	}

	if (m_bIRCAway) {
		// If they want to know their away reason they'll have to whois
		// themselves. At least we can tell them their away status...
		pClient->PutClient("":irc.znc.in 306 "" + GetIRCNick().GetNick() + "" :You have been marked as being away"");
	}

	const vector<CChan*>& vChans = GetChans();
	for (unsigned int a = 0; a < vChans.size(); a++) {
		if ((vChans[a]->IsOn()) && (!vChans[a]->IsDetached())) {
			vChans[a]->JoinUser(true, """", pClient);
		}
	}

	CString sBufLine;
	while (m_QueryBuffer.GetNextLine(GetIRCNick().GetNick(), sBufLine)) {
		MODULECALL(OnPrivBufferPlayLine(*pClient, sBufLine), this, NULL, continue);
		pClient->PutClient(sBufLine);
	}

	// Tell them why they won't connect
	if (!GetIRCConnectEnabled())
		pClient->PutStatus(""You are currently disconnected from IRC. ""
				""Use 'connect' to reconnect."");
}

void CUser::UserDisconnected(CClient* pClient) {
	for (unsigned int a = 0; a < m_vClients.size(); a++) {
		if (m_vClients[a] == pClient) {
			m_vClients.erase(m_vClients.begin() + a);
			break;
		}
	}
}

bool CUser::Clone(const CUser& User, CString& sErrorRet, bool bCloneChans) {
	unsigned int a = 0;
	sErrorRet.clear();

	if (!User.IsValid(sErrorRet, true)) {
		return false;
	}

	if (GetUserName() != User.GetUserName()) {
		if (CZNC::Get().FindUser(User.GetUserName())) {
			sErrorRet = ""New username already exists"";
			return false;
		}

		SetUserName(User.GetUserName());
	}

	if (!User.GetPass().empty()) {
		SetPass(User.GetPass(), User.GetPassHashType(), User.GetPassSalt());
	}

	SetNick(User.GetNick(false));
	SetAltNick(User.GetAltNick(false));
	SetIdent(User.GetIdent(false));
	SetRealName(User.GetRealName());
	SetStatusPrefix(User.GetStatusPrefix());
	SetVHost(User.GetVHost());
	SetDCCVHost(User.GetDCCVHost());
	SetQuitMsg(User.GetQuitMsg());
	SetDefaultChanModes(User.GetDefaultChanModes());
	SetBufferCount(User.GetBufferCount());
	SetJoinTries(User.JoinTries());
	SetMaxJoins(User.MaxJoins());

	// Allowed Hosts
	m_ssAllowedHosts.clear();
	const set<CString>& ssHosts = User.GetAllowedHosts();
	for (set<CString>::const_iterator it = ssHosts.begin(); it != ssHosts.end(); it++) {
		AddAllowedHost(*it);
	}

	for (a = 0; a < m_vClients.size(); a++) {
		CClient* pSock = m_vClients[a];

		if (!IsHostAllowed(pSock->GetRemoteIP())) {
			pSock->PutStatusNotice(""You are being disconnected because your IP is no longer allowed to connect to this user"");
			pSock->Close();
		}
	}

	// !Allowed Hosts

	// Servers
	const vector<CServer*>& vServers = User.GetServers();
	CString sServer;
	CServer* pCurServ = GetCurrentServer();

	if (pCurServ) {
		sServer = pCurServ->GetName();
	}

	DelServers();

	for (a = 0; a < vServers.size(); a++) {
		CServer* pServer = vServers[a];
		AddServer(pServer->GetName(), pServer->GetPort(), pServer->GetPass(), pServer->IsSSL());
	}

	m_uServerIdx = 0;
	for (a = 0; a < m_vServers.size(); a++) {
		if (sServer.Equals(m_vServers[a]->GetName())) {
			m_uServerIdx = a + 1;
			break;
		}
	}
	if (m_uServerIdx == 0) {
		m_uServerIdx = m_vServers.size();
		CIRCSock* pSock = GetIRCSock();

		if (pSock) {
			PutStatus(""Jumping servers because this server is no longer in the list"");
			pSock->Quit();
		}
	}
	// !Servers

	// Chans
	const vector<CChan*>& vChans = User.GetChans();
	for (a = 0; a < vChans.size(); a++) {
		CChan* pNewChan = vChans[a];
		CChan* pChan = FindChan(pNewChan->GetName());

		if (pChan) {
			pChan->SetInConfig(pNewChan->InConfig());
		} else {
			AddChan(pNewChan->GetName(), pNewChan->InConfig());
		}
	}

	for (a = 0; a < m_vChans.size(); a++) {
		CChan* pChan = m_vChans[a];
		CChan* pNewChan = User.FindChan(pChan->GetName());

		if (!pNewChan) {
			pChan->SetInConfig(false);
		} else {
			if (bCloneChans)
				pChan->Clone(*pNewChan);
		}
	}
	// !Chans

	// CTCP Replies
	m_mssCTCPReplies.clear();
	const MCString& msReplies = User.GetCTCPReplies();
	for (MCString::const_iterator it = msReplies.begin(); it != msReplies.end(); it++) {
		AddCTCPReply(it->first, it->second);
	}
	// !CTCP Replies

	// Flags
	SetKeepBuffer(User.KeepBuffer());
	SetMultiClients(User.MultiClients());
	SetBounceDCCs(User.BounceDCCs());
	SetUseClientIP(User.UseClientIP());
	SetDenyLoadMod(User.DenyLoadMod());
	SetAdmin(User.IsAdmin());
	SetDenySetVHost(User.DenySetVHost());
	SetTimestampAppend(User.GetTimestampAppend());
	SetTimestampPrepend(User.GetTimestampPrepend());
	SetTimestampFormat(User.GetTimestampFormat());
	SetTimezoneOffset(User.GetTimezoneOffset());
	// !Flags

#ifdef _MODULES
	// Modules
	set<CString> ssUnloadMods;
	CModules& vCurMods = GetModules();
	const CModules& vNewMods = User.GetModules();

	for (a = 0; a < vNewMods.size(); a++) {
		CString sModRet;
		CModule* pNewMod = vNewMods[a];
		CModule* pCurMod = vCurMods.FindModule(pNewMod->GetModName());

		if (!pCurMod) {
			vCurMods.LoadModule(pNewMod->GetModName(), pNewMod->GetArgs(), this, sModRet);
		} else if (pNewMod->GetArgs() != pCurMod->GetArgs()) {
			vCurMods.ReloadModule(pNewMod->GetModName(), pNewMod->GetArgs(), this, sModRet);
		}
	}

	for (a = 0; a < vCurMods.size(); a++) {
		CModule* pCurMod = vCurMods[a];
		CModule* pNewMod = vNewMods.FindModule(pCurMod->GetModName());

		if (!pNewMod) {
			ssUnloadMods.insert(pCurMod->GetModName());
		}
	}

	for (set<CString>::iterator it = ssUnloadMods.begin(); it != ssUnloadMods.end(); it++) {
		vCurMods.UnloadModule(*it);
	}
	// !Modules
#endif // !_MODULES

	return true;
}

const set<CString>& CUser::GetAllowedHosts() const { return m_ssAllowedHosts; }
bool CUser::AddAllowedHost(const CString& sHostMask) {
	if (sHostMask.empty() || m_ssAllowedHosts.find(sHostMask) != m_ssAllowedHosts.end()) {
		return false;
	}

	m_ssAllowedHosts.insert(sHostMask);
	return true;
}

bool CUser::IsHostAllowed(const CString& sHostMask) const {
	if (m_ssAllowedHosts.empty()) {
		return true;
	}

	for (set<CString>::const_iterator a = m_ssAllowedHosts.begin(); a != m_ssAllowedHosts.end(); a++) {
		if (sHostMask.WildCmp(*a)) {
			return true;
		}
	}

	return false;
}

const CString& CUser::GetTimestampFormat() const { return m_sTimestampFormat; }
bool CUser::GetTimestampAppend() const { return m_bAppendTimestamp; }
bool CUser::GetTimestampPrepend() const { return m_bPrependTimestamp; }

bool CUser::IsValidUserName(const CString& sUserName) {
	const char* p = sUserName.c_str();

	if (sUserName.empty()) {
		return false;
	}

	if ((*p < 'a' || *p > 'z') && (*p < 'A' || *p > 'Z')) {
		return false;
	}

	while (*p) {
		if (*p != '@' && *p != '.' && *p != '-' && *p != '_' && !isalnum(*p)) {
			return false;
		}

		p++;
	}

	return true;
}

bool CUser::IsValid(CString& sErrMsg, bool bSkipPass) const {
	sErrMsg.clear();

	if (!bSkipPass && m_sPass.empty()) {
		sErrMsg = ""Pass is empty"";
		return false;
	}

	if (m_sUserName.empty()) {
		sErrMsg = ""Username is empty"";
		return false;
	}

	if (!CUser::IsValidUserName(m_sUserName)) {
		sErrMsg = ""Username is invalid"";
		return false;
	}

	return true;
}

bool CUser::AddChan(CChan* pChan) {
	if (!pChan) {
		return false;
	}

	for (unsigned int a = 0; a < m_vChans.size(); a++) {
		if (m_vChans[a]->GetName().Equals(pChan->GetName())) {
			delete pChan;
			return false;
		}
	}

	m_vChans.push_back(pChan);
	return true;
}

bool CUser::AddChan(const CString& sName, bool bInConfig) {
	if (sName.empty() || FindChan(sName)) {
		return false;
	}

	CChan* pChan = new CChan(sName, this, bInConfig);
	m_vChans.push_back(pChan);
	return true;
}

bool CUser::DelChan(const CString& sName) {
	for (vector<CChan*>::iterator a = m_vChans.begin(); a != m_vChans.end(); a++) {
		if (sName.Equals((*a)->GetName())) {
			delete *a;
			m_vChans.erase(a);
			return true;
		}
	}

	return false;
}

bool CUser::PrintLine(CFile& File, const CString& sName, const CString& sValue) {
	if (sName.empty() || sValue.empty()) {
		return false;
	}

	// FirstLine() so that no one can inject new lines to the config if he
	// manages to add ""\n"" to e.g. sValue.
	CString sLine = ""\t"" + sName.FirstLine() + "" = "" + sValue.FirstLine() + ""\n"";
	if (File.Write(sLine) <= 0)
		return false;
	return true;
}

bool CUser::WriteConfig(CFile& File) {
	File.Write(""<User "" + GetUserName().FirstLine() + "">\n"");

	if (m_eHashType != HASH_NONE) {
		CString sHash = ""md5"";
		if (m_eHashType == HASH_SHA256)
			sHash = ""sha256"";
		if (m_sPassSalt.empty()) {
			PrintLine(File, ""Pass"", sHash + ""#"" + GetPass());
		} else {
			PrintLine(File, ""Pass"", sHash + ""#"" + GetPass() + ""#"" + m_sPassSalt + ""#"");
		}
	} else {
		PrintLine(File, ""Pass"", ""plain#"" + GetPass());
	}
	PrintLine(File, ""Nick"", GetNick());
	PrintLine(File, ""AltNick"", GetAltNick());
	PrintLine(File, ""Ident"", GetIdent());
	PrintLine(File, ""RealName"", GetRealName());
	PrintLine(File, ""VHost"", GetVHost());
	PrintLine(File, ""DCCVHost"", GetDCCVHost());
	PrintLine(File, ""QuitMsg"", GetQuitMsg());
	if (CZNC::Get().GetStatusPrefix() != GetStatusPrefix())
		PrintLine(File, ""StatusPrefix"", GetStatusPrefix());
	PrintLine(File, ""ChanModes"", GetDefaultChanModes());
	PrintLine(File, ""Buffer"", CString(GetBufferCount()));
	PrintLine(File, ""KeepBuffer"", CString(KeepBuffer()));
	PrintLine(File, ""MultiClients"", CString(MultiClients()));
	PrintLine(File, ""BounceDCCs"", CString(BounceDCCs()));
	PrintLine(File, ""DenyLoadMod"", CString(DenyLoadMod()));
	PrintLine(File, ""Admin"", CString(IsAdmin()));
	PrintLine(File, ""DenySetVHost"", CString(DenySetVHost()));
	PrintLine(File, ""DCCLookupMethod"", CString((UseClientIP()) ? ""client"" : ""default""));
	PrintLine(File, ""TimestampFormat"", GetTimestampFormat());
	PrintLine(File, ""AppendTimestamp"", CString(GetTimestampAppend()));
	PrintLine(File, ""PrependTimestamp"", CString(GetTimestampPrepend()));
	PrintLine(File, ""TimezoneOffset"", CString(m_fTimezoneOffset));
	PrintLine(File, ""JoinTries"", CString(m_uMaxJoinTries));
	PrintLine(File, ""MaxJoins"", CString(m_uMaxJoins));
	File.Write(""\n"");

	// Allow Hosts
	if (!m_ssAllowedHosts.empty()) {
		for (set<CString>::iterator it = m_ssAllowedHosts.begin(); it != m_ssAllowedHosts.end(); it++) {
			PrintLine(File, ""Allow"", *it);
		}

		File.Write(""\n"");
	}

	// CTCP Replies
	if (!m_mssCTCPReplies.empty()) {
		for (MCString::iterator itb = m_mssCTCPReplies.begin(); itb != m_mssCTCPReplies.end(); itb++) {
			PrintLine(File, ""CTCPReply"", itb->first.AsUpper() + "" "" + itb->second);
		}

		File.Write(""\n"");
	}

#ifdef _MODULES
	// Modules
	CModules& Mods = GetModules();

	if (!Mods.empty()) {
		for (unsigned int a = 0; a < Mods.size(); a++) {
			CString sArgs = Mods[a]->GetArgs();

			if (!sArgs.empty()) {
				sArgs = "" "" + sArgs;
			}

			PrintLine(File, ""LoadModule"", Mods[a]->GetModName() + sArgs);
		}

		File.Write(""\n"");
	}
#endif

	// Servers
	for (unsigned int b = 0; b < m_vServers.size(); b++) {
		PrintLine(File, ""Server"", m_vServers[b]->GetString());
	}

	// Chans
	for (unsigned int c = 0; c < m_vChans.size(); c++) {
		CChan* pChan = m_vChans[c];
		if (pChan->InConfig()) {
			File.Write(""\n"");
			if (!pChan->WriteConfig(File)) {
				return false;
			}
		}
	}

	File.Write(""</User>\n"");

	return true;
}

CChan* CUser::FindChan(const CString& sName) const {
	for (unsigned int a = 0; a < m_vChans.size(); a++) {
		CChan* pChan = m_vChans[a];
		if (sName.Equals(pChan->GetName())) {
			return pChan;
		}
	}

	return NULL;
}

void CUser::JoinChans() {
	// Avoid divsion by zero, it's bad!
	if (m_vChans.size() == 0)
		return;

	// We start at a random offset into the channel list so that if your
	// first 3 channels are invite-only and you got MaxJoins == 3, ZNC will
	// still be able to join the rest of your channels.
	unsigned int start = rand() % m_vChans.size();
	unsigned int uJoins = m_uMaxJoins;
	for (unsigned int a = 0; a < m_vChans.size(); a++) {
		unsigned int idx = (start + a) % m_vChans.size();
		CChan* pChan = m_vChans[idx];
		if (!pChan->IsOn() && !pChan->IsDisabled()) {
			if (!JoinChan(pChan))
				continue;

			// Limit the number of joins
			if (uJoins != 0 && --uJoins == 0)
				return;
		}
	}
}

bool CUser::JoinChan(CChan* pChan) {
	if (JoinTries() != 0 && pChan->GetJoinTries() >= JoinTries()) {
		PutStatus(""The channel "" + pChan->GetName() + "" could not be joined, disabling it."");
		pChan->Disable();
	} else {
		pChan->IncJoinTries();
		MODULECALL(OnTimerAutoJoin(*pChan), this, NULL, return false);

		PutIRC(""JOIN "" + pChan->GetName() + "" "" + pChan->GetKey());
		return true;
	}
	return false;
}

CServer* CUser::FindServer(const CString& sName) const {
	for (unsigned int a = 0; a < m_vServers.size(); a++) {
		CServer* pServer = m_vServers[a];
		if (sName.Equals(pServer->GetName())) {
			return pServer;
		}
	}

	return NULL;
}

bool CUser::DelServer(const CString& sName, unsigned short uPort, const CString& sPass) {
	if (sName.empty()) {
		return false;
	}

	unsigned int a = 0;
	bool bSawCurrentServer = false;
	CServer* pCurServer = GetCurrentServer();

	for (vector<CServer*>::iterator it = m_vServers.begin(); it != m_vServers.end(); it++, a++) {
		CServer* pServer = *it;

		if (pServer == pCurServer)
			bSawCurrentServer = true;

		if (!pServer->GetName().Equals(sName))
			continue;

		if (uPort != 0 && pServer->GetPort() != uPort)
			continue;

		if (!sPass.empty() && pServer->GetPass() != sPass)
			continue;

		m_vServers.erase(it);

		if (pServer == pCurServer) {
			CIRCSock* pIRCSock = GetIRCSock();

			// Make sure we don't skip the next server in the list!
			if (m_uServerIdx) {
				m_uServerIdx--;
			}

			if (pIRCSock) {
				pIRCSock->Quit();
				PutStatus(""Your current server was removed, jumping..."");
			}
		} else if (!bSawCurrentServer) {
			// Our current server comes after the server which we
			// are removing. This means that it now got a different
			// index in m_vServers!
			m_uServerIdx--;
		}

		delete pServer;

		return true;
	}

	return false;
}

bool CUser::AddServer(const CString& sName) {
	if (sName.empty()) {
		return false;
	}

	bool bSSL = false;
	CString sLine = sName;
	sLine.Trim();

	CString sHost = sLine.Token(0);
	CString sPort = sLine.Token(1);

	if (sPort.Left(1) == ""+"") {
		bSSL = true;
		sPort.LeftChomp();
	}

	unsigned short uPort = sPort.ToUShort();
	CString sPass = sLine.Token(2, true);

	return AddServer(sHost, uPort, sPass, bSSL);
}

bool CUser::AddServer(const CString& sName, unsigned short uPort, const CString& sPass, bool bSSL) {
#ifndef HAVE_LIBSSL
	if (bSSL) {
		return false;
	}
#endif

	if (sName.empty()) {
		return false;
	}

	if (!uPort) {
		uPort = 6667;
	}

	// Check if server is already added
	for (unsigned int a = 0; a < m_vServers.size(); a++) {
		CServer* pServer = m_vServers[a];

		if (!sName.Equals(pServer->GetName()))
			continue;

		if (uPort != pServer->GetPort())
			continue;

		if (sPass != pServer->GetPass())
			continue;

		if (bSSL != pServer->IsSSL())
			continue;

		// Server is already added
		return false;
	}

	CServer* pServer = new CServer(sName, uPort, sPass, bSSL);
	m_vServers.push_back(pServer);

	CheckIRCConnect();

	return true;
}

bool CUser::IsLastServer() const {
	return (m_uServerIdx >= m_vServers.size());
}

CServer* CUser::GetNextServer() {
	if (m_vServers.empty()) {
		return NULL;
	}

	if (m_uServerIdx >= m_vServers.size()) {
		m_uServerIdx = 0;
	}

	return m_vServers[m_uServerIdx++];	// Todo: cycle through these
}

CServer* CUser::GetCurrentServer() const {
	unsigned int uIdx = (m_uServerIdx) ? m_uServerIdx -1 : 0;

	if (uIdx >= m_vServers.size()) {
		return NULL;
	}

	return m_vServers[uIdx];
}

bool CUser::CheckPass(const CString& sPass) const {
	switch (m_eHashType)
	{
	case HASH_MD5:
		return m_sPass.Equals(CUtils::SaltedMD5Hash(sPass, m_sPassSalt));
	case HASH_SHA256:
		return m_sPass.Equals(CUtils::SaltedSHA256Hash(sPass, m_sPassSalt));
	case HASH_NONE:
	default:
		return (sPass == m_sPass);
	}
}

/*CClient* CUser::GetClient() {
	// Todo: optimize this by saving a pointer to the sock
	CSockManager& Manager = CZNC::Get().GetManager();
	CString sSockName = ""USR::"" + m_sUserName;

	for (unsigned int a = 0; a < Manager.size(); a++) {
		Csock* pSock = Manager[a];
		if (pSock->GetSockName().Equals(sSockName)) {
			if (!pSock->IsClosed()) {
				return (CClient*) pSock;
			}
		}
	}

	return (CClient*) CZNC::Get().GetManager().FindSockByName(sSockName);
}*/

CString CUser::GetLocalIP() {
	CIRCSock* pIRCSock = GetIRCSock();

	if (pIRCSock) {
		return pIRCSock->GetLocalIP();
	}

	if (m_vClients.size()) {
		return m_vClients[0]->GetLocalIP();
	}

	return """";
}

CString CUser::GetLocalDCCIP() {
	if (!GetDCCVHost().empty())
		return GetDCCVHost();
	return GetLocalIP();
}

bool CUser::PutIRC(const CString& sLine) {
	CIRCSock* pIRCSock = GetIRCSock();

	if (!pIRCSock) {
		return false;
	}

	pIRCSock->PutIRC(sLine);
	return true;
}

bool CUser::PutUser(const CString& sLine, CClient* pClient, CClient* pSkipClient) {
	for (unsigned int a = 0; a < m_vClients.size(); a++) {
		if ((!pClient || pClient == m_vClients[a]) && pSkipClient != m_vClients[a]) {
			m_vClients[a]->PutClient(sLine);

			if (pClient) {
				return true;
			}
		}
	}

	return (pClient == NULL);
}

bool CUser::PutStatus(const CString& sLine, CClient* pClient, CClient* pSkipClient) {
	for (unsigned int a = 0; a < m_vClients.size(); a++) {
		if ((!pClient || pClient == m_vClients[a]) && pSkipClient != m_vClients[a]) {
			m_vClients[a]->PutStatus(sLine);

			if (pClient) {
				return true;
			}
		}
	}

	return (pClient == NULL);
}

bool CUser::PutStatusNotice(const CString& sLine, CClient* pClient, CClient* pSkipClient) {
	for (unsigned int a = 0; a < m_vClients.size(); a++) {
		if ((!pClient || pClient == m_vClients[a]) && pSkipClient != m_vClients[a]) {
			m_vClients[a]->PutStatusNotice(sLine);

			if (pClient) {
				return true;
			}
		}
	}

	return (pClient == NULL);
}

bool CUser::PutModule(const CString& sModule, const CString& sLine, CClient* pClient, CClient* pSkipClient) {
	for (unsigned int a = 0; a < m_vClients.size(); a++) {
		if ((!pClient || pClient == m_vClients[a]) && pSkipClient != m_vClients[a]) {
			m_vClients[a]->PutModule(sModule, sLine);

			if (pClient) {
				return true;
			}
		}
	}

	return (pClient == NULL);
}

bool CUser::ResumeFile(unsigned short uPort, unsigned long uFileSize) {
	CSockManager& Manager = CZNC::Get().GetManager();

	for (unsigned int a = 0; a < Manager.size(); a++) {
		if (Manager[a]->GetSockName().Equals(""DCC::LISTEN::"", false, 13)) {
			CDCCSock* pSock = (CDCCSock*) Manager[a];

			if (pSock->GetLocalPort() == uPort) {
				if (pSock->Seek(uFileSize)) {
					PutModule(pSock->GetModuleName(), ""DCC -> ["" + pSock->GetRemoteNick() + ""]["" + pSock->GetFileName() + ""] - Attempting to resume from file position ["" + CString(uFileSize) + ""]"");
					return true;
				} else {
					return false;
				}
			}
		}
	}

	return false;
}

bool CUser::SendFile(const CString& sRemoteNick, const CString& sFileName, const CString& sModuleName) {
	CString sFullPath = CDir::ChangeDir(GetDLPath(), sFileName, CZNC::Get().GetHomePath());
	CDCCSock* pSock = new CDCCSock(this, sRemoteNick, sFullPath, sModuleName);

	CFile* pFile = pSock->OpenFile(false);

	if (!pFile) {
		delete pSock;
		return false;
	}

	unsigned short uPort = CZNC::Get().GetManager().ListenRand(""DCC::LISTEN::"" + sRemoteNick, GetLocalDCCIP(), false, SOMAXCONN, pSock, 120);

	if (GetNick().Equals(sRemoteNick)) {
		PutUser("":"" + GetStatusPrefix() + ""status!znc@znc.in PRIVMSG "" + sRemoteNick + "" :\001DCC SEND "" + pFile->GetShortName() + "" "" + CString(CUtils::GetLongIP(GetLocalDCCIP())) + "" ""
				+ CString(uPort) + "" "" + CString(pFile->GetSize()) + ""\001"");
	} else {
		PutIRC(""PRIVMSG "" + sRemoteNick + "" :\001DCC SEND "" + pFile->GetShortName() + "" "" + CString(CUtils::GetLongIP(GetLocalDCCIP())) + "" ""
			    + CString(uPort) + "" "" + CString(pFile->GetSize()) + ""\001"");
	}

	PutModule(sModuleName, ""DCC -> ["" + sRemoteNick + ""]["" + pFile->GetShortName() + ""] - Attempting Send."");
	return true;
}

bool CUser::GetFile(const CString& sRemoteNick, const CString& sRemoteIP, unsigned short uRemotePort, const CString& sFileName, unsigned long uFileSize, const CString& sModuleName) {
	if (CFile::Exists(sFileName)) {
		PutModule(sModuleName, ""DCC <- ["" + sRemoteNick + ""]["" + sFileName + ""] - File already exists."");
		return false;
	}

	CDCCSock* pSock = new CDCCSock(this, sRemoteNick, sRemoteIP, uRemotePort, sFileName, uFileSize, sModuleName);

	if (!pSock->OpenFile()) {
		delete pSock;
		return false;
	}

	if (!CZNC::Get().GetManager().Connect(sRemoteIP, uRemotePort, ""DCC::GET::"" + sRemoteNick, 60, false, GetLocalDCCIP(), pSock)) {
		PutModule(sModuleName, ""DCC <- ["" + sRemoteNick + ""]["" + sFileName + ""] - Unable to connect."");
		return false;
	}

	PutModule(sModuleName, ""DCC <- ["" + sRemoteNick + ""]["" + sFileName + ""] - Attempting to connect to ["" + sRemoteIP + ""]"");
	return true;
}

CString CUser::GetCurNick() const {
	const CIRCSock* pIRCSock = GetIRCSock();

	if (pIRCSock) {
		return pIRCSock->GetNick();
	}

	if (m_vClients.size()) {
		return m_vClients[0]->GetNick();
	}

	return """";
}

CString CUser::MakeCleanUserName(const CString& sUserName) {
	return sUserName.Token(0, false, ""@"").Replace_n(""."", """");
}

// Setters
void CUser::SetUserName(const CString& s) {
	m_sCleanUserName = CUser::MakeCleanUserName(s);
	m_sUserName = s;
}

bool CUser::IsChan(const CString& sChan) const {
	if (sChan.empty())
		return false; // There is no way this is a chan
	if (GetChanPrefixes().empty())
		return true; // We can't know, so we allow everything
	// Thanks to the above if (empty), we can do sChan[0]
	return GetChanPrefixes().find(sChan[0]) != CString::npos;
}

void CUser::SetNick(const CString& s) { m_sNick = s; }
void CUser::SetAltNick(const CString& s) { m_sAltNick = s; }
void CUser::SetIdent(const CString& s) { m_sIdent = s; }
void CUser::SetRealName(const CString& s) { m_sRealName = s; }
void CUser::SetVHost(const CString& s) { m_sVHost = s; }
void CUser::SetDCCVHost(const CString& s) { m_sDCCVHost = s; }
void CUser::SetPass(const CString& s, eHashType eHash, const CString& sSalt) {
	m_sPass = s;
	m_eHashType = eHash;
	m_sPassSalt = sSalt;
}
void CUser::SetMultiClients(bool b) { m_bMultiClients = b; }
void CUser::SetBounceDCCs(bool b) { m_bBounceDCCs = b; }
void CUser::SetUseClientIP(bool b) { m_bUseClientIP = b; }
void CUser::SetDenyLoadMod(bool b) { m_bDenyLoadMod = b; }
void CUser::SetAdmin(bool b) { m_bAdmin = b; }
void CUser::SetDenySetVHost(bool b) { m_bDenySetVHost = b; }
void CUser::SetDefaultChanModes(const CString& s) { m_sDefaultChanModes = s; }
void CUser::SetIRCServer(const CString& s) { m_sIRCServer = s; }
void CUser::SetQuitMsg(const CString& s) { m_sQuitMsg = s; }
void CUser::SetBufferCount(unsigned int u) { m_uBufferCount = u; }
void CUser::SetKeepBuffer(bool b) { m_bKeepBuffer = b; }

void CUser::CheckIRCConnect()
{
	// Do we want to connect?
	if (m_bIRCConnectEnabled && GetIRCSock() == NULL)
		CZNC::Get().EnableConnectUser();
}

void CUser::SetIRCNick(const CNick& n) {
	m_IRCNick = n;

	for (unsigned int a = 0; a < m_vClients.size(); a++) {
		m_vClients[a]->SetNick(n.GetNick());
	}
}

bool CUser::AddCTCPReply(const CString& sCTCP, const CString& sReply) {
	if (sCTCP.empty()) {
		return false;
	}

	m_mssCTCPReplies[sCTCP.AsUpper()] = sReply;
	return true;
}

bool CUser::SetStatusPrefix(const CString& s) {
	if ((!s.empty()) && (s.length() < 6) && (s.find(' ') == CString::npos)) {
		m_sStatusPrefix = (s.empty()) ? ""*"" : s;
		return true;
	}

	return false;
}
// !Setters

// Getters
const CString& CUser::GetUserName() const { return m_sUserName; }
const CString& CUser::GetCleanUserName() const { return m_sCleanUserName; }
const CString& CUser::GetNick(bool bAllowDefault) const { return (bAllowDefault && m_sNick.empty()) ? GetCleanUserName() : m_sNick; }
const CString& CUser::GetAltNick(bool bAllowDefault) const { return (bAllowDefault && m_sAltNick.empty()) ? GetCleanUserName() : m_sAltNick; }
const CString& CUser::GetIdent(bool bAllowDefault) const { return (bAllowDefault && m_sIdent.empty()) ? GetCleanUserName() : m_sIdent; }
const CString& CUser::GetRealName() const { return m_sRealName.empty() ? m_sUserName : m_sRealName; }
const CString& CUser::GetVHost() const { return m_sVHost; }
const CString& CUser::GetDCCVHost() const { return m_sDCCVHost; }
const CString& CUser::GetPass() const { return m_sPass; }
CUser::eHashType CUser::GetPassHashType() const { return m_eHashType; }
const CString& CUser::GetPassSalt() const { return m_sPassSalt; }

bool CUser::ConnectPaused() {
	if (!m_uConnectTime) {
		m_uConnectTime = time(NULL);
		return false;
	}

	if (time(NULL) - m_uConnectTime >= 5) {
		m_uConnectTime = time(NULL);
		return false;
	}

	return true;
}

bool CUser::UseClientIP() const { return m_bUseClientIP; }
bool CUser::DenyLoadMod() const { return m_bDenyLoadMod; }
bool CUser::IsAdmin() const { return m_bAdmin; }
bool CUser::DenySetVHost() const { return m_bDenySetVHost; }
bool CUser::MultiClients() const { return m_bMultiClients; }
bool CUser::BounceDCCs() const { return m_bBounceDCCs; }
const CString& CUser::GetStatusPrefix() const { return m_sStatusPrefix; }
const CString& CUser::GetDefaultChanModes() const { return m_sDefaultChanModes; }
const vector<CChan*>& CUser::GetChans() const { return m_vChans; }
const vector<CServer*>& CUser::GetServers() const { return m_vServers; }
const CNick& CUser::GetIRCNick() const { return m_IRCNick; }
const CString& CUser::GetIRCServer() const { return m_sIRCServer; }
CString CUser::GetQuitMsg() const { return (!m_sQuitMsg.empty()) ? m_sQuitMsg : CZNC::GetTag(false); }
const MCString& CUser::GetCTCPReplies() const { return m_mssCTCPReplies; }
unsigned int CUser::GetBufferCount() const { return m_uBufferCount; }
bool CUser::KeepBuffer() const { return m_bKeepBuffer; }
// !Getters
""",CUser::DelServer,[765:816]
znc,https://github.com/znc/znc/commit/70e46ac1748069a95f77e96df88724e8cb7bf2c7,"""Improved perform module description.


git-svn-id: https://znc.svn.sourceforge.net/svnroot/znc/trunk@1989 726aef4b-f618-498e-8847-2d620e286838""","""/*
 * Copyright (C) 2004-2010  See the AUTHORS file for details.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 as published
 * by the Free Software Foundation.
 */

#include ""User.h""
#include <algorithm>

class CPerform : public CModule {
public:
	MODCONSTRUCTOR(CPerform) {}

	virtual ~CPerform() {}

	virtual bool OnLoad(const CString& sArgs, CString& sMessage) {
		GetNV(""Perform"").Split(""\n"", m_vPerform, false);

		return true;
	}

	virtual void OnModCommand(const CString& sCommand) {
		CString sCmdName = sCommand.Token(0).AsLower();
		if (sCmdName == ""add"") {
			CString sPerf = sCommand.Token(1, true);

			if (sPerf.empty()) {
				PutModule(""Usage: add <command>"");
				return;
			}

			if (sPerf.Left(1) == ""/"")
				sPerf.LeftChomp();

			if (sPerf.Token(0).Equals(""MSG"")) {
				sPerf = ""PRIVMSG "" + sPerf.Token(1, true);
			}

			if ((sPerf.Token(0).Equals(""PRIVMSG"") ||
				sPerf.Token(0).Equals(""NOTICE"")) &&
				sPerf.Token(2).Left(1) != "":"") {
				sPerf = sPerf.Token(0) + "" "" + sPerf.Token(1)
					+ "" :"" + sPerf.Token(2, true);
			}
			m_vPerform.push_back(sPerf);
			PutModule(""Added!"");
			Save();
		} else if (sCmdName == ""del"") {
			u_int iNum = sCommand.Token(1, true).ToUInt();
			if (iNum > m_vPerform.size() || iNum <= 0) {
				PutModule(""Illegal # Requested"");
				return;
			} else {
				m_vPerform.erase(m_vPerform.begin() + iNum - 1);
				PutModule(""Command Erased."");
			}
			Save();
		} else if (sCmdName == ""list"") {
			int i = 1;
			CString sExpanded;
			for (VCString::iterator it = m_vPerform.begin(); it != m_vPerform.end(); it++, i++) {
				sExpanded = GetUser()->ExpandString(*it);
				if (sExpanded != *it)
					PutModule(CString(i) + "": "" + *it + "" ("" + sExpanded + "")"");
				else
					PutModule(CString(i) + "": "" + *it);
			}
			PutModule("" -- End of List"");
		} else if (sCmdName == ""execute"") {
			OnIRCConnected();
			PutModule(""perform commands sent"");
		} else if (sCmdName == ""swap"") {
			u_int iNumA = sCommand.Token(1).ToUInt();
			u_int iNumB = sCommand.Token(2).ToUInt();

			if (iNumA > m_vPerform.size() || iNumA <= 0 || iNumB > m_vPerform.size() || iNumB <= 0) {
				PutModule(""Illegal # Requested"");
			} else {
				std::iter_swap(m_vPerform.begin() + (iNumA - 1), m_vPerform.begin() + (iNumB - 1));
				PutModule(""Commands Swapped."");
				Save();
			}
		} else {
			PutModule(""Commands: add <command>, del <nr>, list, execute, swap <nr> <nr>"");
		}
	}

	virtual void OnIRCConnected() {
		for (VCString::iterator it = m_vPerform.begin();
			it != m_vPerform.end();  ++it) {
			PutIRC(GetUser()->ExpandString(*it));
		}
	}

private:
	bool Save() {
		CString sBuffer = """";

		for (VCString::iterator it = m_vPerform.begin(); it != m_vPerform.end(); ++it) {
			sBuffer += *it + ""\n"";
		}
		SetNV(""Perform"", sBuffer);

		return true;
	}

	VCString m_vPerform;
};

MODULEDEFS(CPerform, ""Adds perform capabilities"")
""","""/*
 * Copyright (C) 2004-2010  See the AUTHORS file for details.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 as published
 * by the Free Software Foundation.
 */

#include ""User.h""
#include <algorithm>

class CPerform : public CModule {
public:
	MODCONSTRUCTOR(CPerform) {}

	virtual ~CPerform() {}

	virtual bool OnLoad(const CString& sArgs, CString& sMessage) {
		GetNV(""Perform"").Split(""\n"", m_vPerform, false);

		return true;
	}

	virtual void OnModCommand(const CString& sCommand) {
		CString sCmdName = sCommand.Token(0).AsLower();
		if (sCmdName == ""add"") {
			CString sPerf = sCommand.Token(1, true);

			if (sPerf.empty()) {
				PutModule(""Usage: add <command>"");
				return;
			}

			if (sPerf.Left(1) == ""/"")
				sPerf.LeftChomp();

			if (sPerf.Token(0).Equals(""MSG"")) {
				sPerf = ""PRIVMSG "" + sPerf.Token(1, true);
			}

			if ((sPerf.Token(0).Equals(""PRIVMSG"") ||
				sPerf.Token(0).Equals(""NOTICE"")) &&
				sPerf.Token(2).Left(1) != "":"") {
				sPerf = sPerf.Token(0) + "" "" + sPerf.Token(1)
					+ "" :"" + sPerf.Token(2, true);
			}
			m_vPerform.push_back(sPerf);
			PutModule(""Added!"");
			Save();
		} else if (sCmdName == ""del"") {
			u_int iNum = sCommand.Token(1, true).ToUInt();
			if (iNum > m_vPerform.size() || iNum <= 0) {
				PutModule(""Illegal # Requested"");
				return;
			} else {
				m_vPerform.erase(m_vPerform.begin() + iNum - 1);
				PutModule(""Command Erased."");
			}
			Save();
		} else if (sCmdName == ""list"") {
			int i = 1;
			CString sExpanded;
			for (VCString::iterator it = m_vPerform.begin(); it != m_vPerform.end(); it++, i++) {
				sExpanded = GetUser()->ExpandString(*it);
				if (sExpanded != *it)
					PutModule(CString(i) + "": "" + *it + "" ("" + sExpanded + "")"");
				else
					PutModule(CString(i) + "": "" + *it);
			}
			PutModule("" -- End of List"");
		} else if (sCmdName == ""execute"") {
			OnIRCConnected();
			PutModule(""perform commands sent"");
		} else if (sCmdName == ""swap"") {
			u_int iNumA = sCommand.Token(1).ToUInt();
			u_int iNumB = sCommand.Token(2).ToUInt();

			if (iNumA > m_vPerform.size() || iNumA <= 0 || iNumB > m_vPerform.size() || iNumB <= 0) {
				PutModule(""Illegal # Requested"");
			} else {
				std::iter_swap(m_vPerform.begin() + (iNumA - 1), m_vPerform.begin() + (iNumB - 1));
				PutModule(""Commands Swapped."");
				Save();
			}
		} else {
			PutModule(""Commands: add <command>, del <nr>, list, execute, swap <nr> <nr>"");
		}
	}

	virtual void OnIRCConnected() {
		for (VCString::iterator it = m_vPerform.begin();
			it != m_vPerform.end();  ++it) {
			PutIRC(GetUser()->ExpandString(*it));
		}
	}

private:
	bool Save() {
		CString sBuffer = """";

		for (VCString::iterator it = m_vPerform.begin(); it != m_vPerform.end(); ++it) {
			sBuffer += *it + ""\n"";
		}
		SetNV(""Perform"", sBuffer);

		return true;
	}

	VCString m_vPerform;
};

MODULEDEFS(CPerform, ""Keeps a list of commands to be executed when ZNC connects to IRC."")
""",,
znc,https://github.com/znc/znc/commit/e5ecd9c944d7f75e3f8ac50e200c9e72720bbe8b,"""Micro optimization

Only call GetUser() when we actually need the result


git-svn-id: https://znc.svn.sourceforge.net/svnroot/znc/trunk@2028 726aef4b-f618-498e-8847-2d620e286838""","""/*
 * Copyright (C) 2004-2010  See the AUTHORS file for details.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 as published
 * by the Free Software Foundation.
 */

#include ""Client.h""
#include ""Chan.h""
#include ""DCCBounce.h""
#include ""IRCSock.h""
#include ""User.h""
#include ""znc.h""
#include ""WebModules.h""

#define CALLMOD(MOD, CLIENT, USER, FUNC) {                                      \
	CModule* pModule = CZNC::Get().GetModules().FindModule(MOD);            \
	if (pModule) {                                                          \
		try {                                                           \
			pModule->SetClient(CLIENT);                             \
			pModule->SetUser(USER);                                 \
			pModule->FUNC;                                          \
			pModule->SetClient(NULL);                               \
			pModule->SetUser(NULL);                                 \
		} catch (CModule::EModException e) {                            \
			if (e == CModule::UNLOAD) {                             \
				CZNC::Get().GetModules().UnloadModule(MOD);     \
			}                                                       \
		}                                                               \
	} else {                                                                \
		pModule = (USER)->GetModules().FindModule(MOD);                 \
		if (pModule) {                                                  \
			try {                                                   \
				pModule->SetClient(CLIENT);                     \
				pModule->FUNC;                                  \
				pModule->SetClient(NULL);                       \
			} catch (CModule::EModException e) {                    \
				if (e == CModule::UNLOAD) {                     \
					(USER)->GetModules().UnloadModule(MOD); \
				}                                               \
			}                                                       \
		} else {                                                        \
			PutStatus(""No such module ["" + MOD + ""]"");              \
		}                                                               \
	}                                                                       \
}

CClient::~CClient() {
	if (!m_spAuth.IsNull()) {
		CClientAuth* pAuth = (CClientAuth*) &(*m_spAuth);
		pAuth->Invalidate();
	}
	if (m_pUser != NULL) {
		m_pUser->AddBytesRead(GetBytesRead());
		m_pUser->AddBytesWritten(GetBytesWritten());
	}
}

void CClient::ReadLine(const CString& sData) {
	CString sLine = sData;

	sLine.TrimRight(""\n\r"");

	DEBUG(""("" << ((m_pUser) ? m_pUser->GetUserName() : GetRemoteIP()) << "") CLI -> ZNC ["" << sLine << ""]"");

	if (IsAttached()) {
		MODULECALL(OnUserRaw(sLine), m_pUser, this, return);
	} else {
		if (CZNC::Get().GetModules().OnUnknownUserRaw(this, sLine)) {
			return;
		}
	}

	CString sCommand = sLine.Token(0);
	if (sCommand.Left(1) == "":"") {
		// Evil client! Sending a nickmask prefix on client's command
		// is bad, bad, bad, bad, bad, bad, bad, bad, BAD, B A D!
		sLine = sLine.Token(1, true);
		sCommand = sLine.Token(0);
	}

	if (sCommand.Equals(""PASS"")) {
		if (!IsAttached()) {
			m_bGotPass = true;
			m_sPass = sLine.Token(1);
			if (m_sPass.Left(1) == "":"")
				m_sPass.LeftChomp();

			if (m_sPass.find("":"") != CString::npos) {
				m_sUser = m_sPass.Token(0, false, "":"");
				m_sPass = m_sPass.Token(1, true, "":"");
			}

			AuthUser();
			return;  // Don't forward this msg.  ZNC has already registered us.
		}
	} else if (sCommand.Equals(""NICK"")) {
		CString sNick = sLine.Token(1);
		if (sNick.Left(1) == "":"") {
			sNick.LeftChomp();
		}

		if (!IsAttached()) {
			m_sNick = sNick;
			m_bGotNick = true;

			AuthUser();
			return;  // Don't forward this msg.  ZNC will handle nick changes until auth is complete
		}
	} else if (sCommand.Equals(""USER"")) {
		if (!IsAttached()) {
			if (m_sUser.empty()) {
				m_sUser = sLine.Token(1);
			}

			m_bGotUser = true;

			if (m_bGotPass) {
				AuthUser();
			} else {
				PutClient("":irc.znc.in NOTICE AUTH :*** ""
					""You need to send your password. ""
					""Try /quote PASS <username>:<password>"");
			}

			return;  // Don't forward this msg.  ZNC has already registered us.
		}
	} else if (sCommand.Equals(""CAP"")) {
		HandleCap(sLine);

		// Don't let the client talk to the server directly about CAP,
		// we don't want anything enabled that znc does not support.
		return;
	}

	if (!m_pUser) {
		// Only CAP, NICK, USER and PASS are allowed before login
		return;
	}

	if (sCommand.Equals(""ZNC"")) {
		CString sTarget = sLine.Token(1);
		CString sModCommand;

		if (sTarget.TrimPrefix(m_pUser->GetStatusPrefix())) {
			sModCommand = sLine.Token(2, true);
		} else {
			sTarget  = ""status"";
			sModCommand = sLine.Token(1, true);
		}

		if (sTarget.Equals(""status"")) {
			if (sModCommand.empty())
				PutStatus(""Hello. How may I help you?"");
			else
				UserCommand(sModCommand);
		} else {
			if (sModCommand.empty())
				CALLMOD(sTarget, this, m_pUser, PutModule(""Hello. How may I help you?""))
			else
				CALLMOD(sTarget, this, m_pUser, OnModCommand(sModCommand))
		}
		return;
	} else if (sCommand.Equals(""DETACH"")) {
		CString sChan = sLine.Token(1);

		if (sChan.empty()) {
			PutStatusNotice(""Usage: /detach <#chan>"");
			return;
		}

		CChan* pChan = m_pUser->FindChan(sChan);
		if (!pChan) {
			PutStatusNotice(""You are not on ["" + sChan + ""]"");
			return;
		}

		pChan->DetachUser();
		PutStatusNotice(""Detached from ["" + sChan + ""]"");
		return;
	} else if (sCommand.Equals(""PING"")) {
		CString sTarget = sLine.Token(1);

		// If the client meant to ping us or we can be sure the server
		// won't answer the ping (=no server connected) -> PONG back.
		// else: It's the server's job to send a PONG.
		if (sTarget.Equals(""irc.znc.in"") || !GetIRCSock()) {
			PutClient(""PONG "" + sLine.substr(5));
			return;
		}
	} else if (sCommand.Equals(""PONG"")) {
		return;  // Block pong replies, we already responded to the pings
	} else if (sCommand.Equals(""JOIN"")) {
		CString sChans = sLine.Token(1);
		CString sKey = sLine.Token(2);

		if (sChans.Left(1) == "":"") {
			sChans.LeftChomp();
		}

		VCString vChans;
		sChans.Split("","", vChans, false);
		sChans.clear();

		for (unsigned int a = 0; a < vChans.size(); a++) {
			CString sChannel = vChans[a];
			MODULECALL(OnUserJoin(sChannel, sKey), m_pUser, this, continue);

			CChan* pChan = m_pUser->FindChan(sChannel);

			if (pChan) {
				pChan->JoinUser(false, sKey);
				continue;
			}

			if (!sChannel.empty()) {
				sChans += (sChans.empty()) ? sChannel : CString("","" + sChannel);
			}
		}

		if (sChans.empty()) {
			return;
		}

		sLine = ""JOIN "" + sChans;

		if (!sKey.empty()) {
			sLine += "" "" + sKey;
		}
	} else if (sCommand.Equals(""PART"")) {
		CString sChan = sLine.Token(1);
		CString sMessage = sLine.Token(2, true);

		if (sChan.Left(1) == "":"") {
			// I hate those broken clients, I hate them so much, I really hate them...
			sChan.LeftChomp();
		}
		if (sMessage.Left(1) == "":"") {
			sMessage.LeftChomp();
		}

		MODULECALL(OnUserPart(sChan, sMessage), m_pUser, this, return);

		CChan* pChan = m_pUser->FindChan(sChan);

		if (pChan && !pChan->IsOn()) {
			PutStatusNotice(""Removing channel ["" + sChan + ""]"");
			m_pUser->DelChan(sChan);
			return;
		}

		sLine = ""PART "" + sChan;

		if (!sMessage.empty()) {
			sLine += "" :"" + sMessage;
		}
	} else if (sCommand.Equals(""TOPIC"")) {
		CString sChan = sLine.Token(1);
		CString sTopic = sLine.Token(2, true);

		if (!sTopic.empty()) {
			if (sTopic.Left(1) == "":"")
				sTopic.LeftChomp();
			MODULECALL(OnUserTopic(sChan, sTopic), m_pUser, this, return);
			sLine = ""TOPIC "" + sChan + "" :"" + sTopic;
		} else {
			MODULECALL(OnUserTopicRequest(sChan), m_pUser, this, return);
		}
	} else if (sCommand.Equals(""MODE"")) {
		CString sTarget = sLine.Token(1);
		CString sModes = sLine.Token(2, true);

		if (m_pUser->IsChan(sTarget)) {
			CChan *pChan = m_pUser->FindChan(sTarget);

			// If we are on that channel and already received a
			// /mode reply from the server, we can answer this
			// request ourself.
			if (pChan && pChan->IsOn() && sModes.empty() && !pChan->GetModeString().empty()) {
				PutClient("":"" + m_pUser->GetIRCServer() + "" 324 "" + GetNick() + "" "" + sTarget + "" "" + pChan->GetModeString());
				if (pChan->GetCreationDate() > 0) {
					PutClient("":"" + m_pUser->GetIRCServer() + "" 329 "" + GetNick() + "" "" + sTarget + "" "" + CString(pChan->GetCreationDate()));
				}
				return;
			}
		}
	} else if (sCommand.Equals(""QUIT"")) {
		m_pUser->UserDisconnected(this);

		Close(Csock::CLT_AFTERWRITE); // Treat a client quit as a detach
		return;                       // Don't forward this msg.  We don't want the client getting us disconnected.
	} else if (sCommand.Equals(""PROTOCTL"")) {
		VCString vsTokens;
		VCString::const_iterator it;
		sLine.Token(1, true).Split("" "", vsTokens, false);

		for (it = vsTokens.begin(); it != vsTokens.end(); ++it) {
			if (*it == ""NAMESX"") {
				m_bNamesx = true;
			} else if (*it == ""UHNAMES"") {
				m_bUHNames = true;
			}
		}
		return;  // If the server understands it, we already enabled namesx / uhnames
	} else if (sCommand.Equals(""NOTICE"")) {
		CString sTarget = sLine.Token(1);
		CString sMsg = sLine.Token(2, true);

		if (sMsg.Left(1) == "":"") {
			sMsg.LeftChomp();
		}

		if (sTarget.TrimPrefix(m_pUser->GetStatusPrefix())) {
			if (!sTarget.Equals(""status"")) {
				CALLMOD(sTarget, this, m_pUser, OnModNotice(sMsg));
			}
			return;
		}

		// No idea what this is supposed to do, but it doesn't seem to
		// make sense. Comment this out and wait for complaints.
#if 0
		if (sMsg.WildCmp(""DCC * (*)"")) {
			sMsg = ""DCC "" + sLine.Token(3) + "" ("" + ((GetIRCSock()) ? GetIRCSock()->GetLocalIP() : GetLocalIP()) + "")"";
		}
#endif

		if (sMsg.WildCmp(""\001*\001"")) {
			CString sCTCP = sMsg;
			sCTCP.LeftChomp();
			sCTCP.RightChomp();

			MODULECALL(OnUserCTCPReply(sTarget, sCTCP), m_pUser, this, return);

			sMsg = ""\001"" + sCTCP + ""\001"";
		} else {
			MODULECALL(OnUserNotice(sTarget, sMsg), m_pUser, this, return);
		}

		if (!GetIRCSock()) {
			// Some lagmeters do a NOTICE to their own nick, ignore those.
			if (!sTarget.Equals(m_sNick))
				PutStatus(""Your notice to ["" + sTarget + ""] got lost, ""
						""you are not connected to IRC!"");
			return;
		}

		CChan* pChan = m_pUser->FindChan(sTarget);

		if ((pChan) && (pChan->KeepBuffer())) {
			pChan->AddBuffer("":"" + GetNickMask() + "" NOTICE "" + sTarget + "" :"" + m_pUser->AddTimestamp(sMsg));
		}

		// Relay to the rest of the clients that may be connected to this user
		if (m_pUser->IsChan(sTarget)) {
			vector<CClient*>& vClients = m_pUser->GetClients();

			for (unsigned int a = 0; a < vClients.size(); a++) {
				CClient* pClient = vClients[a];

				if (pClient != this) {
					pClient->PutClient("":"" + GetNickMask() + "" NOTICE "" + sTarget + "" :"" + sMsg);
				}
			}
		}

		PutIRC(""NOTICE "" + sTarget + "" :"" + sMsg);
		return;
	} else if (sCommand.Equals(""PRIVMSG"")) {
		CString sTarget = sLine.Token(1);
		CString sMsg = sLine.Token(2, true);

		if (sMsg.Left(1) == "":"") {
			sMsg.LeftChomp();
		}

		if (sMsg.WildCmp(""\001*\001"")) {
			CString sCTCP = sMsg;
			sCTCP.LeftChomp();
			sCTCP.RightChomp();

			if (sCTCP.Equals(""DCC "", false, 4) && m_pUser->BounceDCCs()) {
				CString sType = sCTCP.Token(1);
				CString sFile = sCTCP.Token(2);
				unsigned long uLongIP = sCTCP.Token(3).ToULong();
				unsigned short uPort = sCTCP.Token(4).ToUShort();
				unsigned long uFileSize = sCTCP.Token(5).ToULong();
				CString sIP = m_pUser->GetLocalDCCIP();

				if (!m_pUser->UseClientIP()) {
					uLongIP = CUtils::GetLongIP(GetRemoteIP());
				}

				if (sType.Equals(""CHAT"")) {
					if (!sTarget.TrimPrefix(m_pUser->GetStatusPrefix())) {
						unsigned short uBNCPort = CDCCBounce::DCCRequest(sTarget, uLongIP, uPort, """", true, m_pUser, """");
						if (uBNCPort) {
							PutIRC(""PRIVMSG "" + sTarget + "" :\001DCC CHAT chat "" + CString(CUtils::GetLongIP(sIP)) + "" "" + CString(uBNCPort) + ""\001"");
						}
					}
				} else if (sType.Equals(""SEND"")) {
					// DCC SEND readme.txt 403120438 5550 1104

					if (sTarget.TrimPrefix(m_pUser->GetStatusPrefix())) {
						if (sTarget.Equals(""status"")) {
							CString sPath = m_pUser->GetDLPath();
							if (!CFile::Exists(sPath)) {
								PutStatus(""Could not create ["" + sPath + ""] directory."");
								return;
							} else if (!CFile::IsDir(sPath)) {
								PutStatus(""Error: ["" + sPath + ""] is not a directory."");
								return;
							}

							CString sAbsolutePath = CDir::CheckPathPrefix(sPath, sFile);

							if (sAbsolutePath.empty()) {
								PutStatus(""Illegal path."");
								return;
							}

							m_pUser->GetFile(GetNick(), CUtils::GetIP(uLongIP), uPort, sAbsolutePath, uFileSize);
						} else {
							MODULECALL(OnDCCUserSend(CString(m_pUser->GetStatusPrefix() + sTarget), uLongIP, uPort, sFile, uFileSize), m_pUser, this, return);
						}
					} else {
						unsigned short uBNCPort = CDCCBounce::DCCRequest(sTarget, uLongIP, uPort, sFile, false, m_pUser, """");
						if (uBNCPort) {
							PutIRC(""PRIVMSG "" + sTarget + "" :\001DCC SEND "" + sFile + "" "" + CString(CUtils::GetLongIP(sIP)) + "" "" + CString(uBNCPort) + "" "" + CString(uFileSize) + ""\001"");
						}
					}
				} else if (sType.Equals(""RESUME"")) {
					// PRIVMSG user :DCC RESUME ""znc.o"" 58810 151552
					unsigned short uResumePort = sCTCP.Token(3).ToUShort();
					unsigned long uResumeSize = sCTCP.Token(4).ToULong();

					// Need to lookup the connection by port, filter the port, and forward to the user
					CString sStatusPrefix = m_pUser->GetStatusPrefix();
					if (sTarget.Equals(sStatusPrefix, false, sStatusPrefix.length())) {
						if (m_pUser->ResumeFile(uResumePort, uResumeSize)) {
							PutClient("":"" + sTarget + ""!znc@znc.in PRIVMSG "" + GetNick() + "" :\001DCC ACCEPT "" + sFile + "" "" + CString(uResumePort) + "" "" + CString(uResumeSize) + ""\001"");
						} else {
							PutStatus(""DCC -> ["" + GetNick() + ""]["" + sFile + ""] Unable to find send to initiate resume."");
						}
					} else {
						CDCCBounce* pSock = (CDCCBounce*) CZNC::Get().GetManager().FindSockByLocalPort(uResumePort);
						if (pSock && pSock->GetSockName().Equals(""DCC::"", false, 5)) {
							PutIRC(""PRIVMSG "" + sTarget + "" :\001DCC "" + sType + "" "" + sFile + "" "" + CString(pSock->GetUserPort()) + "" "" + sCTCP.Token(4) + ""\001"");
						}
					}
				} else if (sType.Equals(""ACCEPT"")) {
					CString sStatusPrefix = m_pUser->GetStatusPrefix();
					if (!sTarget.Equals(sStatusPrefix, false, sStatusPrefix.length())) {
						// Need to lookup the connection by port, filter the port, and forward to the user
						CSockManager& Manager = CZNC::Get().GetManager();

						for (unsigned int a = 0; a < Manager.size(); a++) {
							CDCCBounce* pSock = (CDCCBounce*) Manager[a];

							if (pSock && pSock->GetSockName().Equals(""DCC::"", false, 5)) {
								if (pSock->GetUserPort() == sCTCP.Token(3).ToUShort()) {
									PutIRC(""PRIVMSG "" + sTarget + "" :\001DCC "" + sType + "" "" + sFile + "" "" + CString(pSock->GetLocalPort()) + "" "" + sCTCP.Token(4) + ""\001"");
								}
							}
						}
					}
				}

				return;
			}

			if (sTarget.TrimPrefix(m_pUser->GetStatusPrefix())) {
				if (sTarget.Equals(""status"")) {
					StatusCTCP(sCTCP);
				} else {
					CALLMOD(sTarget, this, m_pUser, OnModCTCP(sCTCP));
				}
				return;
			}

			CChan* pChan = m_pUser->FindChan(sTarget);

			if (sCTCP.Token(0).Equals(""ACTION"")) {
				CString sMessage = sCTCP.Token(1, true);
				MODULECALL(OnUserAction(sTarget, sMessage), m_pUser, this, return);
				sCTCP = ""ACTION "" + sMessage;

				if (pChan && pChan->KeepBuffer()) {
					pChan->AddBuffer("":"" + GetNickMask() + "" PRIVMSG "" + sTarget + "" :\001ACTION "" + m_pUser->AddTimestamp(sMessage) + ""\001"");
				}

				// Relay to the rest of the clients that may be connected to this user
				if (m_pUser->IsChan(sTarget)) {
					vector<CClient*>& vClients = m_pUser->GetClients();

					for (unsigned int a = 0; a < vClients.size(); a++) {
						CClient* pClient = vClients[a];

						if (pClient != this) {
							pClient->PutClient("":"" + GetNickMask() + "" PRIVMSG "" + sTarget + "" :\001"" + sCTCP + ""\001"");
						}
					}
				}
			} else {
				MODULECALL(OnUserCTCP(sTarget, sCTCP), m_pUser, this, return);
			}

			PutIRC(""PRIVMSG "" + sTarget + "" :\001"" + sCTCP + ""\001"");
			return;
		}

		if (sTarget.TrimPrefix(m_pUser->GetStatusPrefix())) {
			if (sTarget.Equals(""status"")) {
				UserCommand(sMsg);
			} else {
				CALLMOD(sTarget, this, m_pUser, OnModCommand(sMsg));
			}
			return;
		}

		MODULECALL(OnUserMsg(sTarget, sMsg), m_pUser, this, return);

		if (!GetIRCSock()) {
			// Some lagmeters do a PRIVMSG to their own nick, ignore those.
			if (!sTarget.Equals(m_sNick))
				PutStatus(""Your message to ["" + sTarget + ""] got lost, ""
						""you are not connected to IRC!"");
			return;
		}

		CChan* pChan = m_pUser->FindChan(sTarget);

		if ((pChan) && (pChan->KeepBuffer())) {
			pChan->AddBuffer("":"" + GetNickMask() + "" PRIVMSG "" + sTarget + "" :"" + m_pUser->AddTimestamp(sMsg));
		}

		PutIRC(""PRIVMSG "" + sTarget + "" :"" + sMsg);

		// Relay to the rest of the clients that may be connected to this user

		if (m_pUser->IsChan(sTarget)) {
			vector<CClient*>& vClients = m_pUser->GetClients();

			for (unsigned int a = 0; a < vClients.size(); a++) {
				CClient* pClient = vClients[a];

				if (pClient != this) {
					pClient->PutClient("":"" + GetNickMask() + "" PRIVMSG "" + sTarget + "" :"" + sMsg);
				}
			}
		}

		return;
	}

	PutIRC(sLine);
}

void CClient::SetNick(const CString& s) {
	m_sNick = s;
}

const CIRCSock* CClient::GetIRCSock() const {
	return m_pUser->GetIRCSock();
}

CIRCSock* CClient::GetIRCSock() {
	return m_pUser->GetIRCSock();
}

void CClient::StatusCTCP(const CString& sLine) {
	CString sCommand = sLine.Token(0);

	if (sCommand.Equals(""PING"")) {
		PutStatusNotice(""\001PING "" + sLine.Token(1, true) + ""\001"");
	} else if (sCommand.Equals(""VERSION"")) {
		PutStatusNotice(""\001VERSION "" + CZNC::GetTag() + ""\001"");
	}
}

bool CClient::SendMotd() {
	const VCString& vsMotd = CZNC::Get().GetMotd();

	if (!vsMotd.size()) {
		return false;
	}

	for (unsigned int a = 0; a < vsMotd.size(); a++) {
		PutStatusNotice(m_pUser->ExpandString(vsMotd[a]));
	}

	return true;
}

void CClient::AuthUser() {
	if (!m_bGotNick || !m_bGotUser || m_bInCap || IsAttached())
		return;

	m_spAuth = new CClientAuth(this, m_sUser, m_sPass);

	CZNC::Get().AuthUser(m_spAuth);
}

CClientAuth::CClientAuth(CClient* pClient, const CString& sUsername, const CString& sPassword)
		: CAuthBase(sUsername, sPassword, pClient) {
	m_pClient = pClient;
}

void CClientAuth::RefusedLogin(const CString& sReason) {
	if (m_pClient) {
		m_pClient->RefuseLogin(sReason);
	}
}

CString CAuthBase::GetRemoteIP() const {
	if (m_pSock)
		return m_pSock->GetRemoteIP();
	return """";
}

void CAuthBase::Invalidate() {
	m_pSock = NULL;
}

void CAuthBase::AcceptLogin(CUser& User) {
	if (m_pSock) {
		AcceptedLogin(User);
		Invalidate();
	}
}

void CAuthBase::RefuseLogin(const CString& sReason) {
	CUser* pUser = CZNC::Get().GetUser(GetUsername());

	if (!m_pSock)
		return;

	// If the username is valid, notify that user that someone tried to
	// login. Use sReason because there are other reasons than ""wrong
	// password"" for a login to be rejected (e.g. fail2ban).
	if (pUser) {
		pUser->PutStatus(""A client from ["" + GetRemoteIP() + ""] attempted ""
				""to login as you, but was rejected ["" + sReason + ""]."");
	}

	CZNC::Get().GetModules().OnFailedLogin(GetUsername(), GetRemoteIP());
	RefusedLogin(sReason);
	Invalidate();
}

void CClient::RefuseLogin(const CString& sReason) {
	PutStatus(""Bad username and/or password."");
	PutClient("":irc.znc.in 464 "" + GetNick() + "" :"" + sReason);
	Close(Csock::CLT_AFTERWRITE);
}

void CClientAuth::AcceptedLogin(CUser& User) {
	if (m_pClient) {
		m_pClient->AcceptLogin(User);
	}
}

void CClient::AcceptLogin(CUser& User) {
	m_sPass = """";
	m_pUser = &User;

	// Set our proper timeout and set back our proper timeout mode
	// (constructor set a different timeout and mode)
	SetTimeout(240, TMO_READ);

	SetSockName(""USR::"" + m_pUser->GetUserName());

	m_pUser->UserConnected(this);

	SendMotd();

	MODULECALL(OnClientLogin(), m_pUser, this, );
}

void CClient::Timeout() {
	PutClient(""ERROR :Closing link [Timeout]"");
}

void CClient::Connected() {
	DEBUG(GetSockName() << "" == Connected();"");
}

void CClient::ConnectionRefused() {
	DEBUG(GetSockName() << "" == ConnectionRefused()"");
}

void CClient::Disconnected() {
	DEBUG(GetSockName() << "" == Disconnected()"");
	if (m_pUser) {
		m_pUser->UserDisconnected(this);
	}

	MODULECALL(OnClientDisconnect(), m_pUser, this, );
}

void CClient::ReachedMaxBuffer() {
	DEBUG(GetSockName() << "" == ReachedMaxBuffer()"");
	if (IsAttached()) {
		PutClient(""ERROR :Closing link [Too long raw line]"");
	}
	Close();
}

void CClient::BouncedOff() {
	PutStatusNotice(""You are being disconnected because another user just authenticated as you."");
	Close(Csock::CLT_AFTERWRITE);
}

void CClient::PutIRC(const CString& sLine) {
	m_pUser->PutIRC(sLine);
}

void CClient::PutClient(const CString& sLine) {
	DEBUG(""("" << ((m_pUser) ? m_pUser->GetUserName() : GetRemoteIP()) << "") ZNC -> CLI ["" << sLine << ""]"");
	Write(sLine + ""\r\n"");
}

void CClient::PutStatusNotice(const CString& sLine) {
	PutModNotice(""status"", sLine);
}

unsigned int CClient::PutStatus(const CTable& table) {
	unsigned int idx = 0;
	CString sLine;
	while (table.GetLine(idx++, sLine))
		PutStatus(sLine);
	return idx - 1;
}

void CClient::PutStatus(const CString& sLine) {
	PutModule(""status"", sLine);
}

void CClient::PutModNotice(const CString& sModule, const CString& sLine) {
	if (!m_pUser) {
		return;
	}

	DEBUG(""("" << m_pUser->GetUserName() << "") ZNC -> CLI [:"" + m_pUser->GetStatusPrefix() + ((sModule.empty()) ? ""status"" : sModule) + ""!znc@znc.in NOTICE "" << GetNick() << "" :"" << sLine << ""]"");
	Write("":"" + m_pUser->GetStatusPrefix() + ((sModule.empty()) ? ""status"" : sModule) + ""!znc@znc.in NOTICE "" + GetNick() + "" :"" + sLine + ""\r\n"");
}

void CClient::PutModule(const CString& sModule, const CString& sLine) {
	if (!m_pUser) {
		return;
	}

	DEBUG(""("" << m_pUser->GetUserName() << "") ZNC -> CLI [:"" + m_pUser->GetStatusPrefix() + ((sModule.empty()) ? ""status"" : sModule) + ""!znc@znc.in PRIVMSG "" << GetNick() << "" :"" << sLine << ""]"");
	Write("":"" + m_pUser->GetStatusPrefix() + ((sModule.empty()) ? ""status"" : sModule) + ""!znc@znc.in PRIVMSG "" + GetNick() + "" :"" + sLine + ""\r\n"");
}

CString CClient::GetNick(bool bAllowIRCNick) const {
	CString sRet;

	if ((bAllowIRCNick) && (IsAttached()) && (GetIRCSock())) {
		sRet = GetIRCSock()->GetNick();
	}

	return (sRet.empty()) ? m_sNick : sRet;
}

CString CClient::GetNickMask() const {
	if (GetIRCSock() && GetIRCSock()->IsAuthed()) {
		return GetIRCSock()->GetNickMask();
	}

	CString sHost = m_pUser->GetVHost();
	if (sHost.empty()) {
		sHost = ""irc.znc.in"";
	}

	return GetNick() + ""!"" + m_pUser->GetIdent() + ""@"" + sHost;
}

void CClient::RespondCap(const CString& sResponse)
{
	PutClient("":irc.znc.in CAP "" + GetNick() + "" "" + sResponse);
}

void CClient::HandleCap(const CString& sLine)
{
	CString sSubCmd = sLine.Token(1);

	if (sSubCmd.Equals(""LS"")) {
		RespondCap(""LS :userhost-in-names multi-prefix"");
		m_bInCap = true;
	} else if (sSubCmd.Equals(""END"")) {
		m_bInCap = false;
		AuthUser();
	} else if (sSubCmd.Equals(""REQ"")) {
		bool bReqUHNames = false;
		bool bReqNamesx = false;
		bool bValueUHNames = false;
		bool bValueNamesx = false;

		VCString vsTokens;
		VCString::iterator it;
		sLine.Token(2).TrimPrefix_n("":"").Split("" "", vsTokens, false);

		for (it = vsTokens.begin(); it != vsTokens.end(); ++it) {
			bool bVal = true;
			if (it->TrimPrefix(""-""))
				bVal = false;

			if (*it == ""multi-prefix"") {
				bReqNamesx = true;
				bValueNamesx = bVal;
			} else if (*it == ""userhost-in-names"") {
				bReqUHNames = true;
				bValueUHNames = bVal;
			} else {
				// Some unsupported capability is requested
				RespondCap(""NAK :"" + sLine.Token(2, true).TrimPrefix_n("":""));
				return;
			}
		}

		// All is fine, we support what was requested
		RespondCap(""ACK :"" + sLine.Token(2, true).TrimPrefix_n("":""));
		if (bReqUHNames)
			m_bUHNames = bValueUHNames;
		if (bReqNamesx)
			m_bNamesx = bValueNamesx;
	} else if (sSubCmd.Equals(""LIST"")) {
		CString sList = """";
		if (m_bNamesx)
			sList += ""multi-prefix "";
		if (m_bUHNames)
			sList += ""userhost-in-names "";
		RespondCap(""LIST :"" + sList.TrimSuffix_n("" ""));
	}
}
""","""/*
 * Copyright (C) 2004-2010  See the AUTHORS file for details.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 as published
 * by the Free Software Foundation.
 */

#include ""Client.h""
#include ""Chan.h""
#include ""DCCBounce.h""
#include ""IRCSock.h""
#include ""User.h""
#include ""znc.h""
#include ""WebModules.h""

#define CALLMOD(MOD, CLIENT, USER, FUNC) {                                      \
	CModule* pModule = CZNC::Get().GetModules().FindModule(MOD);            \
	if (pModule) {                                                          \
		try {                                                           \
			pModule->SetClient(CLIENT);                             \
			pModule->SetUser(USER);                                 \
			pModule->FUNC;                                          \
			pModule->SetClient(NULL);                               \
			pModule->SetUser(NULL);                                 \
		} catch (CModule::EModException e) {                            \
			if (e == CModule::UNLOAD) {                             \
				CZNC::Get().GetModules().UnloadModule(MOD);     \
			}                                                       \
		}                                                               \
	} else {                                                                \
		pModule = (USER)->GetModules().FindModule(MOD);                 \
		if (pModule) {                                                  \
			try {                                                   \
				pModule->SetClient(CLIENT);                     \
				pModule->FUNC;                                  \
				pModule->SetClient(NULL);                       \
			} catch (CModule::EModException e) {                    \
				if (e == CModule::UNLOAD) {                     \
					(USER)->GetModules().UnloadModule(MOD); \
				}                                               \
			}                                                       \
		} else {                                                        \
			PutStatus(""No such module ["" + MOD + ""]"");              \
		}                                                               \
	}                                                                       \
}

CClient::~CClient() {
	if (!m_spAuth.IsNull()) {
		CClientAuth* pAuth = (CClientAuth*) &(*m_spAuth);
		pAuth->Invalidate();
	}
	if (m_pUser != NULL) {
		m_pUser->AddBytesRead(GetBytesRead());
		m_pUser->AddBytesWritten(GetBytesWritten());
	}
}

void CClient::ReadLine(const CString& sData) {
	CString sLine = sData;

	sLine.TrimRight(""\n\r"");

	DEBUG(""("" << ((m_pUser) ? m_pUser->GetUserName() : GetRemoteIP()) << "") CLI -> ZNC ["" << sLine << ""]"");

	if (IsAttached()) {
		MODULECALL(OnUserRaw(sLine), m_pUser, this, return);
	} else {
		if (CZNC::Get().GetModules().OnUnknownUserRaw(this, sLine)) {
			return;
		}
	}

	CString sCommand = sLine.Token(0);
	if (sCommand.Left(1) == "":"") {
		// Evil client! Sending a nickmask prefix on client's command
		// is bad, bad, bad, bad, bad, bad, bad, bad, BAD, B A D!
		sLine = sLine.Token(1, true);
		sCommand = sLine.Token(0);
	}

	if (sCommand.Equals(""PASS"")) {
		if (!IsAttached()) {
			m_bGotPass = true;
			m_sPass = sLine.Token(1);
			if (m_sPass.Left(1) == "":"")
				m_sPass.LeftChomp();

			if (m_sPass.find("":"") != CString::npos) {
				m_sUser = m_sPass.Token(0, false, "":"");
				m_sPass = m_sPass.Token(1, true, "":"");
			}

			AuthUser();
			return;  // Don't forward this msg.  ZNC has already registered us.
		}
	} else if (sCommand.Equals(""NICK"")) {
		CString sNick = sLine.Token(1);
		if (sNick.Left(1) == "":"") {
			sNick.LeftChomp();
		}

		if (!IsAttached()) {
			m_sNick = sNick;
			m_bGotNick = true;

			AuthUser();
			return;  // Don't forward this msg.  ZNC will handle nick changes until auth is complete
		}
	} else if (sCommand.Equals(""USER"")) {
		if (!IsAttached()) {
			if (m_sUser.empty()) {
				m_sUser = sLine.Token(1);
			}

			m_bGotUser = true;

			if (m_bGotPass) {
				AuthUser();
			} else {
				PutClient("":irc.znc.in NOTICE AUTH :*** ""
					""You need to send your password. ""
					""Try /quote PASS <username>:<password>"");
			}

			return;  // Don't forward this msg.  ZNC has already registered us.
		}
	} else if (sCommand.Equals(""CAP"")) {
		HandleCap(sLine);

		// Don't let the client talk to the server directly about CAP,
		// we don't want anything enabled that znc does not support.
		return;
	}

	if (!m_pUser) {
		// Only CAP, NICK, USER and PASS are allowed before login
		return;
	}

	if (sCommand.Equals(""ZNC"")) {
		CString sTarget = sLine.Token(1);
		CString sModCommand;

		if (sTarget.TrimPrefix(m_pUser->GetStatusPrefix())) {
			sModCommand = sLine.Token(2, true);
		} else {
			sTarget  = ""status"";
			sModCommand = sLine.Token(1, true);
		}

		if (sTarget.Equals(""status"")) {
			if (sModCommand.empty())
				PutStatus(""Hello. How may I help you?"");
			else
				UserCommand(sModCommand);
		} else {
			if (sModCommand.empty())
				CALLMOD(sTarget, this, m_pUser, PutModule(""Hello. How may I help you?""))
			else
				CALLMOD(sTarget, this, m_pUser, OnModCommand(sModCommand))
		}
		return;
	} else if (sCommand.Equals(""DETACH"")) {
		CString sChan = sLine.Token(1);

		if (sChan.empty()) {
			PutStatusNotice(""Usage: /detach <#chan>"");
			return;
		}

		CChan* pChan = m_pUser->FindChan(sChan);
		if (!pChan) {
			PutStatusNotice(""You are not on ["" + sChan + ""]"");
			return;
		}

		pChan->DetachUser();
		PutStatusNotice(""Detached from ["" + sChan + ""]"");
		return;
	} else if (sCommand.Equals(""PING"")) {
		CString sTarget = sLine.Token(1);

		// If the client meant to ping us or we can be sure the server
		// won't answer the ping (=no server connected) -> PONG back.
		// else: It's the server's job to send a PONG.
		if (sTarget.Equals(""irc.znc.in"") || !GetIRCSock()) {
			PutClient(""PONG "" + sLine.substr(5));
			return;
		}
	} else if (sCommand.Equals(""PONG"")) {
		return;  // Block pong replies, we already responded to the pings
	} else if (sCommand.Equals(""JOIN"")) {
		CString sChans = sLine.Token(1);
		CString sKey = sLine.Token(2);

		if (sChans.Left(1) == "":"") {
			sChans.LeftChomp();
		}

		VCString vChans;
		sChans.Split("","", vChans, false);
		sChans.clear();

		for (unsigned int a = 0; a < vChans.size(); a++) {
			CString sChannel = vChans[a];
			MODULECALL(OnUserJoin(sChannel, sKey), m_pUser, this, continue);

			CChan* pChan = m_pUser->FindChan(sChannel);

			if (pChan) {
				pChan->JoinUser(false, sKey);
				continue;
			}

			if (!sChannel.empty()) {
				sChans += (sChans.empty()) ? sChannel : CString("","" + sChannel);
			}
		}

		if (sChans.empty()) {
			return;
		}

		sLine = ""JOIN "" + sChans;

		if (!sKey.empty()) {
			sLine += "" "" + sKey;
		}
	} else if (sCommand.Equals(""PART"")) {
		CString sChan = sLine.Token(1);
		CString sMessage = sLine.Token(2, true);

		if (sChan.Left(1) == "":"") {
			// I hate those broken clients, I hate them so much, I really hate them...
			sChan.LeftChomp();
		}
		if (sMessage.Left(1) == "":"") {
			sMessage.LeftChomp();
		}

		MODULECALL(OnUserPart(sChan, sMessage), m_pUser, this, return);

		CChan* pChan = m_pUser->FindChan(sChan);

		if (pChan && !pChan->IsOn()) {
			PutStatusNotice(""Removing channel ["" + sChan + ""]"");
			m_pUser->DelChan(sChan);
			return;
		}

		sLine = ""PART "" + sChan;

		if (!sMessage.empty()) {
			sLine += "" :"" + sMessage;
		}
	} else if (sCommand.Equals(""TOPIC"")) {
		CString sChan = sLine.Token(1);
		CString sTopic = sLine.Token(2, true);

		if (!sTopic.empty()) {
			if (sTopic.Left(1) == "":"")
				sTopic.LeftChomp();
			MODULECALL(OnUserTopic(sChan, sTopic), m_pUser, this, return);
			sLine = ""TOPIC "" + sChan + "" :"" + sTopic;
		} else {
			MODULECALL(OnUserTopicRequest(sChan), m_pUser, this, return);
		}
	} else if (sCommand.Equals(""MODE"")) {
		CString sTarget = sLine.Token(1);
		CString sModes = sLine.Token(2, true);

		if (m_pUser->IsChan(sTarget)) {
			CChan *pChan = m_pUser->FindChan(sTarget);

			// If we are on that channel and already received a
			// /mode reply from the server, we can answer this
			// request ourself.
			if (pChan && pChan->IsOn() && sModes.empty() && !pChan->GetModeString().empty()) {
				PutClient("":"" + m_pUser->GetIRCServer() + "" 324 "" + GetNick() + "" "" + sTarget + "" "" + pChan->GetModeString());
				if (pChan->GetCreationDate() > 0) {
					PutClient("":"" + m_pUser->GetIRCServer() + "" 329 "" + GetNick() + "" "" + sTarget + "" "" + CString(pChan->GetCreationDate()));
				}
				return;
			}
		}
	} else if (sCommand.Equals(""QUIT"")) {
		m_pUser->UserDisconnected(this);

		Close(Csock::CLT_AFTERWRITE); // Treat a client quit as a detach
		return;                       // Don't forward this msg.  We don't want the client getting us disconnected.
	} else if (sCommand.Equals(""PROTOCTL"")) {
		VCString vsTokens;
		VCString::const_iterator it;
		sLine.Token(1, true).Split("" "", vsTokens, false);

		for (it = vsTokens.begin(); it != vsTokens.end(); ++it) {
			if (*it == ""NAMESX"") {
				m_bNamesx = true;
			} else if (*it == ""UHNAMES"") {
				m_bUHNames = true;
			}
		}
		return;  // If the server understands it, we already enabled namesx / uhnames
	} else if (sCommand.Equals(""NOTICE"")) {
		CString sTarget = sLine.Token(1);
		CString sMsg = sLine.Token(2, true);

		if (sMsg.Left(1) == "":"") {
			sMsg.LeftChomp();
		}

		if (sTarget.TrimPrefix(m_pUser->GetStatusPrefix())) {
			if (!sTarget.Equals(""status"")) {
				CALLMOD(sTarget, this, m_pUser, OnModNotice(sMsg));
			}
			return;
		}

		// No idea what this is supposed to do, but it doesn't seem to
		// make sense. Comment this out and wait for complaints.
#if 0
		if (sMsg.WildCmp(""DCC * (*)"")) {
			sMsg = ""DCC "" + sLine.Token(3) + "" ("" + ((GetIRCSock()) ? GetIRCSock()->GetLocalIP() : GetLocalIP()) + "")"";
		}
#endif

		if (sMsg.WildCmp(""\001*\001"")) {
			CString sCTCP = sMsg;
			sCTCP.LeftChomp();
			sCTCP.RightChomp();

			MODULECALL(OnUserCTCPReply(sTarget, sCTCP), m_pUser, this, return);

			sMsg = ""\001"" + sCTCP + ""\001"";
		} else {
			MODULECALL(OnUserNotice(sTarget, sMsg), m_pUser, this, return);
		}

		if (!GetIRCSock()) {
			// Some lagmeters do a NOTICE to their own nick, ignore those.
			if (!sTarget.Equals(m_sNick))
				PutStatus(""Your notice to ["" + sTarget + ""] got lost, ""
						""you are not connected to IRC!"");
			return;
		}

		CChan* pChan = m_pUser->FindChan(sTarget);

		if ((pChan) && (pChan->KeepBuffer())) {
			pChan->AddBuffer("":"" + GetNickMask() + "" NOTICE "" + sTarget + "" :"" + m_pUser->AddTimestamp(sMsg));
		}

		// Relay to the rest of the clients that may be connected to this user
		if (m_pUser->IsChan(sTarget)) {
			vector<CClient*>& vClients = m_pUser->GetClients();

			for (unsigned int a = 0; a < vClients.size(); a++) {
				CClient* pClient = vClients[a];

				if (pClient != this) {
					pClient->PutClient("":"" + GetNickMask() + "" NOTICE "" + sTarget + "" :"" + sMsg);
				}
			}
		}

		PutIRC(""NOTICE "" + sTarget + "" :"" + sMsg);
		return;
	} else if (sCommand.Equals(""PRIVMSG"")) {
		CString sTarget = sLine.Token(1);
		CString sMsg = sLine.Token(2, true);

		if (sMsg.Left(1) == "":"") {
			sMsg.LeftChomp();
		}

		if (sMsg.WildCmp(""\001*\001"")) {
			CString sCTCP = sMsg;
			sCTCP.LeftChomp();
			sCTCP.RightChomp();

			if (sCTCP.Equals(""DCC "", false, 4) && m_pUser->BounceDCCs()) {
				CString sType = sCTCP.Token(1);
				CString sFile = sCTCP.Token(2);
				unsigned long uLongIP = sCTCP.Token(3).ToULong();
				unsigned short uPort = sCTCP.Token(4).ToUShort();
				unsigned long uFileSize = sCTCP.Token(5).ToULong();
				CString sIP = m_pUser->GetLocalDCCIP();

				if (!m_pUser->UseClientIP()) {
					uLongIP = CUtils::GetLongIP(GetRemoteIP());
				}

				if (sType.Equals(""CHAT"")) {
					if (!sTarget.TrimPrefix(m_pUser->GetStatusPrefix())) {
						unsigned short uBNCPort = CDCCBounce::DCCRequest(sTarget, uLongIP, uPort, """", true, m_pUser, """");
						if (uBNCPort) {
							PutIRC(""PRIVMSG "" + sTarget + "" :\001DCC CHAT chat "" + CString(CUtils::GetLongIP(sIP)) + "" "" + CString(uBNCPort) + ""\001"");
						}
					}
				} else if (sType.Equals(""SEND"")) {
					// DCC SEND readme.txt 403120438 5550 1104

					if (sTarget.TrimPrefix(m_pUser->GetStatusPrefix())) {
						if (sTarget.Equals(""status"")) {
							CString sPath = m_pUser->GetDLPath();
							if (!CFile::Exists(sPath)) {
								PutStatus(""Could not create ["" + sPath + ""] directory."");
								return;
							} else if (!CFile::IsDir(sPath)) {
								PutStatus(""Error: ["" + sPath + ""] is not a directory."");
								return;
							}

							CString sAbsolutePath = CDir::CheckPathPrefix(sPath, sFile);

							if (sAbsolutePath.empty()) {
								PutStatus(""Illegal path."");
								return;
							}

							m_pUser->GetFile(GetNick(), CUtils::GetIP(uLongIP), uPort, sAbsolutePath, uFileSize);
						} else {
							MODULECALL(OnDCCUserSend(CString(m_pUser->GetStatusPrefix() + sTarget), uLongIP, uPort, sFile, uFileSize), m_pUser, this, return);
						}
					} else {
						unsigned short uBNCPort = CDCCBounce::DCCRequest(sTarget, uLongIP, uPort, sFile, false, m_pUser, """");
						if (uBNCPort) {
							PutIRC(""PRIVMSG "" + sTarget + "" :\001DCC SEND "" + sFile + "" "" + CString(CUtils::GetLongIP(sIP)) + "" "" + CString(uBNCPort) + "" "" + CString(uFileSize) + ""\001"");
						}
					}
				} else if (sType.Equals(""RESUME"")) {
					// PRIVMSG user :DCC RESUME ""znc.o"" 58810 151552
					unsigned short uResumePort = sCTCP.Token(3).ToUShort();
					unsigned long uResumeSize = sCTCP.Token(4).ToULong();

					// Need to lookup the connection by port, filter the port, and forward to the user
					CString sStatusPrefix = m_pUser->GetStatusPrefix();
					if (sTarget.Equals(sStatusPrefix, false, sStatusPrefix.length())) {
						if (m_pUser->ResumeFile(uResumePort, uResumeSize)) {
							PutClient("":"" + sTarget + ""!znc@znc.in PRIVMSG "" + GetNick() + "" :\001DCC ACCEPT "" + sFile + "" "" + CString(uResumePort) + "" "" + CString(uResumeSize) + ""\001"");
						} else {
							PutStatus(""DCC -> ["" + GetNick() + ""]["" + sFile + ""] Unable to find send to initiate resume."");
						}
					} else {
						CDCCBounce* pSock = (CDCCBounce*) CZNC::Get().GetManager().FindSockByLocalPort(uResumePort);
						if (pSock && pSock->GetSockName().Equals(""DCC::"", false, 5)) {
							PutIRC(""PRIVMSG "" + sTarget + "" :\001DCC "" + sType + "" "" + sFile + "" "" + CString(pSock->GetUserPort()) + "" "" + sCTCP.Token(4) + ""\001"");
						}
					}
				} else if (sType.Equals(""ACCEPT"")) {
					CString sStatusPrefix = m_pUser->GetStatusPrefix();
					if (!sTarget.Equals(sStatusPrefix, false, sStatusPrefix.length())) {
						// Need to lookup the connection by port, filter the port, and forward to the user
						CSockManager& Manager = CZNC::Get().GetManager();

						for (unsigned int a = 0; a < Manager.size(); a++) {
							CDCCBounce* pSock = (CDCCBounce*) Manager[a];

							if (pSock && pSock->GetSockName().Equals(""DCC::"", false, 5)) {
								if (pSock->GetUserPort() == sCTCP.Token(3).ToUShort()) {
									PutIRC(""PRIVMSG "" + sTarget + "" :\001DCC "" + sType + "" "" + sFile + "" "" + CString(pSock->GetLocalPort()) + "" "" + sCTCP.Token(4) + ""\001"");
								}
							}
						}
					}
				}

				return;
			}

			if (sTarget.TrimPrefix(m_pUser->GetStatusPrefix())) {
				if (sTarget.Equals(""status"")) {
					StatusCTCP(sCTCP);
				} else {
					CALLMOD(sTarget, this, m_pUser, OnModCTCP(sCTCP));
				}
				return;
			}

			CChan* pChan = m_pUser->FindChan(sTarget);

			if (sCTCP.Token(0).Equals(""ACTION"")) {
				CString sMessage = sCTCP.Token(1, true);
				MODULECALL(OnUserAction(sTarget, sMessage), m_pUser, this, return);
				sCTCP = ""ACTION "" + sMessage;

				if (pChan && pChan->KeepBuffer()) {
					pChan->AddBuffer("":"" + GetNickMask() + "" PRIVMSG "" + sTarget + "" :\001ACTION "" + m_pUser->AddTimestamp(sMessage) + ""\001"");
				}

				// Relay to the rest of the clients that may be connected to this user
				if (m_pUser->IsChan(sTarget)) {
					vector<CClient*>& vClients = m_pUser->GetClients();

					for (unsigned int a = 0; a < vClients.size(); a++) {
						CClient* pClient = vClients[a];

						if (pClient != this) {
							pClient->PutClient("":"" + GetNickMask() + "" PRIVMSG "" + sTarget + "" :\001"" + sCTCP + ""\001"");
						}
					}
				}
			} else {
				MODULECALL(OnUserCTCP(sTarget, sCTCP), m_pUser, this, return);
			}

			PutIRC(""PRIVMSG "" + sTarget + "" :\001"" + sCTCP + ""\001"");
			return;
		}

		if (sTarget.TrimPrefix(m_pUser->GetStatusPrefix())) {
			if (sTarget.Equals(""status"")) {
				UserCommand(sMsg);
			} else {
				CALLMOD(sTarget, this, m_pUser, OnModCommand(sMsg));
			}
			return;
		}

		MODULECALL(OnUserMsg(sTarget, sMsg), m_pUser, this, return);

		if (!GetIRCSock()) {
			// Some lagmeters do a PRIVMSG to their own nick, ignore those.
			if (!sTarget.Equals(m_sNick))
				PutStatus(""Your message to ["" + sTarget + ""] got lost, ""
						""you are not connected to IRC!"");
			return;
		}

		CChan* pChan = m_pUser->FindChan(sTarget);

		if ((pChan) && (pChan->KeepBuffer())) {
			pChan->AddBuffer("":"" + GetNickMask() + "" PRIVMSG "" + sTarget + "" :"" + m_pUser->AddTimestamp(sMsg));
		}

		PutIRC(""PRIVMSG "" + sTarget + "" :"" + sMsg);

		// Relay to the rest of the clients that may be connected to this user

		if (m_pUser->IsChan(sTarget)) {
			vector<CClient*>& vClients = m_pUser->GetClients();

			for (unsigned int a = 0; a < vClients.size(); a++) {
				CClient* pClient = vClients[a];

				if (pClient != this) {
					pClient->PutClient("":"" + GetNickMask() + "" PRIVMSG "" + sTarget + "" :"" + sMsg);
				}
			}
		}

		return;
	}

	PutIRC(sLine);
}

void CClient::SetNick(const CString& s) {
	m_sNick = s;
}

const CIRCSock* CClient::GetIRCSock() const {
	return m_pUser->GetIRCSock();
}

CIRCSock* CClient::GetIRCSock() {
	return m_pUser->GetIRCSock();
}

void CClient::StatusCTCP(const CString& sLine) {
	CString sCommand = sLine.Token(0);

	if (sCommand.Equals(""PING"")) {
		PutStatusNotice(""\001PING "" + sLine.Token(1, true) + ""\001"");
	} else if (sCommand.Equals(""VERSION"")) {
		PutStatusNotice(""\001VERSION "" + CZNC::GetTag() + ""\001"");
	}
}

bool CClient::SendMotd() {
	const VCString& vsMotd = CZNC::Get().GetMotd();

	if (!vsMotd.size()) {
		return false;
	}

	for (unsigned int a = 0; a < vsMotd.size(); a++) {
		PutStatusNotice(m_pUser->ExpandString(vsMotd[a]));
	}

	return true;
}

void CClient::AuthUser() {
	if (!m_bGotNick || !m_bGotUser || m_bInCap || IsAttached())
		return;

	m_spAuth = new CClientAuth(this, m_sUser, m_sPass);

	CZNC::Get().AuthUser(m_spAuth);
}

CClientAuth::CClientAuth(CClient* pClient, const CString& sUsername, const CString& sPassword)
		: CAuthBase(sUsername, sPassword, pClient) {
	m_pClient = pClient;
}

void CClientAuth::RefusedLogin(const CString& sReason) {
	if (m_pClient) {
		m_pClient->RefuseLogin(sReason);
	}
}

CString CAuthBase::GetRemoteIP() const {
	if (m_pSock)
		return m_pSock->GetRemoteIP();
	return """";
}

void CAuthBase::Invalidate() {
	m_pSock = NULL;
}

void CAuthBase::AcceptLogin(CUser& User) {
	if (m_pSock) {
		AcceptedLogin(User);
		Invalidate();
	}
}

void CAuthBase::RefuseLogin(const CString& sReason) {
	if (!m_pSock)
		return;

	CUser* pUser = CZNC::Get().GetUser(GetUsername());

	// If the username is valid, notify that user that someone tried to
	// login. Use sReason because there are other reasons than ""wrong
	// password"" for a login to be rejected (e.g. fail2ban).
	if (pUser) {
		pUser->PutStatus(""A client from ["" + GetRemoteIP() + ""] attempted ""
				""to login as you, but was rejected ["" + sReason + ""]."");
	}

	CZNC::Get().GetModules().OnFailedLogin(GetUsername(), GetRemoteIP());
	RefusedLogin(sReason);
	Invalidate();
}

void CClient::RefuseLogin(const CString& sReason) {
	PutStatus(""Bad username and/or password."");
	PutClient("":irc.znc.in 464 "" + GetNick() + "" :"" + sReason);
	Close(Csock::CLT_AFTERWRITE);
}

void CClientAuth::AcceptedLogin(CUser& User) {
	if (m_pClient) {
		m_pClient->AcceptLogin(User);
	}
}

void CClient::AcceptLogin(CUser& User) {
	m_sPass = """";
	m_pUser = &User;

	// Set our proper timeout and set back our proper timeout mode
	// (constructor set a different timeout and mode)
	SetTimeout(240, TMO_READ);

	SetSockName(""USR::"" + m_pUser->GetUserName());

	m_pUser->UserConnected(this);

	SendMotd();

	MODULECALL(OnClientLogin(), m_pUser, this, );
}

void CClient::Timeout() {
	PutClient(""ERROR :Closing link [Timeout]"");
}

void CClient::Connected() {
	DEBUG(GetSockName() << "" == Connected();"");
}

void CClient::ConnectionRefused() {
	DEBUG(GetSockName() << "" == ConnectionRefused()"");
}

void CClient::Disconnected() {
	DEBUG(GetSockName() << "" == Disconnected()"");
	if (m_pUser) {
		m_pUser->UserDisconnected(this);
	}

	MODULECALL(OnClientDisconnect(), m_pUser, this, );
}

void CClient::ReachedMaxBuffer() {
	DEBUG(GetSockName() << "" == ReachedMaxBuffer()"");
	if (IsAttached()) {
		PutClient(""ERROR :Closing link [Too long raw line]"");
	}
	Close();
}

void CClient::BouncedOff() {
	PutStatusNotice(""You are being disconnected because another user just authenticated as you."");
	Close(Csock::CLT_AFTERWRITE);
}

void CClient::PutIRC(const CString& sLine) {
	m_pUser->PutIRC(sLine);
}

void CClient::PutClient(const CString& sLine) {
	DEBUG(""("" << ((m_pUser) ? m_pUser->GetUserName() : GetRemoteIP()) << "") ZNC -> CLI ["" << sLine << ""]"");
	Write(sLine + ""\r\n"");
}

void CClient::PutStatusNotice(const CString& sLine) {
	PutModNotice(""status"", sLine);
}

unsigned int CClient::PutStatus(const CTable& table) {
	unsigned int idx = 0;
	CString sLine;
	while (table.GetLine(idx++, sLine))
		PutStatus(sLine);
	return idx - 1;
}

void CClient::PutStatus(const CString& sLine) {
	PutModule(""status"", sLine);
}

void CClient::PutModNotice(const CString& sModule, const CString& sLine) {
	if (!m_pUser) {
		return;
	}

	DEBUG(""("" << m_pUser->GetUserName() << "") ZNC -> CLI [:"" + m_pUser->GetStatusPrefix() + ((sModule.empty()) ? ""status"" : sModule) + ""!znc@znc.in NOTICE "" << GetNick() << "" :"" << sLine << ""]"");
	Write("":"" + m_pUser->GetStatusPrefix() + ((sModule.empty()) ? ""status"" : sModule) + ""!znc@znc.in NOTICE "" + GetNick() + "" :"" + sLine + ""\r\n"");
}

void CClient::PutModule(const CString& sModule, const CString& sLine) {
	if (!m_pUser) {
		return;
	}

	DEBUG(""("" << m_pUser->GetUserName() << "") ZNC -> CLI [:"" + m_pUser->GetStatusPrefix() + ((sModule.empty()) ? ""status"" : sModule) + ""!znc@znc.in PRIVMSG "" << GetNick() << "" :"" << sLine << ""]"");
	Write("":"" + m_pUser->GetStatusPrefix() + ((sModule.empty()) ? ""status"" : sModule) + ""!znc@znc.in PRIVMSG "" + GetNick() + "" :"" + sLine + ""\r\n"");
}

CString CClient::GetNick(bool bAllowIRCNick) const {
	CString sRet;

	if ((bAllowIRCNick) && (IsAttached()) && (GetIRCSock())) {
		sRet = GetIRCSock()->GetNick();
	}

	return (sRet.empty()) ? m_sNick : sRet;
}

CString CClient::GetNickMask() const {
	if (GetIRCSock() && GetIRCSock()->IsAuthed()) {
		return GetIRCSock()->GetNickMask();
	}

	CString sHost = m_pUser->GetVHost();
	if (sHost.empty()) {
		sHost = ""irc.znc.in"";
	}

	return GetNick() + ""!"" + m_pUser->GetIdent() + ""@"" + sHost;
}

void CClient::RespondCap(const CString& sResponse)
{
	PutClient("":irc.znc.in CAP "" + GetNick() + "" "" + sResponse);
}

void CClient::HandleCap(const CString& sLine)
{
	CString sSubCmd = sLine.Token(1);

	if (sSubCmd.Equals(""LS"")) {
		RespondCap(""LS :userhost-in-names multi-prefix"");
		m_bInCap = true;
	} else if (sSubCmd.Equals(""END"")) {
		m_bInCap = false;
		AuthUser();
	} else if (sSubCmd.Equals(""REQ"")) {
		bool bReqUHNames = false;
		bool bReqNamesx = false;
		bool bValueUHNames = false;
		bool bValueNamesx = false;

		VCString vsTokens;
		VCString::iterator it;
		sLine.Token(2).TrimPrefix_n("":"").Split("" "", vsTokens, false);

		for (it = vsTokens.begin(); it != vsTokens.end(); ++it) {
			bool bVal = true;
			if (it->TrimPrefix(""-""))
				bVal = false;

			if (*it == ""multi-prefix"") {
				bReqNamesx = true;
				bValueNamesx = bVal;
			} else if (*it == ""userhost-in-names"") {
				bReqUHNames = true;
				bValueUHNames = bVal;
			} else {
				// Some unsupported capability is requested
				RespondCap(""NAK :"" + sLine.Token(2, true).TrimPrefix_n("":""));
				return;
			}
		}

		// All is fine, we support what was requested
		RespondCap(""ACK :"" + sLine.Token(2, true).TrimPrefix_n("":""));
		if (bReqUHNames)
			m_bUHNames = bValueUHNames;
		if (bReqNamesx)
			m_bNamesx = bValueNamesx;
	} else if (sSubCmd.Equals(""LIST"")) {
		CString sList = """";
		if (m_bNamesx)
			sList += ""multi-prefix "";
		if (m_bUHNames)
			sList += ""userhost-in-names "";
		RespondCap(""LIST :"" + sList.TrimSuffix_n("" ""));
	}
}
""",CAuthBase::RefuseLogin,[633:650]
znc,https://github.com/znc/znc/commit/d38953f02ced4760ac329057b4c6e4d72b21fbb4,"""Minor optimization

Convert a while-loop into a for-loop in route_replies.


git-svn-id: https://znc.svn.sourceforge.net/svnroot/znc/trunk@2034 726aef4b-f618-498e-8847-2d620e286838""","""/*
 * Copyright (C) 2004-2010  See the AUTHORS file for details.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 as published
 * by the Free Software Foundation.
 */

#include ""znc.h""
#include ""User.h""
#include ""IRCSock.h""

struct reply {
	const char *szReply;
	bool bLastResponse;
};

// TODO this list is far from complete, no errors are handled
static const struct {
	const char *szRequest;
	struct reply vReplies[10];
} vRouteReplies[] = {
	{""WHO"", {
		{""352"", false},
		{""403"", true}, // No such chan
		{""315"", true},
		{NULL, true}
	}},
	{""LIST"", {
		{""321"", false},
		{""322"", false},
		{""323"", true},
		{NULL, true}
	}},
	{""NAMES"", {
		{""353"", false},
		{""366"", true},
		// No such nick/channel
		{""401"", true},
		{NULL, true},
	}},
	{""LUSERS"", {
		{""251"", false},
		{""252"", false},
		{""253"", false},
		{""254"", false},
		{""255"", false},
		{""265"", false},
		{""266"", true},
		// We don't handle 250 here since some IRCds don't sent it
		//{""250"", true},
		{NULL, true}
	}},
	{""WHOIS"", {
		{""311"", false},
		{""319"", false},
		{""312"", false},
		// ""<ip> :actually using host""
		{""338"", false},
		{""318"", true},
		// No such nick/channel
		{""401"", true},
		// No such server
		{""402"", true},
		{NULL, true}
	}},
	{""PING"", {
		{""PONG"", true},
		{NULL, true}
	}},
	{""USERHOST"", {
		{""302"", true},
		{NULL, true}
	}},
	{""TIME"", {
		{""391"", true},
		{NULL, true}
	}},
	{""WHOWAS"", {
		{""312"", false},
		{""314"", false},
		{""369"", true},
		{NULL, true}
	}},
	{""ISON"", {
		{""303"", true},
		{NULL, true}
	}},
	{""LINKS"", {
		{""364"", false},
		{""365"", true},
		{NULL, true}
	}},
	{""MAP"", {
		{""006"", false},
		// inspircd
		{""270"", false},
		// SilverLeo wants this two added
		{""015"", false},
		{""017"", true},
		{""007"", true},
		{NULL, true}
	}},
	{""TRACE"", {
		{""200"", false},
		{""205"", false},
		{""262"", true},
		{NULL, true}
	}},
	{""USERS"", {
		{""265"", false},
		{""266"", true},
		{NULL, true},
	}},
	// END (last item!)
	{NULL, {{NULL, true}}}
};

class CRouteTimeout : public CTimer {
public:
	CRouteTimeout(CModule* pModule, unsigned int uInterval, unsigned int uCycles,
			const CString& sLabel, const CString& sDescription)
		: CTimer(pModule, uInterval, uCycles, sLabel, sDescription) {}
	virtual ~CRouteTimeout() {}

protected:
	virtual void RunJob();
};

struct queued_req {
	CString sLine;
	const struct reply *reply;
};

typedef std::map<CClient *, std::vector<struct queued_req> > requestQueue;

class CRouteRepliesMod : public CModule
{
public:
	MODCONSTRUCTOR(CRouteRepliesMod)
	{
		m_pDoing = NULL;
		m_pReplies = NULL;
	}

	virtual ~CRouteRepliesMod() {
		requestQueue::iterator it;

		while (!m_vsPending.empty()) {
			it = m_vsPending.begin();

			while (!it->second.empty()) {
				PutIRC(it->second[0].sLine);
				it->second.erase(it->second.begin());
			}

			m_vsPending.erase(it);
		}
	}

	virtual void OnIRCConnected()
	{
		m_pDoing = NULL;
		m_pReplies = NULL;
		m_vsPending.clear();

		// No way we get a reply, so stop the timer (If it's running)
		RemTimer(""RouteTimeout"");
	}

	virtual void OnIRCDisconnected()
	{
		OnIRCConnected(); // Let's keep it in one place
	}

	virtual void OnClientDisconnect()
	{
		requestQueue::iterator it;

		if (m_pClient == m_pDoing) {
			// The replies which aren't received yet will be
			// broadcasted to everyone, but at least nothing breaks
			m_pDoing = NULL;
			m_pReplies = NULL;
		}

		it = m_vsPending.find(m_pClient);

		if (it == m_vsPending.end())
			return;

		m_vsPending.erase(it);
	}

	virtual EModRet OnRaw(CString& sLine)
	{
		CString sCmd = sLine.Token(1).AsUpper();
		size_t i = 0;

		if (!m_pReplies)
			return CONTINUE;

		// Is this a ""not enough arguments"" error?
		if (sCmd == ""461"") {
			// :server 461 nick WHO :Not enough parameters
			CString sOrigCmd = sLine.Token(3);

			if (m_sLastRequest.Token(0).Equals(sOrigCmd)) {
				// This is the reply to the last request
				if (RouteReply(sLine, true))
					return HALTCORE;
				return CONTINUE;
			}
		}

		while (m_pReplies[i].szReply != NULL) {
			if (m_pReplies[i].szReply == sCmd) {
				if (RouteReply(sLine, m_pReplies[i].bLastResponse, sCmd == ""353""))
					return HALTCORE;
				return CONTINUE;
			}
			i++;
		}

		// TODO HALTCORE is wrong, it should not be passed to
		// the clients, but the core itself should still handle it!

		return CONTINUE;
	}

	virtual EModRet OnUserRaw(CString& sLine)
	{
		CString sCmd = sLine.Token(0).AsUpper();
		size_t i = 0;

		if (!m_pUser->GetIRCSock())
			return CONTINUE;

		while (vRouteReplies[i].szRequest != NULL) {
			if (vRouteReplies[i].szRequest == sCmd) {

				struct queued_req req = {
					sLine, vRouteReplies[i].vReplies
				};
				m_vsPending[m_pClient].push_back(req);
				SendRequest();

				return HALTCORE;
			}
			i++;
		}

		return CONTINUE;
	}

	void Timeout()
	{
		// The timer will be deleted after this by the event loop

		if (GetNV(""silent_timeouts"") != ""yes"") {
			PutModule(""This module hit a timeout which is possibly a bug."");
			PutModule(""Use \""silent yes\"" to disable this message."");
			PutModule(""Last request: "" + m_sLastRequest);
			PutModule(""Expected replies: "");

			for (size_t i = 0; m_pReplies[i].szReply != NULL; i++) {
				if (m_pReplies[i].bLastResponse)
					PutModule(m_pReplies[i].szReply +
							CString("" (last)""));
				else
					PutModule(m_pReplies[i].szReply);
			}
		}

		m_pDoing = NULL;
		m_pReplies = NULL;
		SendRequest();
	}

private:
	bool RouteReply(const CString& sLine, bool bFinished = false, bool bIsRaw353 = false)
	{
		if (!m_pDoing)
			return false;

		// 353 needs special treatment due to NAMESX and UHNAMES
		if (bIsRaw353)
			GetUser()->GetIRCSock()->ForwardRaw353(sLine, m_pDoing);
		else
			m_pDoing->PutClient(sLine);

		if (bFinished) {
			// Stop the timeout
			RemTimer(""RouteTimeout"");

			m_pDoing = NULL;
			m_pReplies = NULL;
			SendRequest();
		}

		return true;
	}

	void SendRequest()
	{
		requestQueue::iterator it;

		if (m_pDoing || m_pReplies)
			return;

		if (m_vsPending.empty())
			return;

		it = m_vsPending.begin();

		if (it->second.empty()) {
			m_vsPending.erase(it);
			SendRequest();
			return;
		}

		// When we are called from the timer, we need to remove it.
		// We can't delete it (segfault on return), thus we
		// just stop it. The main loop will delete it.
		CTimer *pTimer = FindTimer(""RouteTimeout"");
		if (pTimer) {
			pTimer->Stop();
			UnlinkTimer(pTimer);
		}
		AddTimer(new CRouteTimeout(this, 60, 1, ""RouteTimeout"",
				""Recover from missing / wrong server replies""));

		m_pDoing = it->first;
		m_pReplies = it->second[0].reply;
		m_sLastRequest = it->second[0].sLine;
		PutIRC(it->second[0].sLine);
		it->second.erase(it->second.begin());
	}

	virtual void OnModCommand(const CString& sCommand) {
		const CString sCmd = sCommand.Token(0);
		const CString sArgs = sCommand.Token(1, true);

		if (sCmd.Equals(""silent"")) {
			if (sArgs.Equals(""yes"")) {
				SetNV(""silent_timeouts"", ""yes"");
				PutModule(""Disabled timeout messages"");
			} else if (sArgs.Equals(""no"")) {
				DelNV(""silent_timeouts"");
				PutModule(""Enabled timeout messages"");
			} else if (sArgs.empty()) {
				if (GetNV(""silent_timeouts"") == ""yes"")
					PutModule(""Timeout messages are disabled"");
				else
					PutModule(""Timeout message are enabled"");
			} else
				PutModule(""Invalid argument"");
		} else {
			PutModule(""Available commands: silent [yes/no], silent"");
		}
	}

	CClient            *m_pDoing;
	const struct reply *m_pReplies;
	requestQueue        m_vsPending;
	// This field is only used for display purpose.
	CString             m_sLastRequest;
};

void CRouteTimeout::RunJob()
{
	CRouteRepliesMod *pMod = (CRouteRepliesMod *) m_pModule;
	pMod->Timeout();
}

MODULEDEFS(CRouteRepliesMod, ""Send replies (e.g. to /who) to the right client only"")
""","""/*
 * Copyright (C) 2004-2010  See the AUTHORS file for details.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 as published
 * by the Free Software Foundation.
 */

#include ""znc.h""
#include ""User.h""
#include ""IRCSock.h""

struct reply {
	const char *szReply;
	bool bLastResponse;
};

// TODO this list is far from complete, no errors are handled
static const struct {
	const char *szRequest;
	struct reply vReplies[10];
} vRouteReplies[] = {
	{""WHO"", {
		{""352"", false},
		{""403"", true}, // No such chan
		{""315"", true},
		{NULL, true}
	}},
	{""LIST"", {
		{""321"", false},
		{""322"", false},
		{""323"", true},
		{NULL, true}
	}},
	{""NAMES"", {
		{""353"", false},
		{""366"", true},
		// No such nick/channel
		{""401"", true},
		{NULL, true},
	}},
	{""LUSERS"", {
		{""251"", false},
		{""252"", false},
		{""253"", false},
		{""254"", false},
		{""255"", false},
		{""265"", false},
		{""266"", true},
		// We don't handle 250 here since some IRCds don't sent it
		//{""250"", true},
		{NULL, true}
	}},
	{""WHOIS"", {
		{""311"", false},
		{""319"", false},
		{""312"", false},
		// ""<ip> :actually using host""
		{""338"", false},
		{""318"", true},
		// No such nick/channel
		{""401"", true},
		// No such server
		{""402"", true},
		{NULL, true}
	}},
	{""PING"", {
		{""PONG"", true},
		{NULL, true}
	}},
	{""USERHOST"", {
		{""302"", true},
		{NULL, true}
	}},
	{""TIME"", {
		{""391"", true},
		{NULL, true}
	}},
	{""WHOWAS"", {
		{""312"", false},
		{""314"", false},
		{""369"", true},
		{NULL, true}
	}},
	{""ISON"", {
		{""303"", true},
		{NULL, true}
	}},
	{""LINKS"", {
		{""364"", false},
		{""365"", true},
		{NULL, true}
	}},
	{""MAP"", {
		{""006"", false},
		// inspircd
		{""270"", false},
		// SilverLeo wants this two added
		{""015"", false},
		{""017"", true},
		{""007"", true},
		{NULL, true}
	}},
	{""TRACE"", {
		{""200"", false},
		{""205"", false},
		{""262"", true},
		{NULL, true}
	}},
	{""USERS"", {
		{""265"", false},
		{""266"", true},
		{NULL, true},
	}},
	// END (last item!)
	{NULL, {{NULL, true}}}
};

class CRouteTimeout : public CTimer {
public:
	CRouteTimeout(CModule* pModule, unsigned int uInterval, unsigned int uCycles,
			const CString& sLabel, const CString& sDescription)
		: CTimer(pModule, uInterval, uCycles, sLabel, sDescription) {}
	virtual ~CRouteTimeout() {}

protected:
	virtual void RunJob();
};

struct queued_req {
	CString sLine;
	const struct reply *reply;
};

typedef std::map<CClient *, std::vector<struct queued_req> > requestQueue;

class CRouteRepliesMod : public CModule
{
public:
	MODCONSTRUCTOR(CRouteRepliesMod)
	{
		m_pDoing = NULL;
		m_pReplies = NULL;
	}

	virtual ~CRouteRepliesMod() {
		requestQueue::iterator it;

		while (!m_vsPending.empty()) {
			it = m_vsPending.begin();

			while (!it->second.empty()) {
				PutIRC(it->second[0].sLine);
				it->second.erase(it->second.begin());
			}

			m_vsPending.erase(it);
		}
	}

	virtual void OnIRCConnected()
	{
		m_pDoing = NULL;
		m_pReplies = NULL;
		m_vsPending.clear();

		// No way we get a reply, so stop the timer (If it's running)
		RemTimer(""RouteTimeout"");
	}

	virtual void OnIRCDisconnected()
	{
		OnIRCConnected(); // Let's keep it in one place
	}

	virtual void OnClientDisconnect()
	{
		requestQueue::iterator it;

		if (m_pClient == m_pDoing) {
			// The replies which aren't received yet will be
			// broadcasted to everyone, but at least nothing breaks
			m_pDoing = NULL;
			m_pReplies = NULL;
		}

		it = m_vsPending.find(m_pClient);

		if (it == m_vsPending.end())
			return;

		m_vsPending.erase(it);
	}

	virtual EModRet OnRaw(CString& sLine)
	{
		CString sCmd = sLine.Token(1).AsUpper();
		size_t i = 0;

		if (!m_pReplies)
			return CONTINUE;

		// Is this a ""not enough arguments"" error?
		if (sCmd == ""461"") {
			// :server 461 nick WHO :Not enough parameters
			CString sOrigCmd = sLine.Token(3);

			if (m_sLastRequest.Token(0).Equals(sOrigCmd)) {
				// This is the reply to the last request
				if (RouteReply(sLine, true))
					return HALTCORE;
				return CONTINUE;
			}
		}

		while (m_pReplies[i].szReply != NULL) {
			if (m_pReplies[i].szReply == sCmd) {
				if (RouteReply(sLine, m_pReplies[i].bLastResponse, sCmd == ""353""))
					return HALTCORE;
				return CONTINUE;
			}
			i++;
		}

		// TODO HALTCORE is wrong, it should not be passed to
		// the clients, but the core itself should still handle it!

		return CONTINUE;
	}

	virtual EModRet OnUserRaw(CString& sLine)
	{
		CString sCmd = sLine.Token(0).AsUpper();

		if (!m_pUser->GetIRCSock())
			return CONTINUE;

		for (size_t i = 0; vRouteReplies[i].szRequest != NULL; i++) {
			if (vRouteReplies[i].szRequest == sCmd) {

				struct queued_req req = {
					sLine, vRouteReplies[i].vReplies
				};
				m_vsPending[m_pClient].push_back(req);
				SendRequest();

				return HALTCORE;
			}
		}

		return CONTINUE;
	}

	void Timeout()
	{
		// The timer will be deleted after this by the event loop

		if (GetNV(""silent_timeouts"") != ""yes"") {
			PutModule(""This module hit a timeout which is possibly a bug."");
			PutModule(""Use \""silent yes\"" to disable this message."");
			PutModule(""Last request: "" + m_sLastRequest);
			PutModule(""Expected replies: "");

			for (size_t i = 0; m_pReplies[i].szReply != NULL; i++) {
				if (m_pReplies[i].bLastResponse)
					PutModule(m_pReplies[i].szReply +
							CString("" (last)""));
				else
					PutModule(m_pReplies[i].szReply);
			}
		}

		m_pDoing = NULL;
		m_pReplies = NULL;
		SendRequest();
	}

private:
	bool RouteReply(const CString& sLine, bool bFinished = false, bool bIsRaw353 = false)
	{
		if (!m_pDoing)
			return false;

		// 353 needs special treatment due to NAMESX and UHNAMES
		if (bIsRaw353)
			GetUser()->GetIRCSock()->ForwardRaw353(sLine, m_pDoing);
		else
			m_pDoing->PutClient(sLine);

		if (bFinished) {
			// Stop the timeout
			RemTimer(""RouteTimeout"");

			m_pDoing = NULL;
			m_pReplies = NULL;
			SendRequest();
		}

		return true;
	}

	void SendRequest()
	{
		requestQueue::iterator it;

		if (m_pDoing || m_pReplies)
			return;

		if (m_vsPending.empty())
			return;

		it = m_vsPending.begin();

		if (it->second.empty()) {
			m_vsPending.erase(it);
			SendRequest();
			return;
		}

		// When we are called from the timer, we need to remove it.
		// We can't delete it (segfault on return), thus we
		// just stop it. The main loop will delete it.
		CTimer *pTimer = FindTimer(""RouteTimeout"");
		if (pTimer) {
			pTimer->Stop();
			UnlinkTimer(pTimer);
		}
		AddTimer(new CRouteTimeout(this, 60, 1, ""RouteTimeout"",
				""Recover from missing / wrong server replies""));

		m_pDoing = it->first;
		m_pReplies = it->second[0].reply;
		m_sLastRequest = it->second[0].sLine;
		PutIRC(it->second[0].sLine);
		it->second.erase(it->second.begin());
	}

	virtual void OnModCommand(const CString& sCommand) {
		const CString sCmd = sCommand.Token(0);
		const CString sArgs = sCommand.Token(1, true);

		if (sCmd.Equals(""silent"")) {
			if (sArgs.Equals(""yes"")) {
				SetNV(""silent_timeouts"", ""yes"");
				PutModule(""Disabled timeout messages"");
			} else if (sArgs.Equals(""no"")) {
				DelNV(""silent_timeouts"");
				PutModule(""Enabled timeout messages"");
			} else if (sArgs.empty()) {
				if (GetNV(""silent_timeouts"") == ""yes"")
					PutModule(""Timeout messages are disabled"");
				else
					PutModule(""Timeout message are enabled"");
			} else
				PutModule(""Invalid argument"");
		} else {
			PutModule(""Available commands: silent [yes/no], silent"");
		}
	}

	CClient            *m_pDoing;
	const struct reply *m_pReplies;
	requestQueue        m_vsPending;
	// This field is only used for display purpose.
	CString             m_sLastRequest;
};

void CRouteTimeout::RunJob()
{
	CRouteRepliesMod *pMod = (CRouteRepliesMod *) m_pModule;
	pMod->Timeout();
}

MODULEDEFS(CRouteRepliesMod, ""Send replies (e.g. to /who) to the right client only"")
""",CRouteRepliesMod::OnUserRaw,[231:252]
znc,https://github.com/znc/znc/commit/84199641650e2f9a80d0a872782100135d36323b,"""watch: Use empty() instead of !size()

Yay for useless micro-optimizations. ;-)

Signed-off-by: Uli Schlachter <psychon@znc.in>""","""/*
 * Copyright (C) 2004-2011  See the AUTHORS file for details.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 as published
 * by the Free Software Foundation.
 */

#include ""Chan.h""
#include ""User.h""
#include <list>

using std::list;

class CWatchSource {
public:
	CWatchSource(const CString& sSource, bool bNegated) {
		m_sSource = sSource;
		m_bNegated = bNegated;
	}
	virtual ~CWatchSource() {}

	// Getters
	const CString& GetSource() const { return m_sSource; }
	bool IsNegated() const { return m_bNegated; }
	// !Getters

	// Setters
	// !Setters
private:
protected:
	bool    m_bNegated;
	CString m_sSource;
};

class CWatchEntry {
public:
	CWatchEntry(const CString& sHostMask, const CString& sTarget, const CString& sPattern) {
		m_bDisabled = false;
		m_sPattern = (sPattern.size()) ? sPattern : ""*"";

		CNick Nick;
		Nick.Parse(sHostMask);

		m_sHostMask = (Nick.GetNick().size()) ? Nick.GetNick() : ""*"";
		m_sHostMask += ""!"";
		m_sHostMask += (Nick.GetIdent().size()) ? Nick.GetIdent() : ""*"";
		m_sHostMask += ""@"";
		m_sHostMask += (Nick.GetHost().size()) ? Nick.GetHost() : ""*"";

		if (sTarget.size()) {
			m_sTarget = sTarget;
		} else {
			m_sTarget = ""$"";
			m_sTarget += Nick.GetNick();
		}
	}
	virtual ~CWatchEntry() {}

	bool IsMatch(const CNick& Nick, const CString& sText, const CString& sSource, const CUser* pUser) {
		if (IsDisabled()) {
			return false;
		}

		bool bGoodSource = true;

		if (sSource.size() && m_vsSources.size()) {
			bGoodSource = false;

			for (unsigned int a = 0; a < m_vsSources.size(); a++) {
				const CWatchSource& WatchSource = m_vsSources[a];

				if (sSource.AsLower().WildCmp(WatchSource.GetSource().AsLower())) {
					if (WatchSource.IsNegated()) {
						return false;
					} else {
						bGoodSource = true;
					}
				}
			}
		}

		if (!bGoodSource)
			return false;
		if (!Nick.GetHostMask().AsLower().WildCmp(m_sHostMask.AsLower()))
			return false;
		if (!sText.AsLower().WildCmp(pUser->ExpandString(m_sPattern).AsLower()))
			return false;

		return true;
	}

	bool operator ==(const CWatchEntry& WatchEntry) {
		return (GetHostMask().Equals(WatchEntry.GetHostMask())
				&& GetTarget().Equals(WatchEntry.GetTarget())
				&& GetPattern().Equals(WatchEntry.GetPattern())
		);
	}

	// Getters
	const CString& GetHostMask() const { return m_sHostMask; }
	const CString& GetTarget() const { return m_sTarget; }
	const CString& GetPattern() const { return m_sPattern; }
	bool IsDisabled() const { return m_bDisabled; }
	const vector<CWatchSource>& GetSources() const { return m_vsSources; }
	CString GetSourcesStr() const {
		CString sRet;

		for (unsigned int a = 0; a < m_vsSources.size(); a++) {
			const CWatchSource& WatchSource = m_vsSources[a];

			if (a) {
				sRet += "" "";
			}

			if (WatchSource.IsNegated()) {
				sRet += ""!"";
			}

			sRet += WatchSource.GetSource();
		}

		return sRet;
	}
	// !Getters

	// Setters
	void SetHostMask(const CString& s) { m_sHostMask = s; }
	void SetTarget(const CString& s) { m_sTarget = s; }
	void SetPattern(const CString& s) { m_sPattern = s; }
	void SetDisabled(bool b = true) { m_bDisabled = b; }
	void SetSources(const CString& sSources) {
		VCString vsSources;
		VCString::iterator it;
		sSources.Split("" "", vsSources, false);

		m_vsSources.clear();

		for (it = vsSources.begin(); it != vsSources.end(); ++it) {
			if (it->at(0) == '!' && it->size() > 1) {
				m_vsSources.push_back(CWatchSource(it->substr(1), true));
			} else {
				m_vsSources.push_back(CWatchSource(*it, false));
			}
		}
	}
	// !Setters
private:
protected:
	CString              m_sHostMask;
	CString              m_sTarget;
	CString              m_sPattern;
	bool                 m_bDisabled;
	vector<CWatchSource> m_vsSources;
};

class CWatcherMod : public CModule {
public:
	MODCONSTRUCTOR(CWatcherMod) {
		m_Buffer.SetLineCount(500);
		Load();
	}

	virtual ~CWatcherMod() {}

	virtual void OnRawMode(const CNick& OpNick, CChan& Channel, const CString& sModes, const CString& sArgs) {
		Process(OpNick, ""* "" + OpNick.GetNick() + "" sets mode: "" + sModes + "" "" +
			sArgs + "" on "" + Channel.GetName(), Channel.GetName());
	}

	virtual void OnClientLogin() {
		CString sBufLine;
		while (m_Buffer.GetNextLine(m_pUser->GetCurNick(), sBufLine)) {
			PutUser(sBufLine);
		}

		m_Buffer.Clear();
	}

	virtual void OnKick(const CNick& OpNick, const CString& sKickedNick, CChan& Channel, const CString& sMessage) {
		Process(OpNick, ""* "" + OpNick.GetNick() + "" kicked "" + sKickedNick + "" from "" + 
			Channel.GetName() + "" because ["" + sMessage + ""]"", Channel.GetName());
	}

	virtual void OnQuit(const CNick& Nick, const CString& sMessage, const vector<CChan*>& vChans) {
		Process(Nick, ""* Quits: "" + Nick.GetNick() + "" ("" + Nick.GetIdent() + ""@"" + Nick.GetHost() + "") ""
			""("" + sMessage + "")"", """");
	}

	virtual void OnJoin(const CNick& Nick, CChan& Channel) {
		Process(Nick, ""* "" + Nick.GetNick() + "" ("" + Nick.GetIdent() + ""@"" + Nick.GetHost() + "") joins "" +
			Channel.GetName(), Channel.GetName());
	}

	virtual void OnPart(const CNick& Nick, CChan& Channel, const CString& sMessage) {
		Process(Nick, ""* "" + Nick.GetNick() + "" ("" + Nick.GetIdent() + ""@"" + Nick.GetHost() + "") parts "" +
			Channel.GetName() + ""("" + sMessage + "")"", Channel.GetName());
	}

	virtual void OnNick(const CNick& OldNick, const CString& sNewNick, const vector<CChan*>& vChans) {
		Process(OldNick, ""* "" + OldNick.GetNick() + "" is now known as "" + sNewNick, """");
	}

	virtual EModRet OnCTCPReply(CNick& Nick, CString& sMessage) {
		Process(Nick, ""* CTCP: "" + Nick.GetNick() + "" reply ["" + sMessage + ""]"", ""priv"");
		return CONTINUE;
	}

	virtual EModRet OnPrivCTCP(CNick& Nick, CString& sMessage) {
		Process(Nick, ""* CTCP: "" + Nick.GetNick() + "" ["" + sMessage + ""]"", ""priv"");
		return CONTINUE;
	}

	virtual EModRet OnChanCTCP(CNick& Nick, CChan& Channel, CString& sMessage) {
		Process(Nick, ""* CTCP: "" + Nick.GetNick() + "" ["" + sMessage + ""] to ""
			""["" + Channel.GetName() + ""]"", Channel.GetName());
		return CONTINUE;
	}

	virtual EModRet OnPrivNotice(CNick& Nick, CString& sMessage) {
		Process(Nick, ""-"" + Nick.GetNick() + ""- "" + sMessage, ""priv"");
		return CONTINUE;
	}

	virtual EModRet OnChanNotice(CNick& Nick, CChan& Channel, CString& sMessage) {
		Process(Nick, ""-"" + Nick.GetNick() + "":"" + Channel.GetName() + ""- "" + sMessage, Channel.GetName());
		return CONTINUE;
	}

	virtual EModRet OnPrivMsg(CNick& Nick, CString& sMessage) {
		Process(Nick, ""<"" + Nick.GetNick() + ""> "" + sMessage, ""priv"");
		return CONTINUE;
	}

	virtual EModRet OnChanMsg(CNick& Nick, CChan& Channel, CString& sMessage) {
		Process(Nick, ""<"" + Nick.GetNick() + "":"" + Channel.GetName() + ""> "" + sMessage, Channel.GetName());
		return CONTINUE;
	}

	virtual void OnModCommand(const CString& sCommand) {
		CString sCmdName = sCommand.Token(0);
		if (sCmdName.Equals(""ADD"") || sCmdName.Equals(""WATCH"")) {
			Watch(sCommand.Token(1), sCommand.Token(2), sCommand.Token(3, true));
		} else if (sCmdName.Equals(""HELP"")) {
			Help();
		} else if (sCmdName.Equals(""LIST"")) {
			List();
		} else if (sCmdName.Equals(""DUMP"")) {
			Dump();
		} else if (sCmdName.Equals(""ENABLE"")) {
			CString sTok = sCommand.Token(1);

			if (sTok == ""*"") {
				SetDisabled(~0, false);
			} else {
				SetDisabled(sTok.ToUInt(), false);
			}
		} else if (sCmdName.Equals(""DISABLE"")) {
			CString sTok = sCommand.Token(1);

			if (sTok == ""*"") {
				SetDisabled(~0, true);
			} else {
				SetDisabled(sTok.ToUInt(), true);
			}
		} else if (sCmdName.Equals(""SETSOURCES"")) {
			SetSources(sCommand.Token(1).ToUInt(), sCommand.Token(2, true));
		} else if (sCmdName.Equals(""CLEAR"")) {
			m_lsWatchers.clear();
			PutModule(""All entries cleared."");
			Save();
		} else if (sCmdName.Equals(""BUFFER"")) {
			CString sCount = sCommand.Token(1);

			if (sCount.size()) {
				m_Buffer.SetLineCount(sCount.ToUInt());
			}

			PutModule(""Buffer count is set to ["" + CString(m_Buffer.GetLineCount()) + ""]"");
		} else if (sCmdName.Equals(""DEL"")) {
			Remove(sCommand.Token(1).ToUInt());
		} else {
			PutModule(""Unknown command: ["" + sCmdName + ""]"");
		}
	}

private:
	void Process(const CNick& Nick, const CString& sMessage, const CString& sSource) {
		for (list<CWatchEntry>::iterator it = m_lsWatchers.begin(); it != m_lsWatchers.end(); ++it) {
			CWatchEntry& WatchEntry = *it;

			if (WatchEntry.IsMatch(Nick, sMessage, sSource, m_pUser)) {
				if (m_pUser->IsUserAttached()) {
					m_pUser->PutUser("":"" + WatchEntry.GetTarget() + ""!watch@znc.in PRIVMSG "" +
							m_pUser->GetCurNick() + "" :"" + sMessage);
				} else {
					m_Buffer.AddLine("":"" + WatchEntry.GetTarget() + ""!watch@znc.in PRIVMSG "",
							"" :"" + m_pUser->AddTimestamp(sMessage));
				}
			}
		}
	}

	void SetDisabled(unsigned int uIdx, bool bDisabled) {
		if (uIdx == (unsigned int) ~0) {
			for (list<CWatchEntry>::iterator it = m_lsWatchers.begin(); it != m_lsWatchers.end(); ++it) {
				(*it).SetDisabled(bDisabled);
			}

			PutModule(((bDisabled) ? ""Disabled all entries."" : ""Enabled all entries.""));
			Save();
			return;
		}

		uIdx--; // ""convert"" index to zero based
		if (uIdx >= m_lsWatchers.size()) {
			PutModule(""Invalid Id"");
			return;
		}

		list<CWatchEntry>::iterator it = m_lsWatchers.begin();
		for (unsigned int a = 0; a < uIdx; a++)
			it++;

		(*it).SetDisabled(bDisabled);
		PutModule(""Id "" + CString(uIdx +1) + ((bDisabled) ? "" Disabled"" : "" Enabled""));
		Save();
	}

	void List() {
		CTable Table;
		Table.AddColumn(""Id"");
		Table.AddColumn(""HostMask"");
		Table.AddColumn(""Target"");
		Table.AddColumn(""Pattern"");
		Table.AddColumn(""Sources"");
		Table.AddColumn(""Off"");

		unsigned int uIdx = 1;

		for (list<CWatchEntry>::iterator it = m_lsWatchers.begin(); it != m_lsWatchers.end(); it++, uIdx++) {
			CWatchEntry& WatchEntry = *it;

			Table.AddRow();
			Table.SetCell(""Id"", CString(uIdx));
			Table.SetCell(""HostMask"", WatchEntry.GetHostMask());
			Table.SetCell(""Target"", WatchEntry.GetTarget());
			Table.SetCell(""Pattern"", WatchEntry.GetPattern());
			Table.SetCell(""Sources"", WatchEntry.GetSourcesStr());
			Table.SetCell(""Off"", (WatchEntry.IsDisabled()) ? ""Off"" : """");
		}

		if (Table.size()) {
			PutModule(Table);
		} else {
			PutModule(""You have no entries."");
		}
	}

	void Dump() {
		if (!m_lsWatchers.size()) {
			PutModule(""You have no entries."");
			return;
		}

		PutModule(""---------------"");
		PutModule(""/msg "" + GetModNick() + "" CLEAR"");

		unsigned int uIdx = 1;

		for (list<CWatchEntry>::iterator it = m_lsWatchers.begin(); it != m_lsWatchers.end(); it++, uIdx++) {
			CWatchEntry& WatchEntry = *it;

			PutModule(""/msg "" + GetModNick() + "" ADD "" + WatchEntry.GetHostMask() + "" "" +
				WatchEntry.GetTarget() + "" "" + WatchEntry.GetPattern());

			if (WatchEntry.GetSourcesStr().size()) {
				PutModule(""/msg "" + GetModNick() + "" SETSOURCES "" + CString(uIdx) + "" "" +
					WatchEntry.GetSourcesStr());
			}

			if (WatchEntry.IsDisabled()) {
				PutModule(""/msg "" + GetModNick() + "" DISABLE "" + CString(uIdx));
			}
		}

		PutModule(""---------------"");
	}

	void SetSources(unsigned int uIdx, const CString& sSources) {
		uIdx--; // ""convert"" index to zero based
		if (uIdx >= m_lsWatchers.size()) {
			PutModule(""Invalid Id"");
			return;
		}

		list<CWatchEntry>::iterator it = m_lsWatchers.begin();
		for (unsigned int a = 0; a < uIdx; a++)
			it++;

		(*it).SetSources(sSources);
		PutModule(""Sources set for Id "" + CString(uIdx +1) + ""."");
		Save();
	}

	void Remove(unsigned int uIdx) {
		uIdx--; // ""convert"" index to zero based
		if (uIdx >= m_lsWatchers.size()) {
			PutModule(""Invalid Id"");
			return;
		}

		list<CWatchEntry>::iterator it = m_lsWatchers.begin();
		for (unsigned int a = 0; a < uIdx; a++)
			it++;

		m_lsWatchers.erase(it);
		PutModule(""Id "" + CString(uIdx +1) + "" Removed."");
		Save();
	}

	void Help() {
		CTable Table;

		Table.AddColumn(""Command"");
		Table.AddColumn(""Description"");

		Table.AddRow();
		Table.SetCell(""Command"", ""Add <HostMask> [Target] [Pattern]"");
		Table.SetCell(""Description"", ""Used to add an entry to watch for."");

		Table.AddRow();
		Table.SetCell(""Command"", ""List"");
		Table.SetCell(""Description"", ""List all entries being watched."");

		Table.AddRow();
		Table.SetCell(""Command"", ""Dump"");
		Table.SetCell(""Description"", ""Dump a list of all current entries to be used later."");

		Table.AddRow();
		Table.SetCell(""Command"", ""Del <Id>"");
		Table.SetCell(""Description"", ""Deletes Id from the list of watched entries."");

		Table.AddRow();
		Table.SetCell(""Command"", ""Clear"");
		Table.SetCell(""Description"", ""Delete all entries."");

		Table.AddRow();
		Table.SetCell(""Command"", ""Enable <Id | *>"");
		Table.SetCell(""Description"", ""Enable a disabled entry."");

		Table.AddRow();
		Table.SetCell(""Command"", ""Disable <Id | *>"");
		Table.SetCell(""Description"", ""Disable (but don't delete) an entry."");

		Table.AddRow();
		Table.SetCell(""Command"", ""Buffer [Count]"");
		Table.SetCell(""Description"", ""Show/Set the amount of buffered lines while detached."");

		Table.AddRow();
		Table.SetCell(""Command"", ""SetSources <Id> [#chan priv #foo* !#bar]"");
		Table.SetCell(""Description"", ""Set the source channels that you care about."");

		Table.AddRow();
		Table.SetCell(""Command"", ""Help"");
		Table.SetCell(""Description"", ""This help."");

		PutModule(Table);
	}

	void Watch(const CString& sHostMask, const CString& sTarget, const CString& sPattern, bool bNotice = false) {
		CString sMessage;

		if (sHostMask.size()) {
			CWatchEntry WatchEntry(sHostMask, sTarget, sPattern);

			bool bExists = false;
			for (list<CWatchEntry>::iterator it = m_lsWatchers.begin(); it != m_lsWatchers.end(); ++it) {
				if (*it == WatchEntry) {
					sMessage = ""Entry for ["" + WatchEntry.GetHostMask() + ""] already exists."";
					bExists = true;
					break;
				}
			}

			if (!bExists) {
				sMessage = ""Adding entry: ["" + WatchEntry.GetHostMask() + ""] watching for ""
					""["" + WatchEntry.GetPattern() + ""] -> ["" + WatchEntry.GetTarget() + ""]"";
				m_lsWatchers.push_back(WatchEntry);
			}
		} else {
			sMessage = ""Watch: Not enough arguments.  Try Help"";
		}

		if (bNotice) {
			PutModNotice(sMessage);
		} else {
			PutModule(sMessage);
		}
		Save();
	}

	void Save() {
		ClearNV(false);
		for (list<CWatchEntry>::iterator it = m_lsWatchers.begin(); it != m_lsWatchers.end(); ++it) {
			CWatchEntry& WatchEntry = *it;
			CString sSave;

			sSave  = WatchEntry.GetHostMask() + ""\n"";
			sSave += WatchEntry.GetTarget() + ""\n"";
			sSave += WatchEntry.GetPattern() + ""\n"";
			sSave += (WatchEntry.IsDisabled() ? ""disabled\n"" : ""enabled\n"");
			sSave += WatchEntry.GetSourcesStr();
			// Without this, loading fails if GetSourcesStr()
			// returns an empty string
			sSave += "" "";

			SetNV(sSave, """", false);
		}

		SaveRegistry();
	}

	void Load() {
		// Just to make sure we dont mess up badly
		m_lsWatchers.clear();

		bool bWarn = false;

		for (MCString::iterator it = BeginNV(); it != EndNV(); ++it) {
			VCString vList;
			it->first.Split(""\n"", vList);

			if (vList.size() != 5) {
				bWarn = true;
				continue;
			}

			CWatchEntry WatchEntry(vList[0], vList[1], vList[2]);
			if (vList[3].Equals(""disabled""))
				WatchEntry.SetDisabled(true);
			else
				WatchEntry.SetDisabled(false);
			WatchEntry.SetSources(vList[4]);
			m_lsWatchers.push_back(WatchEntry);
		}

		if (bWarn)
			PutModule(""WARNING: malformed entry found while loading"");
	}

	list<CWatchEntry>  m_lsWatchers;
	CBuffer            m_Buffer;
};

MODULEDEFS(CWatcherMod, ""Copy activity from a specific user into a separate window"")
""","""/*
 * Copyright (C) 2004-2011  See the AUTHORS file for details.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 as published
 * by the Free Software Foundation.
 */

#include ""Chan.h""
#include ""User.h""
#include <list>

using std::list;

class CWatchSource {
public:
	CWatchSource(const CString& sSource, bool bNegated) {
		m_sSource = sSource;
		m_bNegated = bNegated;
	}
	virtual ~CWatchSource() {}

	// Getters
	const CString& GetSource() const { return m_sSource; }
	bool IsNegated() const { return m_bNegated; }
	// !Getters

	// Setters
	// !Setters
private:
protected:
	bool    m_bNegated;
	CString m_sSource;
};

class CWatchEntry {
public:
	CWatchEntry(const CString& sHostMask, const CString& sTarget, const CString& sPattern) {
		m_bDisabled = false;
		m_sPattern = (sPattern.size()) ? sPattern : ""*"";

		CNick Nick;
		Nick.Parse(sHostMask);

		m_sHostMask = (Nick.GetNick().size()) ? Nick.GetNick() : ""*"";
		m_sHostMask += ""!"";
		m_sHostMask += (Nick.GetIdent().size()) ? Nick.GetIdent() : ""*"";
		m_sHostMask += ""@"";
		m_sHostMask += (Nick.GetHost().size()) ? Nick.GetHost() : ""*"";

		if (sTarget.size()) {
			m_sTarget = sTarget;
		} else {
			m_sTarget = ""$"";
			m_sTarget += Nick.GetNick();
		}
	}
	virtual ~CWatchEntry() {}

	bool IsMatch(const CNick& Nick, const CString& sText, const CString& sSource, const CUser* pUser) {
		if (IsDisabled()) {
			return false;
		}

		bool bGoodSource = true;

		if (sSource.size() && m_vsSources.size()) {
			bGoodSource = false;

			for (unsigned int a = 0; a < m_vsSources.size(); a++) {
				const CWatchSource& WatchSource = m_vsSources[a];

				if (sSource.AsLower().WildCmp(WatchSource.GetSource().AsLower())) {
					if (WatchSource.IsNegated()) {
						return false;
					} else {
						bGoodSource = true;
					}
				}
			}
		}

		if (!bGoodSource)
			return false;
		if (!Nick.GetHostMask().AsLower().WildCmp(m_sHostMask.AsLower()))
			return false;
		if (!sText.AsLower().WildCmp(pUser->ExpandString(m_sPattern).AsLower()))
			return false;

		return true;
	}

	bool operator ==(const CWatchEntry& WatchEntry) {
		return (GetHostMask().Equals(WatchEntry.GetHostMask())
				&& GetTarget().Equals(WatchEntry.GetTarget())
				&& GetPattern().Equals(WatchEntry.GetPattern())
		);
	}

	// Getters
	const CString& GetHostMask() const { return m_sHostMask; }
	const CString& GetTarget() const { return m_sTarget; }
	const CString& GetPattern() const { return m_sPattern; }
	bool IsDisabled() const { return m_bDisabled; }
	const vector<CWatchSource>& GetSources() const { return m_vsSources; }
	CString GetSourcesStr() const {
		CString sRet;

		for (unsigned int a = 0; a < m_vsSources.size(); a++) {
			const CWatchSource& WatchSource = m_vsSources[a];

			if (a) {
				sRet += "" "";
			}

			if (WatchSource.IsNegated()) {
				sRet += ""!"";
			}

			sRet += WatchSource.GetSource();
		}

		return sRet;
	}
	// !Getters

	// Setters
	void SetHostMask(const CString& s) { m_sHostMask = s; }
	void SetTarget(const CString& s) { m_sTarget = s; }
	void SetPattern(const CString& s) { m_sPattern = s; }
	void SetDisabled(bool b = true) { m_bDisabled = b; }
	void SetSources(const CString& sSources) {
		VCString vsSources;
		VCString::iterator it;
		sSources.Split("" "", vsSources, false);

		m_vsSources.clear();

		for (it = vsSources.begin(); it != vsSources.end(); ++it) {
			if (it->at(0) == '!' && it->size() > 1) {
				m_vsSources.push_back(CWatchSource(it->substr(1), true));
			} else {
				m_vsSources.push_back(CWatchSource(*it, false));
			}
		}
	}
	// !Setters
private:
protected:
	CString              m_sHostMask;
	CString              m_sTarget;
	CString              m_sPattern;
	bool                 m_bDisabled;
	vector<CWatchSource> m_vsSources;
};

class CWatcherMod : public CModule {
public:
	MODCONSTRUCTOR(CWatcherMod) {
		m_Buffer.SetLineCount(500);
		Load();
	}

	virtual ~CWatcherMod() {}

	virtual void OnRawMode(const CNick& OpNick, CChan& Channel, const CString& sModes, const CString& sArgs) {
		Process(OpNick, ""* "" + OpNick.GetNick() + "" sets mode: "" + sModes + "" "" +
			sArgs + "" on "" + Channel.GetName(), Channel.GetName());
	}

	virtual void OnClientLogin() {
		CString sBufLine;
		while (m_Buffer.GetNextLine(m_pUser->GetCurNick(), sBufLine)) {
			PutUser(sBufLine);
		}

		m_Buffer.Clear();
	}

	virtual void OnKick(const CNick& OpNick, const CString& sKickedNick, CChan& Channel, const CString& sMessage) {
		Process(OpNick, ""* "" + OpNick.GetNick() + "" kicked "" + sKickedNick + "" from "" + 
			Channel.GetName() + "" because ["" + sMessage + ""]"", Channel.GetName());
	}

	virtual void OnQuit(const CNick& Nick, const CString& sMessage, const vector<CChan*>& vChans) {
		Process(Nick, ""* Quits: "" + Nick.GetNick() + "" ("" + Nick.GetIdent() + ""@"" + Nick.GetHost() + "") ""
			""("" + sMessage + "")"", """");
	}

	virtual void OnJoin(const CNick& Nick, CChan& Channel) {
		Process(Nick, ""* "" + Nick.GetNick() + "" ("" + Nick.GetIdent() + ""@"" + Nick.GetHost() + "") joins "" +
			Channel.GetName(), Channel.GetName());
	}

	virtual void OnPart(const CNick& Nick, CChan& Channel, const CString& sMessage) {
		Process(Nick, ""* "" + Nick.GetNick() + "" ("" + Nick.GetIdent() + ""@"" + Nick.GetHost() + "") parts "" +
			Channel.GetName() + ""("" + sMessage + "")"", Channel.GetName());
	}

	virtual void OnNick(const CNick& OldNick, const CString& sNewNick, const vector<CChan*>& vChans) {
		Process(OldNick, ""* "" + OldNick.GetNick() + "" is now known as "" + sNewNick, """");
	}

	virtual EModRet OnCTCPReply(CNick& Nick, CString& sMessage) {
		Process(Nick, ""* CTCP: "" + Nick.GetNick() + "" reply ["" + sMessage + ""]"", ""priv"");
		return CONTINUE;
	}

	virtual EModRet OnPrivCTCP(CNick& Nick, CString& sMessage) {
		Process(Nick, ""* CTCP: "" + Nick.GetNick() + "" ["" + sMessage + ""]"", ""priv"");
		return CONTINUE;
	}

	virtual EModRet OnChanCTCP(CNick& Nick, CChan& Channel, CString& sMessage) {
		Process(Nick, ""* CTCP: "" + Nick.GetNick() + "" ["" + sMessage + ""] to ""
			""["" + Channel.GetName() + ""]"", Channel.GetName());
		return CONTINUE;
	}

	virtual EModRet OnPrivNotice(CNick& Nick, CString& sMessage) {
		Process(Nick, ""-"" + Nick.GetNick() + ""- "" + sMessage, ""priv"");
		return CONTINUE;
	}

	virtual EModRet OnChanNotice(CNick& Nick, CChan& Channel, CString& sMessage) {
		Process(Nick, ""-"" + Nick.GetNick() + "":"" + Channel.GetName() + ""- "" + sMessage, Channel.GetName());
		return CONTINUE;
	}

	virtual EModRet OnPrivMsg(CNick& Nick, CString& sMessage) {
		Process(Nick, ""<"" + Nick.GetNick() + ""> "" + sMessage, ""priv"");
		return CONTINUE;
	}

	virtual EModRet OnChanMsg(CNick& Nick, CChan& Channel, CString& sMessage) {
		Process(Nick, ""<"" + Nick.GetNick() + "":"" + Channel.GetName() + ""> "" + sMessage, Channel.GetName());
		return CONTINUE;
	}

	virtual void OnModCommand(const CString& sCommand) {
		CString sCmdName = sCommand.Token(0);
		if (sCmdName.Equals(""ADD"") || sCmdName.Equals(""WATCH"")) {
			Watch(sCommand.Token(1), sCommand.Token(2), sCommand.Token(3, true));
		} else if (sCmdName.Equals(""HELP"")) {
			Help();
		} else if (sCmdName.Equals(""LIST"")) {
			List();
		} else if (sCmdName.Equals(""DUMP"")) {
			Dump();
		} else if (sCmdName.Equals(""ENABLE"")) {
			CString sTok = sCommand.Token(1);

			if (sTok == ""*"") {
				SetDisabled(~0, false);
			} else {
				SetDisabled(sTok.ToUInt(), false);
			}
		} else if (sCmdName.Equals(""DISABLE"")) {
			CString sTok = sCommand.Token(1);

			if (sTok == ""*"") {
				SetDisabled(~0, true);
			} else {
				SetDisabled(sTok.ToUInt(), true);
			}
		} else if (sCmdName.Equals(""SETSOURCES"")) {
			SetSources(sCommand.Token(1).ToUInt(), sCommand.Token(2, true));
		} else if (sCmdName.Equals(""CLEAR"")) {
			m_lsWatchers.clear();
			PutModule(""All entries cleared."");
			Save();
		} else if (sCmdName.Equals(""BUFFER"")) {
			CString sCount = sCommand.Token(1);

			if (sCount.size()) {
				m_Buffer.SetLineCount(sCount.ToUInt());
			}

			PutModule(""Buffer count is set to ["" + CString(m_Buffer.GetLineCount()) + ""]"");
		} else if (sCmdName.Equals(""DEL"")) {
			Remove(sCommand.Token(1).ToUInt());
		} else {
			PutModule(""Unknown command: ["" + sCmdName + ""]"");
		}
	}

private:
	void Process(const CNick& Nick, const CString& sMessage, const CString& sSource) {
		for (list<CWatchEntry>::iterator it = m_lsWatchers.begin(); it != m_lsWatchers.end(); ++it) {
			CWatchEntry& WatchEntry = *it;

			if (WatchEntry.IsMatch(Nick, sMessage, sSource, m_pUser)) {
				if (m_pUser->IsUserAttached()) {
					m_pUser->PutUser("":"" + WatchEntry.GetTarget() + ""!watch@znc.in PRIVMSG "" +
							m_pUser->GetCurNick() + "" :"" + sMessage);
				} else {
					m_Buffer.AddLine("":"" + WatchEntry.GetTarget() + ""!watch@znc.in PRIVMSG "",
							"" :"" + m_pUser->AddTimestamp(sMessage));
				}
			}
		}
	}

	void SetDisabled(unsigned int uIdx, bool bDisabled) {
		if (uIdx == (unsigned int) ~0) {
			for (list<CWatchEntry>::iterator it = m_lsWatchers.begin(); it != m_lsWatchers.end(); ++it) {
				(*it).SetDisabled(bDisabled);
			}

			PutModule(((bDisabled) ? ""Disabled all entries."" : ""Enabled all entries.""));
			Save();
			return;
		}

		uIdx--; // ""convert"" index to zero based
		if (uIdx >= m_lsWatchers.size()) {
			PutModule(""Invalid Id"");
			return;
		}

		list<CWatchEntry>::iterator it = m_lsWatchers.begin();
		for (unsigned int a = 0; a < uIdx; a++)
			it++;

		(*it).SetDisabled(bDisabled);
		PutModule(""Id "" + CString(uIdx +1) + ((bDisabled) ? "" Disabled"" : "" Enabled""));
		Save();
	}

	void List() {
		CTable Table;
		Table.AddColumn(""Id"");
		Table.AddColumn(""HostMask"");
		Table.AddColumn(""Target"");
		Table.AddColumn(""Pattern"");
		Table.AddColumn(""Sources"");
		Table.AddColumn(""Off"");

		unsigned int uIdx = 1;

		for (list<CWatchEntry>::iterator it = m_lsWatchers.begin(); it != m_lsWatchers.end(); it++, uIdx++) {
			CWatchEntry& WatchEntry = *it;

			Table.AddRow();
			Table.SetCell(""Id"", CString(uIdx));
			Table.SetCell(""HostMask"", WatchEntry.GetHostMask());
			Table.SetCell(""Target"", WatchEntry.GetTarget());
			Table.SetCell(""Pattern"", WatchEntry.GetPattern());
			Table.SetCell(""Sources"", WatchEntry.GetSourcesStr());
			Table.SetCell(""Off"", (WatchEntry.IsDisabled()) ? ""Off"" : """");
		}

		if (Table.size()) {
			PutModule(Table);
		} else {
			PutModule(""You have no entries."");
		}
	}

	void Dump() {
		if (m_lsWatchers.empty()) {
			PutModule(""You have no entries."");
			return;
		}

		PutModule(""---------------"");
		PutModule(""/msg "" + GetModNick() + "" CLEAR"");

		unsigned int uIdx = 1;

		for (list<CWatchEntry>::iterator it = m_lsWatchers.begin(); it != m_lsWatchers.end(); it++, uIdx++) {
			CWatchEntry& WatchEntry = *it;

			PutModule(""/msg "" + GetModNick() + "" ADD "" + WatchEntry.GetHostMask() + "" "" +
				WatchEntry.GetTarget() + "" "" + WatchEntry.GetPattern());

			if (WatchEntry.GetSourcesStr().size()) {
				PutModule(""/msg "" + GetModNick() + "" SETSOURCES "" + CString(uIdx) + "" "" +
					WatchEntry.GetSourcesStr());
			}

			if (WatchEntry.IsDisabled()) {
				PutModule(""/msg "" + GetModNick() + "" DISABLE "" + CString(uIdx));
			}
		}

		PutModule(""---------------"");
	}

	void SetSources(unsigned int uIdx, const CString& sSources) {
		uIdx--; // ""convert"" index to zero based
		if (uIdx >= m_lsWatchers.size()) {
			PutModule(""Invalid Id"");
			return;
		}

		list<CWatchEntry>::iterator it = m_lsWatchers.begin();
		for (unsigned int a = 0; a < uIdx; a++)
			it++;

		(*it).SetSources(sSources);
		PutModule(""Sources set for Id "" + CString(uIdx +1) + ""."");
		Save();
	}

	void Remove(unsigned int uIdx) {
		uIdx--; // ""convert"" index to zero based
		if (uIdx >= m_lsWatchers.size()) {
			PutModule(""Invalid Id"");
			return;
		}

		list<CWatchEntry>::iterator it = m_lsWatchers.begin();
		for (unsigned int a = 0; a < uIdx; a++)
			it++;

		m_lsWatchers.erase(it);
		PutModule(""Id "" + CString(uIdx +1) + "" Removed."");
		Save();
	}

	void Help() {
		CTable Table;

		Table.AddColumn(""Command"");
		Table.AddColumn(""Description"");

		Table.AddRow();
		Table.SetCell(""Command"", ""Add <HostMask> [Target] [Pattern]"");
		Table.SetCell(""Description"", ""Used to add an entry to watch for."");

		Table.AddRow();
		Table.SetCell(""Command"", ""List"");
		Table.SetCell(""Description"", ""List all entries being watched."");

		Table.AddRow();
		Table.SetCell(""Command"", ""Dump"");
		Table.SetCell(""Description"", ""Dump a list of all current entries to be used later."");

		Table.AddRow();
		Table.SetCell(""Command"", ""Del <Id>"");
		Table.SetCell(""Description"", ""Deletes Id from the list of watched entries."");

		Table.AddRow();
		Table.SetCell(""Command"", ""Clear"");
		Table.SetCell(""Description"", ""Delete all entries."");

		Table.AddRow();
		Table.SetCell(""Command"", ""Enable <Id | *>"");
		Table.SetCell(""Description"", ""Enable a disabled entry."");

		Table.AddRow();
		Table.SetCell(""Command"", ""Disable <Id | *>"");
		Table.SetCell(""Description"", ""Disable (but don't delete) an entry."");

		Table.AddRow();
		Table.SetCell(""Command"", ""Buffer [Count]"");
		Table.SetCell(""Description"", ""Show/Set the amount of buffered lines while detached."");

		Table.AddRow();
		Table.SetCell(""Command"", ""SetSources <Id> [#chan priv #foo* !#bar]"");
		Table.SetCell(""Description"", ""Set the source channels that you care about."");

		Table.AddRow();
		Table.SetCell(""Command"", ""Help"");
		Table.SetCell(""Description"", ""This help."");

		PutModule(Table);
	}

	void Watch(const CString& sHostMask, const CString& sTarget, const CString& sPattern, bool bNotice = false) {
		CString sMessage;

		if (sHostMask.size()) {
			CWatchEntry WatchEntry(sHostMask, sTarget, sPattern);

			bool bExists = false;
			for (list<CWatchEntry>::iterator it = m_lsWatchers.begin(); it != m_lsWatchers.end(); ++it) {
				if (*it == WatchEntry) {
					sMessage = ""Entry for ["" + WatchEntry.GetHostMask() + ""] already exists."";
					bExists = true;
					break;
				}
			}

			if (!bExists) {
				sMessage = ""Adding entry: ["" + WatchEntry.GetHostMask() + ""] watching for ""
					""["" + WatchEntry.GetPattern() + ""] -> ["" + WatchEntry.GetTarget() + ""]"";
				m_lsWatchers.push_back(WatchEntry);
			}
		} else {
			sMessage = ""Watch: Not enough arguments.  Try Help"";
		}

		if (bNotice) {
			PutModNotice(sMessage);
		} else {
			PutModule(sMessage);
		}
		Save();
	}

	void Save() {
		ClearNV(false);
		for (list<CWatchEntry>::iterator it = m_lsWatchers.begin(); it != m_lsWatchers.end(); ++it) {
			CWatchEntry& WatchEntry = *it;
			CString sSave;

			sSave  = WatchEntry.GetHostMask() + ""\n"";
			sSave += WatchEntry.GetTarget() + ""\n"";
			sSave += WatchEntry.GetPattern() + ""\n"";
			sSave += (WatchEntry.IsDisabled() ? ""disabled\n"" : ""enabled\n"");
			sSave += WatchEntry.GetSourcesStr();
			// Without this, loading fails if GetSourcesStr()
			// returns an empty string
			sSave += "" "";

			SetNV(sSave, """", false);
		}

		SaveRegistry();
	}

	void Load() {
		// Just to make sure we dont mess up badly
		m_lsWatchers.clear();

		bool bWarn = false;

		for (MCString::iterator it = BeginNV(); it != EndNV(); ++it) {
			VCString vList;
			it->first.Split(""\n"", vList);

			if (vList.size() != 5) {
				bWarn = true;
				continue;
			}

			CWatchEntry WatchEntry(vList[0], vList[1], vList[2]);
			if (vList[3].Equals(""disabled""))
				WatchEntry.SetDisabled(true);
			else
				WatchEntry.SetDisabled(false);
			WatchEntry.SetSources(vList[4]);
			m_lsWatchers.push_back(WatchEntry);
		}

		if (bWarn)
			PutModule(""WARNING: malformed entry found while loading"");
	}

	list<CWatchEntry>  m_lsWatchers;
	CBuffer            m_Buffer;
};

MODULEDEFS(CWatcherMod, ""Copy activity from a specific user into a separate window"")
""",CWatcherMod::Dump,[360:388]
znc,https://github.com/znc/znc/commit/211bab0f0078bdfbb4b5a36b4cc84f520c55aa77,"""Update the perform command to use CModCommand""","""/*
 * Copyright (C) 2004-2011  See the AUTHORS file for details.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 as published
 * by the Free Software Foundation.
 */

#include ""User.h""
#include <algorithm>

class CPerform : public CModule {
public:
	MODCONSTRUCTOR(CPerform) {}

	virtual ~CPerform() {}

	CString ParsePerform(const CString& sArg) const {
		CString sPerf = sArg;

		if (sPerf.Left(1) == ""/"")
			sPerf.LeftChomp();

		if (sPerf.Token(0).Equals(""MSG"")) {
			sPerf = ""PRIVMSG "" + sPerf.Token(1, true);
		}

		if ((sPerf.Token(0).Equals(""PRIVMSG"") ||
				sPerf.Token(0).Equals(""NOTICE"")) &&
				sPerf.Token(2).Left(1) != "":"") {
			sPerf = sPerf.Token(0) + "" "" + sPerf.Token(1)
				+ "" :"" + sPerf.Token(2, true);
		}

		return sPerf;
	}

	virtual bool OnLoad(const CString& sArgs, CString& sMessage) {
		GetNV(""Perform"").Split(""\n"", m_vPerform, false);

		return true;
	}

	virtual void OnModCommand(const CString& sCommand) {
		CString sCmdName = sCommand.Token(0).AsLower();
		if (sCmdName == ""add"") {
			CString sPerf = sCommand.Token(1, true);

			if (sPerf.empty()) {
				PutModule(""Usage: add <command>"");
				return;
			}

			m_vPerform.push_back(ParsePerform(sPerf));
			PutModule(""Added!"");
			Save();
		} else if (sCmdName == ""del"") {
			u_int iNum = sCommand.Token(1, true).ToUInt();
			if (iNum > m_vPerform.size() || iNum <= 0) {
				PutModule(""Illegal # Requested"");
				return;
			} else {
				m_vPerform.erase(m_vPerform.begin() + iNum - 1);
				PutModule(""Command Erased."");
			}
			Save();
		} else if (sCmdName == ""list"") {
			int i = 1;
			CString sExpanded;
			for (VCString::const_iterator it = m_vPerform.begin(); it != m_vPerform.end(); it++, i++) {
				sExpanded = GetUser()->ExpandString(*it);
				if (sExpanded != *it)
					PutModule(CString(i) + "": "" + *it + "" ("" + sExpanded + "")"");
				else
					PutModule(CString(i) + "": "" + *it);
			}
			PutModule("" -- End of List"");
		} else if (sCmdName == ""execute"") {
			OnIRCConnected();
			PutModule(""perform commands sent"");
		} else if (sCmdName == ""swap"") {
			u_int iNumA = sCommand.Token(1).ToUInt();
			u_int iNumB = sCommand.Token(2).ToUInt();

			if (iNumA > m_vPerform.size() || iNumA <= 0 || iNumB > m_vPerform.size() || iNumB <= 0) {
				PutModule(""Illegal # Requested"");
			} else {
				std::iter_swap(m_vPerform.begin() + (iNumA - 1), m_vPerform.begin() + (iNumB - 1));
				PutModule(""Commands Swapped."");
				Save();
			}
		} else {
			PutModule(""Commands: add <command>, del <nr>, list, execute, swap <nr> <nr>"");
		}
	}

	virtual void OnIRCConnected() {
		for (VCString::const_iterator it = m_vPerform.begin(); it != m_vPerform.end(); ++it) {
			PutIRC(GetUser()->ExpandString(*it));
		}
	}

	virtual CString GetWebMenuTitle() { return ""Perform""; }

	virtual bool OnWebRequest(CWebSock& WebSock, const CString& sPageName, CTemplate& Tmpl) {
		if (sPageName != ""index"") {
			// only accept requests to /mods/perform/
			return false;
		}

		if (WebSock.IsPost()) {
			VCString vsPerf;
			WebSock.GetRawParam(""perform"", true).Split(""\n"", vsPerf, false);
			m_vPerform.clear();

			for (VCString::const_iterator it = vsPerf.begin(); it != vsPerf.end(); ++it)
				m_vPerform.push_back(ParsePerform(*it));

			Save();
		}

		for (VCString::const_iterator it = m_vPerform.begin(); it != m_vPerform.end(); ++it) {
			CTemplate& Row = Tmpl.AddRow(""PerformLoop"");
			Row[""Perform""] = *it;
		}

		return true;
	}

private:
	void Save() {
		CString sBuffer = """";

		for (VCString::const_iterator it = m_vPerform.begin(); it != m_vPerform.end(); ++it) {
			sBuffer += *it + ""\n"";
		}
		SetNV(""Perform"", sBuffer);
	}

	VCString m_vPerform;
};

MODULEDEFS(CPerform, ""Keeps a list of commands to be executed when ZNC connects to IRC."")
""","""/*
 * Copyright (C) 2004-2011  See the AUTHORS file for details.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 as published
 * by the Free Software Foundation.
 */

#include ""User.h""
#include <algorithm>

class CPerform : public CModule {
	void Add(const CString& sCommand) {
		CString sPerf = sCommand.Token(1, true);

		if (sPerf.empty()) {
			PutModule(""Usage: add <command>"");
			return;
		}

		m_vPerform.push_back(ParsePerform(sPerf));
		PutModule(""Added!"");
		Save();
	}

	void Del(const CString& sCommand) {
		u_int iNum = sCommand.Token(1, true).ToUInt();
		
		if (iNum > m_vPerform.size() || iNum <= 0) {
			PutModule(""Illegal # Requested"");
			return;
		} else {
			m_vPerform.erase(m_vPerform.begin() + iNum - 1);
			PutModule(""Command Erased."");
		}
		Save();
	}

	void List(const CString& sCommand) {
		int i = 1;
		CString sExpanded;
		for (VCString::const_iterator it = m_vPerform.begin(); it != m_vPerform.end(); it++, i++) {
			sExpanded = GetUser()->ExpandString(*it);
			if (sExpanded != *it)
				PutModule(CString(i) + "": "" + *it + "" ("" + sExpanded + "")"");
			else
				PutModule(CString(i) + "": "" + *it);
		}
		PutModule("" -- End of List"");
	}

	void Execute(const CString& sCommand) {
		OnIRCConnected();
		PutModule(""perform commands sent"");
	}

	void Swap(const CString& sCommand) {
		u_int iNumA = sCommand.Token(1).ToUInt();
		u_int iNumB = sCommand.Token(2).ToUInt();

		if (iNumA > m_vPerform.size() || iNumA <= 0 || iNumB > m_vPerform.size() || iNumB <= 0) {
			PutModule(""Illegal # Requested"");
		} else {
			std::iter_swap(m_vPerform.begin() + (iNumA - 1), m_vPerform.begin() + (iNumB - 1));
			PutModule(""Commands Swapped."");
			Save();
		}
	}

public:
	MODCONSTRUCTOR(CPerform) {
		AddHelpCommand();
		AddCommand(""Add"",     static_cast<CModCommand::ModCmdFunc>(&CPerform::Add),
			""<command>"");
		AddCommand(""Del"",     static_cast<CModCommand::ModCmdFunc>(&CPerform::Del),
			""<nr>"");
		AddCommand(""List"",    static_cast<CModCommand::ModCmdFunc>(&CPerform::List));
		AddCommand(""Execute"", static_cast<CModCommand::ModCmdFunc>(&CPerform::Execute));
		AddCommand(""Swap"",    static_cast<CModCommand::ModCmdFunc>(&CPerform::Swap),
			""<nr> <nr>"");
	}

	virtual ~CPerform() {}

	CString ParsePerform(const CString& sArg) const {
		CString sPerf = sArg;

		if (sPerf.Left(1) == ""/"")
			sPerf.LeftChomp();

		if (sPerf.Token(0).Equals(""MSG"")) {
			sPerf = ""PRIVMSG "" + sPerf.Token(1, true);
		}

		if ((sPerf.Token(0).Equals(""PRIVMSG"") ||
				sPerf.Token(0).Equals(""NOTICE"")) &&
				sPerf.Token(2).Left(1) != "":"") {
			sPerf = sPerf.Token(0) + "" "" + sPerf.Token(1)
				+ "" :"" + sPerf.Token(2, true);
		}

		return sPerf;
	}

	virtual bool OnLoad(const CString& sArgs, CString& sMessage) {
		GetNV(""Perform"").Split(""\n"", m_vPerform, false);

		return true;
	}

	virtual void OnIRCConnected() {
		for (VCString::const_iterator it = m_vPerform.begin(); it != m_vPerform.end(); ++it) {
			PutIRC(GetUser()->ExpandString(*it));
		}
	}

	virtual CString GetWebMenuTitle() { return ""Perform""; }

	virtual bool OnWebRequest(CWebSock& WebSock, const CString& sPageName, CTemplate& Tmpl) {
		if (sPageName != ""index"") {
			// only accept requests to /mods/perform/
			return false;
		}

		if (WebSock.IsPost()) {
			VCString vsPerf;
			WebSock.GetRawParam(""perform"", true).Split(""\n"", vsPerf, false);
			m_vPerform.clear();

			for (VCString::const_iterator it = vsPerf.begin(); it != vsPerf.end(); ++it)
				m_vPerform.push_back(ParsePerform(*it));

			Save();
		}

		for (VCString::const_iterator it = m_vPerform.begin(); it != m_vPerform.end(); ++it) {
			CTemplate& Row = Tmpl.AddRow(""PerformLoop"");
			Row[""Perform""] = *it;
		}

		return true;
	}

private:
	void Save() {
		CString sBuffer = """";

		for (VCString::const_iterator it = m_vPerform.begin(); it != m_vPerform.end(); ++it) {
			sBuffer += *it + ""\n"";
		}
		SetNV(""Perform"", sBuffer);
	}

	VCString m_vPerform;
};

MODULEDEFS(CPerform, ""Keeps a list of commands to be executed when ZNC connects to IRC."")
""",,
znc,https://github.com/znc/znc/commit/3c030c8d2b1e6a997ac5a076150a8032d0e4bee9,"""Use a CTable to list all the commands to be performed in the perform module""","""/*
 * Copyright (C) 2004-2011  See the AUTHORS file for details.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 as published
 * by the Free Software Foundation.
 */

#include ""User.h""
#include <algorithm>

class CPerform : public CModule {
	void Add(const CString& sCommand) {
		CString sPerf = sCommand.Token(1, true);

		if (sPerf.empty()) {
			PutModule(""Usage: add <command>"");
			return;
		}

		m_vPerform.push_back(ParsePerform(sPerf));
		PutModule(""Added!"");
		Save();
	}

	void Del(const CString& sCommand) {
		u_int iNum = sCommand.Token(1, true).ToUInt();
		
		if (iNum > m_vPerform.size() || iNum <= 0) {
			PutModule(""Illegal # Requested"");
			return;
		} else {
			m_vPerform.erase(m_vPerform.begin() + iNum - 1);
			PutModule(""Command Erased."");
		}
		Save();
	}

	void List(const CString& sCommand) {
		int i = 1;
		CString sExpanded;
		for (VCString::const_iterator it = m_vPerform.begin(); it != m_vPerform.end(); it++, i++) {
			sExpanded = GetUser()->ExpandString(*it);
			if (sExpanded != *it)
				PutModule(CString(i) + "": "" + *it + "" ("" + sExpanded + "")"");
			else
				PutModule(CString(i) + "": "" + *it);
		}
		PutModule("" -- End of List"");
	}

	void Execute(const CString& sCommand) {
		OnIRCConnected();
		PutModule(""perform commands sent"");
	}

	void Swap(const CString& sCommand) {
		u_int iNumA = sCommand.Token(1).ToUInt();
		u_int iNumB = sCommand.Token(2).ToUInt();

		if (iNumA > m_vPerform.size() || iNumA <= 0 || iNumB > m_vPerform.size() || iNumB <= 0) {
			PutModule(""Illegal # Requested"");
		} else {
			std::iter_swap(m_vPerform.begin() + (iNumA - 1), m_vPerform.begin() + (iNumB - 1));
			PutModule(""Commands Swapped."");
			Save();
		}
	}

public:
	MODCONSTRUCTOR(CPerform) {
		AddHelpCommand();
		AddCommand(""Add"",     static_cast<CModCommand::ModCmdFunc>(&CPerform::Add),
			""<command>"");
		AddCommand(""Del"",     static_cast<CModCommand::ModCmdFunc>(&CPerform::Del),
			""<nr>"");
		AddCommand(""List"",    static_cast<CModCommand::ModCmdFunc>(&CPerform::List));
		AddCommand(""Execute"", static_cast<CModCommand::ModCmdFunc>(&CPerform::Execute));
		AddCommand(""Swap"",    static_cast<CModCommand::ModCmdFunc>(&CPerform::Swap),
			""<nr> <nr>"");
	}

	virtual ~CPerform() {}

	CString ParsePerform(const CString& sArg) const {
		CString sPerf = sArg;

		if (sPerf.Left(1) == ""/"")
			sPerf.LeftChomp();

		if (sPerf.Token(0).Equals(""MSG"")) {
			sPerf = ""PRIVMSG "" + sPerf.Token(1, true);
		}

		if ((sPerf.Token(0).Equals(""PRIVMSG"") ||
				sPerf.Token(0).Equals(""NOTICE"")) &&
				sPerf.Token(2).Left(1) != "":"") {
			sPerf = sPerf.Token(0) + "" "" + sPerf.Token(1)
				+ "" :"" + sPerf.Token(2, true);
		}

		return sPerf;
	}

	virtual bool OnLoad(const CString& sArgs, CString& sMessage) {
		GetNV(""Perform"").Split(""\n"", m_vPerform, false);

		return true;
	}

	virtual void OnIRCConnected() {
		for (VCString::const_iterator it = m_vPerform.begin(); it != m_vPerform.end(); ++it) {
			PutIRC(GetUser()->ExpandString(*it));
		}
	}

	virtual CString GetWebMenuTitle() { return ""Perform""; }

	virtual bool OnWebRequest(CWebSock& WebSock, const CString& sPageName, CTemplate& Tmpl) {
		if (sPageName != ""index"") {
			// only accept requests to /mods/perform/
			return false;
		}

		if (WebSock.IsPost()) {
			VCString vsPerf;
			WebSock.GetRawParam(""perform"", true).Split(""\n"", vsPerf, false);
			m_vPerform.clear();

			for (VCString::const_iterator it = vsPerf.begin(); it != vsPerf.end(); ++it)
				m_vPerform.push_back(ParsePerform(*it));

			Save();
		}

		for (VCString::const_iterator it = m_vPerform.begin(); it != m_vPerform.end(); ++it) {
			CTemplate& Row = Tmpl.AddRow(""PerformLoop"");
			Row[""Perform""] = *it;
		}

		return true;
	}

private:
	void Save() {
		CString sBuffer = """";

		for (VCString::const_iterator it = m_vPerform.begin(); it != m_vPerform.end(); ++it) {
			sBuffer += *it + ""\n"";
		}
		SetNV(""Perform"", sBuffer);
	}

	VCString m_vPerform;
};

MODULEDEFS(CPerform, ""Keeps a list of commands to be executed when ZNC connects to IRC."")
""","""/*
 * Copyright (C) 2004-2011  See the AUTHORS file for details.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 as published
 * by the Free Software Foundation.
 */

#include ""User.h""
#include <algorithm>

class CPerform : public CModule {
	void Add(const CString& sCommand) {
		CString sPerf = sCommand.Token(1, true);

		if (sPerf.empty()) {
			PutModule(""Usage: add <command>"");
			return;
		}

		m_vPerform.push_back(ParsePerform(sPerf));
		PutModule(""Added!"");
		Save();
	}

	void Del(const CString& sCommand) {
		u_int iNum = sCommand.Token(1, true).ToUInt();
		
		if (iNum > m_vPerform.size() || iNum <= 0) {
			PutModule(""Illegal # Requested"");
			return;
		} else {
			m_vPerform.erase(m_vPerform.begin() + iNum - 1);
			PutModule(""Command Erased."");
		}
		Save();
	}

	void List(const CString& sCommand) {
		CTable Table;
		unsigned int index = 1;
		CString sExpanded;

		Table.AddColumn(""Id"");
		Table.AddColumn(""Perform"");
		Table.AddColumn(""Expanded"");

		for (VCString::const_iterator it = m_vPerform.begin(); it != m_vPerform.end(); it++, index++) {
			Table.AddRow();
			Table.SetCell(""Id"", CString(index));
			Table.SetCell(""Perform"", *it);

			sExpanded = GetUser()->ExpandString(*it);
			if (sExpanded != *it) {
				Table.SetCell(""Expanded"", sExpanded);
			}
		}

		if (PutModule(Table) == 0) {
			PutModule(""No commands in your perform list."");
		}
	}

	void Execute(const CString& sCommand) {
		OnIRCConnected();
		PutModule(""perform commands sent"");
	}

	void Swap(const CString& sCommand) {
		u_int iNumA = sCommand.Token(1).ToUInt();
		u_int iNumB = sCommand.Token(2).ToUInt();

		if (iNumA > m_vPerform.size() || iNumA <= 0 || iNumB > m_vPerform.size() || iNumB <= 0) {
			PutModule(""Illegal # Requested"");
		} else {
			std::iter_swap(m_vPerform.begin() + (iNumA - 1), m_vPerform.begin() + (iNumB - 1));
			PutModule(""Commands Swapped."");
			Save();
		}
	}

public:
	MODCONSTRUCTOR(CPerform) {
		AddHelpCommand();
		AddCommand(""Add"",     static_cast<CModCommand::ModCmdFunc>(&CPerform::Add),
			""<command>"");
		AddCommand(""Del"",     static_cast<CModCommand::ModCmdFunc>(&CPerform::Del),
			""<nr>"");
		AddCommand(""List"",    static_cast<CModCommand::ModCmdFunc>(&CPerform::List));
		AddCommand(""Execute"", static_cast<CModCommand::ModCmdFunc>(&CPerform::Execute));
		AddCommand(""Swap"",    static_cast<CModCommand::ModCmdFunc>(&CPerform::Swap),
			""<nr> <nr>"");
	}

	virtual ~CPerform() {}

	CString ParsePerform(const CString& sArg) const {
		CString sPerf = sArg;

		if (sPerf.Left(1) == ""/"")
			sPerf.LeftChomp();

		if (sPerf.Token(0).Equals(""MSG"")) {
			sPerf = ""PRIVMSG "" + sPerf.Token(1, true);
		}

		if ((sPerf.Token(0).Equals(""PRIVMSG"") ||
				sPerf.Token(0).Equals(""NOTICE"")) &&
				sPerf.Token(2).Left(1) != "":"") {
			sPerf = sPerf.Token(0) + "" "" + sPerf.Token(1)
				+ "" :"" + sPerf.Token(2, true);
		}

		return sPerf;
	}

	virtual bool OnLoad(const CString& sArgs, CString& sMessage) {
		GetNV(""Perform"").Split(""\n"", m_vPerform, false);

		return true;
	}

	virtual void OnIRCConnected() {
		for (VCString::const_iterator it = m_vPerform.begin(); it != m_vPerform.end(); ++it) {
			PutIRC(GetUser()->ExpandString(*it));
		}
	}

	virtual CString GetWebMenuTitle() { return ""Perform""; }

	virtual bool OnWebRequest(CWebSock& WebSock, const CString& sPageName, CTemplate& Tmpl) {
		if (sPageName != ""index"") {
			// only accept requests to /mods/perform/
			return false;
		}

		if (WebSock.IsPost()) {
			VCString vsPerf;
			WebSock.GetRawParam(""perform"", true).Split(""\n"", vsPerf, false);
			m_vPerform.clear();

			for (VCString::const_iterator it = vsPerf.begin(); it != vsPerf.end(); ++it)
				m_vPerform.push_back(ParsePerform(*it));

			Save();
		}

		for (VCString::const_iterator it = m_vPerform.begin(); it != m_vPerform.end(); ++it) {
			CTemplate& Row = Tmpl.AddRow(""PerformLoop"");
			Row[""Perform""] = *it;
		}

		return true;
	}

private:
	void Save() {
		CString sBuffer = """";

		for (VCString::const_iterator it = m_vPerform.begin(); it != m_vPerform.end(); ++it) {
			sBuffer += *it + ""\n"";
		}
		SetNV(""Perform"", sBuffer);
	}

	VCString m_vPerform;
};

MODULEDEFS(CPerform, ""Keeps a list of commands to be executed when ZNC connects to IRC."")
""",CPerform::List,[39:62]
znc,https://github.com/znc/znc/commit/554429a61f432d8cc4ee5ebfee9034008808361f,"""Fix a bug in MCString::Encode()

For character values above 127, the signed char that could be used here did the
wrong thing. That is, *it >> 4 returned a negative value and the array hexdigits
was read indexed with that wrong value.

Fix this by explicitly using unsigned char.

Thanks to crocket for reporting this bug which he found with perform (broken
entries after a restart/reload).

Signed-off-by: Uli Schlachter <psychon@znc.in>""","""/*
 * Copyright (C) 2004-2011  See the AUTHORS file for details.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 as published
 * by the Free Software Foundation.
 */

#include ""ZNCString.h""
#include ""FileUtils.h""
#include ""Utils.h""
#include ""MD5.h""
#include ""SHA256.h""
#include <sstream>

using std::stringstream;

CString::CString(char c) : string() { stringstream s; s << c; *this = s.str(); }
CString::CString(unsigned char c) : string() { stringstream s; s << c; *this = s.str(); }
CString::CString(short i) : string() { stringstream s; s << i; *this = s.str(); }
CString::CString(unsigned short i) : string() { stringstream s; s << i; *this = s.str(); }
CString::CString(int i) : string() { stringstream s; s << i; *this = s.str(); }
CString::CString(unsigned int i) : string() { stringstream s; s << i; *this = s.str(); }
CString::CString(long i) : string() { stringstream s; s << i; *this = s.str(); }
CString::CString(unsigned long i) : string() { stringstream s; s << i; *this = s.str(); }
CString::CString(long long i) : string() { stringstream s; s << i; *this = s.str(); }
CString::CString(unsigned long long i) : string() { stringstream s; s << i; *this = s.str(); }
CString::CString(double i, int precision) : string() { stringstream s; s.precision(precision); s << std::fixed << i; *this = s.str(); }
CString::CString(float i, int precision) : string() { stringstream s; s.precision(precision); s << std::fixed << i; *this = s.str(); }

unsigned char* CString::strnchr(const unsigned char* src, unsigned char c, unsigned int iMaxBytes, unsigned char* pFill, unsigned int* piCount) const {
	for (unsigned int a = 0; a < iMaxBytes && *src; a++, src++) {
		if (pFill) {
			pFill[a] = *src;
		}

		if (*src == c) {
			if (pFill) {
				pFill[a +1] = 0;
			}

			if (piCount) {
				*piCount = a;
			}

			return (unsigned char*) src;
		}
	}

	if (pFill) {
		*pFill = 0;
	}

	if (piCount) {
		*piCount = 0;
	}

	return NULL;
}

int CString::CaseCmp(const CString& s, unsigned long uLen) const {
	if (uLen != CString::npos) {
		return strncasecmp(c_str(), s.c_str(), uLen);
	}
	return strcasecmp(c_str(), s.c_str());
}

int CString::StrCmp(const CString& s, unsigned long uLen) const {
	if (uLen != CString::npos) {
		return strncmp(c_str(), s.c_str(), uLen);
	}
	return strcmp(c_str(), s.c_str());
}

bool CString::Equals(const CString& s, bool bCaseSensitive, unsigned long uLen) const {
	if (bCaseSensitive) {
		return (StrCmp(s, uLen) == 0);
	} else {
		return (CaseCmp(s, uLen) == 0);
	}
}

bool CString::WildCmp(const CString& sWild, const CString& sString) {
	// Written by Jack Handy - jakkhandy@hotmail.com
	const char *wild = sWild.c_str(), *CString = sString.c_str();
	const char *cp = NULL, *mp = NULL;

	while ((*CString) && (*wild != '*')) {
		if ((*wild != *CString) && (*wild != '?')) {
			return false;
		}

		wild++;
		CString++;
	}

	while (*CString) {
		if (*wild == '*') {
			if (!*++wild) {
				return true;
			}

			mp = wild;
			cp = CString+1;
		} else if ((*wild == *CString) || (*wild == '?')) {
			wild++;
			CString++;
		} else {
			wild = mp;
			CString = cp++;
		}
	}

	while (*wild == '*') {
		wild++;
	}

	return (*wild == 0);
}

bool CString::WildCmp(const CString& sWild) const {
	return CString::WildCmp(sWild, *this);
}

CString& CString::MakeUpper() {
	for (unsigned int a = 0; a < length(); a++) {
		char& c = (*this)[a];
		c = toupper(c);
	}

	return *this;
}

CString& CString::MakeLower() {
	for (unsigned int a = 0; a < length(); a++) {
		char& c = (*this)[a];
		c = tolower(c);
	}

	return *this;
}

CString CString::AsUpper() const {
	CString sRet = *this;

	for (unsigned int a = 0; a < length(); a++) {
		char& c = sRet[a];
		c = toupper(c);
	}

	return sRet;
}

CString CString::AsLower() const {
	CString sRet = *this;

	for (unsigned int a = 0; a < length(); a++) {
		char& c = sRet[a];
		c = tolower(c);
	}

	return sRet;
}

CString::EEscape CString::ToEscape(const CString& sEsc) {
	if (sEsc.Equals(""ASCII"")) {
		return EASCII;
	} else if (sEsc.Equals(""HTML"")) {
		return EHTML;
	} else if (sEsc.Equals(""URL"")) {
		return EURL;
	} else if (sEsc.Equals(""SQL"")) {
		return ESQL;
	}

	return EASCII;
}

CString CString::Escape_n(EEscape eFrom, EEscape eTo) const {
	CString sRet;
	const char szHex[] = ""0123456789ABCDEF"";
	const unsigned char *pStart = (const unsigned char*) data();
	const unsigned char *p = (const unsigned char*) data();
	unsigned int iLength = length();
	sRet.reserve(iLength *3);
	unsigned char pTmp[21];
	unsigned int iCounted = 0;

	for (unsigned int a = 0; a < iLength; a++, p = pStart + a) {
		unsigned char ch = 0;

		switch (eFrom) {
			case EHTML:
				if ((*p == '&') && (strnchr((unsigned char*) p, ';', sizeof(pTmp) - 1, pTmp, &iCounted))) {
					// please note that we do not have any Unicode or UTF-8 support here at all.

					if ((iCounted >= 3) && (pTmp[1] == '#')) {  // do XML and HTML &#97; &#x3c
						int base = 10;

						if ((pTmp[2] & 0xDF) == 'X') {
							base = 16;
						}

						char* endptr = NULL;
						unsigned int b = strtol((const char*) (pTmp +2 + (base == 16)), &endptr, base);

						if ((*endptr == ';') && (b <= 255)) { // incase they do something like &#7777777777;
							ch = b;
							a += iCounted;
							break;
						}
					}

					if (ch == 0) {
						if (!strncasecmp((const char*) &pTmp, ""lt"", 2)) ch = '<';
						else if (!strncasecmp((const char*) &pTmp, ""gt"", 2)) ch = '>';
						else if (!strncasecmp((const char*) &pTmp, ""quot"", 4)) ch = '""';
						else if (!strncasecmp((const char*) &pTmp, ""amp"", 3)) ch = '&';
					}

					if (ch > 0) {
						a += iCounted;
					} else {
						ch = *p;   // Not a valid escape, just record the &
					}
				} else {
					ch = *p;
				}
				break;
			case EASCII:
				ch = *p;
				break;
			case EURL:
				if (*p == '%' && (a +2) < iLength && isxdigit(*(p +1)) && isxdigit(*(p +2))) {
					p++;
					if (isdigit(*p)) {
						ch = (*p - '0') << 4;
					} else {
						ch = (tolower(*p) - 'a' +10) << 4;
					}

					p++;
					if (isdigit(*p)) {
						ch |= (*p - '0');
					} else {
						ch |= (tolower(*p) - 'a' +10);
					}

					a += 2;
				} else if (pStart[a] == '+') {
					ch = ' ';
				} else {
					ch = *p;
				}

				break;
			case ESQL:
				if (*p != '\\' || iLength < (a +1)) {
					ch = *p;
				} else {
					a++;
					p++;

					if (*p == 'n') {
						ch = '\n';
					} else if (*p == 'r') {
						ch = '\r';
					} else if (*p == '0') {
						ch = '\0';
					} else if (*p == 't') {
						ch = '\t';
					} else if (*p == 'b') {
						ch = '\b';
					} else {
						ch = *p;
					}
				}

				break;
		}

		switch (eTo) {
			case EHTML:
				if (ch == '<') sRet += ""&lt;"";
				else if (ch == '>') sRet += ""&gt;"";
				else if (ch == '""') sRet += ""&quot;"";
				else if (ch == '&') sRet += ""&amp;"";
				else {
					sRet += ch;
				}

				break;
			case EASCII:
				sRet += ch;
				break;
			case EURL:
				if (isalnum(ch) || ch == '_' || ch == '.' || ch == '-') {
					sRet += ch;
				} else if (ch == ' ') {
					sRet += '+';
				} else {
					sRet += '%';
					sRet += szHex[ch >> 4];
					sRet += szHex[ch & 0xf];
				}

				break;
			case ESQL:
				if (ch == '\0') { sRet += '\\'; sRet += '0';
				} else if (ch == '\n') { sRet += '\\'; sRet += 'n';
				} else if (ch == '\t') { sRet += '\\'; sRet += 't';
				} else if (ch == '\r') { sRet += '\\'; sRet += 'r';
				} else if (ch == '\b') { sRet += '\\'; sRet += 'b';
				} else if (ch == '\""') { sRet += '\\'; sRet += '\""';
				} else if (ch == '\'') { sRet += '\\'; sRet += '\'';
				} else if (ch == '\\') { sRet += '\\'; sRet += '\\';
				} else { sRet += ch; }

				break;
		}
	}

	sRet.reserve(0);
	return sRet;
}

CString CString::Escape_n(EEscape eTo) const {
	return Escape_n(EASCII, eTo);
}

CString& CString::Escape(EEscape eFrom, EEscape eTo) {
	return (*this = Escape_n(eFrom, eTo));
}

CString& CString::Escape(EEscape eTo) {
	return (*this = Escape_n(eTo));
}

CString CString::Replace_n(const CString& sReplace, const CString& sWith, const CString& sLeft, const CString& sRight, bool bRemoveDelims) const {
	CString sRet = *this;
	CString::Replace(sRet, sReplace, sWith, sLeft, sRight, bRemoveDelims);
	return sRet;
}

unsigned int CString::Replace(const CString& sReplace, const CString& sWith, const CString& sLeft, const CString& sRight, bool bRemoveDelims) {
	return CString::Replace(*this, sReplace, sWith, sLeft, sRight, bRemoveDelims);
}

unsigned int CString::Replace(CString& sStr, const CString& sReplace, const CString& sWith, const CString& sLeft, const CString& sRight, bool bRemoveDelims) {
	unsigned int uRet = 0;
	CString sCopy = sStr;
	sStr.clear();

	unsigned int uReplaceWidth = sReplace.length();
	unsigned int uLeftWidth = sLeft.length();
	unsigned int uRightWidth = sRight.length();
	const char* p = sCopy.c_str();
	bool bInside = false;

	while (*p) {
		if (!bInside && uLeftWidth && strncmp(p, sLeft.c_str(), uLeftWidth) == 0) {
			if (!bRemoveDelims) {
				sStr += sLeft;
			}

			p += uLeftWidth -1;
			bInside = true;
		} else if (bInside && uRightWidth && strncmp(p, sRight.c_str(), uRightWidth) == 0) {
			if (!bRemoveDelims) {
				sStr += sRight;
			}

			p += uRightWidth -1;
			bInside = false;
		} else if (!bInside && strncmp(p, sReplace.c_str(), uReplaceWidth) == 0) {
			sStr += sWith;
			p += uReplaceWidth -1;
			uRet++;
		} else {
			sStr.append(p, 1);
		}

		p++;
	}

	return uRet;
}

CString CString::Token(unsigned int uPos, bool bRest, const CString& sSep, bool bAllowEmpty,
                       const CString& sLeft, const CString& sRight, bool bTrimQuotes) const {
	VCString vsTokens;
	if (Split(sSep, vsTokens, bAllowEmpty, sLeft, sRight, bTrimQuotes) > uPos) {
		CString sRet;

		for (unsigned int a = uPos; a < vsTokens.size(); a++) {
			if (a > uPos) {
				sRet += sSep;
			}

			sRet += vsTokens[a];

			if (!bRest) {
				break;
			}
		}

		return sRet;
	}

	return Token(uPos, bRest, sSep, bAllowEmpty);
}

CString CString::Token(unsigned int uPos, bool bRest, const CString& sSep, bool bAllowEmpty) const {
	const char *sep_str = sSep.c_str();
	size_t sep_len = sSep.length();
	const char *str = c_str();
	size_t str_len = length();
	size_t start_pos = 0;
	size_t end_pos;

	if (!bAllowEmpty) {
		while (strncmp(&str[start_pos], sep_str, sep_len) == 0) {
			start_pos += sep_len;
		}
	}

	// First, find the start of our token
	while (uPos != 0 && start_pos < str_len) {
		bool bFoundSep = false;

		while (strncmp(&str[start_pos], sep_str, sep_len) == 0 && (!bFoundSep || !bAllowEmpty)) {
			start_pos += sep_len;
			bFoundSep = true;
		}

		if (bFoundSep) {
			uPos--;
		} else {
			start_pos++;
		}
	}

	// String is over?
	if (start_pos >= str_len)
		return """";

	// If they want everything from here on, give it to them
	if (bRest) {
		return substr(start_pos);
	}

	// Now look for the end of the token they want
	end_pos = start_pos;
	while (end_pos < str_len) {
		if (strncmp(&str[end_pos], sep_str, sep_len) == 0)
			return substr(start_pos, end_pos - start_pos);

		end_pos++;
	}

	// They want the last token in the string, not something in between
	return substr(start_pos);
}

CString CString::Ellipsize(unsigned int uLen) const {
	if (uLen >= size()) {
		return *this;
	}

	string sRet;

	// @todo this looks suspect
	if (uLen < 4) {
		for (unsigned int a = 0; a < uLen; a++) {
			sRet += ""."";
		}

		return sRet;
	}

	sRet = substr(0, uLen -3) + ""..."";

	return sRet;
}

CString CString::Left(unsigned int uCount) const {
	uCount = (uCount > length()) ? length() : uCount;
	return substr(0, uCount);
}

CString CString::Right(unsigned int uCount) const {
	uCount = (uCount > length()) ? length() : uCount;
	return substr(length() - uCount, uCount);
}

unsigned int CString::URLSplit(MCString& msRet) const {
	msRet.clear();

	VCString vsPairs;
	Split(""&"", vsPairs);

	for (size_t a = 0; a < vsPairs.size(); a++) {
		const CString& sPair = vsPairs[a];

		msRet[sPair.Token(0, false, ""="").Escape(CString::EURL, CString::EASCII)] = sPair.Token(1, true, ""="").Escape(CString::EURL, CString::EASCII);
	}

	return msRet.size();
}

unsigned int CString::OptionSplit(MCString& msRet, bool bUpperKeys) const {
	CString sName;
	CString sCopy(*this);
	msRet.clear();

	while (!sCopy.empty()) {
		sName = sCopy.Token(0, false, ""="", false, ""\"""", ""\"""", false).Trim_n();
		sCopy = sCopy.Token(1, true, ""="", false, ""\"""", ""\"""", false).TrimLeft_n();

		if (sName.empty()) {
			continue;
		}

		VCString vsNames;
		sName.Split("" "", vsNames, false, ""\"""", ""\"""");

		for (unsigned int a = 0; a < vsNames.size(); a++) {
			CString sKeyName = vsNames[a];

			if (bUpperKeys) {
				sKeyName.MakeUpper();
			}

			if ((a +1) == vsNames.size()) {
				msRet[sKeyName] = sCopy.Token(0, false, "" "", false, ""\"""", ""\"""");
				sCopy = sCopy.Token(1, true, "" "", false, ""\"""", ""\"""", false);
			} else {
				msRet[sKeyName] = """";
			}
		}
	}

	return msRet.size();
}

unsigned int CString::QuoteSplit(VCString& vsRet) const {
	vsRet.clear();
	return Split("" "", vsRet, false, ""\"""", ""\"""", true);
}

unsigned int CString::Split(const CString& sDelim, VCString& vsRet, bool bAllowEmpty,
		const CString& sLeft, const CString& sRight, bool bTrimQuotes, bool bTrimWhiteSpace) const {
	vsRet.clear();

	if (empty()) {
		return 0;
	}

	CString sTmp;
	bool bInside = false;
	unsigned int uDelimLen = sDelim.length();
	unsigned int uLeftLen = sLeft.length();
	unsigned int uRightLen = sRight.length();
	const char* p = c_str();

	if (!bAllowEmpty) {
		while (strncasecmp(p, sDelim.c_str(), uDelimLen) == 0) {
			p += uDelimLen;
		}
	}

	while (*p) {
		if (uLeftLen && uRightLen && !bInside && strncasecmp(p, sLeft.c_str(), uLeftLen) == 0) {
			if (!bTrimQuotes) {
				sTmp += sLeft;
			}

			p += uLeftLen;
			bInside = true;
			continue;
		}

		if (uLeftLen && uRightLen && bInside && strncasecmp(p, sRight.c_str(), uRightLen) == 0) {
			if (!bTrimQuotes) {
				sTmp += sRight;
			}

			p += uRightLen;
			bInside = false;
			continue;
		}

		if (uDelimLen && !bInside && strncasecmp(p, sDelim.c_str(), uDelimLen) == 0) {
			if (bTrimWhiteSpace) {
				sTmp.Trim();
			}

			vsRet.push_back(sTmp);
			sTmp.clear();
			p += uDelimLen;

			if (!bAllowEmpty) {
				while (strncasecmp(p, sDelim.c_str(), uDelimLen) == 0) {
					p += uDelimLen;
				}
			}

			bInside = false;
			continue;
		} else {
			sTmp += *p;
		}

		p++;
	}

	if (!sTmp.empty()) {
		if (bTrimWhiteSpace) {
			sTmp.Trim();
		}

		vsRet.push_back(sTmp);
	}

	return vsRet.size();
}

unsigned int CString::Split(const CString& sDelim, SCString& ssRet, bool bAllowEmpty, const CString& sLeft, const CString& sRight, bool bTrimQuotes, bool bTrimWhiteSpace) const {
	VCString vsTokens;

	Split(sDelim, vsTokens, bAllowEmpty, sLeft, sRight, bTrimQuotes, bTrimWhiteSpace);

	ssRet.clear();

	for (size_t a = 0; a < vsTokens.size(); a++) {
		ssRet.insert(vsTokens[a]);
	}

	return ssRet.size();
}

CString CString::RandomString(unsigned int uLength) {
	const char chars[] = ""abcdefghijklmnopqrstuvwxyz""
		""ABCDEFGHIJKLMNOPQRSTUVWXYZ""
		""0123456789!?.,:;/*-+_()"";
	// -1 because sizeof() includes the trailing '\0' byte
	const size_t len = sizeof(chars) / sizeof(chars[0]) - 1;
	size_t p;
	CString sRet;

	for (unsigned int a = 0; a < uLength; a++) {
		p = (size_t) (len * (rand() / (RAND_MAX + 1.0)));
		sRet += chars[p];
	}

	return sRet;
}

bool CString::Base64Encode(unsigned int uWrap) {
	CString sCopy(*this);
	return sCopy.Base64Encode(*this, uWrap);
}

unsigned long CString::Base64Decode() {
	CString sCopy(*this);
	return sCopy.Base64Decode(*this);
}

CString CString::Base64Encode_n(unsigned int uWrap) const {
	CString sRet;
	Base64Encode(sRet, uWrap);
	return sRet;
}

CString CString::Base64Decode_n() const {
	CString sRet;
	Base64Decode(sRet);
	return sRet;
}

bool CString::Base64Encode(CString& sRet, unsigned int uWrap) const {
	const char b64table[] = ""ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"";
	sRet.clear();
	size_t len = size();
	const unsigned char* input = (const unsigned char*) c_str();
	unsigned char *output, *p;
	size_t        i = 0, mod = len % 3, toalloc;
	toalloc = (len / 3) * 4 + (3 - mod) % 3 + 1 + 8;

	if (uWrap) {
		toalloc += len / 57;
		if (len % 57) {
			toalloc++;
		}
	}

	if (toalloc < len) {
		return 0;
	}

	p = output = new unsigned char [toalloc];

	while (i < len - mod) {
		*p++ = b64table[input[i++] >> 2];
		*p++ = b64table[((input[i - 1] << 4) | (input[i] >> 4)) & 0x3f];
		*p++ = b64table[((input[i] << 2) | (input[i + 1] >> 6)) & 0x3f];
		*p++ = b64table[input[i + 1] & 0x3f];
		i += 2;

		if (uWrap && !(i % 57)) {
			*p++ = '\n';
		}
	}

	if (!mod) {
		if (uWrap && i % 57) {
			*p++ = '\n';
		}
	} else {
		*p++ = b64table[input[i++] >> 2];
		*p++ = b64table[((input[i - 1] << 4) | (input[i] >> 4)) & 0x3f];
		if (mod == 1) {
			*p++ = '=';
		} else {
			*p++ = b64table[(input[i] << 2) & 0x3f];
		}

		*p++ = '=';

		if (uWrap) {
			*p++ = '\n';
		}
	}

	*p = 0;
	sRet = (char*) output;
	delete[] output;
	return true;
}

unsigned long CString::Base64Decode(CString& sRet) const {
	CString sTmp(*this);
	// remove new lines
	sTmp.Replace(""\r"", """");
	sTmp.Replace(""\n"", """");

	const char* in = sTmp.c_str();
	char c, c1, *p;
	unsigned long i;
	unsigned long uLen = sTmp.size();
	char* out = new char[uLen + 1];

	for (i = 0, p = out; i < uLen; i++) {
		c = (char)base64_table[(unsigned char)in[i++]];
		c1 = (char)base64_table[(unsigned char)in[i++]];
		*p++ = (c << 2) | ((c1 >> 4) & 0x3);

		if (i < uLen) {
			if (in[i] == '=') {
				break;
			}
			c = (char)base64_table[(unsigned char)in[i]];
			*p++ = ((c1 << 4) & 0xf0) | ((c >> 2) & 0xf);
		}

		if (++i < uLen) {
			if (in[i] == '=') {
				break;
			}
			*p++ = ((c << 6) & 0xc0) | (char)base64_table[(unsigned char)in[i]];
		}
	}

	*p = '\0';
	unsigned long uRet = p - out;
	sRet.clear();
	sRet.append(out, uRet);
	delete[] out;

	return uRet;
}

CString CString::MD5() const {
	return (const char*) CMD5(*this);
}

CString CString::SHA256() const {
	unsigned char digest[SHA256_DIGEST_SIZE];
	char digest_hex[SHA256_DIGEST_SIZE * 2 + 1];
	const unsigned char *message = (const unsigned char *) c_str();

	sha256(message, length(), digest);

	sprintf(digest_hex,
			""%02x%02x%02x%02x%02x%02x%02x%02x""
			""%02x%02x%02x%02x%02x%02x%02x%02x""
			""%02x%02x%02x%02x%02x%02x%02x%02x""
			""%02x%02x%02x%02x%02x%02x%02x%02x"",
			digest[ 0], digest[ 1], digest[ 2], digest[ 3], digest[ 4], digest[ 5], digest[ 6], digest[ 7],
			digest[ 8], digest[ 9], digest[10], digest[11], digest[12], digest[13], digest[14], digest[15],
			digest[16], digest[17], digest[18], digest[19], digest[20], digest[21], digest[22], digest[23],
			digest[24], digest[25], digest[26], digest[27], digest[28], digest[29], digest[30], digest[31]);

	return digest_hex;
}

#ifdef HAVE_LIBSSL
CString CString::Encrypt_n(const CString& sPass, const CString& sIvec) const {
	CString sRet;
	sRet.Encrypt(sPass, sIvec);
	return sRet;
}

CString CString::Decrypt_n(const CString& sPass, const CString& sIvec) const {
	CString sRet;
	sRet.Decrypt(sPass, sIvec);
	return sRet;
}

void CString::Encrypt(const CString& sPass, const CString& sIvec) {
	Crypt(sPass, true, sIvec);
}

void CString::Decrypt(const CString& sPass, const CString& sIvec) {
	Crypt(sPass, false, sIvec);
}

void CString::Crypt(const CString& sPass, bool bEncrypt, const CString& sIvec) {
	unsigned char szIvec[8] = {0,0,0,0,0,0,0,0};
	BF_KEY bKey;

	if (sIvec.length() >= 8) {
		memcpy(szIvec, sIvec.data(), 8);
	}

	BF_set_key(&bKey, sPass.length(), (unsigned char*) sPass.data());
	unsigned int uPad = (length() % 8);

	if (uPad) {
		uPad = 8 - uPad;
		append(uPad, '\0');
	}

	size_t uLen = length();
	unsigned char* szBuff = (unsigned char*) malloc(uLen);
	BF_cbc_encrypt((const unsigned char*) data(), szBuff, uLen, &bKey, szIvec, ((bEncrypt) ? BF_ENCRYPT : BF_DECRYPT));

	clear();
	append((const char*) szBuff, uLen);
	free(szBuff);
}
#endif	// HAVE_LIBSSL

CString CString::ToPercent(double d) {
	char szRet[32];
	snprintf(szRet, 32, ""%.02f%%"", d);
	return szRet;
}

CString CString::ToByteStr(unsigned long long d) {
	const unsigned long long KiB = 1024;
	const unsigned long long MiB = KiB * 1024;
	const unsigned long long GiB = MiB * 1024;
	const unsigned long long TiB = GiB * 1024;

	if (d > TiB) {
		return CString(d / (double) TiB) + "" TiB"";
	} else if (d > GiB) {
		return CString(d / (double) GiB) + "" GiB"";
	} else if (d > MiB) {
		return CString(d / (double) MiB) + "" MiB"";
	} else if (d > KiB) {
		return CString(d / (double) KiB) + "" KiB"";
	}

	return CString(d) + "" B"";
}

CString CString::ToTimeStr(unsigned long s) {
	const unsigned long m = 60;
	const unsigned long h = m * 60;
	const unsigned long d = h * 24;
	const unsigned long w = d * 7;
	const unsigned long y = d * 365;
	CString sRet;

#define TIMESPAN(time, str)                          \
	if (s >= time) {                             \
		sRet += CString(s / time) + str "" ""; \
		s = s % time;                        \
	}
	TIMESPAN(y, ""y"");
	TIMESPAN(w, ""w"");
	TIMESPAN(d, ""d"");
	TIMESPAN(h, ""h"");
	TIMESPAN(m, ""m"");
	TIMESPAN(1, ""s"");

	if (sRet.empty())
		return ""0s"";

	return sRet.RightChomp_n();
}

bool CString::ToBool() const { return (!Trim_n().Trim_n(""0"").empty() && !Trim_n().Equals(""false"")); }
short CString::ToShort() const { return strtoul(this->c_str(), (char**) NULL, 10); }
unsigned short CString::ToUShort() const { return strtoul(this->c_str(), (char**) NULL, 10); }
unsigned int CString::ToUInt() const { return strtoul(this->c_str(), (char**) NULL, 10); }
int CString::ToInt() const { return strtoul(this->c_str(), (char**) NULL, 10); }
long CString::ToLong() const { return strtoul(this->c_str(), (char**) NULL, 10); }
unsigned long CString::ToULong() const { return strtoul(c_str(), NULL, 10); }
unsigned long long CString::ToULongLong() const { return strtoull(c_str(), NULL, 10); }
long long CString::ToLongLong() const { return strtoll(c_str(), NULL, 10); }
double CString::ToDouble() const { return strtod(c_str(), NULL); }


bool CString::Trim(const CString& s) {
	bool bLeft = TrimLeft(s);
	return (TrimRight(s) || bLeft);
}

bool CString::TrimLeft(const CString& s) {
	size_type i = find_first_not_of(s);

	if (i == 0)
		return false;

	if (i != npos)
		this->erase(0, i);
	else
		this->clear();

	return true;
}

bool CString::TrimRight(const CString& s) {
	size_type i = find_last_not_of(s);

	if (i + 1 == length())
		return false;

	if (i != npos)
		this->erase(i + 1, npos);
	else
		this->clear();

	return true;
}

CString CString::Trim_n(const CString& s) const {
	CString sRet = *this;
	sRet.Trim(s);
	return sRet;
}

CString CString::TrimLeft_n(const CString& s) const {
	CString sRet = *this;
	sRet.TrimLeft(s);
	return sRet;
}

CString CString::TrimRight_n(const CString& s) const {
	CString sRet = *this;
	sRet.TrimRight(s);
	return sRet;
}

bool CString::TrimPrefix(const CString& sPrefix) {
	if (Equals(sPrefix, false, sPrefix.length())) {
		LeftChomp(sPrefix.length());
		return true;
	} else {
		return false;
	}
}

bool CString::TrimSuffix(const CString& sSuffix) {
	if (Right(sSuffix.length()).Equals(sSuffix)) {
		RightChomp(sSuffix.length());
		return true;
	} else {
		return false;
	}
}


CString CString::TrimPrefix_n(const CString& sPrefix) const {
	CString sRet = *this;
	sRet.TrimPrefix(sPrefix);
	return sRet;
}

CString CString::TrimSuffix_n(const CString& sSuffix) const {
	CString sRet = *this;
	sRet.TrimSuffix(sSuffix);
	return sRet;
}

CString CString::LeftChomp_n(unsigned int uLen) const {
	CString sRet = *this;
	sRet.LeftChomp(uLen);
	return sRet;
}

CString CString::RightChomp_n(unsigned int uLen) const {
	CString sRet = *this;
	sRet.RightChomp(uLen);
	return sRet;
}

bool CString::LeftChomp(unsigned int uLen) {
	bool bRet = false;

	while ((uLen--) && (length())) {
		erase(0, 1);
		bRet = true;
	}

	return bRet;
}

bool CString::RightChomp(unsigned int uLen) {
	bool bRet = false;

	while ((uLen--) && (length())) {
		erase(length() -1);
		bRet = true;
	}

	return bRet;
}

//////////////// MCString ////////////////
MCString::status_t MCString::WriteToDisk(const CString& sPath, mode_t iMode) const {
	CFile cFile(sPath);

	if (this->empty()) {
		if (!cFile.Exists())
			return MCS_SUCCESS;
		if (cFile.Delete())
			return MCS_SUCCESS;
	}

	if (!cFile.Open(O_WRONLY|O_CREAT|O_TRUNC, iMode)) {
		return MCS_EOPEN;
	}

	for (MCString::const_iterator it = this->begin(); it != this->end(); ++it) {
		CString sKey = it->first;
		CString sValue = it->second;
		if (!WriteFilter(sKey, sValue)) {
			return MCS_EWRITEFIL;
		}

		if (sKey.empty()) {
			continue;
		}

		if (cFile.Write(Encode(sKey) + "" "" +  Encode(sValue) + ""\n"") <= 0) {
			return MCS_EWRITE;
		}
	}

	cFile.Close();

	return MCS_SUCCESS;
}

MCString::status_t MCString::ReadFromDisk(const CString& sPath) {
	clear();
	CFile cFile(sPath);
	if (!cFile.Open(O_RDONLY)) {
		return MCS_EOPEN;
	}

	CString sBuffer;

	while (cFile.ReadLine(sBuffer)) {
		sBuffer.Trim();
		CString sKey = sBuffer.Token(0);
		CString sValue = sBuffer.Token(1);
		Decode(sKey);
		Decode(sValue);

		if (!ReadFilter(sKey, sValue))
			return MCS_EREADFIL;

		(*this)[sKey] = sValue;
	}
	cFile.Close();

	return MCS_SUCCESS;
}


static const char hexdigits[] = ""0123456789abcdef"";

CString& MCString::Encode(CString& sValue) const {
	CString sTmp;
	for (CString::iterator it = sValue.begin(); it != sValue.end(); ++it) {
		if (isalnum(*it)) {
			sTmp += *it;
		} else {
			sTmp += ""%"";
			sTmp += hexdigits[*it >> 4];
			sTmp += hexdigits[*it & 0xf];
			sTmp += "";"";
		}
	}
	sValue = sTmp;
	return sValue;
}

CString& MCString::Decode(CString& sValue) const {
	const char *pTmp = sValue.c_str();
	char *endptr;
	CString sTmp;

	while (*pTmp) {
		if (*pTmp != '%') {
			sTmp += *pTmp++;
		} else {
			char ch = (char) strtol(pTmp + 1, &endptr, 16);
			if (*endptr == ';') {
				sTmp += ch;
				pTmp = ++endptr;
			} else {
				sTmp += *pTmp++;
			}
		}
	}

	sValue = sTmp;
	return sValue;
}
""","""/*
 * Copyright (C) 2004-2011  See the AUTHORS file for details.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 as published
 * by the Free Software Foundation.
 */

#include ""ZNCString.h""
#include ""FileUtils.h""
#include ""Utils.h""
#include ""MD5.h""
#include ""SHA256.h""
#include <sstream>

using std::stringstream;

CString::CString(char c) : string() { stringstream s; s << c; *this = s.str(); }
CString::CString(unsigned char c) : string() { stringstream s; s << c; *this = s.str(); }
CString::CString(short i) : string() { stringstream s; s << i; *this = s.str(); }
CString::CString(unsigned short i) : string() { stringstream s; s << i; *this = s.str(); }
CString::CString(int i) : string() { stringstream s; s << i; *this = s.str(); }
CString::CString(unsigned int i) : string() { stringstream s; s << i; *this = s.str(); }
CString::CString(long i) : string() { stringstream s; s << i; *this = s.str(); }
CString::CString(unsigned long i) : string() { stringstream s; s << i; *this = s.str(); }
CString::CString(long long i) : string() { stringstream s; s << i; *this = s.str(); }
CString::CString(unsigned long long i) : string() { stringstream s; s << i; *this = s.str(); }
CString::CString(double i, int precision) : string() { stringstream s; s.precision(precision); s << std::fixed << i; *this = s.str(); }
CString::CString(float i, int precision) : string() { stringstream s; s.precision(precision); s << std::fixed << i; *this = s.str(); }

unsigned char* CString::strnchr(const unsigned char* src, unsigned char c, unsigned int iMaxBytes, unsigned char* pFill, unsigned int* piCount) const {
	for (unsigned int a = 0; a < iMaxBytes && *src; a++, src++) {
		if (pFill) {
			pFill[a] = *src;
		}

		if (*src == c) {
			if (pFill) {
				pFill[a +1] = 0;
			}

			if (piCount) {
				*piCount = a;
			}

			return (unsigned char*) src;
		}
	}

	if (pFill) {
		*pFill = 0;
	}

	if (piCount) {
		*piCount = 0;
	}

	return NULL;
}

int CString::CaseCmp(const CString& s, unsigned long uLen) const {
	if (uLen != CString::npos) {
		return strncasecmp(c_str(), s.c_str(), uLen);
	}
	return strcasecmp(c_str(), s.c_str());
}

int CString::StrCmp(const CString& s, unsigned long uLen) const {
	if (uLen != CString::npos) {
		return strncmp(c_str(), s.c_str(), uLen);
	}
	return strcmp(c_str(), s.c_str());
}

bool CString::Equals(const CString& s, bool bCaseSensitive, unsigned long uLen) const {
	if (bCaseSensitive) {
		return (StrCmp(s, uLen) == 0);
	} else {
		return (CaseCmp(s, uLen) == 0);
	}
}

bool CString::WildCmp(const CString& sWild, const CString& sString) {
	// Written by Jack Handy - jakkhandy@hotmail.com
	const char *wild = sWild.c_str(), *CString = sString.c_str();
	const char *cp = NULL, *mp = NULL;

	while ((*CString) && (*wild != '*')) {
		if ((*wild != *CString) && (*wild != '?')) {
			return false;
		}

		wild++;
		CString++;
	}

	while (*CString) {
		if (*wild == '*') {
			if (!*++wild) {
				return true;
			}

			mp = wild;
			cp = CString+1;
		} else if ((*wild == *CString) || (*wild == '?')) {
			wild++;
			CString++;
		} else {
			wild = mp;
			CString = cp++;
		}
	}

	while (*wild == '*') {
		wild++;
	}

	return (*wild == 0);
}

bool CString::WildCmp(const CString& sWild) const {
	return CString::WildCmp(sWild, *this);
}

CString& CString::MakeUpper() {
	for (unsigned int a = 0; a < length(); a++) {
		char& c = (*this)[a];
		c = toupper(c);
	}

	return *this;
}

CString& CString::MakeLower() {
	for (unsigned int a = 0; a < length(); a++) {
		char& c = (*this)[a];
		c = tolower(c);
	}

	return *this;
}

CString CString::AsUpper() const {
	CString sRet = *this;

	for (unsigned int a = 0; a < length(); a++) {
		char& c = sRet[a];
		c = toupper(c);
	}

	return sRet;
}

CString CString::AsLower() const {
	CString sRet = *this;

	for (unsigned int a = 0; a < length(); a++) {
		char& c = sRet[a];
		c = tolower(c);
	}

	return sRet;
}

CString::EEscape CString::ToEscape(const CString& sEsc) {
	if (sEsc.Equals(""ASCII"")) {
		return EASCII;
	} else if (sEsc.Equals(""HTML"")) {
		return EHTML;
	} else if (sEsc.Equals(""URL"")) {
		return EURL;
	} else if (sEsc.Equals(""SQL"")) {
		return ESQL;
	}

	return EASCII;
}

CString CString::Escape_n(EEscape eFrom, EEscape eTo) const {
	CString sRet;
	const char szHex[] = ""0123456789ABCDEF"";
	const unsigned char *pStart = (const unsigned char*) data();
	const unsigned char *p = (const unsigned char*) data();
	unsigned int iLength = length();
	sRet.reserve(iLength *3);
	unsigned char pTmp[21];
	unsigned int iCounted = 0;

	for (unsigned int a = 0; a < iLength; a++, p = pStart + a) {
		unsigned char ch = 0;

		switch (eFrom) {
			case EHTML:
				if ((*p == '&') && (strnchr((unsigned char*) p, ';', sizeof(pTmp) - 1, pTmp, &iCounted))) {
					// please note that we do not have any Unicode or UTF-8 support here at all.

					if ((iCounted >= 3) && (pTmp[1] == '#')) {  // do XML and HTML &#97; &#x3c
						int base = 10;

						if ((pTmp[2] & 0xDF) == 'X') {
							base = 16;
						}

						char* endptr = NULL;
						unsigned int b = strtol((const char*) (pTmp +2 + (base == 16)), &endptr, base);

						if ((*endptr == ';') && (b <= 255)) { // incase they do something like &#7777777777;
							ch = b;
							a += iCounted;
							break;
						}
					}

					if (ch == 0) {
						if (!strncasecmp((const char*) &pTmp, ""lt"", 2)) ch = '<';
						else if (!strncasecmp((const char*) &pTmp, ""gt"", 2)) ch = '>';
						else if (!strncasecmp((const char*) &pTmp, ""quot"", 4)) ch = '""';
						else if (!strncasecmp((const char*) &pTmp, ""amp"", 3)) ch = '&';
					}

					if (ch > 0) {
						a += iCounted;
					} else {
						ch = *p;   // Not a valid escape, just record the &
					}
				} else {
					ch = *p;
				}
				break;
			case EASCII:
				ch = *p;
				break;
			case EURL:
				if (*p == '%' && (a +2) < iLength && isxdigit(*(p +1)) && isxdigit(*(p +2))) {
					p++;
					if (isdigit(*p)) {
						ch = (*p - '0') << 4;
					} else {
						ch = (tolower(*p) - 'a' +10) << 4;
					}

					p++;
					if (isdigit(*p)) {
						ch |= (*p - '0');
					} else {
						ch |= (tolower(*p) - 'a' +10);
					}

					a += 2;
				} else if (pStart[a] == '+') {
					ch = ' ';
				} else {
					ch = *p;
				}

				break;
			case ESQL:
				if (*p != '\\' || iLength < (a +1)) {
					ch = *p;
				} else {
					a++;
					p++;

					if (*p == 'n') {
						ch = '\n';
					} else if (*p == 'r') {
						ch = '\r';
					} else if (*p == '0') {
						ch = '\0';
					} else if (*p == 't') {
						ch = '\t';
					} else if (*p == 'b') {
						ch = '\b';
					} else {
						ch = *p;
					}
				}

				break;
		}

		switch (eTo) {
			case EHTML:
				if (ch == '<') sRet += ""&lt;"";
				else if (ch == '>') sRet += ""&gt;"";
				else if (ch == '""') sRet += ""&quot;"";
				else if (ch == '&') sRet += ""&amp;"";
				else {
					sRet += ch;
				}

				break;
			case EASCII:
				sRet += ch;
				break;
			case EURL:
				if (isalnum(ch) || ch == '_' || ch == '.' || ch == '-') {
					sRet += ch;
				} else if (ch == ' ') {
					sRet += '+';
				} else {
					sRet += '%';
					sRet += szHex[ch >> 4];
					sRet += szHex[ch & 0xf];
				}

				break;
			case ESQL:
				if (ch == '\0') { sRet += '\\'; sRet += '0';
				} else if (ch == '\n') { sRet += '\\'; sRet += 'n';
				} else if (ch == '\t') { sRet += '\\'; sRet += 't';
				} else if (ch == '\r') { sRet += '\\'; sRet += 'r';
				} else if (ch == '\b') { sRet += '\\'; sRet += 'b';
				} else if (ch == '\""') { sRet += '\\'; sRet += '\""';
				} else if (ch == '\'') { sRet += '\\'; sRet += '\'';
				} else if (ch == '\\') { sRet += '\\'; sRet += '\\';
				} else { sRet += ch; }

				break;
		}
	}

	sRet.reserve(0);
	return sRet;
}

CString CString::Escape_n(EEscape eTo) const {
	return Escape_n(EASCII, eTo);
}

CString& CString::Escape(EEscape eFrom, EEscape eTo) {
	return (*this = Escape_n(eFrom, eTo));
}

CString& CString::Escape(EEscape eTo) {
	return (*this = Escape_n(eTo));
}

CString CString::Replace_n(const CString& sReplace, const CString& sWith, const CString& sLeft, const CString& sRight, bool bRemoveDelims) const {
	CString sRet = *this;
	CString::Replace(sRet, sReplace, sWith, sLeft, sRight, bRemoveDelims);
	return sRet;
}

unsigned int CString::Replace(const CString& sReplace, const CString& sWith, const CString& sLeft, const CString& sRight, bool bRemoveDelims) {
	return CString::Replace(*this, sReplace, sWith, sLeft, sRight, bRemoveDelims);
}

unsigned int CString::Replace(CString& sStr, const CString& sReplace, const CString& sWith, const CString& sLeft, const CString& sRight, bool bRemoveDelims) {
	unsigned int uRet = 0;
	CString sCopy = sStr;
	sStr.clear();

	unsigned int uReplaceWidth = sReplace.length();
	unsigned int uLeftWidth = sLeft.length();
	unsigned int uRightWidth = sRight.length();
	const char* p = sCopy.c_str();
	bool bInside = false;

	while (*p) {
		if (!bInside && uLeftWidth && strncmp(p, sLeft.c_str(), uLeftWidth) == 0) {
			if (!bRemoveDelims) {
				sStr += sLeft;
			}

			p += uLeftWidth -1;
			bInside = true;
		} else if (bInside && uRightWidth && strncmp(p, sRight.c_str(), uRightWidth) == 0) {
			if (!bRemoveDelims) {
				sStr += sRight;
			}

			p += uRightWidth -1;
			bInside = false;
		} else if (!bInside && strncmp(p, sReplace.c_str(), uReplaceWidth) == 0) {
			sStr += sWith;
			p += uReplaceWidth -1;
			uRet++;
		} else {
			sStr.append(p, 1);
		}

		p++;
	}

	return uRet;
}

CString CString::Token(unsigned int uPos, bool bRest, const CString& sSep, bool bAllowEmpty,
                       const CString& sLeft, const CString& sRight, bool bTrimQuotes) const {
	VCString vsTokens;
	if (Split(sSep, vsTokens, bAllowEmpty, sLeft, sRight, bTrimQuotes) > uPos) {
		CString sRet;

		for (unsigned int a = uPos; a < vsTokens.size(); a++) {
			if (a > uPos) {
				sRet += sSep;
			}

			sRet += vsTokens[a];

			if (!bRest) {
				break;
			}
		}

		return sRet;
	}

	return Token(uPos, bRest, sSep, bAllowEmpty);
}

CString CString::Token(unsigned int uPos, bool bRest, const CString& sSep, bool bAllowEmpty) const {
	const char *sep_str = sSep.c_str();
	size_t sep_len = sSep.length();
	const char *str = c_str();
	size_t str_len = length();
	size_t start_pos = 0;
	size_t end_pos;

	if (!bAllowEmpty) {
		while (strncmp(&str[start_pos], sep_str, sep_len) == 0) {
			start_pos += sep_len;
		}
	}

	// First, find the start of our token
	while (uPos != 0 && start_pos < str_len) {
		bool bFoundSep = false;

		while (strncmp(&str[start_pos], sep_str, sep_len) == 0 && (!bFoundSep || !bAllowEmpty)) {
			start_pos += sep_len;
			bFoundSep = true;
		}

		if (bFoundSep) {
			uPos--;
		} else {
			start_pos++;
		}
	}

	// String is over?
	if (start_pos >= str_len)
		return """";

	// If they want everything from here on, give it to them
	if (bRest) {
		return substr(start_pos);
	}

	// Now look for the end of the token they want
	end_pos = start_pos;
	while (end_pos < str_len) {
		if (strncmp(&str[end_pos], sep_str, sep_len) == 0)
			return substr(start_pos, end_pos - start_pos);

		end_pos++;
	}

	// They want the last token in the string, not something in between
	return substr(start_pos);
}

CString CString::Ellipsize(unsigned int uLen) const {
	if (uLen >= size()) {
		return *this;
	}

	string sRet;

	// @todo this looks suspect
	if (uLen < 4) {
		for (unsigned int a = 0; a < uLen; a++) {
			sRet += ""."";
		}

		return sRet;
	}

	sRet = substr(0, uLen -3) + ""..."";

	return sRet;
}

CString CString::Left(unsigned int uCount) const {
	uCount = (uCount > length()) ? length() : uCount;
	return substr(0, uCount);
}

CString CString::Right(unsigned int uCount) const {
	uCount = (uCount > length()) ? length() : uCount;
	return substr(length() - uCount, uCount);
}

unsigned int CString::URLSplit(MCString& msRet) const {
	msRet.clear();

	VCString vsPairs;
	Split(""&"", vsPairs);

	for (size_t a = 0; a < vsPairs.size(); a++) {
		const CString& sPair = vsPairs[a];

		msRet[sPair.Token(0, false, ""="").Escape(CString::EURL, CString::EASCII)] = sPair.Token(1, true, ""="").Escape(CString::EURL, CString::EASCII);
	}

	return msRet.size();
}

unsigned int CString::OptionSplit(MCString& msRet, bool bUpperKeys) const {
	CString sName;
	CString sCopy(*this);
	msRet.clear();

	while (!sCopy.empty()) {
		sName = sCopy.Token(0, false, ""="", false, ""\"""", ""\"""", false).Trim_n();
		sCopy = sCopy.Token(1, true, ""="", false, ""\"""", ""\"""", false).TrimLeft_n();

		if (sName.empty()) {
			continue;
		}

		VCString vsNames;
		sName.Split("" "", vsNames, false, ""\"""", ""\"""");

		for (unsigned int a = 0; a < vsNames.size(); a++) {
			CString sKeyName = vsNames[a];

			if (bUpperKeys) {
				sKeyName.MakeUpper();
			}

			if ((a +1) == vsNames.size()) {
				msRet[sKeyName] = sCopy.Token(0, false, "" "", false, ""\"""", ""\"""");
				sCopy = sCopy.Token(1, true, "" "", false, ""\"""", ""\"""", false);
			} else {
				msRet[sKeyName] = """";
			}
		}
	}

	return msRet.size();
}

unsigned int CString::QuoteSplit(VCString& vsRet) const {
	vsRet.clear();
	return Split("" "", vsRet, false, ""\"""", ""\"""", true);
}

unsigned int CString::Split(const CString& sDelim, VCString& vsRet, bool bAllowEmpty,
		const CString& sLeft, const CString& sRight, bool bTrimQuotes, bool bTrimWhiteSpace) const {
	vsRet.clear();

	if (empty()) {
		return 0;
	}

	CString sTmp;
	bool bInside = false;
	unsigned int uDelimLen = sDelim.length();
	unsigned int uLeftLen = sLeft.length();
	unsigned int uRightLen = sRight.length();
	const char* p = c_str();

	if (!bAllowEmpty) {
		while (strncasecmp(p, sDelim.c_str(), uDelimLen) == 0) {
			p += uDelimLen;
		}
	}

	while (*p) {
		if (uLeftLen && uRightLen && !bInside && strncasecmp(p, sLeft.c_str(), uLeftLen) == 0) {
			if (!bTrimQuotes) {
				sTmp += sLeft;
			}

			p += uLeftLen;
			bInside = true;
			continue;
		}

		if (uLeftLen && uRightLen && bInside && strncasecmp(p, sRight.c_str(), uRightLen) == 0) {
			if (!bTrimQuotes) {
				sTmp += sRight;
			}

			p += uRightLen;
			bInside = false;
			continue;
		}

		if (uDelimLen && !bInside && strncasecmp(p, sDelim.c_str(), uDelimLen) == 0) {
			if (bTrimWhiteSpace) {
				sTmp.Trim();
			}

			vsRet.push_back(sTmp);
			sTmp.clear();
			p += uDelimLen;

			if (!bAllowEmpty) {
				while (strncasecmp(p, sDelim.c_str(), uDelimLen) == 0) {
					p += uDelimLen;
				}
			}

			bInside = false;
			continue;
		} else {
			sTmp += *p;
		}

		p++;
	}

	if (!sTmp.empty()) {
		if (bTrimWhiteSpace) {
			sTmp.Trim();
		}

		vsRet.push_back(sTmp);
	}

	return vsRet.size();
}

unsigned int CString::Split(const CString& sDelim, SCString& ssRet, bool bAllowEmpty, const CString& sLeft, const CString& sRight, bool bTrimQuotes, bool bTrimWhiteSpace) const {
	VCString vsTokens;

	Split(sDelim, vsTokens, bAllowEmpty, sLeft, sRight, bTrimQuotes, bTrimWhiteSpace);

	ssRet.clear();

	for (size_t a = 0; a < vsTokens.size(); a++) {
		ssRet.insert(vsTokens[a]);
	}

	return ssRet.size();
}

CString CString::RandomString(unsigned int uLength) {
	const char chars[] = ""abcdefghijklmnopqrstuvwxyz""
		""ABCDEFGHIJKLMNOPQRSTUVWXYZ""
		""0123456789!?.,:;/*-+_()"";
	// -1 because sizeof() includes the trailing '\0' byte
	const size_t len = sizeof(chars) / sizeof(chars[0]) - 1;
	size_t p;
	CString sRet;

	for (unsigned int a = 0; a < uLength; a++) {
		p = (size_t) (len * (rand() / (RAND_MAX + 1.0)));
		sRet += chars[p];
	}

	return sRet;
}

bool CString::Base64Encode(unsigned int uWrap) {
	CString sCopy(*this);
	return sCopy.Base64Encode(*this, uWrap);
}

unsigned long CString::Base64Decode() {
	CString sCopy(*this);
	return sCopy.Base64Decode(*this);
}

CString CString::Base64Encode_n(unsigned int uWrap) const {
	CString sRet;
	Base64Encode(sRet, uWrap);
	return sRet;
}

CString CString::Base64Decode_n() const {
	CString sRet;
	Base64Decode(sRet);
	return sRet;
}

bool CString::Base64Encode(CString& sRet, unsigned int uWrap) const {
	const char b64table[] = ""ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"";
	sRet.clear();
	size_t len = size();
	const unsigned char* input = (const unsigned char*) c_str();
	unsigned char *output, *p;
	size_t        i = 0, mod = len % 3, toalloc;
	toalloc = (len / 3) * 4 + (3 - mod) % 3 + 1 + 8;

	if (uWrap) {
		toalloc += len / 57;
		if (len % 57) {
			toalloc++;
		}
	}

	if (toalloc < len) {
		return 0;
	}

	p = output = new unsigned char [toalloc];

	while (i < len - mod) {
		*p++ = b64table[input[i++] >> 2];
		*p++ = b64table[((input[i - 1] << 4) | (input[i] >> 4)) & 0x3f];
		*p++ = b64table[((input[i] << 2) | (input[i + 1] >> 6)) & 0x3f];
		*p++ = b64table[input[i + 1] & 0x3f];
		i += 2;

		if (uWrap && !(i % 57)) {
			*p++ = '\n';
		}
	}

	if (!mod) {
		if (uWrap && i % 57) {
			*p++ = '\n';
		}
	} else {
		*p++ = b64table[input[i++] >> 2];
		*p++ = b64table[((input[i - 1] << 4) | (input[i] >> 4)) & 0x3f];
		if (mod == 1) {
			*p++ = '=';
		} else {
			*p++ = b64table[(input[i] << 2) & 0x3f];
		}

		*p++ = '=';

		if (uWrap) {
			*p++ = '\n';
		}
	}

	*p = 0;
	sRet = (char*) output;
	delete[] output;
	return true;
}

unsigned long CString::Base64Decode(CString& sRet) const {
	CString sTmp(*this);
	// remove new lines
	sTmp.Replace(""\r"", """");
	sTmp.Replace(""\n"", """");

	const char* in = sTmp.c_str();
	char c, c1, *p;
	unsigned long i;
	unsigned long uLen = sTmp.size();
	char* out = new char[uLen + 1];

	for (i = 0, p = out; i < uLen; i++) {
		c = (char)base64_table[(unsigned char)in[i++]];
		c1 = (char)base64_table[(unsigned char)in[i++]];
		*p++ = (c << 2) | ((c1 >> 4) & 0x3);

		if (i < uLen) {
			if (in[i] == '=') {
				break;
			}
			c = (char)base64_table[(unsigned char)in[i]];
			*p++ = ((c1 << 4) & 0xf0) | ((c >> 2) & 0xf);
		}

		if (++i < uLen) {
			if (in[i] == '=') {
				break;
			}
			*p++ = ((c << 6) & 0xc0) | (char)base64_table[(unsigned char)in[i]];
		}
	}

	*p = '\0';
	unsigned long uRet = p - out;
	sRet.clear();
	sRet.append(out, uRet);
	delete[] out;

	return uRet;
}

CString CString::MD5() const {
	return (const char*) CMD5(*this);
}

CString CString::SHA256() const {
	unsigned char digest[SHA256_DIGEST_SIZE];
	char digest_hex[SHA256_DIGEST_SIZE * 2 + 1];
	const unsigned char *message = (const unsigned char *) c_str();

	sha256(message, length(), digest);

	sprintf(digest_hex,
			""%02x%02x%02x%02x%02x%02x%02x%02x""
			""%02x%02x%02x%02x%02x%02x%02x%02x""
			""%02x%02x%02x%02x%02x%02x%02x%02x""
			""%02x%02x%02x%02x%02x%02x%02x%02x"",
			digest[ 0], digest[ 1], digest[ 2], digest[ 3], digest[ 4], digest[ 5], digest[ 6], digest[ 7],
			digest[ 8], digest[ 9], digest[10], digest[11], digest[12], digest[13], digest[14], digest[15],
			digest[16], digest[17], digest[18], digest[19], digest[20], digest[21], digest[22], digest[23],
			digest[24], digest[25], digest[26], digest[27], digest[28], digest[29], digest[30], digest[31]);

	return digest_hex;
}

#ifdef HAVE_LIBSSL
CString CString::Encrypt_n(const CString& sPass, const CString& sIvec) const {
	CString sRet;
	sRet.Encrypt(sPass, sIvec);
	return sRet;
}

CString CString::Decrypt_n(const CString& sPass, const CString& sIvec) const {
	CString sRet;
	sRet.Decrypt(sPass, sIvec);
	return sRet;
}

void CString::Encrypt(const CString& sPass, const CString& sIvec) {
	Crypt(sPass, true, sIvec);
}

void CString::Decrypt(const CString& sPass, const CString& sIvec) {
	Crypt(sPass, false, sIvec);
}

void CString::Crypt(const CString& sPass, bool bEncrypt, const CString& sIvec) {
	unsigned char szIvec[8] = {0,0,0,0,0,0,0,0};
	BF_KEY bKey;

	if (sIvec.length() >= 8) {
		memcpy(szIvec, sIvec.data(), 8);
	}

	BF_set_key(&bKey, sPass.length(), (unsigned char*) sPass.data());
	unsigned int uPad = (length() % 8);

	if (uPad) {
		uPad = 8 - uPad;
		append(uPad, '\0');
	}

	size_t uLen = length();
	unsigned char* szBuff = (unsigned char*) malloc(uLen);
	BF_cbc_encrypt((const unsigned char*) data(), szBuff, uLen, &bKey, szIvec, ((bEncrypt) ? BF_ENCRYPT : BF_DECRYPT));

	clear();
	append((const char*) szBuff, uLen);
	free(szBuff);
}
#endif	// HAVE_LIBSSL

CString CString::ToPercent(double d) {
	char szRet[32];
	snprintf(szRet, 32, ""%.02f%%"", d);
	return szRet;
}

CString CString::ToByteStr(unsigned long long d) {
	const unsigned long long KiB = 1024;
	const unsigned long long MiB = KiB * 1024;
	const unsigned long long GiB = MiB * 1024;
	const unsigned long long TiB = GiB * 1024;

	if (d > TiB) {
		return CString(d / (double) TiB) + "" TiB"";
	} else if (d > GiB) {
		return CString(d / (double) GiB) + "" GiB"";
	} else if (d > MiB) {
		return CString(d / (double) MiB) + "" MiB"";
	} else if (d > KiB) {
		return CString(d / (double) KiB) + "" KiB"";
	}

	return CString(d) + "" B"";
}

CString CString::ToTimeStr(unsigned long s) {
	const unsigned long m = 60;
	const unsigned long h = m * 60;
	const unsigned long d = h * 24;
	const unsigned long w = d * 7;
	const unsigned long y = d * 365;
	CString sRet;

#define TIMESPAN(time, str)                          \
	if (s >= time) {                             \
		sRet += CString(s / time) + str "" ""; \
		s = s % time;                        \
	}
	TIMESPAN(y, ""y"");
	TIMESPAN(w, ""w"");
	TIMESPAN(d, ""d"");
	TIMESPAN(h, ""h"");
	TIMESPAN(m, ""m"");
	TIMESPAN(1, ""s"");

	if (sRet.empty())
		return ""0s"";

	return sRet.RightChomp_n();
}

bool CString::ToBool() const { return (!Trim_n().Trim_n(""0"").empty() && !Trim_n().Equals(""false"")); }
short CString::ToShort() const { return strtoul(this->c_str(), (char**) NULL, 10); }
unsigned short CString::ToUShort() const { return strtoul(this->c_str(), (char**) NULL, 10); }
unsigned int CString::ToUInt() const { return strtoul(this->c_str(), (char**) NULL, 10); }
int CString::ToInt() const { return strtoul(this->c_str(), (char**) NULL, 10); }
long CString::ToLong() const { return strtoul(this->c_str(), (char**) NULL, 10); }
unsigned long CString::ToULong() const { return strtoul(c_str(), NULL, 10); }
unsigned long long CString::ToULongLong() const { return strtoull(c_str(), NULL, 10); }
long long CString::ToLongLong() const { return strtoll(c_str(), NULL, 10); }
double CString::ToDouble() const { return strtod(c_str(), NULL); }


bool CString::Trim(const CString& s) {
	bool bLeft = TrimLeft(s);
	return (TrimRight(s) || bLeft);
}

bool CString::TrimLeft(const CString& s) {
	size_type i = find_first_not_of(s);

	if (i == 0)
		return false;

	if (i != npos)
		this->erase(0, i);
	else
		this->clear();

	return true;
}

bool CString::TrimRight(const CString& s) {
	size_type i = find_last_not_of(s);

	if (i + 1 == length())
		return false;

	if (i != npos)
		this->erase(i + 1, npos);
	else
		this->clear();

	return true;
}

CString CString::Trim_n(const CString& s) const {
	CString sRet = *this;
	sRet.Trim(s);
	return sRet;
}

CString CString::TrimLeft_n(const CString& s) const {
	CString sRet = *this;
	sRet.TrimLeft(s);
	return sRet;
}

CString CString::TrimRight_n(const CString& s) const {
	CString sRet = *this;
	sRet.TrimRight(s);
	return sRet;
}

bool CString::TrimPrefix(const CString& sPrefix) {
	if (Equals(sPrefix, false, sPrefix.length())) {
		LeftChomp(sPrefix.length());
		return true;
	} else {
		return false;
	}
}

bool CString::TrimSuffix(const CString& sSuffix) {
	if (Right(sSuffix.length()).Equals(sSuffix)) {
		RightChomp(sSuffix.length());
		return true;
	} else {
		return false;
	}
}


CString CString::TrimPrefix_n(const CString& sPrefix) const {
	CString sRet = *this;
	sRet.TrimPrefix(sPrefix);
	return sRet;
}

CString CString::TrimSuffix_n(const CString& sSuffix) const {
	CString sRet = *this;
	sRet.TrimSuffix(sSuffix);
	return sRet;
}

CString CString::LeftChomp_n(unsigned int uLen) const {
	CString sRet = *this;
	sRet.LeftChomp(uLen);
	return sRet;
}

CString CString::RightChomp_n(unsigned int uLen) const {
	CString sRet = *this;
	sRet.RightChomp(uLen);
	return sRet;
}

bool CString::LeftChomp(unsigned int uLen) {
	bool bRet = false;

	while ((uLen--) && (length())) {
		erase(0, 1);
		bRet = true;
	}

	return bRet;
}

bool CString::RightChomp(unsigned int uLen) {
	bool bRet = false;

	while ((uLen--) && (length())) {
		erase(length() -1);
		bRet = true;
	}

	return bRet;
}

//////////////// MCString ////////////////
MCString::status_t MCString::WriteToDisk(const CString& sPath, mode_t iMode) const {
	CFile cFile(sPath);

	if (this->empty()) {
		if (!cFile.Exists())
			return MCS_SUCCESS;
		if (cFile.Delete())
			return MCS_SUCCESS;
	}

	if (!cFile.Open(O_WRONLY|O_CREAT|O_TRUNC, iMode)) {
		return MCS_EOPEN;
	}

	for (MCString::const_iterator it = this->begin(); it != this->end(); ++it) {
		CString sKey = it->first;
		CString sValue = it->second;
		if (!WriteFilter(sKey, sValue)) {
			return MCS_EWRITEFIL;
		}

		if (sKey.empty()) {
			continue;
		}

		if (cFile.Write(Encode(sKey) + "" "" +  Encode(sValue) + ""\n"") <= 0) {
			return MCS_EWRITE;
		}
	}

	cFile.Close();

	return MCS_SUCCESS;
}

MCString::status_t MCString::ReadFromDisk(const CString& sPath) {
	clear();
	CFile cFile(sPath);
	if (!cFile.Open(O_RDONLY)) {
		return MCS_EOPEN;
	}

	CString sBuffer;

	while (cFile.ReadLine(sBuffer)) {
		sBuffer.Trim();
		CString sKey = sBuffer.Token(0);
		CString sValue = sBuffer.Token(1);
		Decode(sKey);
		Decode(sValue);

		if (!ReadFilter(sKey, sValue))
			return MCS_EREADFIL;

		(*this)[sKey] = sValue;
	}
	cFile.Close();

	return MCS_SUCCESS;
}


static const char hexdigits[] = ""0123456789abcdef"";

CString& MCString::Encode(CString& sValue) const {
	CString sTmp;
	for (CString::iterator it = sValue.begin(); it != sValue.end(); ++it) {
		// isalnum() needs unsigned char as argument and this code
		// assumes unsigned, too.
		unsigned char c = *it;
		if (isalnum(c)) {
			sTmp += c;
		} else {
			sTmp += ""%"";
			sTmp += hexdigits[c >> 4];
			sTmp += hexdigits[c & 0xf];
			sTmp += "";"";
		}
	}
	sValue = sTmp;
	return sValue;
}

CString& MCString::Decode(CString& sValue) const {
	const char *pTmp = sValue.c_str();
	char *endptr;
	CString sTmp;

	while (*pTmp) {
		if (*pTmp != '%') {
			sTmp += *pTmp++;
		} else {
			char ch = (char) strtol(pTmp + 1, &endptr, 16);
			if (*endptr == ';') {
				sTmp += ch;
				pTmp = ++endptr;
			} else {
				sTmp += *pTmp++;
			}
		}
	}

	sValue = sTmp;
	return sValue;
}
""",MCString::Encode,[1098:1115]
znc,https://github.com/znc/znc/commit/0188281f58f6c5df7e48216c6099b51a72649243,"""perform: C++11 range-based for loops""","""/*
 * Copyright (C) 2004-2015 ZNC, see the NOTICE file for details.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <znc/IRCNetwork.h>

class CPerform : public CModule {
	void Add(const CString& sCommand) {
		CString sPerf = sCommand.Token(1, true);

		if (sPerf.empty()) {
			PutModule(""Usage: add <command>"");
			return;
		}

		m_vPerform.push_back(ParsePerform(sPerf));
		PutModule(""Added!"");
		Save();
	}

	void Del(const CString& sCommand) {
		u_int iNum = sCommand.Token(1, true).ToUInt();

		if (iNum > m_vPerform.size() || iNum <= 0) {
			PutModule(""Illegal # Requested"");
			return;
		} else {
			m_vPerform.erase(m_vPerform.begin() + iNum - 1);
			PutModule(""Command Erased."");
		}
		Save();
	}

	void List(const CString& sCommand) {
		CTable Table;
		unsigned int index = 1;

		Table.AddColumn(""Id"");
		Table.AddColumn(""Perform"");
		Table.AddColumn(""Expanded"");

		for (VCString::const_iterator it = m_vPerform.begin(); it != m_vPerform.end(); ++it, index++) {
			Table.AddRow();
			Table.SetCell(""Id"", CString(index));
			Table.SetCell(""Perform"", *it);

			CString sExpanded = ExpandString(*it);

			if (sExpanded != *it) {
				Table.SetCell(""Expanded"", sExpanded);
			}
		}

		if (PutModule(Table) == 0) {
			PutModule(""No commands in your perform list."");
		}
	}

	void Execute(const CString& sCommand) {
		OnIRCConnected();
		PutModule(""perform commands sent"");
	}

	void Swap(const CString& sCommand) {
		u_int iNumA = sCommand.Token(1).ToUInt();
		u_int iNumB = sCommand.Token(2).ToUInt();

		if (iNumA > m_vPerform.size() || iNumA <= 0 || iNumB > m_vPerform.size() || iNumB <= 0) {
			PutModule(""Illegal # Requested"");
		} else {
			std::iter_swap(m_vPerform.begin() + (iNumA - 1), m_vPerform.begin() + (iNumB - 1));
			PutModule(""Commands Swapped."");
			Save();
		}
	}

public:
	MODCONSTRUCTOR(CPerform) {
		AddHelpCommand();
		AddCommand(""Add"",     static_cast<CModCommand::ModCmdFunc>(&CPerform::Add),
			""<command>"");
		AddCommand(""Del"",     static_cast<CModCommand::ModCmdFunc>(&CPerform::Del),
			""<nr>"");
		AddCommand(""List"",    static_cast<CModCommand::ModCmdFunc>(&CPerform::List));
		AddCommand(""Execute"", static_cast<CModCommand::ModCmdFunc>(&CPerform::Execute));
		AddCommand(""Swap"",    static_cast<CModCommand::ModCmdFunc>(&CPerform::Swap),
			""<nr> <nr>"");
	}

	virtual ~CPerform() {}

	CString ParsePerform(const CString& sArg) const {
		CString sPerf = sArg;

		if (sPerf.Left(1) == ""/"")
			sPerf.LeftChomp();

		if (sPerf.Token(0).Equals(""MSG"")) {
			sPerf = ""PRIVMSG "" + sPerf.Token(1, true);
		}

		if ((sPerf.Token(0).Equals(""PRIVMSG"") ||
				sPerf.Token(0).Equals(""NOTICE"")) &&
				sPerf.Token(2).Left(1) != "":"") {
			sPerf = sPerf.Token(0) + "" "" + sPerf.Token(1)
				+ "" :"" + sPerf.Token(2, true);
		}

		return sPerf;
	}

	bool OnLoad(const CString& sArgs, CString& sMessage) override {
		GetNV(""Perform"").Split(""\n"", m_vPerform, false);

		return true;
	}

	void OnIRCConnected() override {
		for (VCString::const_iterator it = m_vPerform.begin(); it != m_vPerform.end(); ++it) {
			PutIRC(ExpandString(*it));
		}
	}

	CString GetWebMenuTitle() override { return ""Perform""; }

	bool OnWebRequest(CWebSock& WebSock, const CString& sPageName, CTemplate& Tmpl) override {
		if (sPageName != ""index"") {
			// only accept requests to index
			return false;
		}

		if (WebSock.IsPost()) {
			VCString vsPerf;
			WebSock.GetRawParam(""perform"", true).Split(""\n"", vsPerf, false);
			m_vPerform.clear();

			for (VCString::const_iterator it = vsPerf.begin(); it != vsPerf.end(); ++it)
				m_vPerform.push_back(ParsePerform(*it));

			Save();
		}

		for (VCString::const_iterator it = m_vPerform.begin(); it != m_vPerform.end(); ++it) {
			CTemplate& Row = Tmpl.AddRow(""PerformLoop"");
			Row[""Perform""] = *it;
		}

		return true;
	}

private:
	void Save() {
		CString sBuffer = """";

		for (VCString::const_iterator it = m_vPerform.begin(); it != m_vPerform.end(); ++it) {
			sBuffer += *it + ""\n"";
		}
		SetNV(""Perform"", sBuffer);
	}

	VCString m_vPerform;
};

template<> void TModInfo<CPerform>(CModInfo& Info) {
	Info.AddType(CModInfo::UserModule);
	Info.SetWikiPage(""perform"");
}

NETWORKMODULEDEFS(CPerform, ""Keeps a list of commands to be executed when ZNC connects to IRC."")
""","""/*
 * Copyright (C) 2004-2015 ZNC, see the NOTICE file for details.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <znc/IRCNetwork.h>

class CPerform : public CModule {
	void Add(const CString& sCommand) {
		CString sPerf = sCommand.Token(1, true);

		if (sPerf.empty()) {
			PutModule(""Usage: add <command>"");
			return;
		}

		m_vPerform.push_back(ParsePerform(sPerf));
		PutModule(""Added!"");
		Save();
	}

	void Del(const CString& sCommand) {
		u_int iNum = sCommand.Token(1, true).ToUInt();

		if (iNum > m_vPerform.size() || iNum <= 0) {
			PutModule(""Illegal # Requested"");
			return;
		} else {
			m_vPerform.erase(m_vPerform.begin() + iNum - 1);
			PutModule(""Command Erased."");
		}
		Save();
	}

	void List(const CString& sCommand) {
		CTable Table;
		unsigned int index = 1;

		Table.AddColumn(""Id"");
		Table.AddColumn(""Perform"");
		Table.AddColumn(""Expanded"");

		for (const CString& sPerf : m_vPerform) {
			Table.AddRow();
			Table.SetCell(""Id"", CString(index++));
			Table.SetCell(""Perform"", sPerf);

			CString sExpanded = ExpandString(sPerf);

			if (sExpanded != sPerf) {
				Table.SetCell(""Expanded"", sExpanded);
			}
		}

		if (PutModule(Table) == 0) {
			PutModule(""No commands in your perform list."");
		}
	}

	void Execute(const CString& sCommand) {
		OnIRCConnected();
		PutModule(""perform commands sent"");
	}

	void Swap(const CString& sCommand) {
		u_int iNumA = sCommand.Token(1).ToUInt();
		u_int iNumB = sCommand.Token(2).ToUInt();

		if (iNumA > m_vPerform.size() || iNumA <= 0 || iNumB > m_vPerform.size() || iNumB <= 0) {
			PutModule(""Illegal # Requested"");
		} else {
			std::iter_swap(m_vPerform.begin() + (iNumA - 1), m_vPerform.begin() + (iNumB - 1));
			PutModule(""Commands Swapped."");
			Save();
		}
	}

public:
	MODCONSTRUCTOR(CPerform) {
		AddHelpCommand();
		AddCommand(""Add"",     static_cast<CModCommand::ModCmdFunc>(&CPerform::Add),
			""<command>"");
		AddCommand(""Del"",     static_cast<CModCommand::ModCmdFunc>(&CPerform::Del),
			""<nr>"");
		AddCommand(""List"",    static_cast<CModCommand::ModCmdFunc>(&CPerform::List));
		AddCommand(""Execute"", static_cast<CModCommand::ModCmdFunc>(&CPerform::Execute));
		AddCommand(""Swap"",    static_cast<CModCommand::ModCmdFunc>(&CPerform::Swap),
			""<nr> <nr>"");
	}

	virtual ~CPerform() {}

	CString ParsePerform(const CString& sArg) const {
		CString sPerf = sArg;

		if (sPerf.Left(1) == ""/"")
			sPerf.LeftChomp();

		if (sPerf.Token(0).Equals(""MSG"")) {
			sPerf = ""PRIVMSG "" + sPerf.Token(1, true);
		}

		if ((sPerf.Token(0).Equals(""PRIVMSG"") ||
				sPerf.Token(0).Equals(""NOTICE"")) &&
				sPerf.Token(2).Left(1) != "":"") {
			sPerf = sPerf.Token(0) + "" "" + sPerf.Token(1)
				+ "" :"" + sPerf.Token(2, true);
		}

		return sPerf;
	}

	bool OnLoad(const CString& sArgs, CString& sMessage) override {
		GetNV(""Perform"").Split(""\n"", m_vPerform, false);

		return true;
	}

	void OnIRCConnected() override {
		for (const CString& sPerf : m_vPerform) {
			PutIRC(ExpandString(sPerf));
		}
	}

	CString GetWebMenuTitle() override { return ""Perform""; }

	bool OnWebRequest(CWebSock& WebSock, const CString& sPageName, CTemplate& Tmpl) override {
		if (sPageName != ""index"") {
			// only accept requests to index
			return false;
		}

		if (WebSock.IsPost()) {
			VCString vsPerf;
			WebSock.GetRawParam(""perform"", true).Split(""\n"", vsPerf, false);
			m_vPerform.clear();

			for (const CString& sPerf : vsPerf)
				m_vPerform.push_back(ParsePerform(sPerf));

			Save();
		}

		for (const CString& sPerf : m_vPerform) {
			CTemplate& Row = Tmpl.AddRow(""PerformLoop"");
			Row[""Perform""] = sPerf;
		}

		return true;
	}

private:
	void Save() {
		CString sBuffer = """";

		for (const CString& sPerf : m_vPerform) {
			sBuffer += sPerf + ""\n"";
		}
		SetNV(""Perform"", sBuffer);
	}

	VCString m_vPerform;
};

template<> void TModInfo<CPerform>(CModInfo& Info) {
	Info.AddType(CModInfo::UserModule);
	Info.SetWikiPage(""perform"");
}

NETWORKMODULEDEFS(CPerform, ""Keeps a list of commands to be executed when ZNC connects to IRC."")
""",,
znc,https://github.com/znc/znc/commit/f54ad1f22075940dff3b6ec6d4c39e92425793d7,"""perform: say ""number"" instead of ""nr""

I think it's inconsistent that perform uses abbreviation ""nr"" of ""number""
while it talks about ""command"" instead of ""cmd"".""","""/*
 * Copyright (C) 2004-2015 ZNC, see the NOTICE file for details.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <znc/IRCNetwork.h>

class CPerform : public CModule {
	void Add(const CString& sCommand) {
		CString sPerf = sCommand.Token(1, true);

		if (sPerf.empty()) {
			PutModule(""Usage: add <command>"");
			return;
		}

		m_vPerform.push_back(ParsePerform(sPerf));
		PutModule(""Added!"");
		Save();
	}

	void Del(const CString& sCommand) {
		u_int iNum = sCommand.Token(1, true).ToUInt();

		if (iNum > m_vPerform.size() || iNum <= 0) {
			PutModule(""Illegal # Requested"");
			return;
		} else {
			m_vPerform.erase(m_vPerform.begin() + iNum - 1);
			PutModule(""Command Erased."");
		}
		Save();
	}

	void List(const CString& sCommand) {
		CTable Table;
		unsigned int index = 1;

		Table.AddColumn(""Id"");
		Table.AddColumn(""Perform"");
		Table.AddColumn(""Expanded"");

		for (VCString::const_iterator it = m_vPerform.begin(); it != m_vPerform.end(); ++it, index++) {
			Table.AddRow();
			Table.SetCell(""Id"", CString(index));
			Table.SetCell(""Perform"", *it);

			CString sExpanded = ExpandString(*it);

			if (sExpanded != *it) {
				Table.SetCell(""Expanded"", sExpanded);
			}
		}

		if (PutModule(Table) == 0) {
			PutModule(""No commands in your perform list."");
		}
	}

	void Execute(const CString& sCommand) {
		OnIRCConnected();
		PutModule(""perform commands sent"");
	}

	void Swap(const CString& sCommand) {
		u_int iNumA = sCommand.Token(1).ToUInt();
		u_int iNumB = sCommand.Token(2).ToUInt();

		if (iNumA > m_vPerform.size() || iNumA <= 0 || iNumB > m_vPerform.size() || iNumB <= 0) {
			PutModule(""Illegal # Requested"");
		} else {
			std::iter_swap(m_vPerform.begin() + (iNumA - 1), m_vPerform.begin() + (iNumB - 1));
			PutModule(""Commands Swapped."");
			Save();
		}
	}

public:
	MODCONSTRUCTOR(CPerform) {
		AddHelpCommand();
		AddCommand(""Add"",     static_cast<CModCommand::ModCmdFunc>(&CPerform::Add),
			""<command>"");
		AddCommand(""Del"",     static_cast<CModCommand::ModCmdFunc>(&CPerform::Del),
			""<nr>"");
		AddCommand(""List"",    static_cast<CModCommand::ModCmdFunc>(&CPerform::List));
		AddCommand(""Execute"", static_cast<CModCommand::ModCmdFunc>(&CPerform::Execute));
		AddCommand(""Swap"",    static_cast<CModCommand::ModCmdFunc>(&CPerform::Swap),
			""<nr> <nr>"");
	}

	virtual ~CPerform() {}

	CString ParsePerform(const CString& sArg) const {
		CString sPerf = sArg;

		if (sPerf.Left(1) == ""/"")
			sPerf.LeftChomp();

		if (sPerf.Token(0).Equals(""MSG"")) {
			sPerf = ""PRIVMSG "" + sPerf.Token(1, true);
		}

		if ((sPerf.Token(0).Equals(""PRIVMSG"") ||
				sPerf.Token(0).Equals(""NOTICE"")) &&
				sPerf.Token(2).Left(1) != "":"") {
			sPerf = sPerf.Token(0) + "" "" + sPerf.Token(1)
				+ "" :"" + sPerf.Token(2, true);
		}

		return sPerf;
	}

	virtual bool OnLoad(const CString& sArgs, CString& sMessage) override {
		GetNV(""Perform"").Split(""\n"", m_vPerform, false);

		return true;
	}

	virtual void OnIRCConnected() override {
		for (VCString::const_iterator it = m_vPerform.begin(); it != m_vPerform.end(); ++it) {
			PutIRC(ExpandString(*it));
		}
	}

	virtual CString GetWebMenuTitle() override { return ""Perform""; }

	virtual bool OnWebRequest(CWebSock& WebSock, const CString& sPageName, CTemplate& Tmpl) override {
		if (sPageName != ""index"") {
			// only accept requests to index
			return false;
		}

		if (WebSock.IsPost()) {
			VCString vsPerf;
			WebSock.GetRawParam(""perform"", true).Split(""\n"", vsPerf, false);
			m_vPerform.clear();

			for (VCString::const_iterator it = vsPerf.begin(); it != vsPerf.end(); ++it)
				m_vPerform.push_back(ParsePerform(*it));

			Save();
		}

		for (VCString::const_iterator it = m_vPerform.begin(); it != m_vPerform.end(); ++it) {
			CTemplate& Row = Tmpl.AddRow(""PerformLoop"");
			Row[""Perform""] = *it;
		}

		return true;
	}

private:
	void Save() {
		CString sBuffer = """";

		for (VCString::const_iterator it = m_vPerform.begin(); it != m_vPerform.end(); ++it) {
			sBuffer += *it + ""\n"";
		}
		SetNV(""Perform"", sBuffer);
	}

	VCString m_vPerform;
};

template<> void TModInfo<CPerform>(CModInfo& Info) {
	Info.AddType(CModInfo::UserModule);
	Info.SetWikiPage(""perform"");
}

NETWORKMODULEDEFS(CPerform, ""Keeps a list of commands to be executed when ZNC connects to IRC."")
""","""/*
 * Copyright (C) 2004-2015 ZNC, see the NOTICE file for details.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <znc/IRCNetwork.h>

class CPerform : public CModule {
	void Add(const CString& sCommand) {
		CString sPerf = sCommand.Token(1, true);

		if (sPerf.empty()) {
			PutModule(""Usage: add <command>"");
			return;
		}

		m_vPerform.push_back(ParsePerform(sPerf));
		PutModule(""Added!"");
		Save();
	}

	void Del(const CString& sCommand) {
		u_int iNum = sCommand.Token(1, true).ToUInt();

		if (iNum > m_vPerform.size() || iNum <= 0) {
			PutModule(""Illegal # Requested"");
			return;
		} else {
			m_vPerform.erase(m_vPerform.begin() + iNum - 1);
			PutModule(""Command Erased."");
		}
		Save();
	}

	void List(const CString& sCommand) {
		CTable Table;
		unsigned int index = 1;

		Table.AddColumn(""Id"");
		Table.AddColumn(""Perform"");
		Table.AddColumn(""Expanded"");

		for (VCString::const_iterator it = m_vPerform.begin(); it != m_vPerform.end(); ++it, index++) {
			Table.AddRow();
			Table.SetCell(""Id"", CString(index));
			Table.SetCell(""Perform"", *it);

			CString sExpanded = ExpandString(*it);

			if (sExpanded != *it) {
				Table.SetCell(""Expanded"", sExpanded);
			}
		}

		if (PutModule(Table) == 0) {
			PutModule(""No commands in your perform list."");
		}
	}

	void Execute(const CString& sCommand) {
		OnIRCConnected();
		PutModule(""perform commands sent"");
	}

	void Swap(const CString& sCommand) {
		u_int iNumA = sCommand.Token(1).ToUInt();
		u_int iNumB = sCommand.Token(2).ToUInt();

		if (iNumA > m_vPerform.size() || iNumA <= 0 || iNumB > m_vPerform.size() || iNumB <= 0) {
			PutModule(""Illegal # Requested"");
		} else {
			std::iter_swap(m_vPerform.begin() + (iNumA - 1), m_vPerform.begin() + (iNumB - 1));
			PutModule(""Commands Swapped."");
			Save();
		}
	}

public:
	MODCONSTRUCTOR(CPerform) {
		AddHelpCommand();
		AddCommand(""Add"",     static_cast<CModCommand::ModCmdFunc>(&CPerform::Add),
			""<command>"");
		AddCommand(""Del"",     static_cast<CModCommand::ModCmdFunc>(&CPerform::Del),
			""<number>"");
		AddCommand(""List"",    static_cast<CModCommand::ModCmdFunc>(&CPerform::List));
		AddCommand(""Execute"", static_cast<CModCommand::ModCmdFunc>(&CPerform::Execute));
		AddCommand(""Swap"",    static_cast<CModCommand::ModCmdFunc>(&CPerform::Swap),
			""<number> <number>"");
	}

	virtual ~CPerform() {}

	CString ParsePerform(const CString& sArg) const {
		CString sPerf = sArg;

		if (sPerf.Left(1) == ""/"")
			sPerf.LeftChomp();

		if (sPerf.Token(0).Equals(""MSG"")) {
			sPerf = ""PRIVMSG "" + sPerf.Token(1, true);
		}

		if ((sPerf.Token(0).Equals(""PRIVMSG"") ||
				sPerf.Token(0).Equals(""NOTICE"")) &&
				sPerf.Token(2).Left(1) != "":"") {
			sPerf = sPerf.Token(0) + "" "" + sPerf.Token(1)
				+ "" :"" + sPerf.Token(2, true);
		}

		return sPerf;
	}

	virtual bool OnLoad(const CString& sArgs, CString& sMessage) override {
		GetNV(""Perform"").Split(""\n"", m_vPerform, false);

		return true;
	}

	virtual void OnIRCConnected() override {
		for (VCString::const_iterator it = m_vPerform.begin(); it != m_vPerform.end(); ++it) {
			PutIRC(ExpandString(*it));
		}
	}

	virtual CString GetWebMenuTitle() override { return ""Perform""; }

	virtual bool OnWebRequest(CWebSock& WebSock, const CString& sPageName, CTemplate& Tmpl) override {
		if (sPageName != ""index"") {
			// only accept requests to index
			return false;
		}

		if (WebSock.IsPost()) {
			VCString vsPerf;
			WebSock.GetRawParam(""perform"", true).Split(""\n"", vsPerf, false);
			m_vPerform.clear();

			for (VCString::const_iterator it = vsPerf.begin(); it != vsPerf.end(); ++it)
				m_vPerform.push_back(ParsePerform(*it));

			Save();
		}

		for (VCString::const_iterator it = m_vPerform.begin(); it != m_vPerform.end(); ++it) {
			CTemplate& Row = Tmpl.AddRow(""PerformLoop"");
			Row[""Perform""] = *it;
		}

		return true;
	}

private:
	void Save() {
		CString sBuffer = """";

		for (VCString::const_iterator it = m_vPerform.begin(); it != m_vPerform.end(); ++it) {
			sBuffer += *it + ""\n"";
		}
		SetNV(""Perform"", sBuffer);
	}

	VCString m_vPerform;
};

template<> void TModInfo<CPerform>(CModInfo& Info) {
	Info.AddType(CModInfo::UserModule);
	Info.SetWikiPage(""perform"");
}

NETWORKMODULEDEFS(CPerform, ""Keeps a list of commands to be executed when ZNC connects to IRC."")
""",CPerform::MODCONSTRUCTOR,[90:100]
znc,https://github.com/znc/znc/commit/74bfbea6f217031da3603683e86af80c29c366a1,"""Speed up FixCVE20149403 test

The test was unnecessarily waiting for ZNC to join some channel, which
took a long time.

Signed-off-by: Uli Schlachter <psychon@znc.in>""","""/*
 * Copyright (C) 2004-2016 ZNC, see the NOTICE file for details.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <gtest/gtest.h>
#include <gmock/gmock.h>

#include <QCoreApplication>
#include <QDateTime>
#include <QNetworkAccessManager>
#include <QNetworkRequest>
#include <QNetworkReply>
#include <QProcess>
#include <QTcpServer>
#include <QTcpSocket>
#include <QTemporaryDir>
#include <QTextStream>
#include <QTimer>
#include <QUrl>
#include <QUrlQuery>

#include <memory>

#define Z                                                                    \
    do {                                                                     \
        if (::testing::Test::HasFatalFailure()) {                            \
            std::cerr << ""At: "" << __FILE__ << "":"" << __LINE__ << std::endl; \
            return;                                                          \
        }                                                                    \
    } while (0)

#ifndef ZNC_BIN_DIR
#define ZNC_BIN_DIR """"
#endif

using testing::AnyOf;
using testing::Eq;
using testing::HasSubstr;

namespace {

template <typename Device>
class IO {
  public:
    IO(Device* device, bool verbose = false)
        : m_device(device), m_verbose(verbose) {}
    virtual ~IO() {}
    void ReadUntil(QByteArray pattern) {
        auto deadline = QDateTime::currentDateTime().addSecs(60);
        while (true) {
            int search = m_readed.indexOf(pattern);
            if (search != -1) {
                m_readed.remove(0, search + pattern.length());
                return;
            }
            if (m_readed.length() > pattern.length()) {
                m_readed = m_readed.right(pattern.length());
            }
            const int timeout_ms =
                QDateTime::currentDateTime().msecsTo(deadline);
            ASSERT_GT(timeout_ms, 0) << ""Wanted:"" << pattern.toStdString();
            ASSERT_TRUE(m_device->waitForReadyRead(timeout_ms))
                << ""Wanted: "" << pattern.toStdString();
            QByteArray chunk = m_device->readAll();
            if (m_verbose) {
                std::cout << chunk.toStdString() << std::flush;
            }
            m_readed += chunk;
        }
    }
    void Write(QByteArray s = """", bool new_line = true) {
        if (!m_device) return;
        if (m_verbose) {
            std::cout << s.toStdString() << std::flush;
            if (new_line) {
                std::cout << std::endl;
            }
        }
        s += ""\n"";
        while (!s.isEmpty()) {
            auto res = m_device->write(s);
            ASSERT_NE(res, -1);
            s.remove(0, res);
        }
        FlushIfCan(m_device);
    }
    void Close() {
#ifdef __CYGWIN__
        // Qt on cygwin silently doesn't send the rest of buffer from socket
        // without this line
        sleep(1);
#endif
        m_device->disconnectFromHost();
    }

  private:
    // Need to flush QTcpSocket, and QIODevice doesn't have flush at all...
    static void FlushIfCan(QIODevice*) {}
    static void FlushIfCan(QTcpSocket* sock) { sock->flush(); }

    Device* m_device;
    bool m_verbose;
    QByteArray m_readed;
};

template <typename Device>
IO<Device> WrapIO(Device* d) {
    return IO<Device>(d);
}

using Socket = IO<QTcpSocket>;

class Process : public IO<QProcess> {
  public:
    Process(QString cmd, QStringList args,
            std::function<void(QProcess*)> setup = [](QProcess*) {})
        : IO(&m_proc, true) {
        auto env = QProcessEnvironment::systemEnvironment();
        env.insert(""ZNC_DEBUG_TIMER"", ""1"");
        // Default exit codes of sanitizers upon error:
        // ASAN - 1
        // LSAN - 23 (part of ASAN, but uses a different value)
        // TSAN - 66
        //
        // ZNC uses 1 too to report startup failure.
        // But we don't want to confuse expected startup failure with ASAN
        // error.
        env.insert(""ASAN_OPTIONS"", ""exitcode=57"");
        m_proc.setProcessEnvironment(env);
        setup(&m_proc);
        m_proc.start(cmd, args);
        EXPECT_TRUE(m_proc.waitForStarted())
            << ""Failed to start ZNC, did you install it?"";
    }
    ~Process() override {
        if (m_kill) m_proc.terminate();
        [this]() {
            ASSERT_TRUE(m_proc.waitForFinished());
            if (!m_allowDie) {
                ASSERT_EQ(QProcess::NormalExit, m_proc.exitStatus());
                if (m_allowLeak) {
                    ASSERT_THAT(m_proc.exitStatus(), AnyOf(Eq(23), Eq(m_exit)));
                } else {
                    ASSERT_EQ(m_exit, m_proc.exitCode());
                }
            }
        }();
    }
    void ShouldFinishItself(int code = 0) {
        m_kill = false;
        m_exit = code;
    }
    void CanDie() { m_allowDie = true; }

    // I can't do much about SWIG...
    void CanLeak() { m_allowLeak = true; }

  private:
    bool m_kill = true;
    int m_exit = 0;
    bool m_allowDie = false;
    bool m_allowLeak = false;
    QProcess m_proc;
};

void WriteConfig(QString path) {
    // clang-format off
    Process p(ZNC_BIN_DIR ""/znc"", QStringList() << ""--debug""
                                                << ""--datadir"" << path
                                                << ""--makeconf"");
    p.ReadUntil(""Listen on port"");Z;          p.Write(""12345"");
    p.ReadUntil(""Listen using SSL"");Z;        p.Write();
    p.ReadUntil(""IPv6"");Z;                    p.Write();
    p.ReadUntil(""Username"");Z;                p.Write(""user"");
    p.ReadUntil(""password"");Z;                p.Write(""hunter2"", false);
    p.ReadUntil(""Confirm"");Z;                 p.Write(""hunter2"", false);
    p.ReadUntil(""Nick [user]"");Z;             p.Write();
    p.ReadUntil(""Alternate nick [user_]"");Z;  p.Write();
    p.ReadUntil(""Ident [user]"");Z;            p.Write();
    p.ReadUntil(""Real name"");Z;               p.Write();
    p.ReadUntil(""Bind host"");Z;               p.Write();
    p.ReadUntil(""Set up a network?"");Z;       p.Write();
    p.ReadUntil(""Name [freenode]"");Z;         p.Write(""test"");
    p.ReadUntil(""Server host (host only)"");Z; p.Write(""127.0.0.1"");
    p.ReadUntil(""Server uses SSL?"");Z;        p.Write();
    p.ReadUntil(""6667"");Z;                    p.Write();
    p.ReadUntil(""password"");Z;                p.Write();
    p.ReadUntil(""channels"");Z;                p.Write();
    p.ReadUntil(""Launch ZNC now?"");Z;         p.Write(""no"");
    p.ShouldFinishItself();
    // clang-format on
}

TEST(Config, AlreadyExists) {
    QTemporaryDir dir;
    WriteConfig(dir.path());
    Z;
    Process p(ZNC_BIN_DIR ""/znc"", QStringList() << ""--debug""
                                                << ""--datadir"" << dir.path()
                                                << ""--makeconf"");
    p.ReadUntil(""already exists"");
    Z;
    p.CanDie();
}

// Can't use QEventLoop without existing QCoreApplication
class App {
  public:
    App() : m_argv(new char{}), m_app(m_argc, &m_argv) {}
    ~App() { delete m_argv; }

  private:
    int m_argc = 1;
    char* m_argv;
    QCoreApplication m_app;
};

class ZNCTest : public testing::Test {
  protected:
    void SetUp() override {
        WriteConfig(m_dir.path());
        Z;
        ASSERT_TRUE(m_server.listen(QHostAddress::LocalHost, 6667))
            << m_server.errorString().toStdString();
        Z;
    }

    Socket ConnectIRCd() {
        [this] {
            ASSERT_TRUE(m_server.waitForNewConnection(30000 /* msec */));
        }();
        return WrapIO(m_server.nextPendingConnection());
    }

    Socket ConnectClient() {
        m_clients.emplace_back();
        QTcpSocket& sock = m_clients.back();
        sock.connectToHost(""127.0.0.1"", 12345);
        [&] {
            ASSERT_TRUE(sock.waitForConnected())
                << sock.errorString().toStdString();
        }();
        return WrapIO(&sock);
    }

    std::unique_ptr<Process> Run() {
        return std::unique_ptr<Process>(new Process(
            ZNC_BIN_DIR ""/znc"", QStringList() << ""--debug""
                                              << ""--datadir"" << m_dir.path(),
            [](QProcess* proc) {
                proc->setProcessChannelMode(QProcess::ForwardedChannels);
            }));
    }

    Socket LoginClient() {
        auto client = ConnectClient();
        client.Write(""PASS :hunter2"");
        client.Write(""NICK nick"");
        client.Write(""USER user/test x x :x"");
        return client;
    }

    std::unique_ptr<QNetworkReply> HttpGet(QNetworkRequest request) {
        return HandleHttp(m_network.get(request));
    }
    std::unique_ptr<QNetworkReply> HttpPost(
        QNetworkRequest request, QList<QPair<QString, QString>> data) {
        request.setHeader(QNetworkRequest::ContentTypeHeader,
                          ""application/x-www-form-urlencoded"");
        QUrlQuery q;
        q.setQueryItems(data);
        return HandleHttp(m_network.post(request, q.toString().toUtf8()));
    }
    std::unique_ptr<QNetworkReply> HandleHttp(QNetworkReply* reply) {
        QEventLoop loop;
        QObject::connect(reply, &QNetworkReply::finished, [&]() {
            std::cout << ""Got HTTP reply"" << std::endl;
            loop.quit();
        });
        QObject::connect(
            reply,
            static_cast<void (QNetworkReply::*)(QNetworkReply::NetworkError)>(
                &QNetworkReply::error),
            [&](QNetworkReply::NetworkError e) {
                ADD_FAILURE() << reply->errorString().toStdString();
            });
        QTimer::singleShot(30000 /* msec */, &loop, [&]() {
            ADD_FAILURE() << ""connection timeout"";
            loop.quit();
        });
        std::cout << ""Start HTTP loop.exec()"" << std::endl;
        loop.exec();
        std::cout << ""Finished HTTP loop.exec()"" << std::endl;
        return std::unique_ptr<QNetworkReply>(reply);
    }

    void InstallModule(QString name, QString content) {
        QDir dir(m_dir.path());
        ASSERT_TRUE(dir.mkpath(""modules""));
        ASSERT_TRUE(dir.cd(""modules""));
        if (name.endsWith("".cpp"")) {
            QTemporaryDir srcdir;
            QFile file(QDir(srcdir.path()).filePath(name));
            ASSERT_TRUE(file.open(QIODevice::WriteOnly | QIODevice::Text));
            QTextStream out(&file);
            out << content;
            file.close();
            Process p(
                ZNC_BIN_DIR ""/znc-buildmod"", QStringList() << file.fileName(),
                [&](QProcess* proc) {
                    proc->setWorkingDirectory(dir.absolutePath());
                    proc->setProcessChannelMode(QProcess::ForwardedChannels);
                });
            p.ShouldFinishItself();
        } else {
            QFile file(dir.filePath(name));
            ASSERT_TRUE(file.open(QIODevice::WriteOnly | QIODevice::Text));
            QTextStream out(&file);
            out << content;
        }
    }

    App m_app;
    QNetworkAccessManager m_network;
    QTemporaryDir m_dir;
    QTcpServer m_server;
    std::list<QTcpSocket> m_clients;
};

TEST_F(ZNCTest, Connect) {
    auto znc = Run();
    Z;

    auto ircd = ConnectIRCd();
    Z;
    ircd.ReadUntil(""CAP LS"");
    Z;

    auto client = ConnectClient();
    Z;
    client.Write(""PASS :hunter2"");
    client.Write(""NICK nick"");
    client.Write(""USER user/test x x :x"");
    client.ReadUntil(""Welcome"");
    Z;
    client.Close();

    client = ConnectClient();
    Z;
    client.Write(""PASS :user:hunter2"");
    client.Write(""NICK nick"");
    client.Write(""USER u x x x"");
    client.ReadUntil(""Welcome"");
    Z;
    client.Close();

    client = ConnectClient();
    Z;
    client.Write(""NICK nick"");
    client.Write(""USER user x x x"");
    client.ReadUntil(""Configure your client to send a server password"");
    client.Close();

    ircd.Write("":server 001 nick :Hello"");
    ircd.ReadUntil(""WHO"");
    Z;
}

TEST_F(ZNCTest, Channel) {
    auto znc = Run();
    Z;
    auto ircd = ConnectIRCd();
    Z;

    auto client = LoginClient();
    Z;
    client.ReadUntil(""Welcome"");
    Z;
    client.Write(""JOIN #znc"");
    client.Close();

    ircd.Write("":server 001 nick :Hello"");
    ircd.ReadUntil(""JOIN #znc"");
    Z;
    ircd.Write("":nick JOIN :#znc"");
    ircd.Write("":server 353 nick #znc :nick"");
    ircd.Write("":server 366 nick #znc :End of /NAMES list"");
    ircd.Write("":server PING :1"");
    ircd.ReadUntil(""PONG 1"");

    client = LoginClient();
    Z;
    client.ReadUntil("":nick JOIN :#znc"");
    Z;
}

TEST_F(ZNCTest, HTTP) {
    auto znc = Run();
    Z;
    auto ircd = ConnectIRCd();
    Z;
    auto reply = HttpGet(QNetworkRequest(QUrl(""http://127.0.0.1:12345/"")));
    Z;
    EXPECT_THAT(reply->rawHeader(""Server"").toStdString(), HasSubstr(""ZNC""));
}

TEST_F(ZNCTest, FixCVE20149403) {
    auto znc = Run();
    Z;
    auto ircd = ConnectIRCd();
    Z;
    ircd.Write("":server 001 nick :Hello"");
    ircd.Write("":server 005 nick CHANTYPES=# :supports"");
    ircd.Write("":server PING :1"");
    ircd.ReadUntil(""PONG 1"");
    Z;

    QNetworkRequest request;
    request.setRawHeader(""Authorization"",
                         ""Basic "" + QByteArray(""user:hunter2"").toBase64());
    request.setUrl(QUrl(""http://127.0.0.1:12345/mods/global/webadmin/addchan""));
    HttpPost(request, {
                          {""user"", ""user""},
                          {""network"", ""test""},
                          {""submitted"", ""1""},
                          {""name"", ""znc""},
                          {""enabled"", ""1""},
                      });
    ircd.ReadUntil(""JOIN #znc"");
    Z;
    EXPECT_THAT(HttpPost(request,
                         {
                             {""user"", ""user""},
                             {""network"", ""test""},
                             {""submitted"", ""1""},
                             {""name"", ""znc""},
                             {""enabled"", ""1""},
                         })
                    ->readAll()
                    .toStdString(),
                HasSubstr(""Channel [#znc] already exists""));
}

TEST_F(ZNCTest, FixFixOfCVE20149403) {
    auto znc = Run();
    Z;
    auto ircd = ConnectIRCd();
    Z;
    ircd.Write("":server 001 nick :Hello"");
    ircd.Write("":nick JOIN @#znc"");
    ircd.ReadUntil(""MODE @#znc"");
    Z;
    ircd.Write("":server 005 nick STATUSMSG=@ :supports"");
    ircd.Write("":server PING :12345"");
    ircd.ReadUntil(""PONG 12345"");
    Z;

    QNetworkRequest request;
    request.setRawHeader(""Authorization"",
                         ""Basic "" + QByteArray(""user:hunter2"").toBase64());
    request.setUrl(QUrl(""http://127.0.0.1:12345/mods/global/webadmin/addchan""));
    auto reply = HttpPost(request, {
                                       {""user"", ""user""},
                                       {""network"", ""test""},
                                       {""submitted"", ""1""},
                                       {""name"", ""@#znc""},
                                       {""enabled"", ""1""},
                                   });
    EXPECT_THAT(reply->readAll().toStdString(),
                HasSubstr(""Could not add channel [@#znc]""));
}

TEST_F(ZNCTest, InvalidConfigInChan) {
    QFile conf(m_dir.path() + ""/configs/znc.conf"");
    ASSERT_TRUE(conf.open(QIODevice::Append | QIODevice::Text));
    QTextStream out(&conf);
    out << R""(
        <User foo>
            <Network bar>
                <Chan #baz>
                    Invalid = Line
                </Chan>
            </Network>
        </User>
    )"";
    out.flush();
    auto znc = Run();
    Z;
    znc->ShouldFinishItself(1);
}

TEST_F(ZNCTest, ControlpanelModule) {
    auto znc = Run();
    Z;
    auto ircd = ConnectIRCd();
    Z;
    auto client = LoginClient();
    Z;

    const QByteArray request = ""PRIVMSG *controlpanel :"";
    const QByteArray response = "":*controlpanel!znc@znc.in PRIVMSG nick :"";

    // TODO: Figure out how to check for ""HAVE_ICU"" to test encoding.
    // TODO: Test the CTCP VERSION.

    // 1. Test everything on ""user"".
    // 2. Test everything on another user ""KindOne"" from ""user"".
    // 3. Test one thing on ""foobar"" as the user does not exist from ""user"".

    // Add myself so I can test other things along with ""user"".
    client.Write(request + ""AddUser KindOne hunter2"");
    client.ReadUntil(response + ""User [KindOne] added!"");
    Z;

    client.Write(request + ""AddUser KindOne hunter2"");
    client.ReadUntil(response + ""Error: User [KindOne] already exists!"");
    Z;

    client.Write(request + ""AddCTCP user VERSION Test"");
    client.ReadUntil(response + ""Added!"");
    Z;

    client.Write(request + ""AddNetwork user freenode"");
    client.ReadUntil(response + ""Network [freenode] added for user [user]."");
    Z;

    client.Write(request + ""AddServer user freenode 127.0.0.1 6667"");
    client.ReadUntil(response +
                     ""Added IRC Server [127.0.0.1 6667] for network [freenode] ""
                     ""for user [user]."");
    Z;

    client.Write(request + ""AddChan user freenode #znc"");
    client.ReadUntil(response + ""Channel [#znc] for user [user] added."");
    Z;

    client.Write(request + ""AddChan user freenode #znc"");
    client.ReadUntil(response +
                     ""Error: [user] already has a channel named [#znc]."");
    Z;

    client.Write(request + ""AddUser user hunter2"");
    client.ReadUntil(response + ""Error: User [user] already exists!"");
    Z;

    client.Write(request + ""CloneUser user user_clone"");
    client.ReadUntil(response + ""User [user_clone] added!"");
    Z;

    client.Write(request + ""CloneUser user user_clone"");
    client.ReadUntil(response + ""Error: User not added! [User already exists]"");
    Z;

    client.Write(request + ""DelCTCP user VERSION"");
    client.ReadUntil(response +
                     ""Successfully removed [VERSION] for user [user]."");
    Z;

    client.Write(request + ""DelCTCP user VERSION"");
    client.ReadUntil(response + ""Error: [VERSION] not found for user [user]!"");
    Z;

    client.Write(request + ""DelChan user freenode #znc"");
    client.ReadUntil(response + ""Channel(s) [#znc] for user [user] deleted."");
    Z;

    client.Write(request + ""DelChan user freenode #znc"");
    client.ReadUntil(
        response +
        ""Error: User [user] does not have any channel matching [#znc]."");
    Z;

    client.Write(request + ""DelNetwork freenode"");
    client.ReadUntil(response + ""Network [freenode] deleted on user [user]."");
    Z;

    client.Write(request + ""DelNetwork freenode"");
    client.ReadUntil(response +
                     ""Error: [user] does not have a network named [freenode]."");
    Z;

    client.Write(request + ""AddNetwork user freenode"");
    client.ReadUntil(response + ""Network [freenode] added for user [user]."");
    Z;

    client.Write(request + ""AddChan user freenode #znc"");
    client.ReadUntil(response + ""Channel [#znc] for user [user] added."");
    Z;

    client.Write(request + ""DelUser user_clone"");
    client.ReadUntil(response + ""User [user_clone] deleted!"");
    Z;

    client.Write(request + ""DelUser user_clone"");
    client.ReadUntil(response + ""Error: User [user_clone] does not exist!"");
    Z;

    client.Write(request + ""Disconnect user freenode"");
    client.ReadUntil(
        response +
        ""Closed IRC connection for network [freenode] on user [user]."");
    Z;

    client.Write(request + ""Disconnect user EFnet"");
    client.ReadUntil(response +
                     ""Error: [user] does not have a network named [EFnet]."");
    Z;

    client.Write(request + ""Get Nick"");
    client.ReadUntil(response + ""Nick = user"");
    Z;

    client.Write(request + ""Get Altnick"");
    client.ReadUntil(response + ""AltNick = user_"");
    Z;

    client.Write(request + ""Get Ident"");
    client.ReadUntil(response + ""Ident = user"");
    Z;

    client.Write(request + ""Get RealName"");
    client.ReadUntil(response + ""RealName = ZNC"");
    Z;

    client.Write(request + ""Get BindHost"");
    client.ReadUntil(response + ""BindHost = "");
    Z;

    client.Write(request + ""Get DefaultChanModes"");
    client.ReadUntil(response + ""DefaultChanModes = "");
    Z;

    client.Write(request + ""Get QuitMsg"");
    client.ReadUntil(response + ""QuitMsg = "");
    Z;

    client.Write(request + ""Get Password"");
    client.ReadUntil(response + ""Error: Unknown variable"");
    Z;

    client.Write(request + ""Get Timezone"");
    client.ReadUntil(response + ""Timezone = "");
    Z;

    client.Write(request + ""Get TimestampFormat"");
    client.ReadUntil(response + ""TimestampFormat = "");
    Z;

    client.Write(request + ""Get DCCBindHost"");
    client.ReadUntil(response + ""DCCBindHost = "");
    Z;

    client.Write(request + ""Get StatusPrefix"");
    client.ReadUntil(response + ""StatusPrefix = *"");
    Z;

    client.Write(request + ""Get BufferCount"");
    client.ReadUntil(response + ""BufferCount = 50"");
    Z;

    client.Write(request + ""Get JoinTries"");
    client.ReadUntil(response + ""JoinTries = "");
    Z;

    client.Write(request + ""Get MaxJoins"");
    client.ReadUntil(response + ""MaxJoins = "");
    Z;

    client.Write(request + ""Get MaxNetworks"");
    client.ReadUntil(response + ""MaxNetworks = "");
    Z;

    client.Write(request + ""Get MaxQueryBuffers"");
    client.ReadUntil(response + ""MaxQueryBuffers = "");
    Z;

    client.Write(request + ""Get Admin"");
    client.ReadUntil(response + ""Admin = true"");
    Z;

    client.Write(request + ""Get AppendTimestamp"");
    client.ReadUntil(response + ""AppendTimestamp = false"");
    Z;

    client.Write(request + ""Get AutoClearChanBuffer"");
    client.ReadUntil(response + ""AutoClearChanBuffer = true"");
    Z;

    client.Write(request + ""Get AutoClearQueryBuffer"");
    client.ReadUntil(response + ""AutoClearQueryBuffer = true"");
    Z;

    client.Write(request + ""Get DenyLoadMod"");
    client.ReadUntil(response + ""DenyLoadMod = false"");
    Z;

    client.Write(request + ""Get DenySetBindHost"");
    client.ReadUntil(response + ""DenySetBindHost = false"");
    Z;

    client.Write(request + ""Get MultiClients"");
    client.ReadUntil(response + ""MultiClients = true"");
    Z;

    client.Write(request + ""Get PrependTimestamp"");
    client.ReadUntil(response + ""PrependTimestamp = true"");
    Z;

    client.Write(request + ""GetChan DefModes user freenode #znc"");
    client.ReadUntil(response + ""#znc: DefModes = "");
    Z;

    client.Write(request + ""GetChan Key user freenode #znc"");
    client.ReadUntil(response + ""#znc: Key = "");
    Z;

    client.Write(request + ""GetChan BufferSize user freenode #znc"");
    client.ReadUntil(response + ""#znc: BufferSize = 50 (default)"");
    Z;

    client.Write(request + ""GetChan InConfig user freenode #znc"");
    client.ReadUntil(response + ""#znc: InConfig = true"");
    Z;

    client.Write(request + ""GetChan AutoClearChanBuffer user freenode #znc"");
    client.ReadUntil(response + ""#znc: AutoClearChanBuffer = true (default)"");
    Z;

    client.Write(request + ""GetChan Detached user freenode #znc"");
    client.ReadUntil(response + ""#znc: Detached = false"");
    Z;

    client.Write(request + ""GetNetwork Nick user freenode"");
    client.ReadUntil(response + ""Nick = user"");
    Z;

    client.Write(request + ""GetNetwork Altnick user freenode"");
    client.ReadUntil(response + ""AltNick = user_"");
    Z;

    client.Write(request + ""GetNetwork Ident user freenode"");
    client.ReadUntil(response + ""Ident = user"");
    Z;

    client.Write(request + ""GetNetwork BindHost user freenode"");
    client.ReadUntil(response + ""BindHost = "");
    Z;

    client.Write(request + ""GetNetwork FloodRate user freenode"");
    client.ReadUntil(response + ""FloodRate = 1.00"");
    Z;

    client.Write(request + ""GetNetwork FloodBurst user freenode"");
    client.ReadUntil(response + ""FloodBurst = 4"");
    Z;

    client.Write(request + ""GetNetwork JoinDelay user freenode"");
    client.ReadUntil(response + ""JoinDelay = 0"");
    Z;

    client.Write(request + ""GetNetwork QuitMsg user freenode"");
    client.ReadUntil(response + ""QuitMsg = "");
    Z;

    client.Write(request + ""AddCTCP user VERSION Test"");
    client.ReadUntil(response + ""Added!"");
    Z;

    client.Write(request + ""ListCTCPs"");
    client.ReadUntil(response + ""| VERSION | Test  |"");
    Z;

    client.Write(request + ""ListMods"");
    client.ReadUntil(response + ""Usage: ListMods <username>"");
    Z;

    client.Write(request + ""ListNetMods"");
    client.ReadUntil(response + ""Usage: ListNetMods <username> <network>"");
    Z;

    client.Write(request + ""ListNetworks"");
    client.ReadUntil(response + ""| test "");
    Z;

    client.Write(request + ""ListUsers"");
    client.ReadUntil(response + ""| user "");
    Z;

    client.Write(request + ""LoadModule"");
    client.ReadUntil(response +
                     ""Usage: LoadModule <username> <modulename> [args]"");
    Z;

    client.Write(request + ""LoadModule user"");
    client.ReadUntil(response +
                     ""Usage: LoadModule <username> <modulename> [args]"");
    Z;

    client.Write(request + ""LoadModule user log"");
    client.ReadUntil(response + ""Loaded module [log]"");
    Z;

    client.Write(request + ""LoadModule user log"");
    client.ReadUntil(
        response + ""Unable to load module [log] because it is already loaded"");
    Z;

    client.Write(request + ""LoadModule user autoop"");
    client.ReadUntil(response +
                     ""Unable to load module [autoop] [Module [autoop] does not ""
                     ""support module type [User]."");
    Z;

    client.Write(request + ""LoadNetModule user freenode log"");
    client.ReadUntil(response + ""Loaded module [log]"");
    Z;

    client.Write(request + ""LoadNetModule user freenode log"");
    client.ReadUntil(
        response + ""Unable to load module [log] because it is already loaded"");
    Z;

    client.Write(request + ""LoadNetModule user EFnet log"");
    client.ReadUntil(response +
                     ""Error: [user] does not have a network named [EFnet]."");
    Z;

    client.Write(request + ""Reconnect user freenode"");
    client.ReadUntil(
        response +
        ""Queued network [freenode] for user [user] for a reconnect."");
    Z;

    client.Write(request + ""Reconnect user EFnet"");
    client.ReadUntil(response +
                     ""Error: [user] does not have a network named [EFnet]."");
    Z;

    client.Write(request + ""Set Nick user user1"");
    client.ReadUntil(response + ""Nick = user1"");
    Z;

    client.Write(request + ""Set Altnick user user_1"");
    client.ReadUntil(response + ""AltNick = user_1"");
    Z;

    client.Write(request + ""Set Ident user user1"");
    client.ReadUntil(response + ""Ident = user1"");
    Z;

    client.Write(request + ""Set RealName user lol"");
    client.ReadUntil(response + ""RealName = lol"");
    Z;

    client.Write(request + ""Set BindHost user 0.0.0.0"");
    client.ReadUntil(response + ""BindHost = 0.0.0.0"");
    Z;

    client.Write(request + ""Set BindHost user 0.0.0.0"");
    client.ReadUntil(response + ""This bind host is already set!"");
    Z;

    // Need to clear the bindhost for testing in the 'setnetwork'.
    client.Write(""PRIVMSG *status :ClearUserBindHost"");
    client.ReadUntil(
        "":*status!znc@znc.in PRIVMSG nick :Bind host cleared for your user."");
    Z;

    client.Write(request + ""Set DefaultChanModes user +znst"");
    client.ReadUntil(response + ""DefaultChanModes = +znst"");
    Z;

    client.Write(request + ""Set QuitMsg user Writing this took forever."");
    client.ReadUntil(response + ""QuitMsg = Writing this took forever"");
    Z;

    client.Write(request + ""Set Password user hunter2"");
    client.ReadUntil(response + ""Password has been changed!"");
    Z;

    client.Write(request + ""Set Timezone user America/New_York"");
    client.ReadUntil(response + ""Timezone = America/New_York"");
    Z;

    client.Write(request + ""Set TimestampFormat user [%H:%M]"");
    client.ReadUntil(response + ""TimestampFormat = [%H:%M]"");
    Z;

    client.Write(request + ""Set DCCBindHost user 0.0.0.0"");
    client.ReadUntil(response + ""DCCBindHost = 0.0.0.0"");
    Z;

    client.Write(request + ""Set StatusPrefix user &"");
    client.ReadUntil(
        "":&controlpanel!znc@znc.in PRIVMSG nick :StatusPrefix = &"");
    Z;

    client.Write(""PRIVMSG &controlpanel :Set StatusPrefix user *"");
    client.ReadUntil(response + ""StatusPrefix = *"");
    Z;

    client.Write(request + ""SetChan DefModes user freenode #znc ms"");
    client.ReadUntil(response + ""#znc: DefModes = ms"");
    Z;

    client.Write(request + ""SetChan Key user freenode #znc KindOneRules"");
    client.ReadUntil(response + ""#znc: Key = KindOneRules"");
    Z;

    client.Write(request + ""SetChan BufferSize user freenode #znc 9001"");
    client.ReadUntil(response + ""#znc: BufferSize = 9001"");
    Z;

    client.Write(request + ""SetChan InConfig user freenode #znc true"");
    client.ReadUntil(response + ""#znc: InConfig = true"");
    Z;

    client.Write(request +
                 ""SetChan AutoClearChanBuffer user freenode #znc false"");
    client.ReadUntil(response + ""#znc: AutoClearChanBuffer = false"");
    Z;

    client.Write(request + ""SetChan Detached user freenode #znc false"");
    client.ReadUntil(response + ""#znc: Detached = false"");
    Z;

    client.Write(request + ""SetNetwork Nick user freenode NotUser"");
    client.ReadUntil(response + ""Nick = NotUser"");
    Z;

    client.Write(request + ""SetNetwork Altnick user freenode NotUser_"");
    client.ReadUntil(response + ""AltNick = NotUser_"");
    Z;

    client.Write(request + ""SetNetwork Ident user freenode identd"");
    client.ReadUntil(response + ""Ident = identd"");
    Z;

    client.Write(request + ""SetNetwork BindHost user freenode 0.0.0.0"");
    client.ReadUntil(response + ""BindHost = 0.0.0.0"");
    Z;

    client.Write(request + ""SetNetwork FloodRate user freenode 66.00"");
    client.ReadUntil(response + ""FloodRate = 66.00"");
    Z;

    client.Write(request + ""SetNetwork FloodBurst user freenode 55"");
    client.ReadUntil(response + ""FloodBurst = 55"");
    Z;

    client.Write(request + ""SetNetwork JoinDelay user freenode 22"");
    client.ReadUntil(response + ""JoinDelay = 22"");
    Z;

    client.Write(request + ""SetNetwork QuitMsg user freenode telnet"");
    client.ReadUntil(response + ""QuitMsg = telnet"");
    Z;

    client.Write(request + ""Get Nick user"");
    client.ReadUntil(response + ""Nick = user1"");
    Z;

    client.Write(request + ""Get Altnick user"");
    client.ReadUntil(response + ""AltNick = user_1"");
    Z;

    client.Write(request + ""Get Ident user"");
    client.ReadUntil(response + ""Ident = user1"");
    Z;

    client.Write(request + ""Get RealName user"");
    client.ReadUntil(response + ""RealName = lol"");
    Z;

    client.Write(request + ""Get BindHost user"");
    client.ReadUntil(response + ""BindHost = "");
    Z;

    client.Write(request + ""Get DefaultChanModes user"");
    client.ReadUntil(response + ""DefaultChanModes = +znst"");
    Z;

    client.Write(request + ""Get QuitMsg user"");
    client.ReadUntil(response + ""QuitMsg = Writing this took forever"");
    Z;

    client.Write(request + ""Get Password user"");
    client.ReadUntil(response + ""Error: Unknown variable"");
    Z;

    client.Write(request + ""Get Timezone user"");
    client.ReadUntil(response + ""Timezone = America/New_York"");
    Z;

    client.Write(request + ""Get TimestampFormat user"");
    client.ReadUntil(response + ""TimestampFormat = [%H:%M]"");
    Z;

    client.Write(request + ""Get DCCBindHost user"");
    client.ReadUntil(response + ""DCCBindHost = 0.0.0.0"");
    Z;

    client.Write(request + ""Get StatusPrefix user"");
    client.ReadUntil(response + ""StatusPrefix = *"");
    Z;

    client.Write(request + ""GetChan DefModes user freenode #znc"");
    client.ReadUntil(response + ""#znc: DefModes = ms"");
    Z;

    client.Write(request + ""GetChan Key user freenode #znc"");
    client.ReadUntil(response + ""#znc: Key = KindOneRules"");
    Z;

    client.Write(request + ""GetChan BufferSize user freenode #znc"");
    client.ReadUntil(response + ""#znc: BufferSize = 9001"");
    Z;

    client.Write(request + ""GetChan InConfig user freenode #znc"");
    client.ReadUntil(response + ""#znc: InConfig = true"");
    Z;

    client.Write(request + ""GetChan AutoClearChanBuffer user freenode #znc"");
    client.ReadUntil(response + ""#znc: AutoClearChanBuffer = false"");
    Z;

    client.Write(request + ""GetChan Detached user freenode #znc"");
    client.ReadUntil(response + ""#znc: Detached = false"");
    Z;

    client.Write(request + ""GetNetwork Nick user freenode"");
    client.ReadUntil(response + ""Nick = NotUser"");
    Z;

    client.Write(request + ""GetNetwork Altnick user freenode"");
    client.ReadUntil(response + ""AltNick = NotUser_"");
    Z;

    client.Write(request + ""GetNetwork Ident user freenode"");
    client.ReadUntil(response + ""Ident = identd"");
    Z;

    client.Write(request + ""GetNetwork BindHost user freenode"");
    client.ReadUntil(response + ""BindHost = 0.0.0.0"");
    Z;

    client.Write(request + ""GetNetwork FloodRate user freenode"");
    client.ReadUntil(response + ""FloodRate = 66.00"");
    Z;

    client.Write(request + ""GetNetwork FloodBurst user freenode 55"");
    client.ReadUntil(response + ""FloodBurst = 55"");
    Z;

    client.Write(request + ""GetNetwork JoinDelay user freenode 22"");
    client.ReadUntil(response + ""JoinDelay = 22"");
    Z;

    client.Write(request + ""GetNetwork QuitMsg user freenode"");
    client.ReadUntil(response + ""QuitMsg = telnet"");
    Z;

    client.Write(request + ""UnLoadModule"");
    client.ReadUntil(response + ""Usage: UnloadModule <username> <modulename>"");
    Z;

    client.Write(request + ""UnLoadModule user"");
    client.ReadUntil(response + ""Usage: UnloadModule <username> <modulename>"");
    Z;

    // https://github.com/znc/znc/issues/194
    client.Write(request + ""UnloadModule user controlpanel"");
    client.ReadUntil(response + ""Please use /znc unloadmod controlpanel"");
    Z;

    client.Write(request + ""UnLoadModule user log"");
    client.ReadUntil(response + ""Unloaded module [log]"");
    Z;

    client.Write(request + ""UnLoadModule user log"");
    client.ReadUntil(
        response + ""Unable to unload module [log] [Module [log] not loaded.]"");
    Z;

    client.Write(request + ""UnLoadNetModule user freenode log"");
    client.ReadUntil(response + ""Unloaded module [log]"");
    Z;

    client.Write(request + ""UnLoadNetModule user freenode log"");
    client.ReadUntil(
        response + ""Unable to unload module [log] [Module [log] not loaded.]"");
    Z;

    client.Write(request + ""UnLoadNetModule user EFnet log"");
    client.ReadUntil(response +
                     ""Error: [user] does not have a network named [EFnet]."");
    Z;

    // Test on second user ""KindOne"" from ""user"".

    client.Write(request + ""AddCTCP KindOne VERSION Test"");
    client.ReadUntil(response + ""Added!"");
    Z;

    // Added at the very beginning.
    client.Write(request + ""AddNetwork KindOne freenode"");
    client.ReadUntil(response + ""Network [freenode] added for user [KindOne]."");
    Z;

    client.Write(request + ""AddServer KindOne freenode 127.0.0.1 6667"");
    client.ReadUntil(response +
                     ""Added IRC Server [127.0.0.1 6667] for network [freenode] ""
                     ""for user [KindOne]."");
    Z;

    client.Write(request + ""AddChan KindOne freenode #znc"");
    client.ReadUntil(response + ""Channel [#znc] for user [KindOne] added."");
    Z;

    client.Write(request + ""AddChan KindOne freenode #znc"");
    client.ReadUntil(response +
                     ""Error: [KindOne] already has a channel named [#znc]."");
    Z;

    client.Write(request + ""AddUser KindOne hunter2"");
    client.ReadUntil(response + ""Error: User [KindOne] already exists!"");
    Z;

    client.Write(request + ""CloneUser KindOne KindOne_clone"");
    client.ReadUntil(response + ""User [KindOne_clone] added!"");
    Z;

    client.Write(request + ""CloneUser KindOne KindOne_clone"");
    client.ReadUntil(response + ""Error: User not added! [User already exists]"");
    Z;

    client.Write(request + ""DelCTCP KindOne VERSION"");
    client.ReadUntil(response +
                     ""Successfully removed [VERSION] for user [KindOne]."");
    Z;

    client.Write(request + ""DelCTCP KindOne VERSION"");
    client.ReadUntil(response +
                     ""Error: [VERSION] not found for user [KindOne]!"");
    Z;

    client.Write(request + ""DelChan KindOne freenode #znc"");
    client.ReadUntil(response +
                     ""Channel(s) [#znc] for user [KindOne] deleted."");
    Z;

    client.Write(request + ""DelChan KindOne freenode #znc"");
    client.ReadUntil(
        response +
        ""Error: User [KindOne] does not have any channel matching [#znc]."");
    Z;

    client.Write(request + ""DelNetwork KindOne freenode"");
    client.ReadUntil(response +
                     ""Network [freenode] deleted on user [KindOne]."");
    Z;

    client.Write(request + ""DelNetwork KindOne freenode"");
    client.ReadUntil(
        response +
        ""Error: [KindOne] does not have a network named [freenode]."");
    Z;

    client.Write(request + ""AddNetwork KindOne freenode"");
    client.ReadUntil(response + ""Network [freenode] added for user [KindOne]."");
    Z;

    client.Write(request + ""AddChan KindOne freenode #znc"");
    client.ReadUntil(response + ""Channel [#znc] for user [KindOne] added."");
    Z;

    client.Write(request + ""DelUser KindOne_clone"");
    client.ReadUntil(response + ""User [KindOne_clone] deleted!"");
    Z;

    client.Write(request + ""DelUser KindOne_clone"");
    client.ReadUntil(response + ""Error: User [KindOne_clone] does not exist!"");
    Z;

    client.Write(request + ""Disconnect KindOne freenode"");
    client.ReadUntil(
        response +
        ""Closed IRC connection for network [freenode] on user [KindOne]."");
    Z;

    client.Write(request + ""Disconnect KindOne EFnet"");
    client.ReadUntil(response +
                     ""Error: [KindOne] does not have a network named [EFnet]."");
    Z;

    client.Write(request + ""Get Nick KindOne"");
    client.ReadUntil(response + ""Nick = KindOne"");
    Z;

    client.Write(request + ""Get AltNick KindOne"");
    client.ReadUntil(response + ""AltNick = KindOne"");
    Z;

    client.Write(request + ""Get Ident KindOne"");
    client.ReadUntil(response + ""Ident = KindOne"");
    Z;

    client.Write(request + ""Get RealName KindOne"");
    client.ReadUntil(response + ""RealName = "");
    Z;

    client.Write(request + ""Get BindHost KindOne"");
    client.ReadUntil(response + ""BindHost = "");
    Z;

    client.Write(request + ""Get DefaultChanModes KindOne"");
    client.ReadUntil(response + ""DefaultChanModes = "");
    Z;

    client.Write(request + ""Get QuitMsg KindOne"");
    client.ReadUntil(response + ""QuitMsg = "");
    Z;

    client.Write(request + ""Get Password KindOne"");
    client.ReadUntil(response + ""Error: Unknown variable"");
    Z;

    client.Write(request + ""Get Timezone KindOne"");
    client.ReadUntil(response + ""Timezone = "");
    Z;

    client.Write(request + ""Get TimestampFormat KindOne"");
    client.ReadUntil(response + ""TimestampFormat = "");
    Z;

    client.Write(request + ""Get DCCBindHost KindOne"");
    client.ReadUntil(response + ""DCCBindHost = "");
    Z;

    client.Write(request + ""Get StatusPrefix KindOne"");
    client.ReadUntil(response + ""StatusPrefix = *"");
    Z;

    client.Write(request + ""Get BufferCount KindOne"");
    client.ReadUntil(response + ""BufferCount = 50"");
    Z;

    client.Write(request + ""Get JoinTries KindOne"");
    client.ReadUntil(response + ""JoinTries = "");
    Z;

    client.Write(request + ""Get MaxJoins KindOne"");
    client.ReadUntil(response + ""MaxJoins = "");
    Z;

    client.Write(request + ""Get MaxNetworks KindOne"");
    client.ReadUntil(response + ""MaxNetworks = "");
    Z;

    client.Write(request + ""Get MaxQueryBuffers KindOne"");
    client.ReadUntil(response + ""MaxQueryBuffers = "");
    Z;

    client.Write(request + ""Get Admin KindOne"");
    client.ReadUntil(response + ""Admin = false"");
    Z;

    client.Write(request + ""Get AppendTimestamp KindOne"");
    client.ReadUntil(response + ""AppendTimestamp = false"");
    Z;

    client.Write(request + ""Get AutoClearChanBuffer KindOne"");
    client.ReadUntil(response + ""AutoClearChanBuffer = true"");
    Z;

    client.Write(request + ""Get AutoClearQueryBuffer KindOne"");
    client.ReadUntil(response + ""AutoClearQueryBuffer = true"");
    Z;

    client.Write(request + ""Get DenyLoadMod KindOne"");
    client.ReadUntil(response + ""DenyLoadMod = false"");
    Z;

    client.Write(request + ""Get DenySetBindHost KindOne"");
    client.ReadUntil(response + ""DenySetBindHost = false"");
    Z;

    client.Write(request + ""Get MultiClients KindOne"");
    client.ReadUntil(response + ""MultiClients = true"");
    Z;

    client.Write(request + ""Get PrependTimestamp KindOne"");
    client.ReadUntil(response + ""PrependTimestamp = true"");
    Z;

    client.Write(request + ""GetChan DefModes KindOne freenode #znc"");
    client.ReadUntil(response + ""#znc: DefModes = "");
    Z;

    client.Write(request + ""GetChan Key KindOne freenode #znc"");
    client.ReadUntil(response + ""#znc: Key = "");
    Z;

    client.Write(request + ""GetChan BufferSize KindOne freenode #znc"");
    client.ReadUntil(response + ""#znc: BufferSize = 50 (default)"");
    Z;

    client.Write(request + ""GetChan InConfig KindOne freenode #znc"");
    client.ReadUntil(response + ""#znc: InConfig = true"");
    Z;

    client.Write(request + ""GetChan AutoClearChanBuffer KindOne freenode #znc"");
    client.ReadUntil(response + ""#znc: AutoClearChanBuffer = true (default)"");
    Z;

    client.Write(request + ""GetChan Detached KindOne freenode #znc"");
    client.ReadUntil(response + ""#znc: Detached = false"");
    Z;

    client.Write(request + ""GetNetwork Nick KindOne freenode"");
    client.ReadUntil(response + ""Nick = KindOne"");
    Z;

    client.Write(request + ""GetNetwork Altnick KindOne freenode"");
    client.ReadUntil(response + ""AltNick = KindOne"");
    Z;

    client.Write(request + ""GetNetwork Ident KindOne freenode"");
    client.ReadUntil(response + ""Ident = KindOne"");
    Z;

    client.Write(request + ""GetNetwork BindHost KindOne freenode"");
    client.ReadUntil(response + ""BindHost = "");
    Z;

    client.Write(request + ""GetNetwork FloodRate KindOne freenode"");
    client.ReadUntil(response + ""FloodRate = 1.00"");
    Z;

    client.Write(request + ""GetNetwork FloodBurst KindOne freenode"");
    client.ReadUntil(response + ""FloodBurst = 4"");
    Z;

    client.Write(request + ""GetNetwork JoinDelay KindOne freenode"");
    client.ReadUntil(response + ""JoinDelay = 0"");
    Z;

    client.Write(request + ""GetNetwork QuitMsg KindOne freenode"");
    client.ReadUntil(response + ""QuitMsg = "");
    Z;

    client.Write(request + ""AddCTCP KindOne VERSION Test"");
    client.ReadUntil(response + ""Added!"");
    Z;

    client.Write(request + ""ListCTCPs KindOne"");
    client.ReadUntil(response + ""| VERSION | Test"");
    Z;

    client.Write(request + ""ListMods KindOne"");
    client.ReadUntil(response + ""User [KindOne] has no modules loaded."");
    Z;

    client.Write(request + ""LoadModule KindOne autoop"");
    client.ReadUntil(response +
                     ""Unable to load module [autoop] [Module [autoop] does not ""
                     ""support module type [User].]"");
    Z;

    client.Write(request + ""LoadModule KindOne perform"");
    client.ReadUntil(response + ""Loaded module [perform]"");
    Z;

    client.Write(request + ""ListMods KindOne"");
    client.ReadUntil(response + ""| perform |"");
    Z;

    client.Write(request + ""ListNetMods KindOne"");
    client.ReadUntil(response + ""Usage: ListNetMods <username> <network>"");
    Z;

    client.Write(request + ""ListNetworks KindOne"");
    client.ReadUntil(response + ""| freenode | No "");
    Z;

    client.Write(request + ""ListUsers"");
    client.ReadUntil(response + ""| user "");
    Z;

    client.Write(request + ""LoadModule"");
    client.ReadUntil(response +
                     ""Usage: LoadModule <username> <modulename> [args]"");
    Z;

    client.Write(request + ""LoadModule KindOne"");
    client.ReadUntil(response +
                     ""Usage: LoadModule <username> <modulename> [args]"");
    Z;

    client.Write(request + ""LoadModule KindOne log"");
    client.ReadUntil(response + ""Loaded module [log]"");
    Z;

    client.Write(request + ""LoadModule KindOne log"");
    client.ReadUntil(
        response + ""Unable to load module [log] because it is already loaded"");
    Z;

    client.Write(request + ""LoadNetModule KindOne freenode log"");
    client.ReadUntil(response + ""Loaded module [log]"");
    Z;

    client.Write(request + ""LoadNetModule KindOne freenode log"");
    client.ReadUntil(
        response + ""Unable to load module [log] because it is already loaded"");
    Z;

    client.Write(request + ""LoadNetModule KindOne EFnet log"");
    client.ReadUntil(response +
                     ""Error: [KindOne] does not have a network named [EFnet]."");
    Z;

    client.Write(request + ""Reconnect KindOne freenode"");
    client.ReadUntil(
        response +
        ""Queued network [freenode] for user [KindOne] for a reconnect."");
    Z;

    client.Write(request + ""Reconnect KindOne EFnet"");
    client.ReadUntil(response +
                     ""Error: [KindOne] does not have a network named [EFnet]."");
    Z;

    client.Write(request + ""Set Nick KindOne KindTwo"");
    client.ReadUntil(response + ""Nick = KindTwo"");
    Z;

    client.Write(request + ""Set Altnick KindOne KindTwo_"");
    client.ReadUntil(response + ""AltNick = KindTwo_"");
    Z;

    client.Write(request + ""Set Ident KindOne znc"");
    client.ReadUntil(response + ""Ident = znc"");
    Z;

    client.Write(request + ""Set RealName KindOne real_name"");
    client.ReadUntil(response + ""RealName = real_name"");
    Z;

    client.Write(request + ""Set BindHost KindOne 0.0.0.0"");
    client.ReadUntil(response + ""BindHost = 0.0.0.0"");
    Z;

    client.Write(request + ""Set DefaultChanModes KindOne +inst"");
    client.ReadUntil(response + ""DefaultChanModes = +inst"");
    Z;

    client.Write(request + ""Set QuitMsg KindOne Writing this took forever."");
    client.ReadUntil(response + ""QuitMsg = Writing this took forever"");
    Z;

    client.Write(request + ""Set Password KindOne hunter2"");
    client.ReadUntil(response + ""Password has been changed!"");
    Z;

    client.Write(request + ""Set Timezone KindOne America/New_York"");
    client.ReadUntil(response + ""Timezone = America/New_York"");
    Z;

    client.Write(request + ""Set TimestampFormat KindOne [%H:%M]"");
    client.ReadUntil(response + ""TimestampFormat = [%H:%M]"");
    Z;

    client.Write(request + ""Set DCCBindHost KindOne 0.0.0.0"");
    client.ReadUntil(response + ""DCCBindHost = 0.0.0.0"");
    Z;

    client.Write(request + ""Set StatusPrefix KindOne &"");
    client.ReadUntil(response + ""StatusPrefix = &"");
    Z;

    client.Write(request + ""Set StatusPrefix KindOne *"");
    client.ReadUntil(response + ""StatusPrefix = *"");
    Z;

    client.Write(request + ""SetChan DefModes KindOne freenode #znc is"");
    client.ReadUntil(response + ""#znc: DefModes = is"");
    Z;

    client.Write(request + ""SetChan Key KindOne freenode #znc KindOneRules"");
    client.ReadUntil(response + ""#znc: Key = KindOneRules"");
    Z;

    client.Write(request + ""SetChan BufferSize KindOne freenode #znc 9001"");
    client.ReadUntil(response + ""#znc: BufferSize = 9001"");
    Z;

    client.Write(request + ""SetChan InConfig KindOne freenode #znc true"");
    client.ReadUntil(response + ""#znc: InConfig = true"");
    Z;

    client.Write(request +
                 ""SetChan AutoClearChanBuffer KindOne freenode #znc false"");
    client.ReadUntil(response + ""#znc: AutoClearChanBuffer = false"");
    Z;

    client.Write(request + ""SetChan Detached KindOne freenode #znc false"");
    client.ReadUntil(response + ""#znc: Detached = false"");
    Z;

    client.Write(request + ""SetNetwork Nick KindOne freenode KindTwo"");
    client.ReadUntil(response + ""Nick = KindTwo"");
    Z;

    client.Write(request + ""SetNetwork Altnick KindOne freenode KindTwo_"");
    client.ReadUntil(response + ""AltNick = KindTwo_"");
    Z;

    client.Write(request + ""SetNetwork Ident KindOne freenode znc"");
    client.ReadUntil(response + ""Ident = znc"");
    Z;

    client.Write(request + ""SetNetwork BindHost KindOne freenode 0.0.0.0"");
    client.ReadUntil(response + ""This bind host is already set!"");
    Z;

    client.Write(request + ""SetNetwork FloodRate KindOne freenode 42.00"");
    client.ReadUntil(response + ""FloodRate = 42.00"");
    Z;

    client.Write(request + ""SetNetwork FloodBurst KindOne freenode 20"");
    client.ReadUntil(response + ""FloodBurst = 20"");
    Z;

    client.Write(request + ""SetNetwork JoinDelay KindOne freenode 5"");
    client.ReadUntil(response + ""JoinDelay = 5"");
    Z;

    client.Write(request + ""SetNetwork QuitMsg KindOne freenode telnet"");
    client.ReadUntil(response + ""QuitMsg = telnet"");
    Z;

    client.Write(request + ""Get Nick KindOne"");
    client.ReadUntil(response + ""Nick = KindTwo"");
    Z;

    client.Write(request + ""Get Altnick KindOne"");
    client.ReadUntil(response + ""AltNick = KindTwo_"");
    Z;

    client.Write(request + ""Get Ident KindOne"");
    client.ReadUntil(response + ""Ident = znc"");
    Z;

    client.Write(request + ""Get RealName KindOne"");
    client.ReadUntil(response + ""RealName = real_name"");
    Z;

    client.Write(request + ""Get BindHost KindOne"");
    client.ReadUntil(response + ""BindHost = 0.0.0.0"");
    Z;

    client.Write(request + ""Get DefaultChanModes KindOne"");
    client.ReadUntil(response + ""DefaultChanModes = +inst"");
    Z;

    client.Write(request + ""Get QuitMsg KindOne"");
    client.ReadUntil(response + ""QuitMsg = Writing this took forever"");
    Z;

    client.Write(request + ""Get Password KindOne"");
    client.ReadUntil(response + ""Error: Unknown variable"");
    Z;

    client.Write(request + ""Get Timezone KindOne"");
    client.ReadUntil(response + ""Timezone = America/New_York"");
    Z;

    client.Write(request + ""Get TimestampFormat KindOne"");
    client.ReadUntil(response + ""TimestampFormat = [%H:%M]"");
    Z;

    client.Write(request + ""Get DCCBindHost KindOne"");
    client.ReadUntil(response + ""DCCBindHost = 0.0.0.0"");
    Z;

    client.Write(request + ""Get StatusPrefix KindOne"");
    client.ReadUntil(response + ""StatusPrefix = *"");
    Z;

    client.Write(request + ""GetChan DefModes KindOne freenode #znc"");
    client.ReadUntil(response + ""#znc: DefModes = is"");
    Z;

    client.Write(request + ""GetChan Key KindOne freenode #znc"");
    client.ReadUntil(response + ""#znc: Key = KindOneRules"");
    Z;

    client.Write(request + ""GetChan BufferSize KindOne freenode #znc"");
    client.ReadUntil(response + ""#znc: BufferSize = 9001"");
    Z;

    client.Write(request + ""GetChan InConfig KindOne freenode #znc"");
    client.ReadUntil(response + ""#znc: InConfig = true"");
    Z;

    client.Write(request + ""GetChan AutoClearChanBuffer KindOne freenode #znc"");
    client.ReadUntil(response + ""#znc: AutoClearChanBuffer = false"");
    Z;

    client.Write(request + ""GetChan Detached KindOne freenode #znc"");
    client.ReadUntil(response + ""#znc: Detached = false"");
    Z;

    client.Write(request + ""GetNetwork Nick KindOne freenode"");
    client.ReadUntil(response + ""Nick = KindTwo"");
    Z;

    client.Write(request + ""GetNetwork Altnick KindOne freenode"");
    client.ReadUntil(response + ""AltNick = KindTwo_"");
    Z;

    client.Write(request + ""GetNetwork Ident KindOne freenode"");
    client.ReadUntil(response + ""Ident = znc"");
    Z;

    client.Write(request + ""GetNetwork BindHost KindOne freenode"");
    client.ReadUntil(response + ""BindHost = 0.0.0.0"");
    Z;

    client.Write(request + ""GetNetwork FloodRate KindOne freenode"");
    client.ReadUntil(response + ""FloodRate = 42.00"");
    Z;

    client.Write(request + ""GetNetwork FloodBurst KindOne freenode"");
    client.ReadUntil(response + ""FloodBurst = 20"");
    Z;

    client.Write(request + ""GetNetwork JoinDelay KindOne freenode"");
    client.ReadUntil(response + ""JoinDelay = 5"");
    Z;

    client.Write(request + ""GetNetwork QuitMsg KindOne freenode"");
    client.ReadUntil(response + ""QuitMsg = telnet"");
    Z;

    client.Write(request + ""UnLoadModule"");
    client.ReadUntil(response + ""Usage: UnloadModule <username> <modulename>"");
    Z;

    client.Write(request + ""UnLoadModule KindOne"");
    client.ReadUntil(response + ""Usage: UnloadModule <username> <modulename>"");
    Z;

    client.Write(request + ""UnLoadModule KindOne log"");
    client.ReadUntil(response + ""Unloaded module [log]"");
    Z;

    client.Write(request + ""UnLoadModule KindOne log"");
    client.ReadUntil(
        response + ""Unable to unload module [log] [Module [log] not loaded.]"");
    Z;

    client.Write(request + ""UnLoadNetModule KindOne freenode log"");
    client.ReadUntil(response + ""Unloaded module [log]"");
    Z;

    client.Write(request + ""UnLoadNetModule KindOne freenode log"");
    client.ReadUntil(
        response + ""Unable to unload module [log] [Module [log] not loaded.]"");
    Z;

    client.Write(request + ""UnLoadNetModule KindOne EFnet log"");
    client.ReadUntil(response +
                     ""Error: [KindOne] does not have a network named [EFnet]."");
    Z;

    // Test on ""foobar"", a user that does not exist.

    client.Write(request + ""AddCTCP foobar VERSION Test"");
    client.ReadUntil(response + ""Error: User [foobar] not found."");
    Z;
}

TEST_F(ZNCTest, NotifyConnectModule) {
    auto znc = Run();
    Z;
    auto ircd = ConnectIRCd();
    Z;
    auto client = LoginClient();
    Z;
    client.Write(""znc loadmod notify_connect"");
    client.ReadUntil(""Loaded module"");
    Z;

    auto client2 = ConnectClient();
    client2.Write(""PASS :hunter2"");
    client2.Write(""NICK nick"");
    client2.Write(""USER user/test x x :x"");
    client.ReadUntil(""NOTICE nick :*** user attached (from 127.0.0.1)"");
    Z;

    auto client3 = ConnectClient();
    client3.Write(""PASS :hunter2"");
    client3.Write(""NICK nick"");
    client3.Write(""USER user@identifier/test x x :x"");
    client.ReadUntil(
        ""NOTICE nick :*** user@identifier attached (from 127.0.0.1)"");
    Z;
    client2.ReadUntil(
        ""NOTICE nick :*** user@identifier attached (from 127.0.0.1)"");
    Z;

    client2.Write(""QUIT"");
    client.ReadUntil(""NOTICE nick :*** user detached (from 127.0.0.1)"");
    Z;

    client3.Close();
    client.ReadUntil(
        ""NOTICE nick :*** user@identifier detached (from 127.0.0.1)"");
    Z;
}

TEST_F(ZNCTest, ShellModule) {
    auto znc = Run();
    Z;
    auto ircd = ConnectIRCd();
    Z;
    auto client = LoginClient();
    Z;
    client.Write(""znc loadmod shell"");
    client.Write(""PRIVMSG *shell :echo blahblah"");
    client.ReadUntil(""PRIVMSG nick :blahblah"");
    Z;
    client.ReadUntil(""PRIVMSG nick :znc$"");
    Z;
}

TEST_F(ZNCTest, WatchModule) {
    // TODO test other messages
    // TODO test options
    auto znc = Run();
    Z;
    auto ircd = ConnectIRCd();
    Z;
    auto client = LoginClient();
    Z;
    client.Write(""znc loadmod watch"");
    client.Write(""PRIVMSG *watch :add *"");
    client.ReadUntil(""Adding entry:"");
    Z;
    ircd.Write("":server 001 nick :Hello"");
    ircd.Write("":nick JOIN :#znc"");
    ircd.Write("":n!i@h PRIVMSG #znc :\001ACTION foo\001"");
    client.ReadUntil(
        "":$*!watch@znc.in PRIVMSG nick :* CTCP: n [ACTION foo] to [#znc]"");
}

TEST_F(ZNCTest, Modperl) {
    if (QProcessEnvironment::systemEnvironment().value(
            ""DISABLED_ZNC_PERL_PYTHON_TEST"") == ""1"") {
        return;
    }
    auto znc = Run();
    Z;
    znc->CanLeak();
    auto ircd = ConnectIRCd();
    Z;
    auto client = LoginClient();
    Z;
    client.Write(""znc loadmod modperl"");
    client.Write(""znc loadmod perleval"");
    client.Write(""PRIVMSG *perleval :2+2"");
    client.ReadUntil("":*perleval!znc@znc.in PRIVMSG nick :Result: 4"");
    Z;
    client.Write(""PRIVMSG *perleval :$self->GetUser->GetUserName"");
    client.ReadUntil(""Result: user"");
    Z;
}

TEST_F(ZNCTest, Modpython) {
    if (QProcessEnvironment::systemEnvironment().value(
            ""DISABLED_ZNC_PERL_PYTHON_TEST"") == ""1"") {
        return;
    }
    auto znc = Run();
    Z;
    znc->CanLeak();
    auto ircd = ConnectIRCd();
    Z;
    auto client = LoginClient();
    Z;
    client.Write(""znc loadmod modpython"");
    client.Write(""znc loadmod pyeval"");
    client.Write(""PRIVMSG *pyeval :2+2"");
    client.ReadUntil("":*pyeval!znc@znc.in PRIVMSG nick :4"");
    Z;
    client.Write(""PRIVMSG *pyeval :module.GetUser().GetUserName()"");
    client.ReadUntil(""nick :'user'"");
    Z;
    ircd.Write("":server 001 nick :Hello"");
    ircd.Write("":n!u@h PRIVMSG nick :Hi\xF0, github issue #1229"");
    // ""replacement character""
    client.ReadUntil(""Hi\xEF\xBF\xBD, github issue"");
    Z;
}

TEST_F(ZNCTest, Encoding) {
    auto znc = Run();
    Z;
    auto ircd = ConnectIRCd();
    Z;
    auto client = LoginClient();
    Z;
    ircd.Write("":server 001 nick :hello"");
    // legacy
    ircd.Write("":n!u@h PRIVMSG nick :Hello\xE6world"");
    client.ReadUntil(""Hello\xE6world"");
    Z;
    client.Write(""PRIVMSG *controlpanel :SetNetwork Encoding $me $net UTF-8"");
    client.ReadUntil(""Encoding = UTF-8"");
    Z;
    ircd.Write("":n!u@h PRIVMSG nick :Hello\xE6world"");
    client.ReadUntil(""Hello\xEF\xBF\xBDworld"");
    Z;
    client.Write(
        ""PRIVMSG *controlpanel :SetNetwork Encoding $me $net ^CP-1251"");
    client.ReadUntil(""Encoding = ^CP-1251"");
    Z;
    ircd.Write("":n!u@h PRIVMSG nick :Hello\xE6world"");
    client.ReadUntil(""Hello\xD0\xB6world"");
    Z;
    ircd.Write("":n!u@h PRIVMSG nick :Hello\xD0\xB6world"");
    client.ReadUntil(""Hello\xD0\xB6world"");
    Z;
}

TEST_F(ZNCTest, BuildMod) {
    auto znc = Run();
    Z;
    auto ircd = ConnectIRCd();
    Z;
    auto client = LoginClient();
    Z;
    QTemporaryDir srcd;
    QDir srcdir(srcd.path());
    QFile file(srcdir.filePath(""testmod.cpp""));
    ASSERT_TRUE(file.open(QIODevice::WriteOnly | QIODevice::Text));
    QTextStream out(&file);
    out << R""(
        #include <znc/Modules.h>
        class TestModule : public CModule {
          public:
            MODCONSTRUCTOR(TestModule) {}
            void OnModCommand(const CString& sLine) override {
                PutModule(""Lorem ipsum"");
            }
        };
        MODULEDEFS(TestModule, ""Test"")
    )"";
    file.close();
    QDir dir(m_dir.path());
    EXPECT_TRUE(dir.mkdir(""modules""));
    EXPECT_TRUE(dir.cd(""modules""));
    {
        Process p(ZNC_BIN_DIR ""/znc-buildmod"",
                  QStringList() << srcdir.filePath(""file-not-found.cpp""),
                  [&](QProcess* proc) {
                      proc->setWorkingDirectory(dir.absolutePath());
                      proc->setProcessChannelMode(QProcess::ForwardedChannels);
                  });
        p.ShouldFinishItself(1);
    }
    {
        Process p(ZNC_BIN_DIR ""/znc-buildmod"",
                  QStringList() << srcdir.filePath(""testmod.cpp""),
                  [&](QProcess* proc) {
                      proc->setWorkingDirectory(dir.absolutePath());
                      proc->setProcessChannelMode(QProcess::ForwardedChannels);
                  });
        p.ShouldFinishItself();
    }
    client.Write(""znc loadmod testmod"");
    client.Write(""PRIVMSG *testmod :hi"");
    client.ReadUntil(""Lorem ipsum"");
    Z;
}

TEST_F(ZNCTest, AutoAttachModule) {
    auto znc = Run();
    Z;
    auto ircd = ConnectIRCd();
    Z;
    auto client = LoginClient();
    Z;
    InstallModule(""testmod.cpp"", R""(
        #include <znc/Modules.h>
        #include <znc/Client.h>
        class TestModule : public CModule {
          public:
            MODCONSTRUCTOR(TestModule) {}
            EModRet OnChanBufferPlayMessage(CMessage& Message) override {
                PutIRC(""TEST "" + Message.GetClient()->GetNickMask());
                return CONTINUE;
            }
        };
        MODULEDEFS(TestModule, ""Test"")
    )"");
    Z;
    client.Write(""znc loadmod testmod"");
    client.Write(""PRIVMSG *controlpanel :Set AutoClearChanBuffer $me no"");
    client.Write(""znc loadmod autoattach"");
    client.Write(""PRIVMSG *autoattach :Add * * *"");
    client.ReadUntil(""Added to list"");
    Z;
    ircd.Write("":server 001 nick :Hello"");
    ircd.Write("":nick JOIN :#znc"");
    ircd.Write("":server 353 nick #znc :nick"");
    ircd.Write("":server 366 nick #znc :End of /NAMES list"");
    ircd.Write("":foo PRIVMSG #znc :hi"");
    client.ReadUntil("":foo PRIVMSG"");
    Z;
    client.Write(""detach #znc"");
    client.ReadUntil(""Detached"");
    Z;
    ircd.Write("":foo PRIVMSG #znc :hello"");
    ircd.ReadUntil(""TEST"");
    Z;
    client.ReadUntil(""hello"");
    Z;
}

TEST_F(ZNCTest, KeepNickModule) {
    auto znc = Run();
    Z;
    auto ircd = ConnectIRCd();
    Z;
    auto client = LoginClient();
    Z;
    client.Write(""znc loadmod keepnick"");
    client.ReadUntil(""Loaded module"");
    Z;
    ircd.ReadUntil(""NICK user"");
    ircd.Write("":server 433 * nick :Nickname is already in use."");
    ircd.ReadUntil(""NICK user_"");
    Z;
    ircd.Write("":server 001 user_ :Hello"");
    client.ReadUntil(""Connected!"");
    Z;
    ircd.ReadUntil(""NICK user"");
    Z;
    ircd.Write("":server 435 user_ user #error :Nope :-P"");
    client.ReadUntil(
        "":*keepnick!znc@znc.in PRIVMSG user_ ""
        "":Unable to obtain nick user: Nope :-P, #error"");
}

TEST_F(ZNCTest, ModuleCSRFOverride) {
    auto znc = Run();
    Z;
    auto ircd = ConnectIRCd();
    Z;
    auto client = LoginClient();
    Z;
    client.Write(""znc loadmod samplewebapi"");
    client.ReadUntil(""Loaded module"");
    Z;
    auto request = QNetworkRequest(QUrl(""http://127.0.0.1:12345/mods/global/samplewebapi/""));
    auto reply = HttpPost(request, {
        {""text"", ""ipsum""}
    })->readAll().toStdString();
    Z;
    EXPECT_THAT(reply, HasSubstr(""ipsum""));
}

}  // namespace
""","""/*
 * Copyright (C) 2004-2016 ZNC, see the NOTICE file for details.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <gtest/gtest.h>
#include <gmock/gmock.h>

#include <QCoreApplication>
#include <QDateTime>
#include <QNetworkAccessManager>
#include <QNetworkRequest>
#include <QNetworkReply>
#include <QProcess>
#include <QTcpServer>
#include <QTcpSocket>
#include <QTemporaryDir>
#include <QTextStream>
#include <QTimer>
#include <QUrl>
#include <QUrlQuery>

#include <memory>

#define Z                                                                    \
    do {                                                                     \
        if (::testing::Test::HasFatalFailure()) {                            \
            std::cerr << ""At: "" << __FILE__ << "":"" << __LINE__ << std::endl; \
            return;                                                          \
        }                                                                    \
    } while (0)

#ifndef ZNC_BIN_DIR
#define ZNC_BIN_DIR """"
#endif

using testing::AnyOf;
using testing::Eq;
using testing::HasSubstr;

namespace {

template <typename Device>
class IO {
  public:
    IO(Device* device, bool verbose = false)
        : m_device(device), m_verbose(verbose) {}
    virtual ~IO() {}
    void ReadUntil(QByteArray pattern) {
        auto deadline = QDateTime::currentDateTime().addSecs(60);
        while (true) {
            int search = m_readed.indexOf(pattern);
            if (search != -1) {
                m_readed.remove(0, search + pattern.length());
                return;
            }
            if (m_readed.length() > pattern.length()) {
                m_readed = m_readed.right(pattern.length());
            }
            const int timeout_ms =
                QDateTime::currentDateTime().msecsTo(deadline);
            ASSERT_GT(timeout_ms, 0) << ""Wanted:"" << pattern.toStdString();
            ASSERT_TRUE(m_device->waitForReadyRead(timeout_ms))
                << ""Wanted: "" << pattern.toStdString();
            QByteArray chunk = m_device->readAll();
            if (m_verbose) {
                std::cout << chunk.toStdString() << std::flush;
            }
            m_readed += chunk;
        }
    }
    void Write(QByteArray s = """", bool new_line = true) {
        if (!m_device) return;
        if (m_verbose) {
            std::cout << s.toStdString() << std::flush;
            if (new_line) {
                std::cout << std::endl;
            }
        }
        s += ""\n"";
        while (!s.isEmpty()) {
            auto res = m_device->write(s);
            ASSERT_NE(res, -1);
            s.remove(0, res);
        }
        FlushIfCan(m_device);
    }
    void Close() {
#ifdef __CYGWIN__
        // Qt on cygwin silently doesn't send the rest of buffer from socket
        // without this line
        sleep(1);
#endif
        m_device->disconnectFromHost();
    }

  private:
    // Need to flush QTcpSocket, and QIODevice doesn't have flush at all...
    static void FlushIfCan(QIODevice*) {}
    static void FlushIfCan(QTcpSocket* sock) { sock->flush(); }

    Device* m_device;
    bool m_verbose;
    QByteArray m_readed;
};

template <typename Device>
IO<Device> WrapIO(Device* d) {
    return IO<Device>(d);
}

using Socket = IO<QTcpSocket>;

class Process : public IO<QProcess> {
  public:
    Process(QString cmd, QStringList args,
            std::function<void(QProcess*)> setup = [](QProcess*) {})
        : IO(&m_proc, true) {
        auto env = QProcessEnvironment::systemEnvironment();
        env.insert(""ZNC_DEBUG_TIMER"", ""1"");
        // Default exit codes of sanitizers upon error:
        // ASAN - 1
        // LSAN - 23 (part of ASAN, but uses a different value)
        // TSAN - 66
        //
        // ZNC uses 1 too to report startup failure.
        // But we don't want to confuse expected startup failure with ASAN
        // error.
        env.insert(""ASAN_OPTIONS"", ""exitcode=57"");
        m_proc.setProcessEnvironment(env);
        setup(&m_proc);
        m_proc.start(cmd, args);
        EXPECT_TRUE(m_proc.waitForStarted())
            << ""Failed to start ZNC, did you install it?"";
    }
    ~Process() override {
        if (m_kill) m_proc.terminate();
        [this]() {
            ASSERT_TRUE(m_proc.waitForFinished());
            if (!m_allowDie) {
                ASSERT_EQ(QProcess::NormalExit, m_proc.exitStatus());
                if (m_allowLeak) {
                    ASSERT_THAT(m_proc.exitStatus(), AnyOf(Eq(23), Eq(m_exit)));
                } else {
                    ASSERT_EQ(m_exit, m_proc.exitCode());
                }
            }
        }();
    }
    void ShouldFinishItself(int code = 0) {
        m_kill = false;
        m_exit = code;
    }
    void CanDie() { m_allowDie = true; }

    // I can't do much about SWIG...
    void CanLeak() { m_allowLeak = true; }

  private:
    bool m_kill = true;
    int m_exit = 0;
    bool m_allowDie = false;
    bool m_allowLeak = false;
    QProcess m_proc;
};

void WriteConfig(QString path) {
    // clang-format off
    Process p(ZNC_BIN_DIR ""/znc"", QStringList() << ""--debug""
                                                << ""--datadir"" << path
                                                << ""--makeconf"");
    p.ReadUntil(""Listen on port"");Z;          p.Write(""12345"");
    p.ReadUntil(""Listen using SSL"");Z;        p.Write();
    p.ReadUntil(""IPv6"");Z;                    p.Write();
    p.ReadUntil(""Username"");Z;                p.Write(""user"");
    p.ReadUntil(""password"");Z;                p.Write(""hunter2"", false);
    p.ReadUntil(""Confirm"");Z;                 p.Write(""hunter2"", false);
    p.ReadUntil(""Nick [user]"");Z;             p.Write();
    p.ReadUntil(""Alternate nick [user_]"");Z;  p.Write();
    p.ReadUntil(""Ident [user]"");Z;            p.Write();
    p.ReadUntil(""Real name"");Z;               p.Write();
    p.ReadUntil(""Bind host"");Z;               p.Write();
    p.ReadUntil(""Set up a network?"");Z;       p.Write();
    p.ReadUntil(""Name [freenode]"");Z;         p.Write(""test"");
    p.ReadUntil(""Server host (host only)"");Z; p.Write(""127.0.0.1"");
    p.ReadUntil(""Server uses SSL?"");Z;        p.Write();
    p.ReadUntil(""6667"");Z;                    p.Write();
    p.ReadUntil(""password"");Z;                p.Write();
    p.ReadUntil(""channels"");Z;                p.Write();
    p.ReadUntil(""Launch ZNC now?"");Z;         p.Write(""no"");
    p.ShouldFinishItself();
    // clang-format on
}

TEST(Config, AlreadyExists) {
    QTemporaryDir dir;
    WriteConfig(dir.path());
    Z;
    Process p(ZNC_BIN_DIR ""/znc"", QStringList() << ""--debug""
                                                << ""--datadir"" << dir.path()
                                                << ""--makeconf"");
    p.ReadUntil(""already exists"");
    Z;
    p.CanDie();
}

// Can't use QEventLoop without existing QCoreApplication
class App {
  public:
    App() : m_argv(new char{}), m_app(m_argc, &m_argv) {}
    ~App() { delete m_argv; }

  private:
    int m_argc = 1;
    char* m_argv;
    QCoreApplication m_app;
};

class ZNCTest : public testing::Test {
  protected:
    void SetUp() override {
        WriteConfig(m_dir.path());
        Z;
        ASSERT_TRUE(m_server.listen(QHostAddress::LocalHost, 6667))
            << m_server.errorString().toStdString();
        Z;
    }

    Socket ConnectIRCd() {
        [this] {
            ASSERT_TRUE(m_server.waitForNewConnection(30000 /* msec */));
        }();
        return WrapIO(m_server.nextPendingConnection());
    }

    Socket ConnectClient() {
        m_clients.emplace_back();
        QTcpSocket& sock = m_clients.back();
        sock.connectToHost(""127.0.0.1"", 12345);
        [&] {
            ASSERT_TRUE(sock.waitForConnected())
                << sock.errorString().toStdString();
        }();
        return WrapIO(&sock);
    }

    std::unique_ptr<Process> Run() {
        return std::unique_ptr<Process>(new Process(
            ZNC_BIN_DIR ""/znc"", QStringList() << ""--debug""
                                              << ""--datadir"" << m_dir.path(),
            [](QProcess* proc) {
                proc->setProcessChannelMode(QProcess::ForwardedChannels);
            }));
    }

    Socket LoginClient() {
        auto client = ConnectClient();
        client.Write(""PASS :hunter2"");
        client.Write(""NICK nick"");
        client.Write(""USER user/test x x :x"");
        return client;
    }

    std::unique_ptr<QNetworkReply> HttpGet(QNetworkRequest request) {
        return HandleHttp(m_network.get(request));
    }
    std::unique_ptr<QNetworkReply> HttpPost(
        QNetworkRequest request, QList<QPair<QString, QString>> data) {
        request.setHeader(QNetworkRequest::ContentTypeHeader,
                          ""application/x-www-form-urlencoded"");
        QUrlQuery q;
        q.setQueryItems(data);
        return HandleHttp(m_network.post(request, q.toString().toUtf8()));
    }
    std::unique_ptr<QNetworkReply> HandleHttp(QNetworkReply* reply) {
        QEventLoop loop;
        QObject::connect(reply, &QNetworkReply::finished, [&]() {
            std::cout << ""Got HTTP reply"" << std::endl;
            loop.quit();
        });
        QObject::connect(
            reply,
            static_cast<void (QNetworkReply::*)(QNetworkReply::NetworkError)>(
                &QNetworkReply::error),
            [&](QNetworkReply::NetworkError e) {
                ADD_FAILURE() << reply->errorString().toStdString();
            });
        QTimer::singleShot(30000 /* msec */, &loop, [&]() {
            ADD_FAILURE() << ""connection timeout"";
            loop.quit();
        });
        std::cout << ""Start HTTP loop.exec()"" << std::endl;
        loop.exec();
        std::cout << ""Finished HTTP loop.exec()"" << std::endl;
        return std::unique_ptr<QNetworkReply>(reply);
    }

    void InstallModule(QString name, QString content) {
        QDir dir(m_dir.path());
        ASSERT_TRUE(dir.mkpath(""modules""));
        ASSERT_TRUE(dir.cd(""modules""));
        if (name.endsWith("".cpp"")) {
            QTemporaryDir srcdir;
            QFile file(QDir(srcdir.path()).filePath(name));
            ASSERT_TRUE(file.open(QIODevice::WriteOnly | QIODevice::Text));
            QTextStream out(&file);
            out << content;
            file.close();
            Process p(
                ZNC_BIN_DIR ""/znc-buildmod"", QStringList() << file.fileName(),
                [&](QProcess* proc) {
                    proc->setWorkingDirectory(dir.absolutePath());
                    proc->setProcessChannelMode(QProcess::ForwardedChannels);
                });
            p.ShouldFinishItself();
        } else {
            QFile file(dir.filePath(name));
            ASSERT_TRUE(file.open(QIODevice::WriteOnly | QIODevice::Text));
            QTextStream out(&file);
            out << content;
        }
    }

    App m_app;
    QNetworkAccessManager m_network;
    QTemporaryDir m_dir;
    QTcpServer m_server;
    std::list<QTcpSocket> m_clients;
};

TEST_F(ZNCTest, Connect) {
    auto znc = Run();
    Z;

    auto ircd = ConnectIRCd();
    Z;
    ircd.ReadUntil(""CAP LS"");
    Z;

    auto client = ConnectClient();
    Z;
    client.Write(""PASS :hunter2"");
    client.Write(""NICK nick"");
    client.Write(""USER user/test x x :x"");
    client.ReadUntil(""Welcome"");
    Z;
    client.Close();

    client = ConnectClient();
    Z;
    client.Write(""PASS :user:hunter2"");
    client.Write(""NICK nick"");
    client.Write(""USER u x x x"");
    client.ReadUntil(""Welcome"");
    Z;
    client.Close();

    client = ConnectClient();
    Z;
    client.Write(""NICK nick"");
    client.Write(""USER user x x x"");
    client.ReadUntil(""Configure your client to send a server password"");
    client.Close();

    ircd.Write("":server 001 nick :Hello"");
    ircd.ReadUntil(""WHO"");
    Z;
}

TEST_F(ZNCTest, Channel) {
    auto znc = Run();
    Z;
    auto ircd = ConnectIRCd();
    Z;

    auto client = LoginClient();
    Z;
    client.ReadUntil(""Welcome"");
    Z;
    client.Write(""JOIN #znc"");
    client.Close();

    ircd.Write("":server 001 nick :Hello"");
    ircd.ReadUntil(""JOIN #znc"");
    Z;
    ircd.Write("":nick JOIN :#znc"");
    ircd.Write("":server 353 nick #znc :nick"");
    ircd.Write("":server 366 nick #znc :End of /NAMES list"");
    ircd.Write("":server PING :1"");
    ircd.ReadUntil(""PONG 1"");

    client = LoginClient();
    Z;
    client.ReadUntil("":nick JOIN :#znc"");
    Z;
}

TEST_F(ZNCTest, HTTP) {
    auto znc = Run();
    Z;
    auto ircd = ConnectIRCd();
    Z;
    auto reply = HttpGet(QNetworkRequest(QUrl(""http://127.0.0.1:12345/"")));
    Z;
    EXPECT_THAT(reply->rawHeader(""Server"").toStdString(), HasSubstr(""ZNC""));
}

TEST_F(ZNCTest, FixCVE20149403) {
    auto znc = Run();
    Z;
    auto ircd = ConnectIRCd();
    Z;
    ircd.Write("":server 001 nick :Hello"");
    ircd.Write("":server 005 nick CHANTYPES=# :supports"");
    ircd.Write("":server PING :1"");
    ircd.ReadUntil(""PONG 1"");
    Z;

    QNetworkRequest request;
    request.setRawHeader(""Authorization"",
                         ""Basic "" + QByteArray(""user:hunter2"").toBase64());
    request.setUrl(QUrl(""http://127.0.0.1:12345/mods/global/webadmin/addchan""));
    HttpPost(request, {
                          {""user"", ""user""},
                          {""network"", ""test""},
                          {""submitted"", ""1""},
                          {""name"", ""znc""},
                          {""enabled"", ""1""},
                      });
    EXPECT_THAT(HttpPost(request,
                         {
                             {""user"", ""user""},
                             {""network"", ""test""},
                             {""submitted"", ""1""},
                             {""name"", ""znc""},
                             {""enabled"", ""1""},
                         })
                    ->readAll()
                    .toStdString(),
                HasSubstr(""Channel [#znc] already exists""));
}

TEST_F(ZNCTest, FixFixOfCVE20149403) {
    auto znc = Run();
    Z;
    auto ircd = ConnectIRCd();
    Z;
    ircd.Write("":server 001 nick :Hello"");
    ircd.Write("":nick JOIN @#znc"");
    ircd.ReadUntil(""MODE @#znc"");
    Z;
    ircd.Write("":server 005 nick STATUSMSG=@ :supports"");
    ircd.Write("":server PING :12345"");
    ircd.ReadUntil(""PONG 12345"");
    Z;

    QNetworkRequest request;
    request.setRawHeader(""Authorization"",
                         ""Basic "" + QByteArray(""user:hunter2"").toBase64());
    request.setUrl(QUrl(""http://127.0.0.1:12345/mods/global/webadmin/addchan""));
    auto reply = HttpPost(request, {
                                       {""user"", ""user""},
                                       {""network"", ""test""},
                                       {""submitted"", ""1""},
                                       {""name"", ""@#znc""},
                                       {""enabled"", ""1""},
                                   });
    EXPECT_THAT(reply->readAll().toStdString(),
                HasSubstr(""Could not add channel [@#znc]""));
}

TEST_F(ZNCTest, InvalidConfigInChan) {
    QFile conf(m_dir.path() + ""/configs/znc.conf"");
    ASSERT_TRUE(conf.open(QIODevice::Append | QIODevice::Text));
    QTextStream out(&conf);
    out << R""(
        <User foo>
            <Network bar>
                <Chan #baz>
                    Invalid = Line
                </Chan>
            </Network>
        </User>
    )"";
    out.flush();
    auto znc = Run();
    Z;
    znc->ShouldFinishItself(1);
}

TEST_F(ZNCTest, ControlpanelModule) {
    auto znc = Run();
    Z;
    auto ircd = ConnectIRCd();
    Z;
    auto client = LoginClient();
    Z;

    const QByteArray request = ""PRIVMSG *controlpanel :"";
    const QByteArray response = "":*controlpanel!znc@znc.in PRIVMSG nick :"";

    // TODO: Figure out how to check for ""HAVE_ICU"" to test encoding.
    // TODO: Test the CTCP VERSION.

    // 1. Test everything on ""user"".
    // 2. Test everything on another user ""KindOne"" from ""user"".
    // 3. Test one thing on ""foobar"" as the user does not exist from ""user"".

    // Add myself so I can test other things along with ""user"".
    client.Write(request + ""AddUser KindOne hunter2"");
    client.ReadUntil(response + ""User [KindOne] added!"");
    Z;

    client.Write(request + ""AddUser KindOne hunter2"");
    client.ReadUntil(response + ""Error: User [KindOne] already exists!"");
    Z;

    client.Write(request + ""AddCTCP user VERSION Test"");
    client.ReadUntil(response + ""Added!"");
    Z;

    client.Write(request + ""AddNetwork user freenode"");
    client.ReadUntil(response + ""Network [freenode] added for user [user]."");
    Z;

    client.Write(request + ""AddServer user freenode 127.0.0.1 6667"");
    client.ReadUntil(response +
                     ""Added IRC Server [127.0.0.1 6667] for network [freenode] ""
                     ""for user [user]."");
    Z;

    client.Write(request + ""AddChan user freenode #znc"");
    client.ReadUntil(response + ""Channel [#znc] for user [user] added."");
    Z;

    client.Write(request + ""AddChan user freenode #znc"");
    client.ReadUntil(response +
                     ""Error: [user] already has a channel named [#znc]."");
    Z;

    client.Write(request + ""AddUser user hunter2"");
    client.ReadUntil(response + ""Error: User [user] already exists!"");
    Z;

    client.Write(request + ""CloneUser user user_clone"");
    client.ReadUntil(response + ""User [user_clone] added!"");
    Z;

    client.Write(request + ""CloneUser user user_clone"");
    client.ReadUntil(response + ""Error: User not added! [User already exists]"");
    Z;

    client.Write(request + ""DelCTCP user VERSION"");
    client.ReadUntil(response +
                     ""Successfully removed [VERSION] for user [user]."");
    Z;

    client.Write(request + ""DelCTCP user VERSION"");
    client.ReadUntil(response + ""Error: [VERSION] not found for user [user]!"");
    Z;

    client.Write(request + ""DelChan user freenode #znc"");
    client.ReadUntil(response + ""Channel(s) [#znc] for user [user] deleted."");
    Z;

    client.Write(request + ""DelChan user freenode #znc"");
    client.ReadUntil(
        response +
        ""Error: User [user] does not have any channel matching [#znc]."");
    Z;

    client.Write(request + ""DelNetwork freenode"");
    client.ReadUntil(response + ""Network [freenode] deleted on user [user]."");
    Z;

    client.Write(request + ""DelNetwork freenode"");
    client.ReadUntil(response +
                     ""Error: [user] does not have a network named [freenode]."");
    Z;

    client.Write(request + ""AddNetwork user freenode"");
    client.ReadUntil(response + ""Network [freenode] added for user [user]."");
    Z;

    client.Write(request + ""AddChan user freenode #znc"");
    client.ReadUntil(response + ""Channel [#znc] for user [user] added."");
    Z;

    client.Write(request + ""DelUser user_clone"");
    client.ReadUntil(response + ""User [user_clone] deleted!"");
    Z;

    client.Write(request + ""DelUser user_clone"");
    client.ReadUntil(response + ""Error: User [user_clone] does not exist!"");
    Z;

    client.Write(request + ""Disconnect user freenode"");
    client.ReadUntil(
        response +
        ""Closed IRC connection for network [freenode] on user [user]."");
    Z;

    client.Write(request + ""Disconnect user EFnet"");
    client.ReadUntil(response +
                     ""Error: [user] does not have a network named [EFnet]."");
    Z;

    client.Write(request + ""Get Nick"");
    client.ReadUntil(response + ""Nick = user"");
    Z;

    client.Write(request + ""Get Altnick"");
    client.ReadUntil(response + ""AltNick = user_"");
    Z;

    client.Write(request + ""Get Ident"");
    client.ReadUntil(response + ""Ident = user"");
    Z;

    client.Write(request + ""Get RealName"");
    client.ReadUntil(response + ""RealName = ZNC"");
    Z;

    client.Write(request + ""Get BindHost"");
    client.ReadUntil(response + ""BindHost = "");
    Z;

    client.Write(request + ""Get DefaultChanModes"");
    client.ReadUntil(response + ""DefaultChanModes = "");
    Z;

    client.Write(request + ""Get QuitMsg"");
    client.ReadUntil(response + ""QuitMsg = "");
    Z;

    client.Write(request + ""Get Password"");
    client.ReadUntil(response + ""Error: Unknown variable"");
    Z;

    client.Write(request + ""Get Timezone"");
    client.ReadUntil(response + ""Timezone = "");
    Z;

    client.Write(request + ""Get TimestampFormat"");
    client.ReadUntil(response + ""TimestampFormat = "");
    Z;

    client.Write(request + ""Get DCCBindHost"");
    client.ReadUntil(response + ""DCCBindHost = "");
    Z;

    client.Write(request + ""Get StatusPrefix"");
    client.ReadUntil(response + ""StatusPrefix = *"");
    Z;

    client.Write(request + ""Get BufferCount"");
    client.ReadUntil(response + ""BufferCount = 50"");
    Z;

    client.Write(request + ""Get JoinTries"");
    client.ReadUntil(response + ""JoinTries = "");
    Z;

    client.Write(request + ""Get MaxJoins"");
    client.ReadUntil(response + ""MaxJoins = "");
    Z;

    client.Write(request + ""Get MaxNetworks"");
    client.ReadUntil(response + ""MaxNetworks = "");
    Z;

    client.Write(request + ""Get MaxQueryBuffers"");
    client.ReadUntil(response + ""MaxQueryBuffers = "");
    Z;

    client.Write(request + ""Get Admin"");
    client.ReadUntil(response + ""Admin = true"");
    Z;

    client.Write(request + ""Get AppendTimestamp"");
    client.ReadUntil(response + ""AppendTimestamp = false"");
    Z;

    client.Write(request + ""Get AutoClearChanBuffer"");
    client.ReadUntil(response + ""AutoClearChanBuffer = true"");
    Z;

    client.Write(request + ""Get AutoClearQueryBuffer"");
    client.ReadUntil(response + ""AutoClearQueryBuffer = true"");
    Z;

    client.Write(request + ""Get DenyLoadMod"");
    client.ReadUntil(response + ""DenyLoadMod = false"");
    Z;

    client.Write(request + ""Get DenySetBindHost"");
    client.ReadUntil(response + ""DenySetBindHost = false"");
    Z;

    client.Write(request + ""Get MultiClients"");
    client.ReadUntil(response + ""MultiClients = true"");
    Z;

    client.Write(request + ""Get PrependTimestamp"");
    client.ReadUntil(response + ""PrependTimestamp = true"");
    Z;

    client.Write(request + ""GetChan DefModes user freenode #znc"");
    client.ReadUntil(response + ""#znc: DefModes = "");
    Z;

    client.Write(request + ""GetChan Key user freenode #znc"");
    client.ReadUntil(response + ""#znc: Key = "");
    Z;

    client.Write(request + ""GetChan BufferSize user freenode #znc"");
    client.ReadUntil(response + ""#znc: BufferSize = 50 (default)"");
    Z;

    client.Write(request + ""GetChan InConfig user freenode #znc"");
    client.ReadUntil(response + ""#znc: InConfig = true"");
    Z;

    client.Write(request + ""GetChan AutoClearChanBuffer user freenode #znc"");
    client.ReadUntil(response + ""#znc: AutoClearChanBuffer = true (default)"");
    Z;

    client.Write(request + ""GetChan Detached user freenode #znc"");
    client.ReadUntil(response + ""#znc: Detached = false"");
    Z;

    client.Write(request + ""GetNetwork Nick user freenode"");
    client.ReadUntil(response + ""Nick = user"");
    Z;

    client.Write(request + ""GetNetwork Altnick user freenode"");
    client.ReadUntil(response + ""AltNick = user_"");
    Z;

    client.Write(request + ""GetNetwork Ident user freenode"");
    client.ReadUntil(response + ""Ident = user"");
    Z;

    client.Write(request + ""GetNetwork BindHost user freenode"");
    client.ReadUntil(response + ""BindHost = "");
    Z;

    client.Write(request + ""GetNetwork FloodRate user freenode"");
    client.ReadUntil(response + ""FloodRate = 1.00"");
    Z;

    client.Write(request + ""GetNetwork FloodBurst user freenode"");
    client.ReadUntil(response + ""FloodBurst = 4"");
    Z;

    client.Write(request + ""GetNetwork JoinDelay user freenode"");
    client.ReadUntil(response + ""JoinDelay = 0"");
    Z;

    client.Write(request + ""GetNetwork QuitMsg user freenode"");
    client.ReadUntil(response + ""QuitMsg = "");
    Z;

    client.Write(request + ""AddCTCP user VERSION Test"");
    client.ReadUntil(response + ""Added!"");
    Z;

    client.Write(request + ""ListCTCPs"");
    client.ReadUntil(response + ""| VERSION | Test  |"");
    Z;

    client.Write(request + ""ListMods"");
    client.ReadUntil(response + ""Usage: ListMods <username>"");
    Z;

    client.Write(request + ""ListNetMods"");
    client.ReadUntil(response + ""Usage: ListNetMods <username> <network>"");
    Z;

    client.Write(request + ""ListNetworks"");
    client.ReadUntil(response + ""| test "");
    Z;

    client.Write(request + ""ListUsers"");
    client.ReadUntil(response + ""| user "");
    Z;

    client.Write(request + ""LoadModule"");
    client.ReadUntil(response +
                     ""Usage: LoadModule <username> <modulename> [args]"");
    Z;

    client.Write(request + ""LoadModule user"");
    client.ReadUntil(response +
                     ""Usage: LoadModule <username> <modulename> [args]"");
    Z;

    client.Write(request + ""LoadModule user log"");
    client.ReadUntil(response + ""Loaded module [log]"");
    Z;

    client.Write(request + ""LoadModule user log"");
    client.ReadUntil(
        response + ""Unable to load module [log] because it is already loaded"");
    Z;

    client.Write(request + ""LoadModule user autoop"");
    client.ReadUntil(response +
                     ""Unable to load module [autoop] [Module [autoop] does not ""
                     ""support module type [User]."");
    Z;

    client.Write(request + ""LoadNetModule user freenode log"");
    client.ReadUntil(response + ""Loaded module [log]"");
    Z;

    client.Write(request + ""LoadNetModule user freenode log"");
    client.ReadUntil(
        response + ""Unable to load module [log] because it is already loaded"");
    Z;

    client.Write(request + ""LoadNetModule user EFnet log"");
    client.ReadUntil(response +
                     ""Error: [user] does not have a network named [EFnet]."");
    Z;

    client.Write(request + ""Reconnect user freenode"");
    client.ReadUntil(
        response +
        ""Queued network [freenode] for user [user] for a reconnect."");
    Z;

    client.Write(request + ""Reconnect user EFnet"");
    client.ReadUntil(response +
                     ""Error: [user] does not have a network named [EFnet]."");
    Z;

    client.Write(request + ""Set Nick user user1"");
    client.ReadUntil(response + ""Nick = user1"");
    Z;

    client.Write(request + ""Set Altnick user user_1"");
    client.ReadUntil(response + ""AltNick = user_1"");
    Z;

    client.Write(request + ""Set Ident user user1"");
    client.ReadUntil(response + ""Ident = user1"");
    Z;

    client.Write(request + ""Set RealName user lol"");
    client.ReadUntil(response + ""RealName = lol"");
    Z;

    client.Write(request + ""Set BindHost user 0.0.0.0"");
    client.ReadUntil(response + ""BindHost = 0.0.0.0"");
    Z;

    client.Write(request + ""Set BindHost user 0.0.0.0"");
    client.ReadUntil(response + ""This bind host is already set!"");
    Z;

    // Need to clear the bindhost for testing in the 'setnetwork'.
    client.Write(""PRIVMSG *status :ClearUserBindHost"");
    client.ReadUntil(
        "":*status!znc@znc.in PRIVMSG nick :Bind host cleared for your user."");
    Z;

    client.Write(request + ""Set DefaultChanModes user +znst"");
    client.ReadUntil(response + ""DefaultChanModes = +znst"");
    Z;

    client.Write(request + ""Set QuitMsg user Writing this took forever."");
    client.ReadUntil(response + ""QuitMsg = Writing this took forever"");
    Z;

    client.Write(request + ""Set Password user hunter2"");
    client.ReadUntil(response + ""Password has been changed!"");
    Z;

    client.Write(request + ""Set Timezone user America/New_York"");
    client.ReadUntil(response + ""Timezone = America/New_York"");
    Z;

    client.Write(request + ""Set TimestampFormat user [%H:%M]"");
    client.ReadUntil(response + ""TimestampFormat = [%H:%M]"");
    Z;

    client.Write(request + ""Set DCCBindHost user 0.0.0.0"");
    client.ReadUntil(response + ""DCCBindHost = 0.0.0.0"");
    Z;

    client.Write(request + ""Set StatusPrefix user &"");
    client.ReadUntil(
        "":&controlpanel!znc@znc.in PRIVMSG nick :StatusPrefix = &"");
    Z;

    client.Write(""PRIVMSG &controlpanel :Set StatusPrefix user *"");
    client.ReadUntil(response + ""StatusPrefix = *"");
    Z;

    client.Write(request + ""SetChan DefModes user freenode #znc ms"");
    client.ReadUntil(response + ""#znc: DefModes = ms"");
    Z;

    client.Write(request + ""SetChan Key user freenode #znc KindOneRules"");
    client.ReadUntil(response + ""#znc: Key = KindOneRules"");
    Z;

    client.Write(request + ""SetChan BufferSize user freenode #znc 9001"");
    client.ReadUntil(response + ""#znc: BufferSize = 9001"");
    Z;

    client.Write(request + ""SetChan InConfig user freenode #znc true"");
    client.ReadUntil(response + ""#znc: InConfig = true"");
    Z;

    client.Write(request +
                 ""SetChan AutoClearChanBuffer user freenode #znc false"");
    client.ReadUntil(response + ""#znc: AutoClearChanBuffer = false"");
    Z;

    client.Write(request + ""SetChan Detached user freenode #znc false"");
    client.ReadUntil(response + ""#znc: Detached = false"");
    Z;

    client.Write(request + ""SetNetwork Nick user freenode NotUser"");
    client.ReadUntil(response + ""Nick = NotUser"");
    Z;

    client.Write(request + ""SetNetwork Altnick user freenode NotUser_"");
    client.ReadUntil(response + ""AltNick = NotUser_"");
    Z;

    client.Write(request + ""SetNetwork Ident user freenode identd"");
    client.ReadUntil(response + ""Ident = identd"");
    Z;

    client.Write(request + ""SetNetwork BindHost user freenode 0.0.0.0"");
    client.ReadUntil(response + ""BindHost = 0.0.0.0"");
    Z;

    client.Write(request + ""SetNetwork FloodRate user freenode 66.00"");
    client.ReadUntil(response + ""FloodRate = 66.00"");
    Z;

    client.Write(request + ""SetNetwork FloodBurst user freenode 55"");
    client.ReadUntil(response + ""FloodBurst = 55"");
    Z;

    client.Write(request + ""SetNetwork JoinDelay user freenode 22"");
    client.ReadUntil(response + ""JoinDelay = 22"");
    Z;

    client.Write(request + ""SetNetwork QuitMsg user freenode telnet"");
    client.ReadUntil(response + ""QuitMsg = telnet"");
    Z;

    client.Write(request + ""Get Nick user"");
    client.ReadUntil(response + ""Nick = user1"");
    Z;

    client.Write(request + ""Get Altnick user"");
    client.ReadUntil(response + ""AltNick = user_1"");
    Z;

    client.Write(request + ""Get Ident user"");
    client.ReadUntil(response + ""Ident = user1"");
    Z;

    client.Write(request + ""Get RealName user"");
    client.ReadUntil(response + ""RealName = lol"");
    Z;

    client.Write(request + ""Get BindHost user"");
    client.ReadUntil(response + ""BindHost = "");
    Z;

    client.Write(request + ""Get DefaultChanModes user"");
    client.ReadUntil(response + ""DefaultChanModes = +znst"");
    Z;

    client.Write(request + ""Get QuitMsg user"");
    client.ReadUntil(response + ""QuitMsg = Writing this took forever"");
    Z;

    client.Write(request + ""Get Password user"");
    client.ReadUntil(response + ""Error: Unknown variable"");
    Z;

    client.Write(request + ""Get Timezone user"");
    client.ReadUntil(response + ""Timezone = America/New_York"");
    Z;

    client.Write(request + ""Get TimestampFormat user"");
    client.ReadUntil(response + ""TimestampFormat = [%H:%M]"");
    Z;

    client.Write(request + ""Get DCCBindHost user"");
    client.ReadUntil(response + ""DCCBindHost = 0.0.0.0"");
    Z;

    client.Write(request + ""Get StatusPrefix user"");
    client.ReadUntil(response + ""StatusPrefix = *"");
    Z;

    client.Write(request + ""GetChan DefModes user freenode #znc"");
    client.ReadUntil(response + ""#znc: DefModes = ms"");
    Z;

    client.Write(request + ""GetChan Key user freenode #znc"");
    client.ReadUntil(response + ""#znc: Key = KindOneRules"");
    Z;

    client.Write(request + ""GetChan BufferSize user freenode #znc"");
    client.ReadUntil(response + ""#znc: BufferSize = 9001"");
    Z;

    client.Write(request + ""GetChan InConfig user freenode #znc"");
    client.ReadUntil(response + ""#znc: InConfig = true"");
    Z;

    client.Write(request + ""GetChan AutoClearChanBuffer user freenode #znc"");
    client.ReadUntil(response + ""#znc: AutoClearChanBuffer = false"");
    Z;

    client.Write(request + ""GetChan Detached user freenode #znc"");
    client.ReadUntil(response + ""#znc: Detached = false"");
    Z;

    client.Write(request + ""GetNetwork Nick user freenode"");
    client.ReadUntil(response + ""Nick = NotUser"");
    Z;

    client.Write(request + ""GetNetwork Altnick user freenode"");
    client.ReadUntil(response + ""AltNick = NotUser_"");
    Z;

    client.Write(request + ""GetNetwork Ident user freenode"");
    client.ReadUntil(response + ""Ident = identd"");
    Z;

    client.Write(request + ""GetNetwork BindHost user freenode"");
    client.ReadUntil(response + ""BindHost = 0.0.0.0"");
    Z;

    client.Write(request + ""GetNetwork FloodRate user freenode"");
    client.ReadUntil(response + ""FloodRate = 66.00"");
    Z;

    client.Write(request + ""GetNetwork FloodBurst user freenode 55"");
    client.ReadUntil(response + ""FloodBurst = 55"");
    Z;

    client.Write(request + ""GetNetwork JoinDelay user freenode 22"");
    client.ReadUntil(response + ""JoinDelay = 22"");
    Z;

    client.Write(request + ""GetNetwork QuitMsg user freenode"");
    client.ReadUntil(response + ""QuitMsg = telnet"");
    Z;

    client.Write(request + ""UnLoadModule"");
    client.ReadUntil(response + ""Usage: UnloadModule <username> <modulename>"");
    Z;

    client.Write(request + ""UnLoadModule user"");
    client.ReadUntil(response + ""Usage: UnloadModule <username> <modulename>"");
    Z;

    // https://github.com/znc/znc/issues/194
    client.Write(request + ""UnloadModule user controlpanel"");
    client.ReadUntil(response + ""Please use /znc unloadmod controlpanel"");
    Z;

    client.Write(request + ""UnLoadModule user log"");
    client.ReadUntil(response + ""Unloaded module [log]"");
    Z;

    client.Write(request + ""UnLoadModule user log"");
    client.ReadUntil(
        response + ""Unable to unload module [log] [Module [log] not loaded.]"");
    Z;

    client.Write(request + ""UnLoadNetModule user freenode log"");
    client.ReadUntil(response + ""Unloaded module [log]"");
    Z;

    client.Write(request + ""UnLoadNetModule user freenode log"");
    client.ReadUntil(
        response + ""Unable to unload module [log] [Module [log] not loaded.]"");
    Z;

    client.Write(request + ""UnLoadNetModule user EFnet log"");
    client.ReadUntil(response +
                     ""Error: [user] does not have a network named [EFnet]."");
    Z;

    // Test on second user ""KindOne"" from ""user"".

    client.Write(request + ""AddCTCP KindOne VERSION Test"");
    client.ReadUntil(response + ""Added!"");
    Z;

    // Added at the very beginning.
    client.Write(request + ""AddNetwork KindOne freenode"");
    client.ReadUntil(response + ""Network [freenode] added for user [KindOne]."");
    Z;

    client.Write(request + ""AddServer KindOne freenode 127.0.0.1 6667"");
    client.ReadUntil(response +
                     ""Added IRC Server [127.0.0.1 6667] for network [freenode] ""
                     ""for user [KindOne]."");
    Z;

    client.Write(request + ""AddChan KindOne freenode #znc"");
    client.ReadUntil(response + ""Channel [#znc] for user [KindOne] added."");
    Z;

    client.Write(request + ""AddChan KindOne freenode #znc"");
    client.ReadUntil(response +
                     ""Error: [KindOne] already has a channel named [#znc]."");
    Z;

    client.Write(request + ""AddUser KindOne hunter2"");
    client.ReadUntil(response + ""Error: User [KindOne] already exists!"");
    Z;

    client.Write(request + ""CloneUser KindOne KindOne_clone"");
    client.ReadUntil(response + ""User [KindOne_clone] added!"");
    Z;

    client.Write(request + ""CloneUser KindOne KindOne_clone"");
    client.ReadUntil(response + ""Error: User not added! [User already exists]"");
    Z;

    client.Write(request + ""DelCTCP KindOne VERSION"");
    client.ReadUntil(response +
                     ""Successfully removed [VERSION] for user [KindOne]."");
    Z;

    client.Write(request + ""DelCTCP KindOne VERSION"");
    client.ReadUntil(response +
                     ""Error: [VERSION] not found for user [KindOne]!"");
    Z;

    client.Write(request + ""DelChan KindOne freenode #znc"");
    client.ReadUntil(response +
                     ""Channel(s) [#znc] for user [KindOne] deleted."");
    Z;

    client.Write(request + ""DelChan KindOne freenode #znc"");
    client.ReadUntil(
        response +
        ""Error: User [KindOne] does not have any channel matching [#znc]."");
    Z;

    client.Write(request + ""DelNetwork KindOne freenode"");
    client.ReadUntil(response +
                     ""Network [freenode] deleted on user [KindOne]."");
    Z;

    client.Write(request + ""DelNetwork KindOne freenode"");
    client.ReadUntil(
        response +
        ""Error: [KindOne] does not have a network named [freenode]."");
    Z;

    client.Write(request + ""AddNetwork KindOne freenode"");
    client.ReadUntil(response + ""Network [freenode] added for user [KindOne]."");
    Z;

    client.Write(request + ""AddChan KindOne freenode #znc"");
    client.ReadUntil(response + ""Channel [#znc] for user [KindOne] added."");
    Z;

    client.Write(request + ""DelUser KindOne_clone"");
    client.ReadUntil(response + ""User [KindOne_clone] deleted!"");
    Z;

    client.Write(request + ""DelUser KindOne_clone"");
    client.ReadUntil(response + ""Error: User [KindOne_clone] does not exist!"");
    Z;

    client.Write(request + ""Disconnect KindOne freenode"");
    client.ReadUntil(
        response +
        ""Closed IRC connection for network [freenode] on user [KindOne]."");
    Z;

    client.Write(request + ""Disconnect KindOne EFnet"");
    client.ReadUntil(response +
                     ""Error: [KindOne] does not have a network named [EFnet]."");
    Z;

    client.Write(request + ""Get Nick KindOne"");
    client.ReadUntil(response + ""Nick = KindOne"");
    Z;

    client.Write(request + ""Get AltNick KindOne"");
    client.ReadUntil(response + ""AltNick = KindOne"");
    Z;

    client.Write(request + ""Get Ident KindOne"");
    client.ReadUntil(response + ""Ident = KindOne"");
    Z;

    client.Write(request + ""Get RealName KindOne"");
    client.ReadUntil(response + ""RealName = "");
    Z;

    client.Write(request + ""Get BindHost KindOne"");
    client.ReadUntil(response + ""BindHost = "");
    Z;

    client.Write(request + ""Get DefaultChanModes KindOne"");
    client.ReadUntil(response + ""DefaultChanModes = "");
    Z;

    client.Write(request + ""Get QuitMsg KindOne"");
    client.ReadUntil(response + ""QuitMsg = "");
    Z;

    client.Write(request + ""Get Password KindOne"");
    client.ReadUntil(response + ""Error: Unknown variable"");
    Z;

    client.Write(request + ""Get Timezone KindOne"");
    client.ReadUntil(response + ""Timezone = "");
    Z;

    client.Write(request + ""Get TimestampFormat KindOne"");
    client.ReadUntil(response + ""TimestampFormat = "");
    Z;

    client.Write(request + ""Get DCCBindHost KindOne"");
    client.ReadUntil(response + ""DCCBindHost = "");
    Z;

    client.Write(request + ""Get StatusPrefix KindOne"");
    client.ReadUntil(response + ""StatusPrefix = *"");
    Z;

    client.Write(request + ""Get BufferCount KindOne"");
    client.ReadUntil(response + ""BufferCount = 50"");
    Z;

    client.Write(request + ""Get JoinTries KindOne"");
    client.ReadUntil(response + ""JoinTries = "");
    Z;

    client.Write(request + ""Get MaxJoins KindOne"");
    client.ReadUntil(response + ""MaxJoins = "");
    Z;

    client.Write(request + ""Get MaxNetworks KindOne"");
    client.ReadUntil(response + ""MaxNetworks = "");
    Z;

    client.Write(request + ""Get MaxQueryBuffers KindOne"");
    client.ReadUntil(response + ""MaxQueryBuffers = "");
    Z;

    client.Write(request + ""Get Admin KindOne"");
    client.ReadUntil(response + ""Admin = false"");
    Z;

    client.Write(request + ""Get AppendTimestamp KindOne"");
    client.ReadUntil(response + ""AppendTimestamp = false"");
    Z;

    client.Write(request + ""Get AutoClearChanBuffer KindOne"");
    client.ReadUntil(response + ""AutoClearChanBuffer = true"");
    Z;

    client.Write(request + ""Get AutoClearQueryBuffer KindOne"");
    client.ReadUntil(response + ""AutoClearQueryBuffer = true"");
    Z;

    client.Write(request + ""Get DenyLoadMod KindOne"");
    client.ReadUntil(response + ""DenyLoadMod = false"");
    Z;

    client.Write(request + ""Get DenySetBindHost KindOne"");
    client.ReadUntil(response + ""DenySetBindHost = false"");
    Z;

    client.Write(request + ""Get MultiClients KindOne"");
    client.ReadUntil(response + ""MultiClients = true"");
    Z;

    client.Write(request + ""Get PrependTimestamp KindOne"");
    client.ReadUntil(response + ""PrependTimestamp = true"");
    Z;

    client.Write(request + ""GetChan DefModes KindOne freenode #znc"");
    client.ReadUntil(response + ""#znc: DefModes = "");
    Z;

    client.Write(request + ""GetChan Key KindOne freenode #znc"");
    client.ReadUntil(response + ""#znc: Key = "");
    Z;

    client.Write(request + ""GetChan BufferSize KindOne freenode #znc"");
    client.ReadUntil(response + ""#znc: BufferSize = 50 (default)"");
    Z;

    client.Write(request + ""GetChan InConfig KindOne freenode #znc"");
    client.ReadUntil(response + ""#znc: InConfig = true"");
    Z;

    client.Write(request + ""GetChan AutoClearChanBuffer KindOne freenode #znc"");
    client.ReadUntil(response + ""#znc: AutoClearChanBuffer = true (default)"");
    Z;

    client.Write(request + ""GetChan Detached KindOne freenode #znc"");
    client.ReadUntil(response + ""#znc: Detached = false"");
    Z;

    client.Write(request + ""GetNetwork Nick KindOne freenode"");
    client.ReadUntil(response + ""Nick = KindOne"");
    Z;

    client.Write(request + ""GetNetwork Altnick KindOne freenode"");
    client.ReadUntil(response + ""AltNick = KindOne"");
    Z;

    client.Write(request + ""GetNetwork Ident KindOne freenode"");
    client.ReadUntil(response + ""Ident = KindOne"");
    Z;

    client.Write(request + ""GetNetwork BindHost KindOne freenode"");
    client.ReadUntil(response + ""BindHost = "");
    Z;

    client.Write(request + ""GetNetwork FloodRate KindOne freenode"");
    client.ReadUntil(response + ""FloodRate = 1.00"");
    Z;

    client.Write(request + ""GetNetwork FloodBurst KindOne freenode"");
    client.ReadUntil(response + ""FloodBurst = 4"");
    Z;

    client.Write(request + ""GetNetwork JoinDelay KindOne freenode"");
    client.ReadUntil(response + ""JoinDelay = 0"");
    Z;

    client.Write(request + ""GetNetwork QuitMsg KindOne freenode"");
    client.ReadUntil(response + ""QuitMsg = "");
    Z;

    client.Write(request + ""AddCTCP KindOne VERSION Test"");
    client.ReadUntil(response + ""Added!"");
    Z;

    client.Write(request + ""ListCTCPs KindOne"");
    client.ReadUntil(response + ""| VERSION | Test"");
    Z;

    client.Write(request + ""ListMods KindOne"");
    client.ReadUntil(response + ""User [KindOne] has no modules loaded."");
    Z;

    client.Write(request + ""LoadModule KindOne autoop"");
    client.ReadUntil(response +
                     ""Unable to load module [autoop] [Module [autoop] does not ""
                     ""support module type [User].]"");
    Z;

    client.Write(request + ""LoadModule KindOne perform"");
    client.ReadUntil(response + ""Loaded module [perform]"");
    Z;

    client.Write(request + ""ListMods KindOne"");
    client.ReadUntil(response + ""| perform |"");
    Z;

    client.Write(request + ""ListNetMods KindOne"");
    client.ReadUntil(response + ""Usage: ListNetMods <username> <network>"");
    Z;

    client.Write(request + ""ListNetworks KindOne"");
    client.ReadUntil(response + ""| freenode | No "");
    Z;

    client.Write(request + ""ListUsers"");
    client.ReadUntil(response + ""| user "");
    Z;

    client.Write(request + ""LoadModule"");
    client.ReadUntil(response +
                     ""Usage: LoadModule <username> <modulename> [args]"");
    Z;

    client.Write(request + ""LoadModule KindOne"");
    client.ReadUntil(response +
                     ""Usage: LoadModule <username> <modulename> [args]"");
    Z;

    client.Write(request + ""LoadModule KindOne log"");
    client.ReadUntil(response + ""Loaded module [log]"");
    Z;

    client.Write(request + ""LoadModule KindOne log"");
    client.ReadUntil(
        response + ""Unable to load module [log] because it is already loaded"");
    Z;

    client.Write(request + ""LoadNetModule KindOne freenode log"");
    client.ReadUntil(response + ""Loaded module [log]"");
    Z;

    client.Write(request + ""LoadNetModule KindOne freenode log"");
    client.ReadUntil(
        response + ""Unable to load module [log] because it is already loaded"");
    Z;

    client.Write(request + ""LoadNetModule KindOne EFnet log"");
    client.ReadUntil(response +
                     ""Error: [KindOne] does not have a network named [EFnet]."");
    Z;

    client.Write(request + ""Reconnect KindOne freenode"");
    client.ReadUntil(
        response +
        ""Queued network [freenode] for user [KindOne] for a reconnect."");
    Z;

    client.Write(request + ""Reconnect KindOne EFnet"");
    client.ReadUntil(response +
                     ""Error: [KindOne] does not have a network named [EFnet]."");
    Z;

    client.Write(request + ""Set Nick KindOne KindTwo"");
    client.ReadUntil(response + ""Nick = KindTwo"");
    Z;

    client.Write(request + ""Set Altnick KindOne KindTwo_"");
    client.ReadUntil(response + ""AltNick = KindTwo_"");
    Z;

    client.Write(request + ""Set Ident KindOne znc"");
    client.ReadUntil(response + ""Ident = znc"");
    Z;

    client.Write(request + ""Set RealName KindOne real_name"");
    client.ReadUntil(response + ""RealName = real_name"");
    Z;

    client.Write(request + ""Set BindHost KindOne 0.0.0.0"");
    client.ReadUntil(response + ""BindHost = 0.0.0.0"");
    Z;

    client.Write(request + ""Set DefaultChanModes KindOne +inst"");
    client.ReadUntil(response + ""DefaultChanModes = +inst"");
    Z;

    client.Write(request + ""Set QuitMsg KindOne Writing this took forever."");
    client.ReadUntil(response + ""QuitMsg = Writing this took forever"");
    Z;

    client.Write(request + ""Set Password KindOne hunter2"");
    client.ReadUntil(response + ""Password has been changed!"");
    Z;

    client.Write(request + ""Set Timezone KindOne America/New_York"");
    client.ReadUntil(response + ""Timezone = America/New_York"");
    Z;

    client.Write(request + ""Set TimestampFormat KindOne [%H:%M]"");
    client.ReadUntil(response + ""TimestampFormat = [%H:%M]"");
    Z;

    client.Write(request + ""Set DCCBindHost KindOne 0.0.0.0"");
    client.ReadUntil(response + ""DCCBindHost = 0.0.0.0"");
    Z;

    client.Write(request + ""Set StatusPrefix KindOne &"");
    client.ReadUntil(response + ""StatusPrefix = &"");
    Z;

    client.Write(request + ""Set StatusPrefix KindOne *"");
    client.ReadUntil(response + ""StatusPrefix = *"");
    Z;

    client.Write(request + ""SetChan DefModes KindOne freenode #znc is"");
    client.ReadUntil(response + ""#znc: DefModes = is"");
    Z;

    client.Write(request + ""SetChan Key KindOne freenode #znc KindOneRules"");
    client.ReadUntil(response + ""#znc: Key = KindOneRules"");
    Z;

    client.Write(request + ""SetChan BufferSize KindOne freenode #znc 9001"");
    client.ReadUntil(response + ""#znc: BufferSize = 9001"");
    Z;

    client.Write(request + ""SetChan InConfig KindOne freenode #znc true"");
    client.ReadUntil(response + ""#znc: InConfig = true"");
    Z;

    client.Write(request +
                 ""SetChan AutoClearChanBuffer KindOne freenode #znc false"");
    client.ReadUntil(response + ""#znc: AutoClearChanBuffer = false"");
    Z;

    client.Write(request + ""SetChan Detached KindOne freenode #znc false"");
    client.ReadUntil(response + ""#znc: Detached = false"");
    Z;

    client.Write(request + ""SetNetwork Nick KindOne freenode KindTwo"");
    client.ReadUntil(response + ""Nick = KindTwo"");
    Z;

    client.Write(request + ""SetNetwork Altnick KindOne freenode KindTwo_"");
    client.ReadUntil(response + ""AltNick = KindTwo_"");
    Z;

    client.Write(request + ""SetNetwork Ident KindOne freenode znc"");
    client.ReadUntil(response + ""Ident = znc"");
    Z;

    client.Write(request + ""SetNetwork BindHost KindOne freenode 0.0.0.0"");
    client.ReadUntil(response + ""This bind host is already set!"");
    Z;

    client.Write(request + ""SetNetwork FloodRate KindOne freenode 42.00"");
    client.ReadUntil(response + ""FloodRate = 42.00"");
    Z;

    client.Write(request + ""SetNetwork FloodBurst KindOne freenode 20"");
    client.ReadUntil(response + ""FloodBurst = 20"");
    Z;

    client.Write(request + ""SetNetwork JoinDelay KindOne freenode 5"");
    client.ReadUntil(response + ""JoinDelay = 5"");
    Z;

    client.Write(request + ""SetNetwork QuitMsg KindOne freenode telnet"");
    client.ReadUntil(response + ""QuitMsg = telnet"");
    Z;

    client.Write(request + ""Get Nick KindOne"");
    client.ReadUntil(response + ""Nick = KindTwo"");
    Z;

    client.Write(request + ""Get Altnick KindOne"");
    client.ReadUntil(response + ""AltNick = KindTwo_"");
    Z;

    client.Write(request + ""Get Ident KindOne"");
    client.ReadUntil(response + ""Ident = znc"");
    Z;

    client.Write(request + ""Get RealName KindOne"");
    client.ReadUntil(response + ""RealName = real_name"");
    Z;

    client.Write(request + ""Get BindHost KindOne"");
    client.ReadUntil(response + ""BindHost = 0.0.0.0"");
    Z;

    client.Write(request + ""Get DefaultChanModes KindOne"");
    client.ReadUntil(response + ""DefaultChanModes = +inst"");
    Z;

    client.Write(request + ""Get QuitMsg KindOne"");
    client.ReadUntil(response + ""QuitMsg = Writing this took forever"");
    Z;

    client.Write(request + ""Get Password KindOne"");
    client.ReadUntil(response + ""Error: Unknown variable"");
    Z;

    client.Write(request + ""Get Timezone KindOne"");
    client.ReadUntil(response + ""Timezone = America/New_York"");
    Z;

    client.Write(request + ""Get TimestampFormat KindOne"");
    client.ReadUntil(response + ""TimestampFormat = [%H:%M]"");
    Z;

    client.Write(request + ""Get DCCBindHost KindOne"");
    client.ReadUntil(response + ""DCCBindHost = 0.0.0.0"");
    Z;

    client.Write(request + ""Get StatusPrefix KindOne"");
    client.ReadUntil(response + ""StatusPrefix = *"");
    Z;

    client.Write(request + ""GetChan DefModes KindOne freenode #znc"");
    client.ReadUntil(response + ""#znc: DefModes = is"");
    Z;

    client.Write(request + ""GetChan Key KindOne freenode #znc"");
    client.ReadUntil(response + ""#znc: Key = KindOneRules"");
    Z;

    client.Write(request + ""GetChan BufferSize KindOne freenode #znc"");
    client.ReadUntil(response + ""#znc: BufferSize = 9001"");
    Z;

    client.Write(request + ""GetChan InConfig KindOne freenode #znc"");
    client.ReadUntil(response + ""#znc: InConfig = true"");
    Z;

    client.Write(request + ""GetChan AutoClearChanBuffer KindOne freenode #znc"");
    client.ReadUntil(response + ""#znc: AutoClearChanBuffer = false"");
    Z;

    client.Write(request + ""GetChan Detached KindOne freenode #znc"");
    client.ReadUntil(response + ""#znc: Detached = false"");
    Z;

    client.Write(request + ""GetNetwork Nick KindOne freenode"");
    client.ReadUntil(response + ""Nick = KindTwo"");
    Z;

    client.Write(request + ""GetNetwork Altnick KindOne freenode"");
    client.ReadUntil(response + ""AltNick = KindTwo_"");
    Z;

    client.Write(request + ""GetNetwork Ident KindOne freenode"");
    client.ReadUntil(response + ""Ident = znc"");
    Z;

    client.Write(request + ""GetNetwork BindHost KindOne freenode"");
    client.ReadUntil(response + ""BindHost = 0.0.0.0"");
    Z;

    client.Write(request + ""GetNetwork FloodRate KindOne freenode"");
    client.ReadUntil(response + ""FloodRate = 42.00"");
    Z;

    client.Write(request + ""GetNetwork FloodBurst KindOne freenode"");
    client.ReadUntil(response + ""FloodBurst = 20"");
    Z;

    client.Write(request + ""GetNetwork JoinDelay KindOne freenode"");
    client.ReadUntil(response + ""JoinDelay = 5"");
    Z;

    client.Write(request + ""GetNetwork QuitMsg KindOne freenode"");
    client.ReadUntil(response + ""QuitMsg = telnet"");
    Z;

    client.Write(request + ""UnLoadModule"");
    client.ReadUntil(response + ""Usage: UnloadModule <username> <modulename>"");
    Z;

    client.Write(request + ""UnLoadModule KindOne"");
    client.ReadUntil(response + ""Usage: UnloadModule <username> <modulename>"");
    Z;

    client.Write(request + ""UnLoadModule KindOne log"");
    client.ReadUntil(response + ""Unloaded module [log]"");
    Z;

    client.Write(request + ""UnLoadModule KindOne log"");
    client.ReadUntil(
        response + ""Unable to unload module [log] [Module [log] not loaded.]"");
    Z;

    client.Write(request + ""UnLoadNetModule KindOne freenode log"");
    client.ReadUntil(response + ""Unloaded module [log]"");
    Z;

    client.Write(request + ""UnLoadNetModule KindOne freenode log"");
    client.ReadUntil(
        response + ""Unable to unload module [log] [Module [log] not loaded.]"");
    Z;

    client.Write(request + ""UnLoadNetModule KindOne EFnet log"");
    client.ReadUntil(response +
                     ""Error: [KindOne] does not have a network named [EFnet]."");
    Z;

    // Test on ""foobar"", a user that does not exist.

    client.Write(request + ""AddCTCP foobar VERSION Test"");
    client.ReadUntil(response + ""Error: User [foobar] not found."");
    Z;
}

TEST_F(ZNCTest, NotifyConnectModule) {
    auto znc = Run();
    Z;
    auto ircd = ConnectIRCd();
    Z;
    auto client = LoginClient();
    Z;
    client.Write(""znc loadmod notify_connect"");
    client.ReadUntil(""Loaded module"");
    Z;

    auto client2 = ConnectClient();
    client2.Write(""PASS :hunter2"");
    client2.Write(""NICK nick"");
    client2.Write(""USER user/test x x :x"");
    client.ReadUntil(""NOTICE nick :*** user attached (from 127.0.0.1)"");
    Z;

    auto client3 = ConnectClient();
    client3.Write(""PASS :hunter2"");
    client3.Write(""NICK nick"");
    client3.Write(""USER user@identifier/test x x :x"");
    client.ReadUntil(
        ""NOTICE nick :*** user@identifier attached (from 127.0.0.1)"");
    Z;
    client2.ReadUntil(
        ""NOTICE nick :*** user@identifier attached (from 127.0.0.1)"");
    Z;

    client2.Write(""QUIT"");
    client.ReadUntil(""NOTICE nick :*** user detached (from 127.0.0.1)"");
    Z;

    client3.Close();
    client.ReadUntil(
        ""NOTICE nick :*** user@identifier detached (from 127.0.0.1)"");
    Z;
}

TEST_F(ZNCTest, ShellModule) {
    auto znc = Run();
    Z;
    auto ircd = ConnectIRCd();
    Z;
    auto client = LoginClient();
    Z;
    client.Write(""znc loadmod shell"");
    client.Write(""PRIVMSG *shell :echo blahblah"");
    client.ReadUntil(""PRIVMSG nick :blahblah"");
    Z;
    client.ReadUntil(""PRIVMSG nick :znc$"");
    Z;
}

TEST_F(ZNCTest, WatchModule) {
    // TODO test other messages
    // TODO test options
    auto znc = Run();
    Z;
    auto ircd = ConnectIRCd();
    Z;
    auto client = LoginClient();
    Z;
    client.Write(""znc loadmod watch"");
    client.Write(""PRIVMSG *watch :add *"");
    client.ReadUntil(""Adding entry:"");
    Z;
    ircd.Write("":server 001 nick :Hello"");
    ircd.Write("":nick JOIN :#znc"");
    ircd.Write("":n!i@h PRIVMSG #znc :\001ACTION foo\001"");
    client.ReadUntil(
        "":$*!watch@znc.in PRIVMSG nick :* CTCP: n [ACTION foo] to [#znc]"");
}

TEST_F(ZNCTest, Modperl) {
    if (QProcessEnvironment::systemEnvironment().value(
            ""DISABLED_ZNC_PERL_PYTHON_TEST"") == ""1"") {
        return;
    }
    auto znc = Run();
    Z;
    znc->CanLeak();
    auto ircd = ConnectIRCd();
    Z;
    auto client = LoginClient();
    Z;
    client.Write(""znc loadmod modperl"");
    client.Write(""znc loadmod perleval"");
    client.Write(""PRIVMSG *perleval :2+2"");
    client.ReadUntil("":*perleval!znc@znc.in PRIVMSG nick :Result: 4"");
    Z;
    client.Write(""PRIVMSG *perleval :$self->GetUser->GetUserName"");
    client.ReadUntil(""Result: user"");
    Z;
}

TEST_F(ZNCTest, Modpython) {
    if (QProcessEnvironment::systemEnvironment().value(
            ""DISABLED_ZNC_PERL_PYTHON_TEST"") == ""1"") {
        return;
    }
    auto znc = Run();
    Z;
    znc->CanLeak();
    auto ircd = ConnectIRCd();
    Z;
    auto client = LoginClient();
    Z;
    client.Write(""znc loadmod modpython"");
    client.Write(""znc loadmod pyeval"");
    client.Write(""PRIVMSG *pyeval :2+2"");
    client.ReadUntil("":*pyeval!znc@znc.in PRIVMSG nick :4"");
    Z;
    client.Write(""PRIVMSG *pyeval :module.GetUser().GetUserName()"");
    client.ReadUntil(""nick :'user'"");
    Z;
    ircd.Write("":server 001 nick :Hello"");
    ircd.Write("":n!u@h PRIVMSG nick :Hi\xF0, github issue #1229"");
    // ""replacement character""
    client.ReadUntil(""Hi\xEF\xBF\xBD, github issue"");
    Z;
}

TEST_F(ZNCTest, Encoding) {
    auto znc = Run();
    Z;
    auto ircd = ConnectIRCd();
    Z;
    auto client = LoginClient();
    Z;
    ircd.Write("":server 001 nick :hello"");
    // legacy
    ircd.Write("":n!u@h PRIVMSG nick :Hello\xE6world"");
    client.ReadUntil(""Hello\xE6world"");
    Z;
    client.Write(""PRIVMSG *controlpanel :SetNetwork Encoding $me $net UTF-8"");
    client.ReadUntil(""Encoding = UTF-8"");
    Z;
    ircd.Write("":n!u@h PRIVMSG nick :Hello\xE6world"");
    client.ReadUntil(""Hello\xEF\xBF\xBDworld"");
    Z;
    client.Write(
        ""PRIVMSG *controlpanel :SetNetwork Encoding $me $net ^CP-1251"");
    client.ReadUntil(""Encoding = ^CP-1251"");
    Z;
    ircd.Write("":n!u@h PRIVMSG nick :Hello\xE6world"");
    client.ReadUntil(""Hello\xD0\xB6world"");
    Z;
    ircd.Write("":n!u@h PRIVMSG nick :Hello\xD0\xB6world"");
    client.ReadUntil(""Hello\xD0\xB6world"");
    Z;
}

TEST_F(ZNCTest, BuildMod) {
    auto znc = Run();
    Z;
    auto ircd = ConnectIRCd();
    Z;
    auto client = LoginClient();
    Z;
    QTemporaryDir srcd;
    QDir srcdir(srcd.path());
    QFile file(srcdir.filePath(""testmod.cpp""));
    ASSERT_TRUE(file.open(QIODevice::WriteOnly | QIODevice::Text));
    QTextStream out(&file);
    out << R""(
        #include <znc/Modules.h>
        class TestModule : public CModule {
          public:
            MODCONSTRUCTOR(TestModule) {}
            void OnModCommand(const CString& sLine) override {
                PutModule(""Lorem ipsum"");
            }
        };
        MODULEDEFS(TestModule, ""Test"")
    )"";
    file.close();
    QDir dir(m_dir.path());
    EXPECT_TRUE(dir.mkdir(""modules""));
    EXPECT_TRUE(dir.cd(""modules""));
    {
        Process p(ZNC_BIN_DIR ""/znc-buildmod"",
                  QStringList() << srcdir.filePath(""file-not-found.cpp""),
                  [&](QProcess* proc) {
                      proc->setWorkingDirectory(dir.absolutePath());
                      proc->setProcessChannelMode(QProcess::ForwardedChannels);
                  });
        p.ShouldFinishItself(1);
    }
    {
        Process p(ZNC_BIN_DIR ""/znc-buildmod"",
                  QStringList() << srcdir.filePath(""testmod.cpp""),
                  [&](QProcess* proc) {
                      proc->setWorkingDirectory(dir.absolutePath());
                      proc->setProcessChannelMode(QProcess::ForwardedChannels);
                  });
        p.ShouldFinishItself();
    }
    client.Write(""znc loadmod testmod"");
    client.Write(""PRIVMSG *testmod :hi"");
    client.ReadUntil(""Lorem ipsum"");
    Z;
}

TEST_F(ZNCTest, AutoAttachModule) {
    auto znc = Run();
    Z;
    auto ircd = ConnectIRCd();
    Z;
    auto client = LoginClient();
    Z;
    InstallModule(""testmod.cpp"", R""(
        #include <znc/Modules.h>
        #include <znc/Client.h>
        class TestModule : public CModule {
          public:
            MODCONSTRUCTOR(TestModule) {}
            EModRet OnChanBufferPlayMessage(CMessage& Message) override {
                PutIRC(""TEST "" + Message.GetClient()->GetNickMask());
                return CONTINUE;
            }
        };
        MODULEDEFS(TestModule, ""Test"")
    )"");
    Z;
    client.Write(""znc loadmod testmod"");
    client.Write(""PRIVMSG *controlpanel :Set AutoClearChanBuffer $me no"");
    client.Write(""znc loadmod autoattach"");
    client.Write(""PRIVMSG *autoattach :Add * * *"");
    client.ReadUntil(""Added to list"");
    Z;
    ircd.Write("":server 001 nick :Hello"");
    ircd.Write("":nick JOIN :#znc"");
    ircd.Write("":server 353 nick #znc :nick"");
    ircd.Write("":server 366 nick #znc :End of /NAMES list"");
    ircd.Write("":foo PRIVMSG #znc :hi"");
    client.ReadUntil("":foo PRIVMSG"");
    Z;
    client.Write(""detach #znc"");
    client.ReadUntil(""Detached"");
    Z;
    ircd.Write("":foo PRIVMSG #znc :hello"");
    ircd.ReadUntil(""TEST"");
    Z;
    client.ReadUntil(""hello"");
    Z;
}

TEST_F(ZNCTest, KeepNickModule) {
    auto znc = Run();
    Z;
    auto ircd = ConnectIRCd();
    Z;
    auto client = LoginClient();
    Z;
    client.Write(""znc loadmod keepnick"");
    client.ReadUntil(""Loaded module"");
    Z;
    ircd.ReadUntil(""NICK user"");
    ircd.Write("":server 433 * nick :Nickname is already in use."");
    ircd.ReadUntil(""NICK user_"");
    Z;
    ircd.Write("":server 001 user_ :Hello"");
    client.ReadUntil(""Connected!"");
    Z;
    ircd.ReadUntil(""NICK user"");
    Z;
    ircd.Write("":server 435 user_ user #error :Nope :-P"");
    client.ReadUntil(
        "":*keepnick!znc@znc.in PRIVMSG user_ ""
        "":Unable to obtain nick user: Nope :-P, #error"");
}

TEST_F(ZNCTest, ModuleCSRFOverride) {
    auto znc = Run();
    Z;
    auto ircd = ConnectIRCd();
    Z;
    auto client = LoginClient();
    Z;
    client.Write(""znc loadmod samplewebapi"");
    client.ReadUntil(""Loaded module"");
    Z;
    auto request = QNetworkRequest(QUrl(""http://127.0.0.1:12345/mods/global/samplewebapi/""));
    auto reply = HttpPost(request, {
        {""text"", ""ipsum""}
    })->readAll().toStdString();
    Z;
    EXPECT_THAT(reply, HasSubstr(""ipsum""));
}

}  // namespace
""",TEST_F,[419:454]
